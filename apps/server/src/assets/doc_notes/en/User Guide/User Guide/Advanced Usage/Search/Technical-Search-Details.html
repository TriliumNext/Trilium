<h1>Technical Search Details</h1>
<p>This guide provides technical information about Trilium's search implementation, performance characteristics, and optimization strategies for power users and administrators.</p>

<h2>Search Architecture Overview</h2>

<h3>Three-Layer Search System</h3>
<p>Trilium's search operates across three cache layers:</p>
<ol>
  <li><strong>Becca (Backend Cache)</strong>: Server-side entity cache containing notes, attributes, and relationships</li>
  <li><strong>Froca (Frontend Cache)</strong>: Client-side mirror providing fast UI updates</li>
  <li><strong>Database Layer</strong>: SQLite database with FTS (Full-Text Search) support</li>
</ol>

<h3>Search Processing Pipeline</h3>
<ol>
  <li><strong>Lexical Analysis</strong>: Query parsing and tokenization</li>
  <li><strong>Expression Building</strong>: Converting tokens to executable expressions</li>
  <li><strong>Progressive Execution</strong>: Exact search followed by optional fuzzy search</li>
  <li><strong>Result Scoring</strong>: Relevance calculation and ranking</li>
  <li><strong>Result Presentation</strong>: Formatting and highlighting</li>
</ol>

<h2>Query Processing Details</h2>

<h3>Lexical Analysis (Lex)</h3>
<p>The lexer breaks down search queries into components:</p>
<pre><code>// Input: 'project #status=active note.dateCreated >= TODAY-7'
// Output:
{
  fulltextTokens: ['project'],
  expressionTokens: ['#status', '=', 'active', 'note', '.', 'dateCreated', '>=', 'TODAY-7']
}</code></pre>

<h4>Token Types</h4>
<ul>
  <li><strong>Fulltext Tokens</strong>: Regular search terms</li>
  <li><strong>Expression Tokens</strong>: Attributes, operators, and property references</li>
  <li><strong>Quoted Strings</strong>: Exact phrase matches</li>
  <li><strong>Escaped Characters</strong>: Literal special characters</li>
</ul>

<h3>Expression Building (Parse)</h3>
<p>Tokens are converted into executable expression trees:</p>
<pre><code>// Expression tree for: #book AND #author=Tolkien
AndExp([
  AttributeExistsExp('label', 'book'),
  LabelComparisonExp('label', 'author', equals('tolkien'))
])</code></pre>

<h4>Expression Types</h4>
<ul>
  <li><code>AndExp</code>, <code>OrExp</code>, <code>NotExp</code>: Boolean logic</li>
  <li><code>AttributeExistsExp</code>: Label/relation existence</li>
  <li><code>LabelComparisonExp</code>: Label value comparison</li>
  <li><code>RelationWhereExp</code>: Relation target queries</li>
  <li><code>PropertyComparisonExp</code>: Note property filtering</li>
  <li><code>NoteContentFulltextExp</code>: Content search</li>
  <li><code>OrderByAndLimitExp</code>: Result ordering and limiting</li>
</ul>

<h3>Progressive Search Strategy</h3>

<h4>Phase 1: Exact Search</h4>
<pre><code>// Fast exact matching
const exactResults = performSearch(expression, searchContext, false);</code></pre>
<p>Characteristics:</p>
<ul>
  <li>Substring matching for text</li>
  <li>Exact attribute matching</li>
  <li>Property-based filtering</li>
  <li>Handles 90%+ of searches</li>
  <li>Sub-second response time</li>
</ul>

<h4>Phase 2: Fuzzy Fallback</h4>
<pre><code>// Activated when exact results &lt; 5 high-quality matches
if (highQualityResults.length &lt; 5) {
  const fuzzyResults = performSearch(expression, searchContext, true);
  return mergeExactAndFuzzyResults(exactResults, fuzzyResults);
}</code></pre>
<p>Characteristics:</p>
<ul>
  <li>Edit distance calculations</li>
  <li>Phrase proximity matching</li>
  <li>Typo tolerance</li>
  <li>Performance safeguards</li>
  <li>Exact matches always rank first</li>
</ul>

<h2>Performance Characteristics</h2>

<h3>Search Limits and Thresholds</h3>
<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Value</th>
      <th>Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>MAX_SEARCH_CONTENT_SIZE</code></td>
      <td>2MB</td>
      <td>Database-level content filtering</td>
    </tr>
    <tr>
      <td><code>MIN_FUZZY_TOKEN_LENGTH</code></td>
      <td>3 chars</td>
      <td>Minimum length for fuzzy matching</td>
    </tr>
    <tr>
      <td><code>MAX_EDIT_DISTANCE</code></td>
      <td>2 chars</td>
      <td>Maximum character changes for fuzzy</td>
    </tr>
    <tr>
      <td><code>MAX_PHRASE_PROXIMITY</code></td>
      <td>10 words</td>
      <td>Maximum distance for phrase matching</td>
    </tr>
    <tr>
      <td><code>RESULT_SUFFICIENCY_THRESHOLD</code></td>
      <td>5 results</td>
      <td>Threshold for fuzzy activation</td>
    </tr>
    <tr>
      <td><code>ABSOLUTE_MAX_CONTENT_SIZE</code></td>
      <td>100MB</td>
      <td>Hard limit to prevent system crash</td>
    </tr>
    <tr>
      <td><code>ABSOLUTE_MAX_WORD_COUNT</code></td>
      <td>2M words</td>
      <td>Hard limit for word processing</td>
    </tr>
  </tbody>
</table>

<h3>Performance Optimization</h3>

<h4>Database-Level Optimizations</h4>
<pre><code>-- Content size filtering at database level
SELECT noteId, type, mime, content, isProtected
FROM notes JOIN blobs USING (blobId)
WHERE type IN ('text', 'code', 'mermaid', 'canvas', 'mindMap') 
  AND isDeleted = 0 
  AND LENGTH(content) &lt; 2097152  -- 2MB limit</code></pre>

<h4>Memory Management</h4>
<ul>
  <li>Single-array edit distance calculation</li>
  <li>Early termination for distant matches</li>
  <li>Progressive content processing</li>
  <li>Cached regular expressions</li>
</ul>

<h4>Search Context Optimization</h4>
<pre><code>// Efficient search context configuration
const searchContext = new SearchContext({
  fastSearch: true,           // Skip content search
  limit: 50,                 // Reasonable result limit
  orderBy: 'dateCreated',    // Use indexed property
  includeArchivedNotes: false // Reduce search space
});</code></pre>

<h2>Fuzzy Search Implementation</h2>

<h3>Edit Distance Algorithm</h3>
<p>Trilium uses an optimized Levenshtein distance calculation:</p>
<pre><code>// Optimized single-array implementation
function calculateOptimizedEditDistance(str1, str2, maxDistance) {
  // Early termination checks
  if (Math.abs(str1.length - str2.length) > maxDistance) {
    return maxDistance + 1;
  }
  
  // Single array optimization
  let previousRow = Array.from({ length: str2.length + 1 }, (_, i) => i);
  let currentRow = new Array(str2.length + 1);
  
  for (let i = 1; i &lt;= str1.length; i++) {
    currentRow[0] = i;
    let minInRow = i;
    
    for (let j = 1; j &lt;= str2.length; j++) {
      const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
      currentRow[j] = Math.min(
        previousRow[j] + 1,        // deletion
        currentRow[j - 1] + 1,     // insertion
        previousRow[j - 1] + cost  // substitution
      );
      minInRow = Math.min(minInRow, currentRow[j]);
    }
    
    // Early termination if row minimum exceeds threshold
    if (minInRow > maxDistance) return maxDistance + 1;
    
    [previousRow, currentRow] = [currentRow, previousRow];
  }
  
  return previousRow[str2.length];
}</code></pre>

<h3>Phrase Proximity Matching</h3>
<p>For multi-token fuzzy searches:</p>
<pre><code>// Check if tokens appear within reasonable proximity
function hasProximityMatch(tokenPositions, maxDistance = 10) {
  // For 2 tokens, simple distance check
  if (tokenPositions.length === 2) {
    const [pos1, pos2] = tokenPositions;
    return pos1.some(p1 => pos2.some(p2 => Math.abs(p1 - p2) &lt;= maxDistance));
  }
  
  // For multiple tokens, find sequence within range
  const findSequence = (remaining, currentPos) => {
    if (remaining.length === 0) return true;
    const [nextPositions, ...rest] = remaining;
    return nextPositions.some(pos => 
      Math.abs(pos - currentPos) &lt;= maxDistance && 
      findSequence(rest, pos)
    );
  };
  
  const [firstPositions, ...rest] = tokenPositions;
  return firstPositions.some(startPos => findSequence(rest, startPos));
}</code></pre>

<h2>Indexing and Storage</h2>

<h3>Database Schema Optimization</h3>
<pre><code>-- Relevant indexes for search performance
CREATE INDEX idx_notes_type ON notes(type);
CREATE INDEX idx_notes_isDeleted ON notes(isDeleted);
CREATE INDEX idx_notes_dateCreated ON notes(dateCreated);
CREATE INDEX idx_notes_dateModified ON notes(dateModified);
CREATE INDEX idx_attributes_name ON attributes(name);
CREATE INDEX idx_attributes_type ON attributes(type);
CREATE INDEX idx_attributes_value ON attributes(value);</code></pre>

<h3>Content Processing</h3>
<p>Notes are processed differently based on type:</p>
<pre><code>// Content preprocessing by note type
function preprocessContent(content, type, mime) {
  content = normalize(content.toString());
  
  if (type === "text" && mime === "text/html") {
    content = stripTags(content);
    content = content.replace(/&nbsp;/g, " ");
  } else if (type === "mindMap" && mime === "application/json") {
    content = processMindmapContent(content);
  } else if (type === "canvas" && mime === "application/json") {
    const canvasData = JSON.parse(content);
    const textElements = canvasData.elements
      .filter(el => el.type === "text" && el.text)
      .map(el => el.text);
    content = normalize(textElements.join(" "));
  }
  
  return content.trim();
}</code></pre>

<h2>Search Result Processing</h2>

<h3>Scoring Algorithm</h3>
<p>Results are scored based on multiple factors:</p>
<pre><code>function computeScore(fulltextQuery, highlightedTokens, enableFuzzyMatching) {
  let score = 0;
  
  // Title matches get higher score
  if (this.noteTitle.toLowerCase().includes(fulltextQuery.toLowerCase())) {
    score += 10;
  }
  
  // Path matches (hierarchical context)
  const pathMatch = this.notePathArray.some(pathNote => 
    pathNote.title.toLowerCase().includes(fulltextQuery.toLowerCase())
  );
  if (pathMatch) score += 5;
  
  // Attribute matches
  score += this.attributeMatches * 3;
  
  // Content snippet quality
  if (this.contentSnippet && this.contentSnippet.length > 0) {
    score += 2;
  }
  
  // Fuzzy match penalty
  if (enableFuzzyMatching && this.isFuzzyMatch) {
    score *= 0.8; // 20% penalty for fuzzy matches
  }
  
  return score;
}</code></pre>

<h3>Result Merging</h3>
<p>Exact and fuzzy results are carefully merged:</p>
<pre><code>function mergeExactAndFuzzyResults(exactResults, fuzzyResults) {
  // Deduplicate - exact results take precedence
  const exactNoteIds = new Set(exactResults.map(r => r.noteId));
  const additionalFuzzyResults = fuzzyResults.filter(r => 
    !exactNoteIds.has(r.noteId)
  );
  
  // Sort within each category
  exactResults.sort(byScoreAndDepth);
  additionalFuzzyResults.sort(byScoreAndDepth);
  
  // CRITICAL: Exact matches always come first
  return [...exactResults, ...additionalFuzzyResults];
}</code></pre>

<h2>Performance Monitoring</h2>

<h3>Search Metrics</h3>
<p>Monitor these performance indicators:</p>
<pre><code>// Performance tracking
const searchMetrics = {
  totalQueries: 0,
  exactSearchTime: 0,
  fuzzySearchTime: 0,
  resultCount: 0,
  cacheHitRate: 0,
  slowQueries: [] // queries taking > 1 second
};</code></pre>

<h3>Memory Usage</h3>
<p>Track memory consumption:</p>
<pre><code>// Memory monitoring
const memoryMetrics = {
  searchCacheSize: 0,
  activeSearchContexts: 0,
  largeContentNotes: 0, // notes > 1MB
  indexSize: 0
};</code></pre>

<h3>Query Complexity Analysis</h3>
<p>Identify expensive queries:</p>
<pre><code>// Query complexity factors
const complexityFactors = {
  tokenCount: query.split(' ').length,
  hasRegex: query.includes('%='),
  hasFuzzy: query.includes('~=') || query.includes('~*'),
  hasRelationTraversal: query.includes('.relations.'),
  hasNestedProperties: (query.match(/\./g) || []).length > 2,
  hasOrderBy: query.includes('orderBy'),
  estimatedResultSize: 'unknown'
};</code></pre>

<h2>Troubleshooting Performance Issues</h2>

<h3>Common Performance Problems</h3>

<h4>Slow Full-Text Search</h4>
<p><strong>Diagnosis:</strong></p>
<ul>
  <li>Check note content sizes</li>
  <li>Verify content type filtering</li>
  <li>Monitor regex usage</li>
  <li>Review fuzzy search activation</li>
</ul>
<p><strong>Solutions:</strong></p>
<ul>
  <li>Enable fast search for attribute-only queries</li>
  <li>Add content size limits</li>
  <li>Optimize regex patterns</li>
  <li>Tune fuzzy search thresholds</li>
</ul>

<h4>Memory Issues</h4>
<p><strong>Diagnosis:</strong></p>
<ul>
  <li>Monitor result set sizes</li>
  <li>Check for large content processing</li>
  <li>Review search context caching</li>
  <li>Identify memory leaks</li>
</ul>
<p><strong>Solutions:</strong></p>
<ul>
  <li>Add result limits</li>
  <li>Implement progressive loading</li>
  <li>Clear unused search contexts</li>
  <li>Optimize content preprocessing</li>
</ul>

<h4>High CPU Usage</h4>
<p><strong>Diagnosis:</strong></p>
<ul>
  <li>Profile fuzzy search operations</li>
  <li>Check edit distance calculations</li>
  <li>Monitor regex compilation</li>
  <li>Review phrase proximity matching</li>
</ul>
<p><strong>Solutions:</strong></p>
<ul>
  <li>Increase minimum fuzzy token length</li>
  <li>Reduce maximum edit distance</li>
  <li>Cache compiled regexes</li>
  <li>Limit phrase proximity distance</li>
</ul>

<h3>Debugging Tools</h3>

<h4>Debug Mode</h4>
<p>Enable search debugging:</p>
<pre><code>// Search context with debugging
const searchContext = new SearchContext({
  debug: true // Logs expression parsing and execution
});</code></pre>
<p>Output includes:</p>
<ul>
  <li>Token parsing results</li>
  <li>Expression tree structure</li>
  <li>Execution timing</li>
  <li>Result scoring details</li>
</ul>

<h4>Performance Profiling</h4>
<pre><code>// Manual performance measurement
const startTime = Date.now();
const results = searchService.findResultsWithQuery(query, searchContext);
const endTime = Date.now();
console.log(`Search took ${endTime - startTime}ms for ${results.length} results`);</code></pre>

<h4>Query Analysis</h4>
<pre><code>// Analyze query complexity
function analyzeQuery(query) {
  return {
    tokenCount: query.split(/\s+/).length,
    hasAttributes: /#|\~/.test(query),
    hasProperties: /note\./.test(query),
    hasRegex: /%=/.test(query),
    hasFuzzy: /~[=*]/.test(query),
    complexity: calculateComplexityScore(query)
  };
}</code></pre>

<h2>Configuration and Tuning</h2>

<h3>Server Configuration</h3>
<p>Relevant settings in <code>config.ini</code>:</p>
<pre><code>[Search]
maxContentSize=2097152          # 2MB content limit
minFuzzyTokenLength=3          # Minimum chars for fuzzy
maxEditDistance=2              # Edit distance limit
resultSufficiencyThreshold=5   # Fuzzy activation threshold
enableProgressiveSearch=true   # Enable progressive strategy
cacheSearchResults=true        # Cache frequent searches

[Performance]
searchTimeoutMs=30000         # 30 second search timeout
maxSearchResults=1000         # Hard limit on results
enableSearchProfiling=false   # Performance logging</code></pre>

<h3>Runtime Tuning</h3>
<p>Adjust search behavior programmatically:</p>
<pre><code>// Dynamic configuration
const searchConfig = {
  maxContentSize: 1024 * 1024,  // 1MB for faster processing
  enableFuzzySearch: false,      // Exact only for speed
  resultLimit: 50,               // Smaller result sets
  useIndexedPropertiesOnly: true // Skip expensive calculations
};</code></pre>

<h2>Best Practices for Performance</h2>

<h3>Query Design</h3>
<ol>
  <li><strong>Start Specific</strong>: Use selective criteria first</li>
  <li><strong>Limit Results</strong>: Always set reasonable limits</li>
  <li><strong>Use Indexes</strong>: Prefer indexed properties for ordering</li>
  <li><strong>Avoid Regex</strong>: Use simple operators when possible</li>
  <li><strong>Cache Common Queries</strong>: Save frequently used searches</li>
</ol>

<h3>System Administration</h3>
<ol>
  <li><strong>Monitor Performance</strong>: Track slow queries and memory usage</li>
  <li><strong>Regular Maintenance</strong>: Clean up unused notes and attributes</li>
  <li><strong>Index Optimization</strong>: Ensure database indexes are current</li>
  <li><strong>Content Management</strong>: Archive or compress large content</li>
</ol>

<h3>Development Guidelines</h3>
<ol>
  <li><strong>Test Performance</strong>: Benchmark complex queries</li>
  <li><strong>Profile Regularly</strong>: Identify performance regressions</li>
  <li><strong>Optimize Incrementally</strong>: Make small, measured improvements</li>
  <li><strong>Document Complexity</strong>: Note expensive operations</li>
</ol>

<h2>Next Steps</h2>
<ul>
  <li><a class="reference-link" href="#root/_help_search_fundamentals">Search Fundamentals</a> - Basic concepts and syntax</li>
  <li><a class="reference-link" href="#root/_help_search_advanced">Advanced Search Expressions</a> - Complex query construction</li>
  <li><a class="reference-link" href="#root/_help_search_examples">Search Examples and Use Cases</a> - Practical applications</li>
  <li><a class="reference-link" href="#root/_help_search_saved">Saved Searches</a> - Creating dynamic collections</li>
</ul>