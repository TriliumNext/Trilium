<!DOCTYPE html>
<html>
<head>
    <title>WebSocket API Documentation</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            line-height: 1.6; 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
        h2 { color: #34495e; margin-top: 40px; border-bottom: 2px solid #ecf0f1; padding-bottom: 8px; }
        h3 { color: #7f8c8d; margin-top: 25px; }
        h4 { color: #95a5a6; margin-top: 20px; }
        
        pre { 
            background: #f8f9fa; 
            padding: 20px; 
            border-radius: 8px; 
            overflow-x: auto; 
            border-left: 4px solid #3498db;
            font-size: 14px;
        }
        
        code { 
            background: #f4f4f4; 
            padding: 3px 6px; 
            border-radius: 4px; 
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'Droid Sans Mono', monospace; 
            font-size: 0.9em;
        }
        
        .toc {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .toc h3 { margin-top: 0; color: #495057; }
        .toc ol { margin: 0; }
        .toc li { margin: 5px 0; }
        .toc a { color: #007bff; text-decoration: none; }
        .toc a:hover { text-decoration: underline; }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .feature-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
        }
        
        .feature-card h4 {
            margin-top: 0;
            color: #495057;
        }
        
        .highlight-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .highlight-box h3 {
            margin-top: 0;
            color: white;
        }
        
        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-left: 4px solid #fdcb6e;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }
        
        .info-box {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }
        
        .code-tabs {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .tab-headers {
            background: #f8f9fa;
            display: flex;
            border-bottom: 1px solid #dee2e6;
        }
        
        .tab-header {
            padding: 12px 20px;
            cursor: pointer;
            border-right: 1px solid #dee2e6;
            user-select: none;
        }
        
        .tab-header:last-child { border-right: none; }
        .tab-header.active { background: #007bff; color: white; }
        .tab-header:hover:not(.active) { background: #e9ecef; }
        
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .tab-content pre { margin: 0; border-radius: 0; border: none; }
        
        table { 
            width: 100%; 
            border-collapse: collapse; 
            margin: 20px 0; 
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        
        th, td { 
            padding: 15px; 
            text-align: left; 
            border-bottom: 1px solid #dee2e6;
        }
        
        th { 
            background: #f8f9fa; 
            font-weight: 600;
            color: #495057;
        }
        
        tr:last-child td { border-bottom: none; }
        tr:hover { background: #f8f9fa; }
        
        .method-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .method-get { background: #d4edda; color: #155724; }
        .method-post { background: #cce5ff; color: #004085; }
        .method-put { background: #fff3cd; color: #856404; }
        .method-delete { background: #f8d7da; color: #721c24; }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-connected { background: #28a745; }
        .status-disconnected { background: #dc3545; }
        .status-connecting { background: #ffc107; }
        
        blockquote {
            border-left: 4px solid #007bff;
            margin: 20px 0;
            padding: 10px 20px;
            background: #f8f9fa;
            border-radius: 0 4px 4px 0;
        }
        
        ul li, ol li { margin: 8px 0; }
        
        .navigation-links {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 40px 0;
            text-align: center;
        }
        
        .navigation-links h3 { margin-top: 0; }
        .navigation-links a {
            display: inline-block;
            margin: 5px 10px;
            padding: 8px 16px;
            background: #007bff;
            color: white;
            text-decoration: none;
            border-radius: 4px;
        }
        .navigation-links a:hover { background: #0056b3; }
    </style>
</head>
<body>
    <h1>WebSocket API Documentation</h1>
    
    <div class="toc">
        <h3>Table of Contents</h3>
        <ol>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#connection-setup">Connection Setup</a></li>
            <li><a href="#authentication">Authentication</a></li>
            <li><a href="#message-format">Message Format</a></li>
            <li><a href="#event-types">Event Types</a></li>
            <li><a href="#real-time-synchronization">Real-time Synchronization</a></li>
            <li><a href="#custom-event-broadcasting">Custom Event Broadcasting</a></li>
            <li><a href="#client-implementation-examples">Client Implementation Examples</a></li>
            <li><a href="#debugging-websocket-connections">Debugging WebSocket Connections</a></li>
            <li><a href="#best-practices">Best Practices</a></li>
            <li><a href="#error-handling">Error Handling</a></li>
            <li><a href="#performance-optimization">Performance Optimization</a></li>
        </ol>
    </div>
    
    <h2 id="introduction">Introduction</h2>
    
    <p>The Trilium WebSocket API provides real-time bidirectional communication between the server and clients. It's primarily used for:</p>
    
    <div class="feature-grid">
        <div class="feature-card">
            <h4>Real-time Synchronization</h4>
            <p>Synchronize note changes across multiple clients instantly</p>
        </div>
        <div class="feature-card">
            <h4>Live Collaboration</h4>
            <p>Enable collaborative editing with real-time updates</p>
        </div>
        <div class="feature-card">
            <h4>Push Notifications</h4>
            <p>Send instant notifications for important events</p>
        </div>
        <div class="feature-card">
            <h4>Streaming Updates</h4>
            <p>Stream progress updates for long-running operations</p>
        </div>
        <div class="feature-card">
            <h4>Script Execution</h4>
            <p>Execute frontend scripts triggered from backend</p>
        </div>
        <div class="feature-card">
            <h4>Event Broadcasting</h4>
            <p>Broadcast custom events between clients</p>
        </div>
    </div>
    
    <h3>Key Features</h3>
    <ul>
        <li>Automatic reconnection with exponential backoff</li>
        <li>Message queuing during disconnection</li>
        <li>Event-based architecture</li>
        <li>Support for custom event types</li>
        <li>Built-in heartbeat/ping mechanism</li>
    </ul>
    
    <h3>WebSocket URL</h3>
    <pre><code>ws://localhost:8080   // Local development
wss://your-server.com  // Production with SSL</code></pre>
    
    <h2 id="connection-setup">Connection Setup</h2>
    
    <h3>Basic Connection</h3>
    
    <pre><code>// JavaScript - Basic WebSocket connection
const ws = new WebSocket('ws://localhost:8080');

ws.onopen = (event) => {
    console.log('Connected to Trilium WebSocket');
};

ws.onmessage = (event) => {
    const message = JSON.parse(event.data);
    console.log('Received:', message);
};

ws.onerror = (error) => {
    console.error('WebSocket error:', error);
};

ws.onclose = (event) => {
    console.log('Disconnected from WebSocket');
};</code></pre>
    
    <h3>Advanced Connection Manager</h3>
    
    <div class="highlight-box">
        <h3>Production-Ready WebSocket Manager</h3>
        <p>The following implementation includes reconnection logic, message queuing, and event handling suitable for production use.</p>
    </div>
    
    <pre><code>class TriliumWebSocketManager {
    constructor(url, options = {}) {
        this.url = url;
        this.options = {
            reconnectInterval: 5000,
            maxReconnectInterval: 30000,
            reconnectDecay: 1.5,
            timeoutInterval: 2000,
            maxReconnectAttempts: null,
            ...options
        };
        
        this.ws = null;
        this.forcedClose = false;
        this.reconnectAttempts = 0;
        this.messageQueue = [];
        this.eventHandlers = new Map();
        this.reconnectTimer = null;
        this.pingTimer = null;
    }
    
    connect() {
        this.ws = new WebSocket(this.url);
        
        this.ws.onopen = (event) => {
            console.log('WebSocket connected');
            this.onOpen(event);
        };
        
        this.ws.onmessage = (event) => {
            this.onMessage(event);
        };
        
        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.onError(error);
        };
        
        this.ws.onclose = (event) => {
            console.log('WebSocket closed');
            this.onClose(event);
        };
    }
    
    onOpen(event) {
        this.reconnectAttempts = 0;
        
        // Send queued messages
        while (this.messageQueue.length > 0) {
            const message = this.messageQueue.shift();
            this.send(message);
        }
        
        // Start ping timer
        this.startPing();
        
        // Emit open event
        this.emit('open', event);
    }
    
    onMessage(event) {
        try {
            const message = JSON.parse(event.data);
            
            // Handle different message types
            if (message.type === 'pong') {
                this.handlePong(message);
            } else {
                this.emit('message', message);
                
                // Emit specific event type
                if (message.type) {
                    this.emit(message.type, message.data || message);
                }
            }
        } catch (error) {
            console.error('Failed to parse message:', error);
        }
    }
    
    onError(error) {
        this.emit('error', error);
    }
    
    onClose(event) {
        this.ws = null;
        
        if (!this.forcedClose) {
            this.reconnect();
        }
        
        this.stopPing();
        this.emit('close', event);
    }
    
    reconnect() {
        if (this.options.maxReconnectAttempts && 
            this.reconnectAttempts >= this.options.maxReconnectAttempts) {
            this.emit('max-reconnects');
            return;
        }
        
        this.reconnectAttempts++;
        
        const timeout = Math.min(
            this.options.reconnectInterval * Math.pow(
                this.options.reconnectDecay,
                this.reconnectAttempts - 1
            ),
            this.options.maxReconnectInterval
        );
        
        console.log(`Reconnecting in ${timeout}ms (attempt ${this.reconnectAttempts})`);
        
        this.reconnectTimer = setTimeout(() => {
            console.log('Reconnecting...');
            this.connect();
        }, timeout);
        
        this.emit('reconnecting', {
            attempt: this.reconnectAttempts,
            timeout
        });
    }
    
    send(data) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            const message = typeof data === 'string' ? data : JSON.stringify(data);
            this.ws.send(message);
        } else {
            // Queue message for later
            this.messageQueue.push(data);
        }
    }
    
    startPing() {
        this.pingTimer = setInterval(() => {
            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                this.send({ type: 'ping', timestamp: Date.now() });
            }
        }, 30000); // Ping every 30 seconds
    }
    
    stopPing() {
        if (this.pingTimer) {
            clearInterval(this.pingTimer);
            this.pingTimer = null;
        }
    }
    
    handlePong(message) {
        const latency = Date.now() - message.timestamp;
        this.emit('latency', latency);
    }
    
    on(event, handler) {
        if (!this.eventHandlers.has(event)) {
            this.eventHandlers.set(event, []);
        }
        this.eventHandlers.get(event).push(handler);
    }
    
    off(event, handler) {
        const handlers = this.eventHandlers.get(event);
        if (handlers) {
            const index = handlers.indexOf(handler);
            if (index !== -1) {
                handlers.splice(index, 1);
            }
        }
    }
    
    emit(event, data) {
        const handlers = this.eventHandlers.get(event);
        if (handlers) {
            handlers.forEach(handler => {
                try {
                    handler(data);
                } catch (error) {
                    console.error(`Error in event handler for ${event}:`, error);
                }
            });
        }
    }
    
    close() {
        this.forcedClose = true;
        
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
        }
        
        if (this.ws) {
            this.ws.close();
        }
        
        this.stopPing();
    }
    
    getState() {
        if (!this.ws) {
            return 'DISCONNECTED';
        }
        
        switch (this.ws.readyState) {
            case WebSocket.CONNECTING:
                return 'CONNECTING';
            case WebSocket.OPEN:
                return 'CONNECTED';
            case WebSocket.CLOSING:
                return 'CLOSING';
            case WebSocket.CLOSED:
                return 'DISCONNECTED';
            default:
                return 'UNKNOWN';
        }
    }
}</code></pre>
    
    <h2 id="authentication">Authentication</h2>
    
    <p>WebSocket connections inherit authentication from the HTTP session or require token-based auth.</p>
    
    <div class="code-tabs">
        <div class="tab-headers">
            <div class="tab-header active" onclick="showTab(event, 'session-auth')">Session Auth</div>
            <div class="tab-header" onclick="showTab(event, 'token-auth')">Token Auth</div>
        </div>
        <div id="session-auth" class="tab-content active">
            <pre><code>// Session auth (cookies must be included)
const ws = new WebSocket('ws://localhost:8080', {
    headers: {
        'Cookie': document.cookie  // Include session cookie
    }
});</code></pre>
        </div>
        <div id="token-auth" class="tab-content">
            <pre><code>// Send auth token after connection
class AuthenticatedWebSocket {
    constructor(url, token) {
        this.url = url;
        this.token = token;
        this.authenticated = false;
    }
    
    connect() {
        this.ws = new WebSocket(this.url);
        
        this.ws.onopen = () => {
            // Send authentication message
            this.send({
                type: 'auth',
                token: this.token
            });
        };
        
        this.ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            
            if (message.type === 'auth-success') {
                this.authenticated = true;
                this.onAuthenticated();
            } else if (message.type === 'auth-error') {
                this.onAuthError(message.error);
            } else if (this.authenticated) {
                this.handleMessage(message);
            }
        };
    }
    
    send(data) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(data));
        }
    }
    
    onAuthenticated() {
        console.log('WebSocket authenticated');
    }
    
    onAuthError(error) {
        console.error('Authentication failed:', error);
    }
    
    handleMessage(message) {
        // Handle authenticated messages
    }
}</code></pre>
        </div>
    </div>
    
    <h2 id="message-format">Message Format</h2>
    
    <h3>Standard Message Structure</h3>
    
    <pre><code>interface WebSocketMessage {
    type: string;           // Message type identifier
    data?: any;            // Message payload
    timestamp?: number;    // Unix timestamp
    id?: string;          // Message ID for tracking
    error?: string;       // Error message if applicable
}</code></pre>
    
    <h3>Common Message Types</h3>
    
    <div class="code-tabs">
        <div class="tab-headers">
            <div class="tab-header active" onclick="showTab(event, 'incoming-messages')">Incoming</div>
            <div class="tab-header" onclick="showTab(event, 'outgoing-messages')">Outgoing</div>
        </div>
        <div id="incoming-messages" class="tab-content active">
            <pre><code>// Incoming messages from server
const incomingMessages = {
    // Synchronization
    'sync': {
        type: 'sync',
        data: {
            entityChanges: [],
            lastSyncedPush: 12345
        }
    },
    
    // Entity changes
    'entity-changes': {
        type: 'entity-changes',
        data: [
            {
                entityName: 'notes',
                entityId: 'noteId123',
                action: 'update',
                entity: { /* note data */ }
            }
        ]
    },
    
    // Note events
    'note-created': {
        type: 'note-created',
        data: {
            noteId: 'newNoteId',
            title: 'New Note',
            parentNoteId: 'parentId'
        }
    },
    
    'note-updated': {
        type: 'note-updated',
        data: {
            noteId: 'noteId123',
            changes: { title: 'Updated Title' }
        }
    },
    
    'note-deleted': {
        type: 'note-deleted',
        data: {
            noteId: 'deletedNoteId'
        }
    },
    
    // Tree structure changes
    'refresh-tree': {
        type: 'refresh-tree',
        data: {
            noteId: 'affectedNoteId'
        }
    },
    
    // Script execution
    'frontend-script': {
        type: 'frontend-script',
        data: {
            script: 'console.log("Hello from backend")',
            params: { key: 'value' }
        }
    },
    
    // Progress updates
    'progress-update': {
        type: 'progress-update',
        data: {
            taskId: 'task123',
            progress: 75,
            message: 'Processing...'
        }
    },
    
    // LLM streaming
    'llm-stream': {
        type: 'llm-stream',
        chatNoteId: 'chatNote123',
        content: 'Streaming response...',
        done: false
    }
};</code></pre>
        </div>
        <div id="outgoing-messages" class="tab-content">
            <pre><code>// Outgoing messages to server
const outgoingMessages = {
    // Keep-alive ping
    'ping': {
        type: 'ping',
        timestamp: Date.now()
    },
    
    // Client logging
    'log-error': {
        type: 'log-error',
        error: 'Error message',
        stack: 'Stack trace'
    },
    
    'log-info': {
        type: 'log-info',
        info: 'Information message'
    },
    
    // Custom events
    'custom-event': {
        type: 'custom-event',
        data: {
            eventName: 'user-action',
            payload: { /* custom data */ }
        }
    }
};</code></pre>
        </div>
    </div>
    
    <h2 id="event-types">Event Types</h2>
    
    <h3>System Events</h3>
    
    <pre><code>class TriliumEventHandler {
    constructor(wsManager) {
        this.wsManager = wsManager;
        this.setupEventHandlers();
    }
    
    setupEventHandlers() {
        // Connection events
        this.wsManager.on('open', () => {
            console.log('Connected to Trilium');
            this.onConnect();
        });
        
        this.wsManager.on('close', () => {
            console.log('Disconnected from Trilium');
            this.onDisconnect();
        });
        
        this.wsManager.on('error', (error) => {
            console.error('WebSocket error:', error);
            this.onError(error);
        });
        
        this.wsManager.on('reconnecting', (info) => {
            console.log(`Reconnecting... Attempt ${info.attempt}`);
            this.onReconnecting(info);
        });
        
        // Trilium-specific events
        this.wsManager.on('sync', (data) => {
            this.handleSync(data);
        });
        
        this.wsManager.on('entity-changes', (changes) => {
            this.handleEntityChanges(changes);
        });
        
        this.wsManager.on('note-created', (note) => {
            this.handleNoteCreated(note);
        });
        
        this.wsManager.on('note-updated', (update) => {
            this.handleNoteUpdated(update);
        });
        
        this.wsManager.on('note-deleted', (deletion) => {
            this.handleNoteDeleted(deletion);
        });
        
        this.wsManager.on('refresh-tree', (data) => {
            this.handleTreeRefresh(data);
        });
    }
    
    onConnect() {
        // Update UI to show connected status
        this.updateConnectionStatus('connected');
    }
    
    onDisconnect() {
        // Update UI to show disconnected status
        this.updateConnectionStatus('disconnected');
    }
    
    onError(error) {
        // Handle error
        this.showError(error.message);
    }
    
    onReconnecting(info) {
        // Show reconnection status
        this.updateConnectionStatus(`reconnecting (${info.attempt})`);
    }
    
    handleSync(data) {
        console.log('Sync data received:', data);
        // Process synchronization data
        if (data.entityChanges && data.entityChanges.length > 0) {
            this.processSyncChanges(data.entityChanges);
        }
    }
    
    handleEntityChanges(changes) {
        console.log('Entity changes:', changes);
        
        changes.forEach(change => {
            switch (change.entityName) {
                case 'notes':
                    this.processNoteChange(change);
                    break;
                case 'branches':
                    this.processBranchChange(change);
                    break;
                case 'attributes':
                    this.processAttributeChange(change);
                    break;
            }
        });
    }
    
    handleNoteCreated(note) {
        console.log('Note created:', note);
        // Update local cache
        this.addNoteToCache(note);
        // Update UI
        this.addNoteToTree(note);
    }
    
    handleNoteUpdated(update) {
        console.log('Note updated:', update);
        // Update local cache
        this.updateNoteInCache(update.noteId, update.changes);
        // Update UI if note is visible
        if (this.isNoteVisible(update.noteId)) {
            this.refreshNoteDisplay(update.noteId);
        }
    }
    
    handleNoteDeleted(deletion) {
        console.log('Note deleted:', deletion);
        // Remove from cache
        this.removeNoteFromCache(deletion.noteId);
        // Update UI
        this.removeNoteFromTree(deletion.noteId);
    }
    
    handleTreeRefresh(data) {
        console.log('Tree refresh requested:', data);
        // Refresh tree structure
        this.refreshTreeBranch(data.noteId);
    }
    
    // Placeholder methods for UI updates
    updateConnectionStatus(status) { /* ... */ }
    showError(message) { /* ... */ }
    processSyncChanges(changes) { /* ... */ }
    processNoteChange(change) { /* ... */ }
    processBranchChange(change) { /* ... */ }
    processAttributeChange(change) { /* ... */ }
    addNoteToCache(note) { /* ... */ }
    addNoteToTree(note) { /* ... */ }
    updateNoteInCache(noteId, changes) { /* ... */ }
    isNoteVisible(noteId) { /* ... */ }
    refreshNoteDisplay(noteId) { /* ... */ }
    removeNoteFromCache(noteId) { /* ... */ }
    removeNoteFromTree(noteId) { /* ... */ }
    refreshTreeBranch(noteId) { /* ... */ }
}</code></pre>
    
    <h2 id="real-time-synchronization">Real-time Synchronization</h2>
    
    <div class="info-box">
        <strong>Note:</strong> The synchronization protocol ensures that all connected clients stay in sync with minimal conflicts and optimal performance.
    </div>
    
    <h3>Sync Protocol Implementation</h3>
    
    <pre><code>class TriliumSyncManager {
    constructor(wsManager) {
        this.wsManager = wsManager;
        this.lastSyncedPush = null;
        this.pendingChanges = [];
        this.syncInProgress = false;
        
        this.setupSyncHandlers();
    }
    
    setupSyncHandlers() {
        this.wsManager.on('sync', (data) => {
            this.handleIncomingSync(data);
        });
        
        this.wsManager.on('sync-complete', (data) => {
            this.onSyncComplete(data);
        });
        
        this.wsManager.on('sync-error', (error) => {
            this.onSyncError(error);
        });
    }
    
    async handleIncomingSync(syncData) {
        console.log('Processing sync data:', syncData);
        
        this.syncInProgress = true;
        
        try {
            // Process entity changes in order
            for (const change of syncData.entityChanges) {
                await this.processEntityChange(change);
            }
            
            // Update sync position
            this.lastSyncedPush = syncData.lastSyncedPush;
            
            // Send acknowledgment
            this.wsManager.send({
                type: 'sync-ack',
                lastSyncedPush: this.lastSyncedPush
            });
            
        } catch (error) {
            console.error('Sync processing error:', error);
            this.wsManager.send({
                type: 'sync-error',
                error: error.message,
                lastSyncedPush: this.lastSyncedPush
            });
        } finally {
            this.syncInProgress = false;
            this.processPendingChanges();
        }
    }
    
    async processEntityChange(change) {
        const { entityName, entityId, action, entity } = change;
        
        console.log(`Processing ${action} for ${entityName}:${entityId}`);
        
        switch (entityName) {
            case 'notes':
                await this.processNoteChange(action, entityId, entity);
                break;
            case 'branches':
                await this.processBranchChange(action, entityId, entity);
                break;
            case 'attributes':
                await this.processAttributeChange(action, entityId, entity);
                break;
            case 'note_contents':
                await this.processContentChange(action, entityId, entity);
                break;
        }
    }
    
    async processNoteChange(action, noteId, noteData) {
        switch (action) {
            case 'create':
                await this.createNote(noteId, noteData);
                break;
            case 'update':
                await this.updateNote(noteId, noteData);
                break;
            case 'delete':
                await this.deleteNote(noteId);
                break;
        }
    }
    
    async createNote(noteId, noteData) {
        // Add to local database/cache
        await localDB.notes.add({
            ...noteData,
            noteId,
            syncVersion: this.lastSyncedPush
        });
        
        // Emit event for UI update
        this.emit('note-created', { noteId, noteData });
    }
    
    async updateNote(noteId, updates) {
        // Update local database/cache
        await localDB.notes.update(noteId, {
            ...updates,
            syncVersion: this.lastSyncedPush
        });
        
        // Emit event for UI update
        this.emit('note-updated', { noteId, updates });
    }
    
    async deleteNote(noteId) {
        // Remove from local database/cache
        await localDB.notes.delete(noteId);
        
        // Emit event for UI update
        this.emit('note-deleted', { noteId });
    }
    
    // Send local changes to server
    async pushLocalChanges() {
        if (this.syncInProgress) {
            return;
        }
        
        const localChanges = await this.getLocalChanges();
        
        if (localChanges.length === 0) {
            return;
        }
        
        this.wsManager.send({
            type: 'push-changes',
            changes: localChanges,
            lastSyncedPull: this.lastSyncedPull
        });
    }
    
    async getLocalChanges() {
        // Get changes from local database that haven't been synced
        const changes = await localDB.changes
            .where('syncVersion')
            .above(this.lastSyncedPush || 0)
            .toArray();
        
        return changes;
    }
    
    processPendingChanges() {
        if (this.pendingChanges.length > 0 && !this.syncInProgress) {
            const changes = this.pendingChanges.splice(0);
            this.handleIncomingSync({ entityChanges: changes });
        }
    }
    
    emit(event, data) {
        // Emit events to application
        window.dispatchEvent(new CustomEvent(`trilium:${event}`, { detail: data }));
    }
}</code></pre>
    
    <h2 id="custom-event-broadcasting">Custom Event Broadcasting</h2>
    
    <h3>Creating Custom Events</h3>
    
    <pre><code>class CustomEventBroadcaster {
    constructor(wsManager) {
        this.wsManager = wsManager;
        this.eventListeners = new Map();
    }
    
    // Broadcast event to all connected clients
    broadcast(eventName, data) {
        this.wsManager.send({
            type: 'custom-broadcast',
            eventName,
            data,
            timestamp: Date.now()
        });
    }
    
    // Send event to specific clients
    sendToClients(clientIds, eventName, data) {
        this.wsManager.send({
            type: 'targeted-broadcast',
            targets: clientIds,
            eventName,
            data,
            timestamp: Date.now()
        });
    }
    
    // Subscribe to custom events
    subscribe(eventName, handler) {
        if (!this.eventListeners.has(eventName)) {
            this.eventListeners.set(eventName, []);
        }
        
        this.eventListeners.get(eventName).push(handler);
        
        // Register with server
        this.wsManager.send({
            type: 'subscribe',
            eventName
        });
    }
    
    // Unsubscribe from events
    unsubscribe(eventName, handler) {
        const handlers = this.eventListeners.get(eventName);
        if (handlers) {
            const index = handlers.indexOf(handler);
            if (index !== -1) {
                handlers.splice(index, 1);
            }
            
            if (handlers.length === 0) {
                this.eventListeners.delete(eventName);
                
                // Unregister with server
                this.wsManager.send({
                    type: 'unsubscribe',
                    eventName
                });
            }
        }
    }
    
    // Handle incoming custom events
    handleCustomEvent(message) {
        const { eventName, data } = message;
        const handlers = this.eventListeners.get(eventName);
        
        if (handlers) {
            handlers.forEach(handler => {
                try {
                    handler(data);
                } catch (error) {
                    console.error(`Error handling custom event ${eventName}:`, error);
                }
            });
        }
    }
}

// Usage example
const broadcaster = new CustomEventBroadcaster(wsManager);

// Subscribe to custom events
broadcaster.subscribe('user-joined', (data) => {
    console.log(`User ${data.username} joined`);
});

broadcaster.subscribe('collaborative-edit', (data) => {
    console.log(`Edit on note ${data.noteId}: ${data.change}`);
});

// Broadcast custom event
broadcaster.broadcast('user-action', {
    action: 'viewed-note',
    noteId: 'abc123',
    userId: 'user456'
});</code></pre>
    
    <h2 id="client-implementation-examples">Client Implementation Examples</h2>
    
    <div class="code-tabs">
        <div class="tab-headers">
            <div class="tab-header active" onclick="showTab(event, 'react-hook')">React Hook</div>
            <div class="tab-header" onclick="showTab(event, 'vue-composable')">Vue Composable</div>
            <div class="tab-header" onclick="showTab(event, 'angular-service')">Angular Service</div>
        </div>
        <div id="react-hook" class="tab-content active">
            <pre><code>// useWebSocket.js
import { useEffect, useRef, useState, useCallback } from 'react';

export function useTriliumWebSocket(url, options = {}) {
    const [isConnected, setIsConnected] = useState(false);
    const [lastMessage, setLastMessage] = useState(null);
    const [error, setError] = useState(null);
    
    const wsManager = useRef(null);
    const messageHandlers = useRef(new Map());
    
    useEffect(() => {
        wsManager.current = new TriliumWebSocketManager(url, options);
        
        wsManager.current.on('open', () => {
            setIsConnected(true);
            setError(null);
        });
        
        wsManager.current.on('close', () => {
            setIsConnected(false);
        });
        
        wsManager.current.on('error', (err) => {
            setError(err);
        });
        
        wsManager.current.on('message', (msg) => {
            setLastMessage(msg);
            
            // Call registered handlers
            const handler = messageHandlers.current.get(msg.type);
            if (handler) {
                handler(msg.data || msg);
            }
        });
        
        wsManager.current.connect();
        
        return () => {
            wsManager.current.close();
        };
    }, [url]);
    
    const sendMessage = useCallback((message) => {
        if (wsManager.current) {
            wsManager.current.send(message);
        }
    }, []);
    
    const subscribe = useCallback((messageType, handler) => {
        messageHandlers.current.set(messageType, handler);
        
        return () => {
            messageHandlers.current.delete(messageType);
        };
    }, []);
    
    return {
        isConnected,
        lastMessage,
        error,
        sendMessage,
        subscribe
    };
}

// Usage in React component
function TriliumNoteEditor({ noteId }) {
    const { isConnected, sendMessage, subscribe } = useTriliumWebSocket(
        'ws://localhost:8080'
    );
    
    const [content, setContent] = useState('');
    
    useEffect(() => {
        // Subscribe to note updates
        const unsubscribe = subscribe('note-updated', (data) => {
            if (data.noteId === noteId) {
                setContent(data.content);
            }
        });
        
        return unsubscribe;
    }, [noteId, subscribe]);
    
    const handleContentChange = (newContent) => {
        setContent(newContent);
        
        // Send update via WebSocket
        sendMessage({
            type: 'update-note',
            noteId,
            content: newContent
        });
    };
    
    return (
        &lt;div&gt;
            &lt;div&gt;Connection: {isConnected ? '🟢' : '🔴'}&lt;/div&gt;
            &lt;textarea
                value={content}
                onChange={(e) => handleContentChange(e.target.value)}
            /&gt;
        &lt;/div&gt;
    );
}</code></pre>
        </div>
        <div id="vue-composable" class="tab-content">
            <pre><code>// useTriliumWebSocket.js
import { ref, onMounted, onUnmounted } from 'vue';

export function useTriliumWebSocket(url, options = {}) {
    const isConnected = ref(false);
    const lastMessage = ref(null);
    const error = ref(null);
    
    let wsManager = null;
    const messageHandlers = new Map();
    
    onMounted(() => {
        wsManager = new TriliumWebSocketManager(url, options);
        
        wsManager.on('open', () => {
            isConnected.value = true;
            error.value = null;
        });
        
        wsManager.on('close', () => {
            isConnected.value = false;
        });
        
        wsManager.on('error', (err) => {
            error.value = err;
        });
        
        wsManager.on('message', (msg) => {
            lastMessage.value = msg;
            
            const handler = messageHandlers.get(msg.type);
            if (handler) {
                handler(msg.data || msg);
            }
        });
        
        wsManager.connect();
    });
    
    onUnmounted(() => {
        if (wsManager) {
            wsManager.close();
        }
    });
    
    const sendMessage = (message) => {
        if (wsManager) {
            wsManager.send(message);
        }
    };
    
    const subscribe = (messageType, handler) => {
        messageHandlers.set(messageType, handler);
        
        return () => {
            messageHandlers.delete(messageType);
        };
    };
    
    return {
        isConnected,
        lastMessage,
        error,
        sendMessage,
        subscribe
    };
}</code></pre>
        </div>
        <div id="angular-service" class="tab-content">
            <pre><code>// trilium-websocket.service.ts
import { Injectable, OnDestroy } from '@angular/core';
import { BehaviorSubject, Observable, Subject } from 'rxjs';
import { filter, map } from 'rxjs/operators';

@Injectable({
    providedIn: 'root'
})
export class TriliumWebSocketService implements OnDestroy {
    private wsManager: TriliumWebSocketManager | null = null;
    private isConnected$ = new BehaviorSubject&lt;boolean&gt;(false);
    private messages$ = new Subject&lt;any&gt;();
    private error$ = new Subject&lt;Error&gt;();
    
    constructor() {}
    
    connect(url: string, options: any = {}): void {
        this.wsManager = new TriliumWebSocketManager(url, options);
        
        this.wsManager.on('open', () => {
            this.isConnected$.next(true);
        });
        
        this.wsManager.on('close', () => {
            this.isConnected$.next(false);
        });
        
        this.wsManager.on('error', (error) => {
            this.error$.next(error);
        });
        
        this.wsManager.on('message', (message) => {
            this.messages$.next(message);
        });
        
        this.wsManager.connect();
    }
    
    disconnect(): void {
        if (this.wsManager) {
            this.wsManager.close();
            this.wsManager = null;
        }
    }
    
    send(message: any): void {
        if (this.wsManager) {
            this.wsManager.send(message);
        }
    }
    
    getConnectionStatus(): Observable&lt;boolean&gt; {
        return this.isConnected$.asObservable();
    }
    
    getMessages(): Observable&lt;any&gt; {
        return this.messages$.asObservable();
    }
    
    getMessagesByType(type: string): Observable&lt;any&gt; {
        return this.messages$.pipe(
            filter(msg => msg.type === type),
            map(msg => msg.data || msg)
        );
    }
    
    getErrors(): Observable&lt;Error&gt; {
        return this.error$.asObservable();
    }
    
    ngOnDestroy(): void {
        this.disconnect();
    }
}</code></pre>
        </div>
    </div>
    
    <h2 id="debugging-websocket-connections">Debugging WebSocket Connections</h2>
    
    <div class="warning-box">
        <strong>Debug Mode:</strong> The following debug tools should only be used in development environments. They may impact performance and expose sensitive information.
    </div>
    
    <h3>Debug Logger</h3>
    
    <pre><code>class WebSocketDebugger {
    constructor(wsManager, options = {}) {
        this.wsManager = wsManager;
        this.options = {
            logMessages: true,
            logEvents: true,
            logErrors: true,
            maxLogSize: 100,
            ...options
        };
        
        this.logs = [];
        this.stats = {
            messagesSent: 0,
            messagesReceived: 0,
            bytesReceived: 0,
            errors: 0,
            reconnects: 0,
            latency: []
        };
        
        this.setupDebugHandlers();
    }
    
    setupDebugHandlers() {
        // Intercept send method
        const originalSend = this.wsManager.send.bind(this.wsManager);
        this.wsManager.send = (data) => {
            this.logOutgoing(data);
            this.stats.messagesSent++;
            return originalSend(data);
        };
        
        // Log incoming messages
        this.wsManager.on('message', (message) => {
            this.logIncoming(message);
            this.stats.messagesReceived++;
        });
        
        // Log events
        this.wsManager.on('open', () => {
            this.logEvent('Connected');
        });
        
        this.wsManager.on('close', (event) => {
            this.logEvent(`Disconnected (code: ${event.code})`);
        });
        
        this.wsManager.on('error', (error) => {
            this.logError(error);
            this.stats.errors++;
        });
        
        this.wsManager.on('reconnecting', (info) => {
            this.logEvent(`Reconnecting (attempt ${info.attempt})`);
            this.stats.reconnects++;
        });
        
        this.wsManager.on('latency', (latency) => {
            this.stats.latency.push(latency);
            if (this.stats.latency.length > 100) {
                this.stats.latency.shift();
            }
        });
    }
    
    logOutgoing(data) {
        if (this.options.logMessages) {
            this.addLog('OUT', data);
            console.log('%c→ OUT', 'color: #4CAF50', data);
        }
    }
    
    logIncoming(data) {
        if (this.options.logMessages) {
            this.addLog('IN', data);
            console.log('%c← IN', 'color: #2196F3', data);
        }
        
        // Track data size
        const size = JSON.stringify(data).length;
        this.stats.bytesReceived += size;
    }
    
    logEvent(event) {
        if (this.options.logEvents) {
            this.addLog('EVENT', event);
            console.log('%c● EVENT', 'color: #FF9800', event);
        }
    }
    
    logError(error) {
        if (this.options.logErrors) {
            this.addLog('ERROR', error);
            console.error('WebSocket Error:', error);
        }
    }
    
    addLog(type, data) {
        const log = {
            type,
            data,
            timestamp: new Date().toISOString()
        };
        
        this.logs.push(log);
        
        // Limit log size
        if (this.logs.length > this.options.maxLogSize) {
            this.logs.shift();
        }
    }
    
    getStats() {
        const avgLatency = this.stats.latency.length > 0
            ? this.stats.latency.reduce((a, b) => a + b, 0) / this.stats.latency.length
            : 0;
        
        return {
            ...this.stats,
            averageLatency: avgLatency,
            currentLatency: this.stats.latency[this.stats.latency.length - 1] || 0
        };
    }
    
    getLogs(filter = null) {
        if (filter) {
            return this.logs.filter(log => log.type === filter);
        }
        return this.logs;
    }
    
    exportLogs() {
        const data = {
            logs: this.logs,
            stats: this.getStats(),
            timestamp: new Date().toISOString()
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], {
            type: 'application/json'
        });
        
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `websocket-debug-${Date.now()}.json`;
        a.click();
        
        URL.revokeObjectURL(url);
    }
    
    createDebugPanel() {
        const panel = document.createElement('div');
        panel.id = 'ws-debug-panel';
        panel.innerHTML = `
            &lt;style&gt;
                #ws-debug-panel {
                    position: fixed;
                    bottom: 0;
                    right: 0;
                    width: 400px;
                    height: 300px;
                    background: #1e1e1e;
                    color: #fff;
                    font-family: monospace;
                    font-size: 12px;
                    z-index: 10000;
                    display: flex;
                    flex-direction: column;
                }
                #ws-debug-header {
                    padding: 10px;
                    background: #2d2d2d;
                    display: flex;
                    justify-content: space-between;
                }
                #ws-debug-stats {
                    padding: 10px;
                    border-bottom: 1px solid #444;
                }
                #ws-debug-logs {
                    flex: 1;
                    overflow-y: auto;
                    padding: 10px;
                }
                .ws-log-entry {
                    margin-bottom: 5px;
                    padding: 5px;
                    background: #2d2d2d;
                    border-radius: 3px;
                }
                .ws-log-out { border-left: 3px solid #4CAF50; }
                .ws-log-in { border-left: 3px solid #2196F3; }
                .ws-log-event { border-left: 3px solid #FF9800; }
                .ws-log-error { border-left: 3px solid #f44336; }
            &lt;/style&gt;
            &lt;div id="ws-debug-header"&gt;
                &lt;span&gt;WebSocket Debug&lt;/span&gt;
                &lt;button onclick="this.parentElement.parentElement.remove()"&gt;✕&lt;/button&gt;
            &lt;/div&gt;
            &lt;div id="ws-debug-stats"&gt;&lt;/div&gt;
            &lt;div id="ws-debug-logs"&gt;&lt;/div&gt;
        `;
        
        document.body.appendChild(panel);
        
        // Update stats periodically
        setInterval(() => {
            this.updateDebugPanel();
        }, 1000);
    }
    
    updateDebugPanel() {
        const statsEl = document.getElementById('ws-debug-stats');
        const logsEl = document.getElementById('ws-debug-logs');
        
        if (!statsEl || !logsEl) return;
        
        const stats = this.getStats();
        statsEl.innerHTML = `
            &lt;div&gt;Sent: ${stats.messagesSent} | Received: ${stats.messagesReceived}&lt;/div&gt;
            &lt;div&gt;Bytes: ${(stats.bytesReceived / 1024).toFixed(2)} KB&lt;/div&gt;
            &lt;div&gt;Latency: ${stats.currentLatency}ms (avg: ${stats.averageLatency.toFixed(1)}ms)&lt;/div&gt;
            &lt;div&gt;Errors: ${stats.errors} | Reconnects: ${stats.reconnects}&lt;/div&gt;
        `;
        
        // Show recent logs
        const recentLogs = this.logs.slice(-10);
        logsEl.innerHTML = recentLogs.map(log => `
            &lt;div class="ws-log-entry ws-log-${log.type.toLowerCase()}"&gt;
                &lt;small&gt;${new Date(log.timestamp).toLocaleTimeString()}&lt;/small&gt;
                ${log.type}: ${typeof log.data === 'object' ? JSON.stringify(log.data).substring(0, 100) : log.data}
            &lt;/div&gt;
        `).join('');
    }
}

// Usage
const debugger = new WebSocketDebugger(wsManager, {
    logMessages: true,
    logEvents: true,
    logErrors: true
});

// Create visual debug panel
debugger.createDebugPanel();

// Export logs for analysis
debugger.exportLogs();</code></pre>
    
    <h2 id="best-practices">Best Practices</h2>
    
    <div class="feature-grid">
        <div class="feature-card">
            <h4>1. Connection Management</h4>
            <ul>
                <li>Always implement reconnection logic with exponential backoff</li>
                <li>Handle connection state changes gracefully</li>
                <li>Queue messages during disconnection</li>
                <li>Implement heartbeat/ping mechanism</li>
            </ul>
        </div>
        <div class="feature-card">
            <h4>2. Message Handling</h4>
            <ul>
                <li>Always validate incoming message format</li>
                <li>Use structured message types</li>
                <li>Implement message acknowledgment for critical operations</li>
                <li>Handle message ordering and deduplication</li>
            </ul>
        </div>
        <div class="feature-card">
            <h4>3. Error Recovery</h4>
            <ul>
                <li>Implement comprehensive error handling</li>
                <li>Log errors for debugging</li>
                <li>Provide user feedback for connection issues</li>
                <li>Implement fallback mechanisms</li>
            </ul>
        </div>
        <div class="feature-card">
            <h4>4. Performance</h4>
            <ul>
                <li>Batch messages when possible</li>
                <li>Implement message compression for large payloads</li>
                <li>Use binary frames for file transfers</li>
                <li>Limit message frequency (throttle/debounce)</li>
            </ul>
        </div>
        <div class="feature-card">
            <h4>5. Security</h4>
            <ul>
                <li>Always use WSS (WebSocket Secure) in production</li>
                <li>Validate all incoming data</li>
                <li>Implement rate limiting</li>
                <li>Use authentication tokens with expiration</li>
            </ul>
        </div>
    </div>
    
    <h2>Conclusion</h2>
    
    <div class="highlight-box">
        <h3>Key Takeaways</h3>
        <p>The Trilium WebSocket API provides powerful real-time capabilities for building responsive, collaborative applications.</p>
    </div>
    
    <ol>
        <li><strong>Use WebSocket for real-time features</strong> - synchronization, collaboration, live updates</li>
        <li><strong>Implement robust connection management</strong> - reconnection, queuing, state handling</li>
        <li><strong>Handle all message types</strong> - system events, custom events, errors</li>
        <li><strong>Debug thoroughly</strong> - use logging, monitoring, and debugging tools</li>
        <li><strong>Follow best practices</strong> - security, performance, error handling</li>
    </ol>
    
    <div class="navigation-links">
        <h3>Related Documentation</h3>
        <a href="./Internal%20API%20Reference.html">Internal API Reference</a>
        <a href="./ETAPI%20Complete%20Guide.html">ETAPI Complete Guide</a>
        <a href="./API%20Client%20Libraries.html">API Client Libraries</a>
    </div>
    
    <script>
        function showTab(event, tabId) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tab headers
            const tabHeaders = event.target.parentNode.querySelectorAll('.tab-header');
            tabHeaders.forEach(header => {
                header.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabId).classList.add('active');
            
            // Add active class to clicked tab header
            event.target.classList.add('active');
        }
    </script>
</body>
</html>