<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Widget Development Guide - Trilium Developer Guide</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .content {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-bottom: 1px solid #ecf0f1;
            padding-bottom: 8px;
        }
        h3 {
            color: #555;
            margin-top: 25px;
        }
        pre {
            background: #f8f8f8;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 16px;
            overflow-x: auto;
        }
        code {
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Courier New', monospace;
        }
        pre code {
            background: none;
            padding: 0;
        }
        blockquote {
            border-left: 4px solid #3498db;
            margin: 0;
            padding-left: 20px;
            color: #666;
            font-style: italic;
        }
        ul, ol {
            margin: 16px 0;
            padding-left: 30px;
        }
        li {
            margin: 8px 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 12px;
            margin: 20px 0;
        }
        .info {
            background: #d1ecf1;
            border: 1px solid #17a2b8;
            border-radius: 4px;
            padding: 12px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="content">
        <h1>Custom Widget Development Guide</h1>

<p>This guide provides comprehensive instructions for creating custom widgets in Trilium Notes. Widgets are fundamental UI components that enable you to extend Trilium's functionality with custom interfaces and behaviors.</p>

<h2>Prerequisites</h2>

<p>Before developing custom widgets, ensure you have:
- Basic knowledge of TypeScript/JavaScript
- Understanding of jQuery and DOM manipulation
- Familiarity with Trilium's note structure
- A development environment with Trilium running locally</p>

<h2>Understanding Widget Architecture</h2>

<h3>Widget Hierarchy</h3>

<p>Trilium's widget system follows a hierarchical structure:</p>

<pre><code>Component (base class)
    └── BasicWidget
        ├── NoteContextAwareWidget
        │   ├── TypeWidget (for note type widgets)
        │   └── RightPanelWidget
        └── Custom widgets (buttons, containers, etc.)
</code></pre>

<h3>Core Widget Classes</h3>

<p>#### BasicWidget
The foundation class for all widgets. Provides basic rendering, positioning, and visibility management.</p>

<pre><code class="language-typescript">import BasicWidget from "../widgets/basic_widget.js";

<p>class MyCustomWidget extends BasicWidget {
    doRender() {
        this.$widget = $('<div class="my-widget">Hello Widget</div>');
    }
}
</code></pre></p>

<p>#### NoteContextAwareWidget
Extends BasicWidget to respond to note changes. Use this when your widget needs to update based on the active note.</p>

<pre><code class="language-typescript">import NoteContextAwareWidget from "../widgets/note_context_aware_widget.js";

<p>class NoteInfoWidget extends NoteContextAwareWidget {
    async refreshWithNote(note) {
        if (!note) return;
        
        this.$widget.find('.note-title').text(note.title);
        this.$widget.find('.note-type').text(note.type);
    }
    
    doRender() {
        this.$widget = $(<code>
            <div class="note-info-widget">
                <div class="note-title"></div>
                <div class="note-type"></div>
            </div>
        </code>);
    }
}
</code></pre></p>

<p>#### RightPanelWidget
Specialized widget for rendering panels in the right sidebar with a consistent card layout.</p>

<pre><code class="language-typescript">import RightPanelWidget from "../widgets/right_panel_widget.js";

<p>class StatisticsWidget extends RightPanelWidget {
    get widgetTitle() { 
        return "Note Statistics"; 
    }
    
    async doRenderBody() {
        this.$body.html(<code>
            <div class="stats-container">
                <div class="word-count">Words: <span>0</span></div>
                <div class="char-count">Characters: <span>0</span></div>
            </div>
        </code>);
    }
    
    async refreshWithNote(note) {
        const content = await note.getContent();
        const wordCount = content.split(/\s+/).length;
        const charCount = content.length;
        
        this.$body.find('.word-count span').text(wordCount);
        this.$body.find('.char-count span').text(charCount);
    }
}
</code></pre></p>

<h2>Widget Lifecycle</h2>

<h3>Initialization Phase</h3>
<li><strong>Constructor</strong>: Set up initial state and child widgets</li>
<li><strong>render()</strong>: Called to create the widget's DOM structure</li>
<li><strong>doRender()</strong>: Override this to create your widget's HTML</li>

<h3>Update Phase</h3>
<li><strong>refresh()</strong>: Called when widget needs updating</li>
<li><strong>refreshWithNote()</strong>: Called for NoteContextAwareWidget when note changes</li>
<li><strong>Event handlers</strong>: Respond to various Trilium events</li>

<h3>Cleanup Phase</h3>
<li><strong>cleanup()</strong>: Override to clean up resources, event listeners, etc.</li>
<li><strong>remove()</strong>: Removes widget from DOM</li>

<h2>Event Handling</h2>

<h3>Subscribing to Events</h3>

<p>Widgets can listen to Trilium's event system:</p>

<pre><code class="language-typescript">class EventAwareWidget extends NoteContextAwareWidget {
    constructor() {
        super();
        // Events are automatically subscribed based on method names
    }
    
    // Called when entities are reloaded
    async entitiesReloadedEvent({ loadResults }) {
        console.log('Entities reloaded');
        await this.refresh();
    }
    
    // Called when note content changes
    async noteContentChangedEvent({ noteId }) {
        if (this.noteId === noteId) {
            await this.refresh();
        }
    }
    
    // Called when active context changes
    async activeContextChangedEvent({ noteContext }) {
        this.noteContext = noteContext;
        await this.refresh();
    }
}
</code></pre>

<h3>Common Events</h3>

<p>- <code>noteSwitched</code>: Active note changed
- <code>activeContextChanged</code>: Active tab/context changed
- <code>entitiesReloaded</code>: Notes, branches, or attributes reloaded
- <code>noteContentChanged</code>: Note content modified
- <code>noteTypeMimeChanged</code>: Note type or MIME changed
- <code>frocaReloaded</code>: Frontend cache reloaded</p>

<h2>State Management</h2>

<h3>Local State</h3>
Store widget-specific state in instance properties:

<pre><code class="language-typescript">class StatefulWidget extends BasicWidget {
    constructor() {
        super();
        this.isExpanded = false;
        this.cachedData = null;
    }
    
    toggleExpanded() {
        this.isExpanded = !this.isExpanded;
        this.$widget.toggleClass('expanded', this.isExpanded);
    }
}
</code></pre>

<h3>Persistent State</h3>
Use options or attributes for persistent state:

<pre><code class="language-typescript">class PersistentWidget extends NoteContextAwareWidget {
    async saveState(state) {
        await server.put('options', {
            name: 'widgetState',
            value: JSON.stringify(state)
        });
    }
    
    async loadState() {
        const option = await server.get('options/widgetState');
        return option ? JSON.parse(option.value) : {};
    }
}
</code></pre>

<h2>Accessing Trilium APIs</h2>

<h3>Frontend Services</h3>

<pre><code class="language-typescript">import froca from "../services/froca.js";
import server from "../services/server.js";
import linkService from "../services/link.js";
import toastService from "../services/toast.js";
import dialogService from "../services/dialog.js";

<p>class ApiWidget extends NoteContextAwareWidget {
    async doRenderBody() {
        // Access notes
        const note = await froca.getNote(this.noteId);
        
        // Get attributes
        const attributes = note.getAttributes();
        
        // Create links
        const $link = await linkService.createLink(note.noteId);
        
        // Show notifications
        toastService.showMessage("Widget loaded");
        
        // Open dialogs
        const result = await dialogService.confirm("Continue?");
    }
}
</code></pre></p>

<h3>Server Communication</h3>

<pre><code class="language-typescript">class ServerWidget extends BasicWidget {
    async loadData() {
        // GET request
        const data = await server.get('custom-api/data');
        
        // POST request
        const result = await server.post('custom-api/process', {
            noteId: this.noteId,
            action: 'analyze'
        });
        
        // PUT request
        await server.put(<code>notes/${this.noteId}</code>, {
            title: 'Updated Title'
        });
    }
}
</code></pre>

<h2>Styling Widgets</h2>

<h3>Inline Styles</h3>
<pre><code class="language-typescript">class StyledWidget extends BasicWidget {
    doRender() {
        this.$widget = $('<div>');
        this.css('padding', '10px')
            .css('background-color', '#f0f0f0')
            .css('border-radius', '4px');
    }
}
</code></pre>

<h3>CSS Classes</h3>
<pre><code class="language-typescript">class ClassedWidget extends BasicWidget {
    doRender() {
        this.$widget = $('<div>');
        this.class('custom-widget')
            .class('bordered');
    }
}
</code></pre>

<h3>CSS Blocks</h3>
<pre><code class="language-typescript">class CSSBlockWidget extends BasicWidget {
    doRender() {
        this.$widget = $('<div class="my-widget">Content</div>');
        
        this.cssBlock(<code>
            .my-widget {
                padding: 15px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border-radius: 8px;
            }
            
            .my-widget:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            }
        </code>);
    }
}
</code></pre>

<h2>Performance Optimization</h2>

<h3>Lazy Loading</h3>
<pre><code class="language-typescript">class LazyWidget extends NoteContextAwareWidget {
    constructor() {
        super();
        this.dataLoaded = false;
    }
    
    async refreshWithNote(note) {
        if (!this.isVisible()) {
            return; // Don't load if not visible
        }
        
        if (!this.dataLoaded) {
            await this.loadExpensiveData();
            this.dataLoaded = true;
        }
        
        this.updateDisplay();
    }
}
</code></pre>

<h3>Debouncing Updates</h3>
<pre><code class="language-typescript">import SpacedUpdate from "../services/spaced_update.js";

<p>class DebouncedWidget extends NoteContextAwareWidget {
    constructor() {
        super();
        this.spacedUpdate = new SpacedUpdate(async () => {
            await this.performUpdate();
        }, 500); // 500ms delay
    }
    
    async handleInput(value) {
        await this.spacedUpdate.scheduleUpdate();
    }
}
</code></pre></p>

<h3>Caching</h3>
<pre><code class="language-typescript">class CachedWidget extends NoteContextAwareWidget {
    constructor() {
        super();
        this.cache = new Map();
    }
    
    async getProcessedData(noteId) {
        if (!this.cache.has(noteId)) {
            const data = await this.processExpensiveOperation(noteId);
            this.cache.set(noteId, data);
        }
        return this.cache.get(noteId);
    }
    
    cleanup() {
        this.cache.clear();
    }
}
</code></pre>

<h2>Debugging Widgets</h2>

<h3>Console Logging</h3>
<pre><code class="language-typescript">class DebugWidget extends BasicWidget {
    doRender() {
        console.log('Widget rendering', this.componentId);
        console.time('render');
        
        this.$widget = $('<div>');
        
        console.timeEnd('render');
    }
}
</code></pre>

<h3>Error Handling</h3>
<pre><code class="language-typescript">class SafeWidget extends NoteContextAwareWidget {
    async refreshWithNote(note) {
        try {
            await this.riskyOperation();
        } catch (error) {
            console.error('Widget error:', error);
            this.logRenderingError(error);
            this.$widget.html('<div class="error">Failed to load</div>');
        }
    }
}
</code></pre>

<h3>Development Tools</h3>
<pre><code class="language-typescript">class DevWidget extends BasicWidget {
    doRender() {
        this.$widget = $('<div>');
        
        // Add debug information in development
        if (window.glob.isDev) {
            this.$widget.attr('data-debug', 'true');
            this.$widget.append(<code>
                <div class="debug-info">
                    Component ID: ${this.componentId}
                    Position: ${this.position}
                </div>
            </code>);
        }
    }
}
</code></pre>

<h2>Complete Example: Note Statistics Widget</h2>

<p>Here's a complete example implementing a custom note statistics widget:</p>

<pre><code class="language-typescript">import RightPanelWidget from "../widgets/right_panel_widget.js";
import server from "../services/server.js";
import froca from "../services/froca.js";
import toastService from "../services/toast.js";
import SpacedUpdate from "../services/spaced_update.js";

<p>class NoteStatisticsWidget extends RightPanelWidget {
    constructor() {
        super();
        
        // Initialize state
        this.statistics = {
            words: 0,
            characters: 0,
            paragraphs: 0,
            readingTime: 0,
            links: 0,
            images: 0
        };
        
        // Debounce updates for performance
        this.spacedUpdate = new SpacedUpdate(async () => {
            await this.calculateStatistics();
        }, 300);
    }
    
    get widgetTitle() {
        return "Note Statistics";
    }
    
    get help() {
        return {
            title: "Note Statistics",
            text: "Displays various statistics about the current note including word count, reading time, and more."
        };
    }
    
    async doRenderBody() {
        this.$body.html(<code>
            <div class="note-statistics">
                <div class="stat-group">
                    <h5>Content</h5>
                    <div class="stat-item">
                        <span class="stat-label">Words:</span>
                        <span class="stat-value" data-stat="words">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Characters:</span>
                        <span class="stat-value" data-stat="characters">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Paragraphs:</span>
                        <span class="stat-value" data-stat="paragraphs">0</span>
                    </div>
                </div>
                
                <div class="stat-group">
                    <h5>Reading</h5>
                    <div class="stat-item">
                        <span class="stat-label">Reading time:</span>
                        <span class="stat-value" data-stat="readingTime">0 min</span>
                    </div>
                </div>
                
                <div class="stat-group">
                    <h5>Elements</h5>
                    <div class="stat-item">
                        <span class="stat-label">Links:</span>
                        <span class="stat-value" data-stat="links">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Images:</span>
                        <span class="stat-value" data-stat="images">0</span>
                    </div>
                </div>
                
                <div class="stat-actions">
                    <button class="btn btn-sm refresh-stats">Refresh</button>
                    <button class="btn btn-sm export-stats">Export</button>
                </div>
            </div>
        </code>);
        
        this.cssBlock(<code>
            .note-statistics {
                padding: 10px;
            }
            
            .stat-group {
                margin-bottom: 15px;
                padding-bottom: 15px;
                border-bottom: 1px solid var(--main-border-color);
            }
            
            .stat-group:last-child {
                border-bottom: none;
            }
            
            .stat-group h5 {
                margin: 0 0 10px 0;
                color: var(--muted-text-color);
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .stat-item {
                display: flex;
                justify-content: space-between;
                padding: 5px 0;
            }
            
            .stat-label {
                color: var(--main-text-color);
            }
            
            .stat-value {
                font-weight: 600;
                color: var(--primary-color);
            }
            
            .stat-actions {
                margin-top: 15px;
                display: flex;
                gap: 10px;
            }
            
            .stat-actions .btn {
                flex: 1;
            }
        </code>);
        
        // Bind events
        this.$body.on('click', '.refresh-stats', () => this.handleRefresh());
        this.$body.on('click', '.export-stats', () => this.handleExport());
    }
    
    async refreshWithNote(note) {
        if (!note) {
            this.clearStatistics();
            return;
        }
        
        // Schedule statistics calculation
        await this.spacedUpdate.scheduleUpdate();
    }
    
    async calculateStatistics() {
        try {
            const note = this.note;
            if (!note) return;
            
            const content = await note.getContent();
            
            if (note.type === 'text') {
                // Parse HTML content
                const $content = $('<div>').html(content);
                const textContent = $content.text();
                
                // Calculate statistics
                this.statistics.words = this.countWords(textContent);
                this.statistics.characters = textContent.length;
                this.statistics.paragraphs = $content.find('p').length;
                this.statistics.readingTime = Math.ceil(this.statistics.words / 200);
                this.statistics.links = $content.find('a').length;
                this.statistics.images = $content.find('img').length;
            } else if (note.type === 'code') {
                // For code notes, count lines and characters
                const lines = content.split('\n');
                this.statistics.words = lines.length; // Show lines instead of words
                this.statistics.characters = content.length;
                this.statistics.paragraphs = 0;
                this.statistics.readingTime = 0;
                this.statistics.links = 0;
                this.statistics.images = 0;
            }
            
            this.updateDisplay();
            
        } catch (error) {
            console.error('Failed to calculate statistics:', error);
            toastService.showError("Failed to calculate statistics");
        }
    }
    
    countWords(text) {
        const words = text.match(/\b\w+\b/g);
        return words ? words.length : 0;
    }
    
    clearStatistics() {
        this.statistics = {
            words: 0,
            characters: 0,
            paragraphs: 0,
            readingTime: 0,
            links: 0,
            images: 0
        };
        this.updateDisplay();
    }
    
    updateDisplay() {
        this.$body.find('[data-stat="words"]').text(this.statistics.words);
        this.$body.find('[data-stat="characters"]').text(this.statistics.characters);
        this.$body.find('[data-stat="paragraphs"]').text(this.statistics.paragraphs);
        this.$body.find('[data-stat="readingTime"]').text(<code>${this.statistics.readingTime} min</code>);
        this.$body.find('[data-stat="links"]').text(this.statistics.links);
        this.$body.find('[data-stat="images"]').text(this.statistics.images);
    }
    
    async handleRefresh() {
        await this.calculateStatistics();
        toastService.showMessage("Statistics refreshed");
    }
    
    async handleExport() {
        const note = this.note;
        if (!note) return;
        
        const exportData = {
            noteId: note.noteId,
            title: note.title,
            statistics: this.statistics,
            timestamp: new Date().toISOString()
        };
        
        // Create a CSV
        const csv = [
            'Metric,Value',
            <code>Words,${this.statistics.words}</code>,
            <code>Characters,${this.statistics.characters}</code>,
            <code>Paragraphs,${this.statistics.paragraphs}</code>,
            <code>Reading Time,${this.statistics.readingTime} minutes</code>,
            <code>Links,${this.statistics.links}</code>,
            <code>Images,${this.statistics.images}</code>
        ].join('\n');
        
        // Download CSV
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = <code>statistics-${note.noteId}.csv</code>;
        a.click();
        URL.revokeObjectURL(url);
        
        toastService.showMessage("Statistics exported");
    }
    
    async noteContentChangedEvent({ noteId }) {
        if (this.noteId === noteId) {
            await this.spacedUpdate.scheduleUpdate();
        }
    }
    
    cleanup() {
        this.$body.off('click');
        this.spacedUpdate = null;
    }
}</p>

<p>export default NoteStatisticsWidget;
</code></pre></p>

<h2>Best Practices</h2>

<h3>1. Memory Management</h3>
- Clean up event listeners in <code>cleanup()</code>
- Clear caches and timers when widget is destroyed
- Avoid circular references

<h3>2. Performance</h3>
- Use debouncing for frequent updates
- Implement lazy loading for expensive operations
- Cache computed values when appropriate

<h3>3. Error Handling</h3>
- Always wrap async operations in try-catch
- Provide user feedback for errors
- Log errors for debugging

<h3>4. User Experience</h3>
- Show loading states for async operations
- Provide clear error messages
- Ensure widgets are responsive

<h3>5. Code Organization</h3>
- Keep widgets focused on a single responsibility
- Extract reusable logic into services
- Use composition over inheritance when possible

<h2>Troubleshooting</h2>

<h3>Widget Not Rendering</h3>
- Check <code>doRender()</code> creates <code>this.$widget</code>
- Verify widget is properly registered
- Check console for errors

<h3>Events Not Firing</h3>
- Ensure event method name matches pattern: <code>${eventName}Event</code>
- Check event is being triggered
- Verify widget is active/visible

<h3>State Not Persisting</h3>
- Use options or attributes for persistence
- Check save operations complete successfully
- Verify data serialization

<h3>Performance Issues</h3>
- Profile with browser dev tools
- Implement caching and debouncing
- Optimize DOM operations

<h2>Next Steps</h2>

<p>- Explore existing widgets in <code>/apps/client/src/widgets/</code> for examples
- Review the Frontend Script API documentation
- Join the Trilium community for support and sharing widgets</p>
    </div>
</body>
</html>