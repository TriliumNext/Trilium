<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backend Script Development - Trilium Developer Guide</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .content {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-bottom: 1px solid #ecf0f1;
            padding-bottom: 8px;
        }
        h3 {
            color: #555;
            margin-top: 25px;
        }
        pre {
            background: #f8f8f8;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 16px;
            overflow-x: auto;
        }
        code {
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Courier New', monospace;
        }
        pre code {
            background: none;
            padding: 0;
        }
        blockquote {
            border-left: 4px solid #3498db;
            margin: 0;
            padding-left: 20px;
            color: #666;
            font-style: italic;
        }
        ul, ol {
            margin: 16px 0;
            padding-left: 30px;
        }
        li {
            margin: 8px 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 12px;
            margin: 20px 0;
        }
        .info {
            background: #d1ecf1;
            border: 1px solid #17a2b8;
            border-radius: 4px;
            padding: 12px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="content">
        <h1>Backend Script Development Guide</h1>

<p>This guide covers developing backend scripts in Trilium Notes. Backend scripts run in the Node.js context on the server, providing access to the database, file system, and external services.</p>

<h2>Prerequisites</h2>

<p>- JavaScript/Node.js knowledge
- Understanding of async/await patterns
- Familiarity with Trilium's database structure
- Basic knowledge of SQL (optional but helpful)</p>

<h2>Getting Started</h2>

<h3>Creating a Backend Script</h3>

<li>Create a new code note with type "JS Backend"</li>
<li>Add appropriate execution labels:</li>
   - <code>#run=backendStartup</code> - Run once on startup
   - <code>#run=hourly</code> - Run every hour
   - <code>#run=daily</code> - Run daily
   - <code>#run=never</code> - Manual execution only

<pre><code class="language-javascript">// Basic backend script
const note = await api.createNote(
    'root',
    'Generated Note',
    <code>Created at ${new Date().toISOString()}</code>
);

<p>api.log(<code>Created note ${note.noteId}</code>);
</code></pre></p>

<h3>Execution Context</h3>

<p>Backend scripts have access to:
- Full Node.js API
- Trilium's Backend API (<code>api</code> object)
- Database access via SQL
- File system operations
- Network requests
- System processes</p>

<h2>Backend API Reference</h2>

<h3>Core API Methods</h3>

<pre><code class="language-javascript">// Logging
api.log('Information message');
api.logWarning('Warning message');
api.logError('Error message');

<p>// Get application info
const appInfo = api.getAppInfo();
console.log(<code>Trilium ${appInfo.appVersion}</code>);</p>

<p>// Get instance name
const instanceName = api.getInstanceName();</p>

<p>// Get current date note
const todayNote = await api.getTodayNote();
const dateNote = await api.getDateNote('2024-01-15');</p>

<p>// Get week note
const weekNote = await api.getWeekNote('2024-01-15');</p>

<p>// Get month note
const monthNote = await api.getMonthNote('2024-01');</p>

<p>// Get year note  
const yearNote = await api.getYearNote('2024');
</code></pre></p>

<h3>Note Operations</h3>

<p>#### Creating Notes</p>

<pre><code class="language-javascript">// Simple note creation
const note = await api.createNote(
    parentNoteId,
    title,
    content
);

<p>// Create note with parameters
const note = await api.createNewNote({
    parentNoteId: 'root',
    title: 'Advanced Note',
    content: 'Content here',
    type: 'text',
    mime: 'text/html',
    isProtected: false
});</p>

<p>// Create data note
const dataNote = await api.createDataNote(
    parentNoteId,
    'config.json',
    { 
        settings: {},
        version: 1
    }
);</p>

<p>// Create text note with attributes
const note = await api.createTextNote(
    parentNoteId,
    'Task',
    'Task description',
    {
        attributes: [
            { type: 'label', name: 'status', value: 'pending' },
            { type: 'label', name: 'priority', value: 'high' },
            { type: 'relation', name: 'assignedTo', value: userId }
        ]
    }
);
</code></pre></p>

<p>#### Reading Notes</p>

<pre><code class="language-javascript">// Get note by ID
const note = await api.getNote(noteId);

<p>// Get note with content
const noteWithContent = await api.getNoteWithContent(noteId);</p>

<p>// Get root note
const root = await api.getRootNote();</p>

<p>// Get notes by label
const tasksNote = await api.getNoteWithLabel('tasks');
const pendingTasks = await api.getNotesWithLabel('status', 'pending');</p>

<p>// Search notes
const results = await api.searchForNotes('type:text @label=important');</p>

<p>// Get note content
const content = await note.getContent();
const jsonContent = await note.getJsonContent();
</code></pre></p>

<p>#### Modifying Notes</p>

<pre><code class="language-javascript">// Update note properties
note.title = 'New Title';
note.type = 'code';
note.mime = 'application/javascript';
await note.save();

<p>// Set content
await note.setContent('New content');
await note.setJsonContent({ data: 'value' });</p>

<p>// Add attributes
await note.addLabel('status', 'completed');
await note.addRelation('relatedTo', targetNoteId);</p>

<p>// Remove attributes
await note.removeLabel('draft');
await note.removeRelation('obsolete');</p>

<p>// Toggle label
await note.toggleLabel('archived');
await note.toggleLabel('priority', 'low');</p>

<p>// Set label (add or update)
await note.setLabel('version', '2.0');</p>

<p>// Set relation
await note.setRelation('parent', parentNoteId);
</code></pre></p>

<h3>Database Operations</h3>

<p>#### SQL Queries</p>

<pre><code class="language-javascript">// Execute query
const rows = api.sql.getRows(<code>
    SELECT noteId, title, type 
    FROM notes 
    WHERE isDeleted = 0 
    AND type = ?
</code>, ['text']);

<p>// Get single row
const note = api.sql.getRow(<code>
    SELECT * FROM notes WHERE noteId = ?
</code>, [noteId]);</p>

<p>// Get single value
const count = api.sql.getValue(<code>
    SELECT COUNT(*) FROM notes WHERE type = ?
</code>, ['text']);</p>

<p>// Execute statement (INSERT, UPDATE, DELETE)
api.sql.execute(<code>
    UPDATE notes 
    SET dateModified = ? 
    WHERE noteId = ?
</code>, [new Date().toISOString(), noteId]);</p>

<p>// Transaction
api.sql.transactional(() => {
    api.sql.execute('INSERT INTO ...', params1);
    api.sql.execute('UPDATE ...', params2);
    // All or nothing - rollback on error
});
</code></pre></p>

<p>#### Entity Access</p>

<pre><code class="language-javascript">// Access Becca entities directly
const becca = api.getBecca();

<p>// Get all notes
const allNotes = Object.values(becca.notes);</p>

<p>// Get all attributes
const allAttributes = Object.values(becca.attributes);</p>

<p>// Get branches (hierarchy)
const branches = Object.values(becca.branches);</p>

<p>// Find entities
const note = becca.getNote(noteId);
const attribute = becca.getAttribute(attributeId);
const branch = becca.getBranch(branchId);
</code></pre></p>

<h3>Date and Time</h3>

<pre><code class="language-javascript">// Using dayjs
const dayjs = api.dayjs;

<p>// Current date/time
const now = dayjs();
const formatted = now.format('YYYY-MM-DD HH:mm:ss');</p>

<p>// Date arithmetic
const tomorrow = dayjs().add(1, 'day');
const lastWeek = dayjs().subtract(1, 'week');
const endOfMonth = dayjs().endOf('month');</p>

<p>// Parse dates
const date = dayjs('2024-01-15');
const parsed = dayjs('01/15/2024', 'MM/DD/YYYY');</p>

<p>// Compare dates
const isPast = dayjs('2024-01-01').isBefore(dayjs());
const isFuture = dayjs('2025-01-01').isAfter(dayjs());
const isSame = dayjs('2024-01-15').isSame('2024-01-15', 'day');
</code></pre></p>

<h3>HTTP Requests</h3>

<pre><code class="language-javascript">// Using fetch (recommended)
const response = await fetch('https://api.example.com/data', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer token'
    },
    body: JSON.stringify({ key: 'value' })
});

<p>const data = await response.json();</p>

<p>// Using axios (deprecated but available)
const axios = api.axios;
const response = await axios.get('https://api.example.com/data');
const data = response.data;
</code></pre></p>

<h3>File System Operations</h3>

<pre><code class="language-javascript">const fs = require('fs').promises;
const path = require('path');

<p>// Read file
const content = await fs.readFile('/path/to/file.txt', 'utf8');</p>

<p>// Write file
await fs.writeFile('/path/to/output.txt', 'Content here');</p>

<p>// Check if file exists
const exists = await fs.access('/path/to/file')
    .then(() => true)
    .catch(() => false);</p>

<p>// Read directory
const files = await fs.readdir('/path/to/directory');</p>

<p>// Get file stats
const stats = await fs.stat('/path/to/file');
const fileSize = stats.size;
const isDirectory = stats.isDirectory();
</code></pre></p>

<h2>Complete Example: Note Backup Automation</h2>

<p>Here's a comprehensive example that automatically backs up important notes:</p>

<pre><code class="language-javascript">/<em></em>
 * Automatic Note Backup System
 * Backs up notes with specific labels to JSON files
 * Run daily with #run=daily
 */

<p>const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');</p>

<p>class BackupManager {
    constructor() {
        this.backupDir = this.getBackupDirectory();
        this.config = {
            maxBackups: 30,
            backupLabels: ['important', 'backup', 'critical'],
            excludeLabels: ['draft', 'temporary'],
            includeAttachments: true,
            compress: true
        };
    }
    
    async run() {
        try {
            api.log('Starting backup process...');
            
            // Ensure backup directory exists
            await this.ensureBackupDirectory();
            
            // Get notes to backup
            const notes = await this.getNotesToBackup();
            api.log(<code>Found ${notes.length} notes to backup</code>);
            
            // Create backup
            const backupPath = await this.createBackup(notes);
            api.log(<code>Backup created: ${backupPath}</code>);
            
            // Clean old backups
            await this.cleanOldBackups();
            
            // Send notification
            await this.sendNotification('success', notes.length);
            
            api.log('Backup process completed successfully');
            
        } catch (error) {
            api.logError(<code>Backup failed: ${error.message}</code>);
            await this.sendNotification('error', 0, error.message);
        }
    }
    
    getBackupDirectory() {
        // Use data directory for backups
        const dataDir = process.env.TRILIUM_DATA_DIR || './data';
        return path.join(dataDir, 'backups');
    }
    
    async ensureBackupDirectory() {
        try {
            await fs.access(this.backupDir);
        } catch {
            await fs.mkdir(this.backupDir, { recursive: true });
        }
    }
    
    async getNotesToBackup() {
        const notes = [];
        
        // Get notes with backup labels
        for (const label of this.config.backupLabels) {
            const labeledNotes = await api.getNotesWithLabel(label);
            notes.push(...labeledNotes);
        }
        
        // Filter out excluded notes
        const filtered = notes.filter(note => {
            const labels = note.getLabels();
            return !labels.some(l => 
                this.config.excludeLabels.includes(l.name)
            );
        });
        
        // Remove duplicates
        const uniqueNotes = Array.from(
            new Map(filtered.map(n => [n.noteId, n])).values()
        );
        
        return uniqueNotes;
    }
    
    async createBackup(notes) {
        const timestamp = api.dayjs().format('YYYY-MM-DD_HHmmss');
        const backupName = <code>backup_${timestamp}.json</code>;
        const backupPath = path.join(this.backupDir, backupName);
        
        const backupData = {
            version: '1.0',
            timestamp: new Date().toISOString(),
            instanceName: api.getInstanceName(),
            appVersion: api.getAppInfo().appVersion,
            noteCount: notes.length,
            notes: []
        };
        
        for (const note of notes) {
            const noteData = await this.exportNote(note);
            backupData.notes.push(noteData);
        }
        
        // Write backup file
        const json = JSON.stringify(backupData, null, 2);
        
        if (this.config.compress) {
            const zlib = require('zlib');
            const compressed = await new Promise((resolve, reject) => {
                zlib.gzip(json, (error, result) => {
                    if (error) reject(error);
                    else resolve(result);
                });
            });
            await fs.writeFile(backupPath + '.gz', compressed);
            return backupPath + '.gz';
        } else {
            await fs.writeFile(backupPath, json);
            return backupPath;
        }
    }
    
    async exportNote(note) {
        const content = await note.getContent();
        const attributes = note.getAttributes();
        const children = await note.getChildNotes();
        
        const noteData = {
            noteId: note.noteId,
            title: note.title,
            type: note.type,
            mime: note.mime,
            isProtected: note.isProtected,
            dateCreated: note.dateCreated,
            dateModified: note.dateModified,
            content: content,
            contentHash: this.hashContent(content),
            attributes: attributes.map(attr => ({
                type: attr.type,
                name: attr.name,
                value: attr.value,
                position: attr.position
            })),
            childrenIds: children.map(c => c.noteId),
            parentIds: note.getParentNotes().map(p => p.noteId)
        };
        
        // Include attachments if configured
        if (this.config.includeAttachments && note.type === 'file') {
            const attachments = await note.getAttachments();
            noteData.attachments = [];
            
            for (const attachment of attachments) {
                const blob = await attachment.getBlob();
                noteData.attachments.push({
                    attachmentId: attachment.attachmentId,
                    title: attachment.title,
                    role: attachment.role,
                    mime: attachment.mime,
                    content: blob.content.toString('base64')
                });
            }
        }
        
        return noteData;
    }
    
    hashContent(content) {
        return crypto.createHash('sha256')
            .update(content)
            .digest('hex');
    }
    
    async cleanOldBackups() {
        const files = await fs.readdir(this.backupDir);
        const backupFiles = files
            .filter(f => f.startsWith('backup_'))
            .sort()
            .reverse();
        
        if (backupFiles.length > this.config.maxBackups) {
            const toDelete = backupFiles.slice(this.config.maxBackups);
            
            for (const file of toDelete) {
                const filePath = path.join(this.backupDir, file);
                await fs.unlink(filePath);
                api.log(<code>Deleted old backup: ${file}</code>);
            }
        }
    }
    
    async sendNotification(status, noteCount, error = null) {
        // Create or update status note
        let statusNote = await api.getNoteWithLabel('backupStatus');
        
        if (!statusNote) {
            statusNote = await api.createNote(
                'root',
                'Backup Status',
                ''
            );
            await statusNote.addLabel('backupStatus', 'true');
            await statusNote.addLabel('hideFromTree', 'true');
        }
        
        const statusHtml = <code>
            <h2>Backup Status</h2>
            <table>
                <tr>
                    <td><strong>Last Run:</strong></td>
                    <td>${new Date().toISOString()}</td>
                </tr>
                <tr>
                    <td><strong>Status:</strong></td>
                    <td>${status === 'success' ? '✅ Success' : '❌ Failed'}</td>
                </tr>
                <tr>
                    <td><strong>Notes Backed Up:</strong></td>
                    <td>${noteCount}</td>
                </tr>
                ${error ? </code>
                <tr>
                    <td><strong>Error:</strong></td>
                    <td>${error}</td>
                </tr>
                <code> : ''}
                <tr>
                    <td><strong>Backup Directory:</strong></td>
                    <td><code>${this.backupDir}</code></td>
                </tr>
            </table>
            
            <h3>Recent Backups</h3>
            <ul>
                ${await this.getRecentBackupsList()}
            </ul>
        </code>;
        
        await statusNote.setContent(statusHtml);
    }
    
    async getRecentBackupsList() {
        const files = await fs.readdir(this.backupDir);
        const backupFiles = files
            .filter(f => f.startsWith('backup_'))
            .sort()
            .reverse()
            .slice(0, 10);
        
        const items = [];
        for (const file of backupFiles) {
            const filePath = path.join(this.backupDir, file);
            const stats = await fs.stat(filePath);
            const size = (stats.size / 1024).toFixed(2);
            items.push(<code><ul><li>${file} (${size} KB)</li></ul></code>);
        }
        
        return items.join('\n');
    }
    
    // Restore functionality
    async restore(backupFile) {
        api.log(<code>Starting restore from ${backupFile}</code>);
        
        const backupPath = path.join(this.backupDir, backupFile);
        let content;
        
        if (backupFile.endsWith('.gz')) {
            const zlib = require('zlib');
            const compressed = await fs.readFile(backupPath);
            content = await new Promise((resolve, reject) => {
                zlib.gunzip(compressed, (error, result) => {
                    if (error) reject(error);
                    else resolve(result.toString());
                });
            });
        } else {
            content = await fs.readFile(backupPath, 'utf8');
        }
        
        const backupData = JSON.parse(content);
        
        // Create restore folder
        const restoreNote = await api.createNote(
            'root',
            <code>Restore ${backupData.timestamp}</code>,
            <code><p>Restored ${backupData.noteCount} notes from backup</p></code>
        );
        
        // Restore notes
        const noteIdMap = new Map();
        
        for (const noteData of backupData.notes) {
            const restoredNote = await this.restoreNote(
                noteData,
                restoreNote.noteId,
                noteIdMap
            );
        }
        
        api.log(<code>Restore completed: ${backupData.noteCount} notes</code>);
        return restoreNote;
    }
    
    async restoreNote(noteData, parentId, noteIdMap) {
        // Create note
        const note = await api.createNewNote({
            parentNoteId: parentId,
            title: noteData.title,
            content: noteData.content,
            type: noteData.type,
            mime: noteData.mime,
            isProtected: noteData.isProtected
        });
        
        // Map old ID to new ID
        noteIdMap.set(noteData.noteId, note.noteId);
        
        // Restore attributes
        for (const attr of noteData.attributes) {
            if (attr.type === 'label') {
                await note.addLabel(attr.name, attr.value);
            } else if (attr.type === 'relation') {
                // Will be restored in second pass
            }
        }
        
        // Restore attachments
        if (noteData.attachments) {
            for (const attachmentData of noteData.attachments) {
                const content = Buffer.from(
                    attachmentData.content,
                    'base64'
                );
                await note.addAttachment({
                    title: attachmentData.title,
                    role: attachmentData.role,
                    mime: attachmentData.mime,
                    content: content
                });
            }
        }
        
        return note;
    }
}</p>

<p>// Run backup
const backup = new BackupManager();
await backup.run();</p>

<p>// Optional: Add manual trigger
api.createNote(
    'root',
    'Run Backup',
    <code>
    <button onclick="api.runAsyncOnBackendWithManualTransactionHandling(async () => {
        const backup = new BackupManager();
        await backup.run();
    })">Run Backup Now</button>
    </code>
);
</code></pre></p>

<h2>Advanced Techniques</h2>

<h3>Scheduled Tasks</h3>

<pre><code class="language-javascript">// Schedule task for specific time
class TaskScheduler {
    constructor() {
        this.tasks = [];
    }
    
    scheduleDaily(hour, minute, taskFunc) {
        const task = {
            type: 'daily',
            hour,
            minute,
            func: taskFunc,
            lastRun: null
        };
        
        this.tasks.push(task);
        this.startScheduler();
    }
    
    scheduleHourly(minute, taskFunc) {
        const task = {
            type: 'hourly',
            minute,
            func: taskFunc,
            lastRun: null
        };
        
        this.tasks.push(task);
        this.startScheduler();
    }
    
    startScheduler() {
        setInterval(() => {
            this.checkTasks();
        }, 60000); // Check every minute
    }
    
    checkTasks() {
        const now = api.dayjs();
        
        for (const task of this.tasks) {
            if (this.shouldRun(task, now)) {
                this.runTask(task);
                task.lastRun = now;
            }
        }
    }
    
    shouldRun(task, now) {
        if (task.type === 'daily') {
            return now.hour() === task.hour && 
                   now.minute() === task.minute &&
                   (!task.lastRun || !now.isSame(task.lastRun, 'day'));
        } else if (task.type === 'hourly') {
            return now.minute() === task.minute &&
                   (!task.lastRun || !now.isSame(task.lastRun, 'hour'));
        }
        return false;
    }
    
    async runTask(task) {
        try {
            await task.func();
        } catch (error) {
            api.logError(<code>Task failed: ${error.message}</code>);
        }
    }
}

<p>const scheduler = new TaskScheduler();</p>

<p>// Schedule daily report at 9:00 AM
scheduler.scheduleDaily(9, 0, async () => {
    await generateDailyReport();
});</p>

<p>// Schedule hourly sync at :30
scheduler.scheduleHourly(30, async () => {
    await syncWithExternalService();
});
</code></pre></p>

<h3>Working with External Services</h3>

<pre><code class="language-javascript">// Integrate with external API
class ExternalServiceClient {
    constructor(apiKey) {
        this.apiKey = apiKey;
        this.baseUrl = 'https://api.example.com';
    }
    
    async request(endpoint, method = 'GET', data = null) {
        const url = <code>${this.baseUrl}${endpoint}</code>;
        
        const options = {
            method,
            headers: {
                'Authorization': <code>Bearer ${this.apiKey}</code>,
                'Content-Type': 'application/json'
            }
        };
        
        if (data) {
            options.body = JSON.stringify(data);
        }
        
        try {
            const response = await fetch(url, options);
            
            if (!response.ok) {
                throw new Error(<code>HTTP ${response.status}: ${response.statusText}</code>);
            }
            
            return await response.json();
            
        } catch (error) {
            api.logError(<code>External API error: ${error.message}</code>);
            throw error;
        }
    }
    
    async syncNotes() {
        // Get notes to sync
        const notes = await api.getNotesWithLabel('sync');
        
        for (const note of notes) {
            const content = await note.getContent();
            
            // Send to external service
            const result = await this.request('/notes', 'POST', {
                id: note.noteId,
                title: note.title,
                content: content,
                tags: note.getLabels().map(l => l.value)
            });
            
            // Update sync status
            await note.setLabel('syncId', result.id);
            await note.setLabel('lastSync', new Date().toISOString());
        }
        
        api.log(<code>Synced ${notes.length} notes</code>);
    }
}

<p>// Use the client
const apiKey = await api.getOption('externalApiKey');
const client = new ExternalServiceClient(apiKey);
await client.syncNotes();
</code></pre></p>

<h3>Database Transactions</h3>

<pre><code class="language-javascript">// Complex database operation with transaction
async function reorganizeNotes() {
    await api.sql.transactional(async () => {
        // Get all notes to reorganize
        const notes = api.sql.getRows(<code>
            SELECT noteId, title, dateCreated 
            FROM notes 
            WHERE type = ? 
            AND isDeleted = 0
        </code>, ['text']);
        
        // Create year/month structure
        for (const noteRow of notes) {
            const date = api.dayjs(noteRow.dateCreated);
            const year = date.year();
            const month = date.format('MM');
            
            // Get or create year note
            let yearNote = await api.getYearNote(year.toString());
            if (!yearNote) {
                yearNote = await api.createNote(
                    'root',
                    year.toString(),
                    ''
                );
            }
            
            // Get or create month note
            let monthNote = await api.getMonthNote(<code>${year}-${month}</code>);
            if (!monthNote) {
                monthNote = await api.createNote(
                    yearNote.noteId,
                    date.format('MMMM'),
                    ''
                );
            }
            
            // Move note to month
            const note = await api.getNote(noteRow.noteId);
            await api.sql.execute(<code>
                UPDATE branches 
                SET parentNoteId = ? 
                WHERE noteId = ?
            </code>, [monthNote.noteId, note.noteId]);
        }
        
        api.log(<code>Reorganized ${notes.length} notes</code>);
    });
}
</code></pre>

<h3>Event Processing</h3>

<pre><code class="language-javascript">// Process entity change events
class EventProcessor {
    constructor() {
        this.handlers = new Map();
        this.registerHandlers();
    }
    
    registerHandlers() {
        // Handle note creation
        this.handlers.set('create_note', async (entity) => {
            api.log(<code>Note created: ${entity.title}</code>);
            
            // Auto-tag based on content
            const content = await entity.getContent();
            if (content.includes('TODO')) {
                await entity.addLabel('todo', 'true');
            }
            if (content.includes('IMPORTANT')) {
                await entity.addLabel('priority', 'high');
            }
        });
        
        // Handle attribute changes
        this.handlers.set('update_attribute', async (entity) => {
            if (entity.name === 'status' && entity.value === 'completed') {
                const note = await api.getNote(entity.noteId);
                await note.addLabel('completedDate', new Date().toISOString());
            }
        });
    }
    
    async processEvent(event) {
        const handler = this.handlers.get(event.type);
        if (handler) {
            await handler(event.entity);
        }
    }
}

<p>const processor = new EventProcessor();</p>

<p>// Process events (usually triggered by note changes)
api.onNoteChange(async (note) => {
    await processor.processEvent({
        type: 'update_note',
        entity: note
    });
});
</code></pre></p>

<h2>Performance Optimization</h2>

<h3>Batch Operations</h3>

<pre><code class="language-javascript">// Batch process notes for better performance
async function batchProcess(notes, batchSize = 100) {
    const results = [];
    
    for (let i = 0; i < notes.length; i += batchSize) {
        const batch = notes.slice(i, i + batchSize);
        
        // Process batch in parallel
        const batchResults = await Promise.all(
            batch.map(note => processNote(note))
        );
        
        results.push(...batchResults);
        
        // Log progress
        const progress = Math.min(i + batchSize, notes.length);
        api.log(<code>Processed ${progress}/${notes.length} notes</code>);
    }
    
    return results;
}

<p>async function processNote(note) {
    // Process individual note
    const content = await note.getContent();
    // ... processing logic
    return result;
}
</code></pre></p>

<h3>Caching</h3>

<pre><code class="language-javascript">// Implement caching for expensive operations
class Cache {
    constructor(ttl = 3600000) { // 1 hour default
        this.cache = new Map();
        this.ttl = ttl;
    }
    
    set(key, value) {
        this.cache.set(key, {
            value,
            expires: Date.now() + this.ttl
        });
    }
    
    get(key) {
        const item = this.cache.get(key);
        
        if (!item) return null;
        
        if (Date.now() > item.expires) {
            this.cache.delete(key);
            return null;
        }
        
        return item.value;
    }
    
    clear() {
        this.cache.clear();
    }
}

<p>const cache = new Cache();</p>

<p>async function getProcessedContent(noteId) {
    let result = cache.get(noteId);
    
    if (!result) {
        const note = await api.getNote(noteId);
        result = await expensiveProcessing(note);
        cache.set(noteId, result);
    }
    
    return result;
}
</code></pre></p>

<h3>Resource Management</h3>

<pre><code class="language-javascript">// Manage resources properly
class ResourceManager {
    constructor() {
        this.resources = [];
    }
    
    async acquireConnection() {
        // Get database connection
        const conn = await api.sql.getConnection();
        this.resources.push(conn);
        return conn;
    }
    
    async cleanup() {
        // Clean up all resources
        for (const resource of this.resources) {
            try {
                if (resource.close) {
                    await resource.close();
                }
            } catch (error) {
                api.logError(<code>Failed to close resource: ${error.message}</code>);
            }
        }
        
        this.resources = [];
    }
}

<p>const manager = new ResourceManager();</p>

<p>try {
    // Use resources
    const conn = await manager.acquireConnection();
    // ... do work
} finally {
    // Always cleanup
    await manager.cleanup();
}
</code></pre></p>

<h2>Error Handling and Logging</h2>

<pre><code class="language-javascript">// Comprehensive error handling
class ErrorHandler {
    async handle(error, context) {
        // Log error
        api.logError(<code>Error in ${context}: ${error.message}</code>);
        api.logError(<code>Stack: ${error.stack}</code>);
        
        // Create error note
        const errorNote = await this.getOrCreateErrorLog();
        await this.logErrorToNote(errorNote, error, context);
        
        // Send notification if critical
        if (this.isCritical(error)) {
            await this.sendNotification(error, context);
        }
    }
    
    async getOrCreateErrorLog() {
        let errorLog = await api.getNoteWithLabel('errorLog');
        
        if (!errorLog) {
            errorLog = await api.createNote(
                'root',
                'Script Error Log',
                '<h1>Script Errors</h1>'
            );
            await errorLog.addLabel('errorLog', 'true');
            await errorLog.addLabel('hideFromTree', 'true');
        }
        
        return errorLog;
    }
    
    async logErrorToNote(note, error, context) {
        const content = await note.getContent();
        const errorEntry = <code>
            <div class="error-entry">
                <h3>${new Date().toISOString()}</h3>
                <p><strong>Context:</strong> ${context}</p>
                <p><strong>Error:</strong> ${error.message}</p>
                <pre>${error.stack}</pre>
            </div>
            <hr>
        </code>;
        
        await note.setContent(errorEntry + content);
    }
    
    isCritical(error) {
        return error.message.includes('CRITICAL') ||
               error.code === 'ECONNREFUSED' ||
               error.code === 'EACCES';
    }
    
    async sendNotification(error, context) {
        // Create notification note
        const notification = await api.createNote(
            'root',
            <code>CRITICAL ERROR: ${context}</code>,
            <code><p style="color: red;">A critical error occurred:</p>
             <pre>${error.message}</pre></code>
        );
        
        await notification.addLabel('notification', 'error');
        await notification.addLabel('priority', 'high');
    }
}

<p>const errorHandler = new ErrorHandler();</p>

<p>// Usage in scripts
try {
    await riskyOperation();
} catch (error) {
    await errorHandler.handle(error, 'riskyOperation');
}
</code></pre></p>

<h2>Security Considerations</h2>

<pre><code class="language-javascript">// Secure handling of sensitive data
class SecureStorage {
    async storeSecret(key, value) {
        // Encrypt before storing
        const encrypted = await this.encrypt(value);
        
        // Store in protected note
        let secretNote = await api.getNoteWithLabel('secrets');
        if (!secretNote) {
            secretNote = await api.createNote(
                'root',
                'Secrets',
                '{}'
            );
            await secretNote.addLabel('secrets', 'true');
            await secretNote.addLabel('hideFromTree', 'true');
            await secretNote.setProtected(true);
        }
        
        const secrets = await secretNote.getJsonContent();
        secrets[key] = encrypted;
        await secretNote.setJsonContent(secrets);
    }
    
    async getSecret(key) {
        const secretNote = await api.getNoteWithLabel('secrets');
        if (!secretNote) return null;
        
        const secrets = await secretNote.getJsonContent();
        const encrypted = secrets[key];
        if (!encrypted) return null;
        
        return await this.decrypt(encrypted);
    }
    
    async encrypt(text) {
        const crypto = require('crypto');
        const algorithm = 'aes-256-gcm';
        const key = await this.getKey();
        const iv = crypto.randomBytes(16);
        
        const cipher = crypto.createCipheriv(algorithm, key, iv);
        
        let encrypted = cipher.update(text, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        
        const authTag = cipher.getAuthTag();
        
        return {
            encrypted,
            authTag: authTag.toString('hex'),
            iv: iv.toString('hex')
        };
    }
    
    async decrypt(data) {
        const crypto = require('crypto');
        const algorithm = 'aes-256-gcm';
        const key = await this.getKey();
        
        const decipher = crypto.createDecipheriv(
            algorithm,
            key,
            Buffer.from(data.iv, 'hex')
        );
        
        decipher.setAuthTag(Buffer.from(data.authTag, 'hex'));
        
        let decrypted = decipher.update(data.encrypted, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        
        return decrypted;
    }
    
    async getKey() {
        // Derive key from instance ID or use environment variable
        const crypto = require('crypto');
        const instanceId = api.getInstanceName();
        return crypto.scryptSync(instanceId, 'salt', 32);
    }
}

<p>const storage = new SecureStorage();</p>

<p>// Store API key securely
await storage.storeSecret('apiKey', 'secret-key-123');</p>

<p>// Retrieve API key
const apiKey = await storage.getSecret('apiKey');
</code></pre></p>

<h2>Testing Backend Scripts</h2>

<pre><code class="language-javascript">// Test framework for backend scripts
class TestSuite {
    constructor(name) {
        this.name = name;
        this.tests = [];
        this.results = [];
    }
    
    test(description, testFunc) {
        this.tests.push({ description, testFunc });
    }
    
    async run() {
        api.log(<code>Running test suite: ${this.name}</code>);
        
        for (const test of this.tests) {
            try {
                await test.testFunc();
                this.results.push({
                    description: test.description,
                    status: 'PASS'
                });
                api.log(<code>✓ ${test.description}</code>);
            } catch (error) {
                this.results.push({
                    description: test.description,
                    status: 'FAIL',
                    error: error.message
                });
                api.logError(<code>✗ ${test.description}: ${error.message}</code>);
            }
        }
        
        await this.generateReport();
    }
    
    async generateReport() {
        const passed = this.results.filter(r => r.status === 'PASS').length;
        const failed = this.results.filter(r => r.status === 'FAIL').length;
        
        const report = <code>
            <h1>Test Report: ${this.name}</h1>
            <p>Run at: ${new Date().toISOString()}</p>
            <p>Results: ${passed} passed, ${failed} failed</p>
            
            <h2>Test Results</h2>
            <table>
                <tr>
                    <th>Test</th>
                    <th>Status</th>
                    <th>Error</th>
                </tr>
                ${this.results.map(r => </code>
                    <tr>
                        <td>${r.description}</td>
                        <td style="color: ${r.status === 'PASS' ? 'green' : 'red'}">
                            ${r.status}
                        </td>
                        <td>${r.error || ''}</td>
                    </tr>
                <code>).join('')}
            </table>
        </code>;
        
        const reportNote = await api.createNote(
            'root',
            <code>Test Report ${this.name}</code>,
            report
        );
        
        await reportNote.addLabel('testReport', 'true');
    }
}

<p>// Write tests
const suite = new TestSuite('Backend API Tests');</p>

<p>suite.test('Create and retrieve note', async () => {
    const note = await api.createNote('root', 'Test Note', 'Content');
    const retrieved = await api.getNote(note.noteId);
    
    if (retrieved.title !== 'Test Note') {
        throw new Error('Title mismatch');
    }
});</p>

<p>suite.test('Add and get label', async () => {
    const note = await api.createNote('root', 'Label Test', '');
    await note.addLabel('testLabel', 'testValue');
    
    const value = note.getLabelValue('testLabel');
    if (value !== 'testValue') {
        throw new Error('Label value mismatch');
    }
});</p>

<p>suite.test('SQL query', async () => {
    const count = api.sql.getValue('SELECT COUNT(*) FROM notes');
    if (typeof count !== 'number') {
        throw new Error('Count is not a number');
    }
});</p>

<p>// Run tests
await suite.run();
</code></pre></p>

<h2>Best Practices</h2>

<li><strong>Error Handling</strong></li>
   - Always wrap async operations in try-catch
   - Log errors appropriately
   - Provide fallback behavior

<li><strong>Performance</strong></li>
   - Use batch operations for multiple items
   - Implement caching for expensive operations
   - Clean up resources properly

<li><strong>Security</strong></li>
   - Never hardcode sensitive data
   - Use protected notes for secrets
   - Validate and sanitize input

<li><strong>Maintainability</strong></li>
   - Use classes for complex logic
   - Add logging for debugging
   - Write tests for critical functions

<li><strong>Database Operations</strong></li>
   - Use transactions for related changes
   - Parameterize SQL queries
   - Handle database errors gracefully

<h2>Troubleshooting</h2>

<h3>Script Not Executing</h3>
- Check the <code>#run</code> label value
- Verify script has no syntax errors
- Check logs for error messages

<h3>Database Errors</h3>
- Ensure SQL syntax is correct
- Check table and column names
- Verify data types match

<h3>Memory Issues</h3>
- Implement pagination for large datasets
- Clear caches periodically
- Use streaming for large files

<h3>External API Issues</h3>
- Check network connectivity
- Verify API credentials
- Implement retry logic

<h2>Next Steps</h2>

<p>- Review the Custom Note Type Development guide
- Explore existing backend scripts in the community
- Learn about Theme Development</p>
    </div>
</body>
</html>