export default class NoteDetailWidget extends NoteContextAwareWidget {

    private typeWidgets: Record<string, TypeWidget>;
    private spacedUpdate: SpacedUpdate;
    private type?: ExtendedNoteType;
    private mime?: string;

    constructor() {
        super();

        this.typeWidgets = {};

        appContext.addBeforeUnloadListener(this);
    }

    /**
     * sets full height of container that contains note content for a subset of note-types
     */
    getTypeWidget() {
        if (!this.type || !this.typeWidgets[this.type]) {
            throw new Error(t(`note_detail.could_not_find_typewidget`, { type: this.type }));
        }

        return this.typeWidgets[this.type];
    }

    async beforeNoteSwitchEvent({ noteContext }: EventData<"beforeNoteSwitch">) {
        if (this.isNoteContext(noteContext.ntxId)) {
            await this.spacedUpdate.updateNowIfNecessary();
        }
    }

    async beforeNoteContextRemoveEvent({ ntxIds }: EventData<"beforeNoteContextRemove">) {
        if (this.isNoteContext(ntxIds)) {
            await this.spacedUpdate.updateNowIfNecessary();
        }
    }

    async runActiveNoteCommand(params: CommandListenerData<"runActiveNote">) {
        if (this.isNoteContext(params.ntxId)) {
            // make sure that script is saved before running it #4028
            await this.spacedUpdate.updateNowIfNecessary();
        }

        return await this.parent?.triggerCommand("runActiveNote", params);
    }
    
    beforeUnloadEvent() {
        return this.spacedUpdate.isAllSavedAndTriggerUpdate();
    }

    async executeInActiveNoteDetailWidgetEvent({ callback }: EventData<"executeInActiveNoteDetailWidget">) {
        if (!this.isActiveNoteContext()) {
            return;
        }

        await this.initialized;

        callback(this);
    }

    renderActiveNoteEvent() {
        if (this.noteContext?.isActive()) {
            this.refresh();
        }
    }

}
