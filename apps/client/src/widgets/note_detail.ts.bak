export default class NoteDetailWidget extends NoteContextAwareWidget {

    private typeWidgets: Record<string, TypeWidget>;
    private spacedUpdate: SpacedUpdate;
    private type?: ExtendedNoteType;
    private mime?: string;

    constructor() {
        super();

        this.typeWidgets = {};

        appContext.addBeforeUnloadListener(this);
    }

    /**
     * sets full height of container that contains note content for a subset of note-types
     */
    getTypeWidget() {
        if (!this.type || !this.typeWidgets[this.type]) {
            throw new Error(t(`note_detail.could_not_find_typewidget`, { type: this.type }));
        }

        return this.typeWidgets[this.type];
    }

    async beforeNoteSwitchEvent({ noteContext }: EventData<"beforeNoteSwitch">) {
        if (this.isNoteContext(noteContext.ntxId)) {
            await this.spacedUpdate.updateNowIfNecessary();
        }
    }

    async beforeNoteContextRemoveEvent({ ntxIds }: EventData<"beforeNoteContextRemove">) {
        if (this.isNoteContext(ntxIds)) {
            await this.spacedUpdate.updateNowIfNecessary();
        }
    }

    async runActiveNoteCommand(params: CommandListenerData<"runActiveNote">) {
        if (this.isNoteContext(params.ntxId)) {
            // make sure that script is saved before running it #4028
            await this.spacedUpdate.updateNowIfNecessary();
        }

        return await this.parent?.triggerCommand("runActiveNote", params);
    }

    async printActiveNoteEvent() {
        if (!this.noteContext?.isActive()) {
            return;
        }

        // Trigger in timeout to dismiss the menu while printing.
        setTimeout(window.print, 0);
    }

    async exportAsPdfEvent() {
        if (!this.noteContext?.isActive() || !this.note) {
            return;
        }

        const { ipcRenderer } = utils.dynamicRequire("electron");
        ipcRenderer.send("export-as-pdf", {
            title: this.note.title,
            pageSize: this.note.getAttributeValue("label", "printPageSize") ?? "Letter",
            landscape: this.note.hasAttribute("label", "printLandscape")
        });
    }
    
    beforeUnloadEvent() {
        return this.spacedUpdate.isAllSavedAndTriggerUpdate();
    }

    readOnlyTemporarilyDisabledEvent({ noteContext }: EventData<"readOnlyTemporarilyDisabled">) {
        if (this.isNoteContext(noteContext.ntxId)) {
            this.refresh();
        }
    }

    async executeInActiveNoteDetailWidgetEvent({ callback }: EventData<"executeInActiveNoteDetailWidget">) {
        if (!this.isActiveNoteContext()) {
            return;
        }

        await this.initialized;

        callback(this);
    }

    renderActiveNoteEvent() {
        if (this.noteContext?.isActive()) {
            this.refresh();
        }
    }

}
