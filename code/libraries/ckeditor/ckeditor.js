! function(t) {
    const e = t.en = t.en || {};
    e.dictionary = Object.assign(e.dictionary || {}, {
        "%0 of %1": "%0 of %1",
        Accept: "Accept",
        "Align cell text to the bottom": "Align cell text to the bottom",
        "Align cell text to the center": "Align cell text to the center",
        "Align cell text to the left": "Align cell text to the left",
        "Align cell text to the middle": "Align cell text to the middle",
        "Align cell text to the right": "Align cell text to the right",
        "Align cell text to the top": "Align cell text to the top",
        "Align table to the left": "Align table to the left",
        "Align table to the right": "Align table to the right",
        Alignment: "Alignment",
        Aquamarine: "Aquamarine",
        Background: "Background",
        Big: "Big",
        Black: "Black",
        "Block quote": "Block quote",
        Blue: "Blue",
        Bold: "Bold",
        Border: "Border",
        "Break text": "Break text",
        "Bulleted List": "Bulleted List",
        "Bulleted list styles toolbar": "Bulleted list styles toolbar",
        Cancel: "Cancel",
        "Cannot upload file:": "Cannot upload file:",
        "Caption for image: %0": "Caption for image: %0",
        "Caption for the image": "Caption for the image",
        "Cell properties": "Cell properties",
        "Center table": "Center table",
        "Centered image": "Centered image",
        "Change image text alternative": "Change image text alternative",
        "Choose heading": "Choose heading",
        Circle: "Circle",
        Code: "Code",
        Color: "Color",
        "Color picker": "Color picker",
        Column: "Column",
        Dashed: "Dashed",
        Decimal: "Decimal",
        "Decimal with leading zero": "Decimal with leading zero",
        "Decrease indent": "Decrease indent",
        Default: "Default",
        "Delete column": "Delete column",
        "Delete row": "Delete row",
        "Dim grey": "Dim grey",
        Dimensions: "Dimensions",
        Disc: "Disc",
        "Document colors": "Document colors",
        Dotted: "Dotted",
        Double: "Double",
        Downloadable: "Downloadable",
        "Dropdown toolbar": "Dropdown toolbar",
        "Edit block": "Edit block",
        "Edit link": "Edit link",
        "Editor block content toolbar": "Editor block content toolbar",
        "Editor contextual toolbar": "Editor contextual toolbar",
        "Editor editing area: %0": "Editor editing area: %0",
        "Editor toolbar": "Editor toolbar",
        "Enter image caption": "Enter image caption",
        "Enter table caption": "Enter table caption",
        Find: "Find",
        "Find and replace": "Find and replace",
        "Find in text…": "Find in text…",
        "Font Background Color": "Font Background Color",
        "Font Color": "Font Color",
        "Font Family": "Font Family",
        "Font Size": "Font Size",
        "Full size image": "Full size image",
        Green: "Green",
        Grey: "Grey",
        Groove: "Groove",
        "Header column": "Header column",
        "Header row": "Header row",
        Heading: "Heading",
        "Heading 1": "Heading 1",
        "Heading 2": "Heading 2",
        "Heading 3": "Heading 3",
        "Heading 4": "Heading 4",
        "Heading 5": "Heading 5",
        "Heading 6": "Heading 6",
        Height: "Height",
        HEX: "HEX",
        "Horizontal line": "Horizontal line",
        "Horizontal text alignment toolbar": "Horizontal text alignment toolbar",
        Huge: "Huge",
        "Image resize list": "Image resize list",
        "Image toolbar": "Image toolbar",
        "image widget": "image widget",
        "In line": "In line",
        "Increase indent": "Increase indent",
        Insert: "Insert",
        "Insert code block": "Insert code block",
        "Insert column left": "Insert column left",
        "Insert column right": "Insert column right",
        "Insert image": "Insert image",
        "Insert image via URL": "Insert image via URL",
        "Insert paragraph after block": "Insert paragraph after block",
        "Insert paragraph before block": "Insert paragraph before block",
        "Insert row above": "Insert row above",
        "Insert row below": "Insert row below",
        "Insert table": "Insert table",
        Inset: "Inset",
        Italic: "Italic",
        "Justify cell text": "Justify cell text",
        "Left aligned image": "Left aligned image",
        "Light blue": "Light blue",
        "Light green": "Light green",
        "Light grey": "Light grey",
        Link: "Link",
        "Link image": "Link image",
        "Link URL": "Link URL",
        "List properties": "List properties",
        "Lower-latin": "Lower-latin",
        "Lower–roman": "Lower–roman",
        "Match case": "Match case",
        "Merge cell down": "Merge cell down",
        "Merge cell left": "Merge cell left",
        "Merge cell right": "Merge cell right",
        "Merge cell up": "Merge cell up",
        "Merge cells": "Merge cells",
        Next: "Next",
        "Next result": "Next result",
        None: "None",
        "Numbered List": "Numbered List",
        "Numbered list styles toolbar": "Numbered list styles toolbar",
        "Open in a new tab": "Open in a new tab",
        "Open link in new tab": "Open link in new tab",
        Orange: "Orange",
        Original: "Original",
        Outset: "Outset",
        Padding: "Padding",
        Paragraph: "Paragraph",
        "Plain text": "Plain text",
        "Press Enter to type after or press Shift + Enter to type before the widget": "Press Enter to type after or press Shift + Enter to type before the widget",
        Previous: "Previous",
        "Previous result": "Previous result",
        Purple: "Purple",
        Red: "Red",
        Redo: "Redo",
        "Remove color": "Remove color",
        "Remove Format": "Remove Format",
        Replace: "Replace",
        "Replace all": "Replace all",
        "Replace with…": "Replace with…",
        "Resize image": "Resize image",
        "Resize image to %0": "Resize image to %0",
        "Resize image to the original size": "Resize image to the original size",
        "Restore default": "Restore default",
        "Reversed order": "Reversed order",
        "Rich Text Editor": "Rich Text Editor",
        "Rich Text Editor. Editing area: %0": "Rich Text Editor. Editing area: %0",
        Ridge: "Ridge",
        "Right aligned image": "Right aligned image",
        Row: "Row",
        Save: "Save",
        "Select all": "Select all",
        "Select column": "Select column",
        "Select row": "Select row",
        "Show more items": "Show more items",
        "Show options": "Show options",
        "Side image": "Side image",
        Small: "Small",
        Solid: "Solid",
        "Split cell horizontally": "Split cell horizontally",
        "Split cell vertically": "Split cell vertically",
        Square: "Square",
        "Start at": "Start at",
        "Start index must be greater than 0.": "Start index must be greater than 0.",
        Strikethrough: "Strikethrough",
        Style: "Style",
        Subscript: "Subscript",
        Superscript: "Superscript",
        "Table alignment toolbar": "Table alignment toolbar",
        "Table cell text alignment": "Table cell text alignment",
        "Table properties": "Table properties",
        "Table toolbar": "Table toolbar",
        "Text alternative": "Text alternative",
        "Text to find must not be empty.": "Text to find must not be empty.",
        'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".',
        'The value is invalid. Try "10px" or "2em" or simply "2".': 'The value is invalid. Try "10px" or "2em" or simply "2".',
        "This link has no URL": "This link has no URL",
        Tiny: "Tiny",
        "Tip: Find some text first in order to replace it.": "Tip: Find some text first in order to replace it.",
        "To-do List": "To-do List",
        "Toggle caption off": "Toggle caption off",
        "Toggle caption on": "Toggle caption on",
        "Toggle the circle list style": "Toggle the circle list style",
        "Toggle the decimal list style": "Toggle the decimal list style",
        "Toggle the decimal with leading zero list style": "Toggle the decimal with leading zero list style",
        "Toggle the disc list style": "Toggle the disc list style",
        "Toggle the lower–latin list style": "Toggle the lower–latin list style",
        "Toggle the lower–roman list style": "Toggle the lower–roman list style",
        "Toggle the square list style": "Toggle the square list style",
        "Toggle the upper–latin list style": "Toggle the upper–latin list style",
        "Toggle the upper–roman list style": "Toggle the upper–roman list style",
        Turquoise: "Turquoise",
        "Type or paste your content here.": "Type or paste your content here.",
        "Type your title": "Type your title",
        Underline: "Underline",
        Undo: "Undo",
        Unlink: "Unlink",
        Update: "Update",
        "Update image URL": "Update image URL",
        "Upload failed": "Upload failed",
        "Upload in progress": "Upload in progress",
        "Upper-latin": "Upper-latin",
        "Upper-roman": "Upper-roman",
        "Vertical text alignment toolbar": "Vertical text alignment toolbar",
        White: "White",
        "Whole words only": "Whole words only",
        "Widget toolbar": "Widget toolbar",
        Width: "Width",
        "Wrap text": "Wrap text",
        Yellow: "Yellow"
    })
}(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})),
/*!
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */
function(t, e) {
    "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.BalloonEditor = e() : t.BalloonEditor = e()
}(self, (() => (() => {
    var t = {
            4959: (t, e, n) => {
                const o = n(1103),
                    i = {};
                for (const t of Object.keys(o)) i[o[t]] = t;
                const r = {
                    rgb: {
                        channels: 3,
                        labels: "rgb"
                    },
                    hsl: {
                        channels: 3,
                        labels: "hsl"
                    },
                    hsv: {
                        channels: 3,
                        labels: "hsv"
                    },
                    hwb: {
                        channels: 3,
                        labels: "hwb"
                    },
                    cmyk: {
                        channels: 4,
                        labels: "cmyk"
                    },
                    xyz: {
                        channels: 3,
                        labels: "xyz"
                    },
                    lab: {
                        channels: 3,
                        labels: "lab"
                    },
                    lch: {
                        channels: 3,
                        labels: "lch"
                    },
                    hex: {
                        channels: 1,
                        labels: ["hex"]
                    },
                    keyword: {
                        channels: 1,
                        labels: ["keyword"]
                    },
                    ansi16: {
                        channels: 1,
                        labels: ["ansi16"]
                    },
                    ansi256: {
                        channels: 1,
                        labels: ["ansi256"]
                    },
                    hcg: {
                        channels: 3,
                        labels: ["h", "c", "g"]
                    },
                    apple: {
                        channels: 3,
                        labels: ["r16", "g16", "b16"]
                    },
                    gray: {
                        channels: 1,
                        labels: ["gray"]
                    }
                };
                t.exports = r;
                for (const t of Object.keys(r)) {
                    if (!("channels" in r[t])) throw new Error("missing channels property: " + t);
                    if (!("labels" in r[t])) throw new Error("missing channel labels property: " + t);
                    if (r[t].labels.length !== r[t].channels) throw new Error("channel and label counts mismatch: " + t);
                    const {
                        channels: e,
                        labels: n
                    } = r[t];
                    delete r[t].channels, delete r[t].labels, Object.defineProperty(r[t], "channels", {
                        value: e
                    }), Object.defineProperty(r[t], "labels", {
                        value: n
                    })
                }
                r.rgb.hsl = function(t) {
                    const e = t[0] / 255,
                        n = t[1] / 255,
                        o = t[2] / 255,
                        i = Math.min(e, n, o),
                        r = Math.max(e, n, o),
                        s = r - i;
                    let a, l;
                    r === i ? a = 0 : e === r ? a = (n - o) / s : n === r ? a = 2 + (o - e) / s : o === r && (a = 4 + (e - n) / s), a = Math.min(60 * a, 360), a < 0 && (a += 360);
                    const c = (i + r) / 2;
                    return l = r === i ? 0 : c <= .5 ? s / (r + i) : s / (2 - r - i), [a, 100 * l, 100 * c]
                }, r.rgb.hsv = function(t) {
                    let e, n, o, i, r;
                    const s = t[0] / 255,
                        a = t[1] / 255,
                        l = t[2] / 255,
                        c = Math.max(s, a, l),
                        d = c - Math.min(s, a, l),
                        h = function(t) {
                            return (c - t) / 6 / d + .5
                        };
                    return 0 === d ? (i = 0, r = 0) : (r = d / c, e = h(s), n = h(a), o = h(l), s === c ? i = o - n : a === c ? i = 1 / 3 + e - o : l === c && (i = 2 / 3 + n - e), i < 0 ? i += 1 : i > 1 && (i -= 1)), [360 * i, 100 * r, 100 * c]
                }, r.rgb.hwb = function(t) {
                    const e = t[0],
                        n = t[1];
                    let o = t[2];
                    const i = r.rgb.hsl(t)[0],
                        s = 1 / 255 * Math.min(e, Math.min(n, o));
                    return o = 1 - 1 / 255 * Math.max(e, Math.max(n, o)), [i, 100 * s, 100 * o]
                }, r.rgb.cmyk = function(t) {
                    const e = t[0] / 255,
                        n = t[1] / 255,
                        o = t[2] / 255,
                        i = Math.min(1 - e, 1 - n, 1 - o);
                    return [100 * ((1 - e - i) / (1 - i) || 0), 100 * ((1 - n - i) / (1 - i) || 0), 100 * ((1 - o - i) / (1 - i) || 0), 100 * i]
                }, r.rgb.keyword = function(t) {
                    const e = i[t];
                    if (e) return e;
                    let n, r = 1 / 0;
                    for (const e of Object.keys(o)) {
                        const i = o[e],
                            l = (a = i, ((s = t)[0] - a[0]) ** 2 + (s[1] - a[1]) ** 2 + (s[2] - a[2]) ** 2);
                        l < r && (r = l, n = e)
                    }
                    var s, a;
                    return n
                }, r.keyword.rgb = function(t) {
                    return o[t]
                }, r.rgb.xyz = function(t) {
                    let e = t[0] / 255,
                        n = t[1] / 255,
                        o = t[2] / 255;
                    e = e > .04045 ? ((e + .055) / 1.055) ** 2.4 : e / 12.92, n = n > .04045 ? ((n + .055) / 1.055) ** 2.4 : n / 12.92, o = o > .04045 ? ((o + .055) / 1.055) ** 2.4 : o / 12.92;
                    return [100 * (.4124 * e + .3576 * n + .1805 * o), 100 * (.2126 * e + .7152 * n + .0722 * o), 100 * (.0193 * e + .1192 * n + .9505 * o)]
                }, r.rgb.lab = function(t) {
                    const e = r.rgb.xyz(t);
                    let n = e[0],
                        o = e[1],
                        i = e[2];
                    n /= 95.047, o /= 100, i /= 108.883, n = n > .008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116, o = o > .008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116, i = i > .008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116;
                    return [116 * o - 16, 500 * (n - o), 200 * (o - i)]
                }, r.hsl.rgb = function(t) {
                    const e = t[0] / 360,
                        n = t[1] / 100,
                        o = t[2] / 100;
                    let i, r, s;
                    if (0 === n) return s = 255 * o, [s, s, s];
                    i = o < .5 ? o * (1 + n) : o + n - o * n;
                    const a = 2 * o - i,
                        l = [0, 0, 0];
                    for (let t = 0; t < 3; t++) r = e + 1 / 3 * -(t - 1), r < 0 && r++, r > 1 && r--, s = 6 * r < 1 ? a + 6 * (i - a) * r : 2 * r < 1 ? i : 3 * r < 2 ? a + (i - a) * (2 / 3 - r) * 6 : a, l[t] = 255 * s;
                    return l
                }, r.hsl.hsv = function(t) {
                    const e = t[0];
                    let n = t[1] / 100,
                        o = t[2] / 100,
                        i = n;
                    const r = Math.max(o, .01);
                    o *= 2, n *= o <= 1 ? o : 2 - o, i *= r <= 1 ? r : 2 - r;
                    return [e, 100 * (0 === o ? 2 * i / (r + i) : 2 * n / (o + n)), 100 * ((o + n) / 2)]
                }, r.hsv.rgb = function(t) {
                    const e = t[0] / 60,
                        n = t[1] / 100;
                    let o = t[2] / 100;
                    const i = Math.floor(e) % 6,
                        r = e - Math.floor(e),
                        s = 255 * o * (1 - n),
                        a = 255 * o * (1 - n * r),
                        l = 255 * o * (1 - n * (1 - r));
                    switch (o *= 255, i) {
                        case 0:
                            return [o, l, s];
                        case 1:
                            return [a, o, s];
                        case 2:
                            return [s, o, l];
                        case 3:
                            return [s, a, o];
                        case 4:
                            return [l, s, o];
                        case 5:
                            return [o, s, a]
                    }
                }, r.hsv.hsl = function(t) {
                    const e = t[0],
                        n = t[1] / 100,
                        o = t[2] / 100,
                        i = Math.max(o, .01);
                    let r, s;
                    s = (2 - n) * o;
                    const a = (2 - n) * i;
                    return r = n * i, r /= a <= 1 ? a : 2 - a, r = r || 0, s /= 2, [e, 100 * r, 100 * s]
                }, r.hwb.rgb = function(t) {
                    const e = t[0] / 360;
                    let n = t[1] / 100,
                        o = t[2] / 100;
                    const i = n + o;
                    let r;
                    i > 1 && (n /= i, o /= i);
                    const s = Math.floor(6 * e),
                        a = 1 - o;
                    r = 6 * e - s, 0 != (1 & s) && (r = 1 - r);
                    const l = n + r * (a - n);
                    let c, d, h;
                    switch (s) {
                        default:
                        case 6:
                        case 0:
                            c = a, d = l, h = n;
                            break;
                        case 1:
                            c = l, d = a, h = n;
                            break;
                        case 2:
                            c = n, d = a, h = l;
                            break;
                        case 3:
                            c = n, d = l, h = a;
                            break;
                        case 4:
                            c = l, d = n, h = a;
                            break;
                        case 5:
                            c = a, d = n, h = l
                    }
                    return [255 * c, 255 * d, 255 * h]
                }, r.cmyk.rgb = function(t) {
                    const e = t[0] / 100,
                        n = t[1] / 100,
                        o = t[2] / 100,
                        i = t[3] / 100;
                    return [255 * (1 - Math.min(1, e * (1 - i) + i)), 255 * (1 - Math.min(1, n * (1 - i) + i)), 255 * (1 - Math.min(1, o * (1 - i) + i))]
                }, r.xyz.rgb = function(t) {
                    const e = t[0] / 100,
                        n = t[1] / 100,
                        o = t[2] / 100;
                    let i, r, s;
                    return i = 3.2406 * e + -1.5372 * n + -.4986 * o, r = -.9689 * e + 1.8758 * n + .0415 * o, s = .0557 * e + -.204 * n + 1.057 * o, i = i > .0031308 ? 1.055 * i ** (1 / 2.4) - .055 : 12.92 * i, r = r > .0031308 ? 1.055 * r ** (1 / 2.4) - .055 : 12.92 * r, s = s > .0031308 ? 1.055 * s ** (1 / 2.4) - .055 : 12.92 * s, i = Math.min(Math.max(0, i), 1), r = Math.min(Math.max(0, r), 1), s = Math.min(Math.max(0, s), 1), [255 * i, 255 * r, 255 * s]
                }, r.xyz.lab = function(t) {
                    let e = t[0],
                        n = t[1],
                        o = t[2];
                    e /= 95.047, n /= 100, o /= 108.883, e = e > .008856 ? e ** (1 / 3) : 7.787 * e + 16 / 116, n = n > .008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116, o = o > .008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116;
                    return [116 * n - 16, 500 * (e - n), 200 * (n - o)]
                }, r.lab.xyz = function(t) {
                    let e, n, o;
                    n = (t[0] + 16) / 116, e = t[1] / 500 + n, o = n - t[2] / 200;
                    const i = n ** 3,
                        r = e ** 3,
                        s = o ** 3;
                    return n = i > .008856 ? i : (n - 16 / 116) / 7.787, e = r > .008856 ? r : (e - 16 / 116) / 7.787, o = s > .008856 ? s : (o - 16 / 116) / 7.787, e *= 95.047, n *= 100, o *= 108.883, [e, n, o]
                }, r.lab.lch = function(t) {
                    const e = t[0],
                        n = t[1],
                        o = t[2];
                    let i;
                    i = 360 * Math.atan2(o, n) / 2 / Math.PI, i < 0 && (i += 360);
                    return [e, Math.sqrt(n * n + o * o), i]
                }, r.lch.lab = function(t) {
                    const e = t[0],
                        n = t[1],
                        o = t[2] / 360 * 2 * Math.PI;
                    return [e, n * Math.cos(o), n * Math.sin(o)]
                }, r.rgb.ansi16 = function(t, e = null) {
                    const [n, o, i] = t;
                    let s = null === e ? r.rgb.hsv(t)[2] : e;
                    if (s = Math.round(s / 50), 0 === s) return 30;
                    let a = 30 + (Math.round(i / 255) << 2 | Math.round(o / 255) << 1 | Math.round(n / 255));
                    return 2 === s && (a += 60), a
                }, r.hsv.ansi16 = function(t) {
                    return r.rgb.ansi16(r.hsv.rgb(t), t[2])
                }, r.rgb.ansi256 = function(t) {
                    const e = t[0],
                        n = t[1],
                        o = t[2];
                    if (e === n && n === o) return e < 8 ? 16 : e > 248 ? 231 : Math.round((e - 8) / 247 * 24) + 232;
                    return 16 + 36 * Math.round(e / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(o / 255 * 5)
                }, r.ansi16.rgb = function(t) {
                    let e = t % 10;
                    if (0 === e || 7 === e) return t > 50 && (e += 3.5), e = e / 10.5 * 255, [e, e, e];
                    const n = .5 * (1 + ~~(t > 50));
                    return [(1 & e) * n * 255, (e >> 1 & 1) * n * 255, (e >> 2 & 1) * n * 255]
                }, r.ansi256.rgb = function(t) {
                    if (t >= 232) {
                        const e = 10 * (t - 232) + 8;
                        return [e, e, e]
                    }
                    let e;
                    t -= 16;
                    return [Math.floor(t / 36) / 5 * 255, Math.floor((e = t % 36) / 6) / 5 * 255, e % 6 / 5 * 255]
                }, r.rgb.hex = function(t) {
                    const e = (((255 & Math.round(t[0])) << 16) + ((255 & Math.round(t[1])) << 8) + (255 & Math.round(t[2]))).toString(16).toUpperCase();
                    return "000000".substring(e.length) + e
                }, r.hex.rgb = function(t) {
                    const e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
                    if (!e) return [0, 0, 0];
                    let n = e[0];
                    3 === e[0].length && (n = n.split("").map((t => t + t)).join(""));
                    const o = parseInt(n, 16);
                    return [o >> 16 & 255, o >> 8 & 255, 255 & o]
                }, r.rgb.hcg = function(t) {
                    const e = t[0] / 255,
                        n = t[1] / 255,
                        o = t[2] / 255,
                        i = Math.max(Math.max(e, n), o),
                        r = Math.min(Math.min(e, n), o),
                        s = i - r;
                    let a, l;
                    return a = s < 1 ? r / (1 - s) : 0, l = s <= 0 ? 0 : i === e ? (n - o) / s % 6 : i === n ? 2 + (o - e) / s : 4 + (e - n) / s, l /= 6, l %= 1, [360 * l, 100 * s, 100 * a]
                }, r.hsl.hcg = function(t) {
                    const e = t[1] / 100,
                        n = t[2] / 100,
                        o = n < .5 ? 2 * e * n : 2 * e * (1 - n);
                    let i = 0;
                    return o < 1 && (i = (n - .5 * o) / (1 - o)), [t[0], 100 * o, 100 * i]
                }, r.hsv.hcg = function(t) {
                    const e = t[1] / 100,
                        n = t[2] / 100,
                        o = e * n;
                    let i = 0;
                    return o < 1 && (i = (n - o) / (1 - o)), [t[0], 100 * o, 100 * i]
                }, r.hcg.rgb = function(t) {
                    const e = t[0] / 360,
                        n = t[1] / 100,
                        o = t[2] / 100;
                    if (0 === n) return [255 * o, 255 * o, 255 * o];
                    const i = [0, 0, 0],
                        r = e % 1 * 6,
                        s = r % 1,
                        a = 1 - s;
                    let l = 0;
                    switch (Math.floor(r)) {
                        case 0:
                            i[0] = 1, i[1] = s, i[2] = 0;
                            break;
                        case 1:
                            i[0] = a, i[1] = 1, i[2] = 0;
                            break;
                        case 2:
                            i[0] = 0, i[1] = 1, i[2] = s;
                            break;
                        case 3:
                            i[0] = 0, i[1] = a, i[2] = 1;
                            break;
                        case 4:
                            i[0] = s, i[1] = 0, i[2] = 1;
                            break;
                        default:
                            i[0] = 1, i[1] = 0, i[2] = a
                    }
                    return l = (1 - n) * o, [255 * (n * i[0] + l), 255 * (n * i[1] + l), 255 * (n * i[2] + l)]
                }, r.hcg.hsv = function(t) {
                    const e = t[1] / 100,
                        n = e + t[2] / 100 * (1 - e);
                    let o = 0;
                    return n > 0 && (o = e / n), [t[0], 100 * o, 100 * n]
                }, r.hcg.hsl = function(t) {
                    const e = t[1] / 100,
                        n = t[2] / 100 * (1 - e) + .5 * e;
                    let o = 0;
                    return n > 0 && n < .5 ? o = e / (2 * n) : n >= .5 && n < 1 && (o = e / (2 * (1 - n))), [t[0], 100 * o, 100 * n]
                }, r.hcg.hwb = function(t) {
                    const e = t[1] / 100,
                        n = e + t[2] / 100 * (1 - e);
                    return [t[0], 100 * (n - e), 100 * (1 - n)]
                }, r.hwb.hcg = function(t) {
                    const e = t[1] / 100,
                        n = 1 - t[2] / 100,
                        o = n - e;
                    let i = 0;
                    return o < 1 && (i = (n - o) / (1 - o)), [t[0], 100 * o, 100 * i]
                }, r.apple.rgb = function(t) {
                    return [t[0] / 65535 * 255, t[1] / 65535 * 255, t[2] / 65535 * 255]
                }, r.rgb.apple = function(t) {
                    return [t[0] / 255 * 65535, t[1] / 255 * 65535, t[2] / 255 * 65535]
                }, r.gray.rgb = function(t) {
                    return [t[0] / 100 * 255, t[0] / 100 * 255, t[0] / 100 * 255]
                }, r.gray.hsl = function(t) {
                    return [0, 0, t[0]]
                }, r.gray.hsv = r.gray.hsl, r.gray.hwb = function(t) {
                    return [0, 100, t[0]]
                }, r.gray.cmyk = function(t) {
                    return [0, 0, 0, t[0]]
                }, r.gray.lab = function(t) {
                    return [t[0], 0, 0]
                }, r.gray.hex = function(t) {
                    const e = 255 & Math.round(t[0] / 100 * 255),
                        n = ((e << 16) + (e << 8) + e).toString(16).toUpperCase();
                    return "000000".substring(n.length) + n
                }, r.rgb.gray = function(t) {
                    return [(t[0] + t[1] + t[2]) / 3 / 255 * 100]
                }
            },
            841: (t, e, n) => {
                const o = n(4959),
                    i = n(9325),
                    r = {};
                Object.keys(o).forEach((t => {
                    r[t] = {}, Object.defineProperty(r[t], "channels", {
                        value: o[t].channels
                    }), Object.defineProperty(r[t], "labels", {
                        value: o[t].labels
                    });
                    const e = i(t);
                    Object.keys(e).forEach((n => {
                        const o = e[n];
                        r[t][n] = function(t) {
                            const e = function(...e) {
                                const n = e[0];
                                if (null == n) return n;
                                n.length > 1 && (e = n);
                                const o = t(e);
                                if ("object" == typeof o)
                                    for (let t = o.length, e = 0; e < t; e++) o[e] = Math.round(o[e]);
                                return o
                            };
                            return "conversion" in t && (e.conversion = t.conversion), e
                        }(o), r[t][n].raw = function(t) {
                            const e = function(...e) {
                                const n = e[0];
                                return null == n ? n : (n.length > 1 && (e = n), t(e))
                            };
                            return "conversion" in t && (e.conversion = t.conversion), e
                        }(o)
                    }))
                })), t.exports = r
            },
            9325: (t, e, n) => {
                const o = n(4959);

                function i(t) {
                    const e = function() {
                            const t = {},
                                e = Object.keys(o);
                            for (let n = e.length, o = 0; o < n; o++) t[e[o]] = {
                                distance: -1,
                                parent: null
                            };
                            return t
                        }(),
                        n = [t];
                    for (e[t].distance = 0; n.length;) {
                        const t = n.pop(),
                            i = Object.keys(o[t]);
                        for (let o = i.length, r = 0; r < o; r++) {
                            const o = i[r],
                                s = e[o]; - 1 === s.distance && (s.distance = e[t].distance + 1, s.parent = t, n.unshift(o))
                        }
                    }
                    return e
                }

                function r(t, e) {
                    return function(n) {
                        return e(t(n))
                    }
                }

                function s(t, e) {
                    const n = [e[t].parent, t];
                    let i = o[e[t].parent][t],
                        s = e[t].parent;
                    for (; e[s].parent;) n.unshift(e[s].parent), i = r(o[e[s].parent][s], i), s = e[s].parent;
                    return i.conversion = n, i
                }
                t.exports = function(t) {
                    const e = i(t),
                        n = {},
                        o = Object.keys(e);
                    for (let t = o.length, i = 0; i < t; i++) {
                        const t = o[i];
                        null !== e[t].parent && (n[t] = s(t, e))
                    }
                    return n
                }
            },
            1103: t => {
                "use strict";
                t.exports = {
                    aliceblue: [240, 248, 255],
                    antiquewhite: [250, 235, 215],
                    aqua: [0, 255, 255],
                    aquamarine: [127, 255, 212],
                    azure: [240, 255, 255],
                    beige: [245, 245, 220],
                    bisque: [255, 228, 196],
                    black: [0, 0, 0],
                    blanchedalmond: [255, 235, 205],
                    blue: [0, 0, 255],
                    blueviolet: [138, 43, 226],
                    brown: [165, 42, 42],
                    burlywood: [222, 184, 135],
                    cadetblue: [95, 158, 160],
                    chartreuse: [127, 255, 0],
                    chocolate: [210, 105, 30],
                    coral: [255, 127, 80],
                    cornflowerblue: [100, 149, 237],
                    cornsilk: [255, 248, 220],
                    crimson: [220, 20, 60],
                    cyan: [0, 255, 255],
                    darkblue: [0, 0, 139],
                    darkcyan: [0, 139, 139],
                    darkgoldenrod: [184, 134, 11],
                    darkgray: [169, 169, 169],
                    darkgreen: [0, 100, 0],
                    darkgrey: [169, 169, 169],
                    darkkhaki: [189, 183, 107],
                    darkmagenta: [139, 0, 139],
                    darkolivegreen: [85, 107, 47],
                    darkorange: [255, 140, 0],
                    darkorchid: [153, 50, 204],
                    darkred: [139, 0, 0],
                    darksalmon: [233, 150, 122],
                    darkseagreen: [143, 188, 143],
                    darkslateblue: [72, 61, 139],
                    darkslategray: [47, 79, 79],
                    darkslategrey: [47, 79, 79],
                    darkturquoise: [0, 206, 209],
                    darkviolet: [148, 0, 211],
                    deeppink: [255, 20, 147],
                    deepskyblue: [0, 191, 255],
                    dimgray: [105, 105, 105],
                    dimgrey: [105, 105, 105],
                    dodgerblue: [30, 144, 255],
                    firebrick: [178, 34, 34],
                    floralwhite: [255, 250, 240],
                    forestgreen: [34, 139, 34],
                    fuchsia: [255, 0, 255],
                    gainsboro: [220, 220, 220],
                    ghostwhite: [248, 248, 255],
                    gold: [255, 215, 0],
                    goldenrod: [218, 165, 32],
                    gray: [128, 128, 128],
                    green: [0, 128, 0],
                    greenyellow: [173, 255, 47],
                    grey: [128, 128, 128],
                    honeydew: [240, 255, 240],
                    hotpink: [255, 105, 180],
                    indianred: [205, 92, 92],
                    indigo: [75, 0, 130],
                    ivory: [255, 255, 240],
                    khaki: [240, 230, 140],
                    lavender: [230, 230, 250],
                    lavenderblush: [255, 240, 245],
                    lawngreen: [124, 252, 0],
                    lemonchiffon: [255, 250, 205],
                    lightblue: [173, 216, 230],
                    lightcoral: [240, 128, 128],
                    lightcyan: [224, 255, 255],
                    lightgoldenrodyellow: [250, 250, 210],
                    lightgray: [211, 211, 211],
                    lightgreen: [144, 238, 144],
                    lightgrey: [211, 211, 211],
                    lightpink: [255, 182, 193],
                    lightsalmon: [255, 160, 122],
                    lightseagreen: [32, 178, 170],
                    lightskyblue: [135, 206, 250],
                    lightslategray: [119, 136, 153],
                    lightslategrey: [119, 136, 153],
                    lightsteelblue: [176, 196, 222],
                    lightyellow: [255, 255, 224],
                    lime: [0, 255, 0],
                    limegreen: [50, 205, 50],
                    linen: [250, 240, 230],
                    magenta: [255, 0, 255],
                    maroon: [128, 0, 0],
                    mediumaquamarine: [102, 205, 170],
                    mediumblue: [0, 0, 205],
                    mediumorchid: [186, 85, 211],
                    mediumpurple: [147, 112, 219],
                    mediumseagreen: [60, 179, 113],
                    mediumslateblue: [123, 104, 238],
                    mediumspringgreen: [0, 250, 154],
                    mediumturquoise: [72, 209, 204],
                    mediumvioletred: [199, 21, 133],
                    midnightblue: [25, 25, 112],
                    mintcream: [245, 255, 250],
                    mistyrose: [255, 228, 225],
                    moccasin: [255, 228, 181],
                    navajowhite: [255, 222, 173],
                    navy: [0, 0, 128],
                    oldlace: [253, 245, 230],
                    olive: [128, 128, 0],
                    olivedrab: [107, 142, 35],
                    orange: [255, 165, 0],
                    orangered: [255, 69, 0],
                    orchid: [218, 112, 214],
                    palegoldenrod: [238, 232, 170],
                    palegreen: [152, 251, 152],
                    paleturquoise: [175, 238, 238],
                    palevioletred: [219, 112, 147],
                    papayawhip: [255, 239, 213],
                    peachpuff: [255, 218, 185],
                    peru: [205, 133, 63],
                    pink: [255, 192, 203],
                    plum: [221, 160, 221],
                    powderblue: [176, 224, 230],
                    purple: [128, 0, 128],
                    rebeccapurple: [102, 51, 153],
                    red: [255, 0, 0],
                    rosybrown: [188, 143, 143],
                    royalblue: [65, 105, 225],
                    saddlebrown: [139, 69, 19],
                    salmon: [250, 128, 114],
                    sandybrown: [244, 164, 96],
                    seagreen: [46, 139, 87],
                    seashell: [255, 245, 238],
                    sienna: [160, 82, 45],
                    silver: [192, 192, 192],
                    skyblue: [135, 206, 235],
                    slateblue: [106, 90, 205],
                    slategray: [112, 128, 144],
                    slategrey: [112, 128, 144],
                    snow: [255, 250, 250],
                    springgreen: [0, 255, 127],
                    steelblue: [70, 130, 180],
                    tan: [210, 180, 140],
                    teal: [0, 128, 128],
                    thistle: [216, 191, 216],
                    tomato: [255, 99, 71],
                    turquoise: [64, 224, 208],
                    violet: [238, 130, 238],
                    wheat: [245, 222, 179],
                    white: [255, 255, 255],
                    whitesmoke: [245, 245, 245],
                    yellow: [255, 255, 0],
                    yellowgreen: [154, 205, 50]
                }
            },
            6299: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-math-form{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:nowrap}@media screen and (max-width:600px){.ck.ck-math-form{flex-wrap:wrap}.ck.ck-math-form .ck-math-view,.ck.ck-math-form .ck-math-view .ck-label,.ck.ck-math-form .ck-math-view .ck-labeled-view{flex-basis:100%}.ck.ck-math-form .ck-button{flex-basis:50%}}.ck-math-tex.ck-placeholder:before{display:none!important}.ck.ck-toolbar-container{z-index:calc(var(--ck-z-modal) + 2)}.ck.ck-math-form{padding:var(--ck-spacing-standard)}.ck.ck-math-form:focus{outline:none}[dir=ltr] .ck.ck-math-form>:not(:first-child),[dir=rtl] .ck.ck-math-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-math-form{padding:0}.ck.ck-math-form .ck-labeled-input{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-math-form .ck-labeled-input .ck-input-text{min-width:0;width:100%}.ck.ck-math-form .ck-label,.ck.ck-math-form .ck-math-view .ck-button,.ck.ck-math-form .ck-math-view .ck.ck-math-preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-math-form>.ck-button{border:0;border-radius:0;border-top:1px solid var(--ck-color-base-border);margin-top:var(--ck-spacing-standard);padding:var(--ck-spacing-standard)}[dir=ltr] .ck.ck-math-form>.ck-button{margin-left:0}[dir=ltr] .ck.ck-math-form>.ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-math-form>.ck-button{margin-left:0}[dir=rtl] .ck.ck-math-form>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}}", "", {
                    version: 3,
                    sources: ["webpack://./../../node_modules/@isaul32/ckeditor5-math/theme/mathform.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-math/mathform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"],
                    names: [],
                    mappings: "AAAA,iBAEC,sBAAuB,CADvB,YAAa,CAEb,kBAAmB,CACnB,gBAsBD,CAnBC,oCAPD,iBAQE,cAkBF,CATG,wHACC,eACD,CAGD,4BACC,cACD,CACD,CAGD,mCACC,sBACD,CAEA,yBACC,mCACD,CC/BA,iBACI,kCAsEJ,CApEI,uBAEF,YACD,CASC,2FACC,sCACD,CCdD,oCDHD,iBAqBE,SAkDF,CAhDE,mCACC,8DAMD,CAJC,kDACC,WAAY,CACZ,UACD,CAYA,wHACC,8DACD,CAGD,4BAKC,QAAS,CADT,eAAgB,CAEhB,gDAAiD,CAJjD,qCAAsC,CADtC,kCAsBD,CAvBA,sCASE,aAcF,CAZE,oDACC,kDACD,CAbF,sCAiBE,aAMF,CAJE,mDACC,kDACD,CC9DH",
                    sourcesContent: [".ck.ck-math-form {\n\tdisplay: flex;\n\talign-items: flex-start;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tpadding: var(--ck-spacing-standard);\n\n\t@media screen and (max-width: 600px) {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-math-view {\n\t\t\tflex-basis: 100%;\n\n\t\t\t& .ck-labeled-view {\n\t\t\t\tflex-basis: 100%;\n\t\t\t}\n\n\t\t\t& .ck-label {\n\t\t\t\tflex-basis: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n.ck-math-tex.ck-placeholder::before {\n\tdisplay: none !important;\n}\n\n.ck.ck-toolbar-container {\n\tz-index: calc(var(--ck-z-modal) + 2);\n}\n", '@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-math-form {\n    padding: var(--ck-spacing-standard);\n\n    &:focus {\n\t\t/* https://github.com/ckeditor/ckeditor5-link/issues/90 */\n\t\toutline: none;\n\t}\n\n    @mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\n\t\t& .ck-labeled-input {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t}\n\n        & .ck-label {\n            margin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n        }\n\n\t\t& .ck-math-view {\n\t\t\t& .ck-button {\n\t\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\t\t\t}\n\n\t\t\t& .ck.ck-math-preview {\n\t\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-standard);\n\n\t\t\tborder-radius: 0;\n\t\t\tborder: 0;\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:first-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            8603: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-basic-styles/theme/code.css"],
                    names: [],
                    mappings: "AAKA,iBACC,kCAAuC,CAEvC,iBAAkB,CADlB,aAED,CAEA,0CACC,kCACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content code {\n\tbackground-color: hsla(0, 0%, 78%, 0.3);\n\tpadding: .15em;\n\tborder-radius: 2px;\n}\n\n.ck.ck-editor__editable .ck-code_selected  {\n\tbackground-color: hsla(0, 0%, 78%, 0.5);\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            3062: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-block-quote/theme/blockquote.css"],
                    names: [],
                    mappings: "AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n\t/* See #12 */\n\toverflow: hidden;\n\n\t/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n\tpadding-right: 1.5em;\n\tpadding-left: 1.5em;\n\n\tmargin-left: 0;\n\tmargin-right: 0;\n\tfont-style: italic;\n\tborder-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n\tborder-left: 0;\n\tborder-right: solid 5px hsl(0, 0%, 80%);\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            9932: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck-find-result{background:var(--ck-color-highlight-background);color:var(--ck-color-text)}.ck-find-result_selected{background:#ff9633}", "", {
                    version: 3,
                    sources: ["webpack://./node_modules/@ckeditor/ckeditor5-find-and-replace/theme/findandreplace.css"],
                    names: [],
                    mappings: "AAKA,gBACC,+CAAgD,CAChD,0BACD,CAEA,yBACC,kBACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-find-result {\n\tbackground: var(--ck-color-highlight-background);\n\tcolor: var(--ck-color-text);\n}\n\n.ck-find-result_selected {\n\tbackground: hsl(29, 100%, 60%);\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            2822: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-find-and-replace-form{max-width:100%}.ck.ck-find-and-replace-form fieldset{display:flex}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{position:absolute}.ck.ck-find-and-replace-form{width:400px}.ck.ck-find-and-replace-form:focus{outline:none}.ck.ck-find-and-replace-form fieldset{align-content:stretch;align-items:center;border:0;flex-direction:row;flex-wrap:nowrap;margin:0;padding:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset>.ck-button{flex:0 0 auto}[dir=ltr] .ck.ck-find-and-replace-form fieldset>*+*{margin-left:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-find-and-replace-form fieldset>*+*{margin-right:var(--ck-spacing-standard)}.ck.ck-find-and-replace-form fieldset .ck-labeled-field-view{flex:1 1 auto}.ck.ck-find-and-replace-form fieldset .ck-labeled-field-view .ck-input{min-width:50px;width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find{align-items:flex-start}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-find{font-weight:700}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-find .ck-button__label{padding-left:var(--ck-spacing-large);padding-right:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-prev>.ck-icon{transform:rotate(90deg)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-next>.ck-icon{transform:rotate(-90deg)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{top:50%;transform:translateY(-50%)}[dir=ltr] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{left:var(--ck-spacing-standard)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{color:var(--ck-color-base-border)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace{flex-wrap:wrap;justify-content:flex-end;margin-top:calc(var(--ck-spacing-large)*-1)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view{margin-bottom:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-options-dropdown{margin-left:0;margin-right:auto}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view,.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view .ck-input{width:100%}@media screen and (max-width:600px){.ck.ck-find-and-replace-form{width:300px}.ck.ck-find-and-replace-form fieldset{flex-wrap:wrap}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-labeled-field-view{flex:1 0 auto;margin-bottom:var(--ck-spacing-standard);width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button{text-align:center}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type{flex:1 1 auto}[dir=ltr] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type{margin-left:0}[dir=rtl] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type{margin-right:0}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type .ck-button__label{text-align:center;width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>:not(.ck-labeled-field-view){flex:1 1 auto}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-dropdown:not(.ck-labeled-field-view){flex-grow:0}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-button:not(.ck-labeled-field-view)>.ck-button__label{text-align:center;width:100%}}", "", {
                    version: 3,
                    sources: ["webpack://./node_modules/@ckeditor/ckeditor5-find-and-replace/theme/findandreplaceform.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-find-and-replace/findandreplaceform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"],
                    names: [],
                    mappings: "AAKA,6BACC,cAUD,CARC,sCACC,YAMD,CAHC,yFACC,iBACD,CCNF,6BACC,WAyGD,CAnGC,mCACC,YACD,CAEA,sCAIC,qBAAsB,CADtB,kBAAmB,CAInB,QAAS,CANT,kBAAmB,CACnB,gBAAiB,CAMjB,QAAS,CAFT,+BAwFD,CApFC,iDACC,aACD,CAGC,oDACC,sCACD,CAIA,oDACC,uCACD,CAGD,6DACC,aAMD,CAJC,uEAEC,cAAe,CADf,UAED,CAID,qEAEC,sBAkCD,CAhCC,qFACC,eAOD,CAJC,uGACC,oCAAqC,CACrC,qCACD,CAGD,8FACC,uBACD,CAEA,8FACC,wBACD,CAEA,yFACC,OAAQ,CACR,0BAWD,CAbA,mGAKE,gCAQF,CAbA,mGASE,+BAIF,CAbA,yFAYC,iCACD,CAID,wEACC,cAAe,CACf,wBAAyB,CACzB,2CAeD,CAbC,+FACC,qCACD,CAEA,6FAEC,aAAc,CADd,iBAED,CAEA,wMAEC,UACD,CCzGF,oCD+GA,6BACC,WAiDD,CA/CC,sCACC,cA6CD,CAzCE,4FACC,aAAc,CAEd,wCAAyC,CADzC,UAED,CAEA,gFACC,iBAkBD,CAhBC,8FACC,aAcD,CAfA,wGAIE,aAWF,CAfA,wGAQE,cAOF,CAJC,gHAEC,iBAAkB,CADlB,UAED,CAMH,qGACC,aAUD,CARC,iHACC,WACD,CAEA,iIAEC,iBAAkB,CADlB,UAED,CC5JH",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-find-and-replace-form {\n\tmax-width: 100%;\n\n\t& fieldset {\n\t\tdisplay: flex;\n\n\t\t/* The find fieldset */\n\t\t&.ck-find-and-replace-form__find .ck-results-counter {\n\t\t\tposition: absolute;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-find-and-replace-form {\n\twidth: 400px;\n\n\t/*\n\t * The <form> needs tabindex="-1" for proper Esc handling after being clicked\n\t * but the side effect is that this creates a nasty focus outline in some browsers.\n\t */\n\t&:focus {\n\t\toutline: none;\n\t}\n\n\t& fieldset {\n\t\tflex-direction: row;\n\t\tflex-wrap: nowrap;\n\t\talign-items: center;\n\t\talign-content: stretch;\n\n\t\tpadding: var(--ck-spacing-large);\n\t\tborder: 0;\n\t\tmargin: 0;\n\n\t\t& > .ck-button {\n\t\t\tflex: 0 0 auto;\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\t& > * + * {\n\t\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t& > * + * {\n\t\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex: 1 1 auto;\n\n\t\t\t& .ck-input {\n\t\t\t\twidth: 100%;\n\t\t\t\tmin-width: 50px;\n\t\t\t}\n\t\t}\n\n\t\t/* The find fieldset */\n\t\t&.ck-find-and-replace-form__find {\n\t\t\t/* To display all controls in line when there\'s an error under the input */\n\t\t\talign-items: flex-start;\n\n\t\t\t& > .ck-button-find {\n\t\t\t\tfont-weight: bold;\n\n\t\t\t\t/* Beef the find button up a little. It\'s the main action button in the form */\n\t\t\t\t& .ck-button__label {\n\t\t\t\t\tpadding-left: var(--ck-spacing-large);\n\t\t\t\t\tpadding-right: var(--ck-spacing-large);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& > .ck-button-prev > .ck-icon {\n\t\t\t\ttransform: rotate(90deg);\n\t\t\t}\n\n\t\t\t& > .ck-button-next > .ck-icon {\n\t\t\t\ttransform: rotate(-90deg);\n\t\t\t}\n\n\t\t\t& .ck-results-counter {\n\t\t\t\ttop: 50%;\n\t\t\t\ttransform: translateY(-50%);\n\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\tright: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\tleft: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\tcolor: var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\n\t\t/* The replace fieldset */\n\t\t&.ck-find-and-replace-form__replace {\n\t\t\tflex-wrap: wrap;\n\t\t\tjustify-content: flex-end;\n\t\t\tmargin-top: calc( -1 * var(--ck-spacing-large) );\n\n\t\t\t& > .ck-labeled-field-view {\n\t\t\t\tmargin-bottom: var(--ck-spacing-large);\n\t\t\t}\n\n\t\t\t& > .ck-options-dropdown {\n\t\t\t\tmargin-right: auto;\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t& > .ck-labeled-field-view,\n\t\t\t& > .ck-labeled-field-view .ck-input {\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t}\n\t}\n}\n\n@mixin ck-media-phone {\n\t.ck.ck-find-and-replace-form {\n\t\twidth: 300px;\n\n\t\t& fieldset {\n\t\t\tflex-wrap: wrap;\n\n\t\t\t/* The find fieldset */\n\t\t\t&.ck-find-and-replace-form__find {\n\t\t\t\t& .ck-labeled-field-view {\n\t\t\t\t\tflex: 1 0 auto;\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tmargin-bottom: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\t& > .ck-button {\n\t\t\t\t\ttext-align: center;\n\n\t\t\t\t\t&:first-of-type {\n\t\t\t\t\t\tflex: 1 1 auto;\n\n\t\t\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\t\t\tmargin-left: 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\t\t\tmargin-right: 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t& .ck-button__label {\n\t\t\t\t\t\t\twidth: 100%;\n\t\t\t\t\t\t\ttext-align: center;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* The replace fieldset */\n\t\t\t&.ck-find-and-replace-form__replace > :not(.ck-labeled-field-view) {\n\t\t\t\tflex: 1 1 auto;\n\n\t\t\t\t&.ck-dropdown {\n\t\t\t\t\tflex-grow: 0;\n\t\t\t\t}\n\n\t\t\t\t&.ck-button > .ck-button__label {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\ttext-align: center;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            1134: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/link.css"],
                    names: [],
                    mappings: "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n\tbackground: var(--ck-color-link-selected-background);\n\n\t/* Give linked inline images some outline to let the user know they are also part of the link. */\n\t& span.image-inline {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);\n\t}\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            9376: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", {
                    version: 3,
                    sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"],
                    names: [],
                    mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-link-actions__preview {\n\t\tdisplay: inline-block;\n\n\t\t& .ck-button__label {\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-link-actions__preview {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\t& .ck-button.ck-link-actions__preview {\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\n\t\t& .ck-button__label {\n\t\t\tpadding: 0 var(--ck-spacing-medium);\n\t\t\tcolor: var(--ck-color-link-default);\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: pointer;\n\n\t\t\t/* Match the box model of the link editor form\'s input so the balloon\n\t\t\tdoes not change width when moving between actions and the form. */\n\t\t\tmax-width: var(--ck-input-width);\n\t\t\tmin-width: 3em;\n\t\t\ttext-align: center;\n\n\t\t\t&:hover {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\n\t\t&,\n\t\t&:hover,\n\t\t&:focus,\n\t\t&:active {\n\t\t\tbackground: none;\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&:focus {\n\t\t\t& .ck-button__label {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-button:not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\t& .ck-button.ck-link-actions__preview {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-button__label {\n\t\t\t\tmin-width: 0;\n\t\t\t\tmax-width: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            8117: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", {
                    version: 3,
                    sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"],
                    names: [],
                    mappings: "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n\tdisplay: flex;\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tdisplay: block;\n\n\t/*\n\t * Whether the form is in the responsive mode or not, if there are decorator buttons\n\t * keep the top margin of action buttons medium.\n\t */\n\t& .ck-button {\n\t\t&.ck-button-save,\n\t\t&.ck-button-cancel {\n\t\t\tmargin-top: var(--ck-spacing-medium);\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tpadding: 0;\n\tmin-width: var(--ck-input-width);\n\n\t& .ck-labeled-field-view {\n\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n\t\t& .ck-input-text {\n\t\t\tmin-width: 0;\n\t\t\twidth: 100%;\n\t\t}\n\t}\n\n\t& > .ck-button {\n\t\tpadding: var(--ck-spacing-standard);\n\t\tmargin: 0;\n\t\twidth: 50%;\n\t\tborder-radius: 0;\n\n\t\t&:not(:focus) {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: 0;\n\n\t\t\t&:last-of-type {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n\t& .ck.ck-list {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n\t\t& .ck-button.ck-switchbutton {\n\t\t\tpadding: 0;\n\t\t\twidth: 100%;\n\n\t\t\t&:hover {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            3088: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, '.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{display:block;position:absolute}:root{--ck-link-image-indicator-icon-size:20;--ck-link-image-indicator-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{background-color:rgba(0,0,0,.4);background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");background-position:50%;background-repeat:no-repeat;background-size:14px;border-radius:100%;content:"";height:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size));overflow:hidden;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);width:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size))}', "", {
                    version: 3,
                    sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkimage.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkimage.css"],
                    names: [],
                    mappings: "AASE,+FACC,aAAc,CACd,iBACD,CCPF,MAEC,sCAAuC,CACvC,oEACD,CAME,+FAUC,+BAAqC,CACrC,83BAA+3B,CAG/3B,uBAA2B,CAD3B,2BAA4B,CAD5B,oBAAqB,CAGrB,kBAAmB,CAdnB,UAAW,CAsBX,oGAAuG,CAFvG,eAAgB,CAbhB,sCAAwC,CADxC,oCAAsC,CAetC,mGAED",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/* Linked image indicator */\n\t& figure.image > a,\n\t& a span.image-inline {\n\t\t&::after {\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t}\n\t}\n}\n\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Match the icon size with the upload indicator brought by the image upload feature. */\n\t--ck-link-image-indicator-icon-size: 20;\n\t--ck-link-image-indicator-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck.ck-editor__editable {\n\t/* Linked image indicator */\n\t& figure.image > a,\n\t& a span.image-inline {\n\t\t&::after {\n\t\t\tcontent: "";\n\n\t\t\t/*\n\t\t\t * Smaller images should have the icon closer to the border.\n\t\t\t * Match the icon position with the upload indicator brought by the image upload feature.\n\t\t\t */\n\t\t\ttop: min(var(--ck-spacing-medium), 6%);\n\t\t\tright: min(var(--ck-spacing-medium), 6%);\n\n\t\t\tbackground-color: hsla(0, 0%, 0%, .4);\n\t\t\tbackground-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");\n\t\t\tbackground-size: 14px;\n\t\t\tbackground-repeat: no-repeat;\n\t\t\tbackground-position: center;\n\t\t\tborder-radius: 100%;\n\n\t\t\t/*\n\t\t\t* Use CSS math to simulate container queries.\n\t\t\t* https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n\t\t\t*/\n\t\t\toverflow: hidden;\n\t\t\twidth: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));\n\t\t\theight: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));\n\t\t}\n\t}\n}\n\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            5023: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ":root{--ck-color-mention-background:rgba(153,0,48,.1);--ck-color-mention-text:#990030}.ck-content .mention{background:var(--ck-color-mention-background);color:var(--ck-color-mention-text)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-mention/mention.css"],
                    names: [],
                    mappings: "AAKA,MACC,+CAAwD,CACxD,+BACD,CAEA,qBACC,6CAA8C,CAC9C,kCACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-mention-background: hsla(341, 100%, 30%, 0.1);\n\t--ck-color-mention-text: hsl(341, 100%, 30%);\n}\n\n.ck-content .mention {\n\tbackground: var(--ck-color-mention-background);\n\tcolor: var(--ck-color-mention-text);\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            7640: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ":root{--ck-mention-list-max-height:300px}.ck.ck-mentions{max-height:var(--ck-mention-list-max-height);overflow-x:hidden;overflow-y:auto;overscroll-behavior:contain}.ck.ck-mentions>.ck-list__item{flex-shrink:0;overflow:hidden}", "", {
                    version: 3,
                    sources: ["webpack://./node_modules/@ckeditor/ckeditor5-mention/theme/mentionui.css"],
                    names: [],
                    mappings: "AAKA,MACC,kCACD,CAEA,gBACC,4CAA6C,CAM7C,iBAAkB,CAJlB,eAAgB,CAMhB,2BAQD,CAJC,+BAEC,aAAc,CADd,eAED",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-mention-list-max-height: 300px;\n}\n\n.ck.ck-mentions {\n\tmax-height: var(--ck-mention-list-max-height);\n\n\toverflow-y: auto;\n\n\t/* Prevent unnecessary horizontal scrollbar in Safari\n\thttps://github.com/ckeditor/ckeditor5-mention/issues/41 */\n\toverflow-x: hidden;\n\n\toverscroll-behavior: contain;\n\n\t/* Prevent unnecessary vertical scrollbar in Safari\n\thttps://github.com/ckeditor/ckeditor5-mention/issues/41 */\n\t& > .ck-list__item {\n\t\toverflow: hidden;\n\t\tflex-shrink: 0;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            7657: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-block-toolbar-button{transform:translateX(calc(var(--ck-spacing-large)*-1))}", "", {
                    version: 3,
                    sources: ["webpack://./theme/theme.css"],
                    names: [],
                    mappings: "AAMA,4BACC,sDACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Give the block toolbar button some space, moving it a few pixels away from the editable area. */\n.ck.ck-block-toolbar-button {\n\ttransform: translateX( calc(-1 * var(--ck-spacing-large)) );\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            903: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}.ck.ck-clipboard-drop-target-line{pointer-events:none;position:absolute}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}.ck.ck-clipboard-drop-target-line{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);height:0;margin-top:-1px}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-clipboard/theme/clipboard.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css"],
                    names: [],
                    mappings: "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CAIF,kCAEC,mBAAoB,CADpB,iBAED,CChCA,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CAOF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD,CAGD,kCAGC,gDAAiD,CADjD,sDAAuD,CADvD,QAAS,CAGT,eACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: inline;\n\t\tposition: relative;\n\t\tpointer-events: none;\n\n\t\t& span {\n\t\t\tposition: absolute;\n\t\t\twidth: 0;\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\t& > .ck-widget__selection-handle {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t& > .ck-widget__type-around {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n.ck.ck-clipboard-drop-target-line {\n\tposition: absolute;\n\tpointer-events: none;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-clipboard-drop-target-dot-width: 12px;\n\t--ck-clipboard-drop-target-dot-height: 8px;\n\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border)\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\t& span {\n\t\t\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tbackground: var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-left: -1px;\n\n\t\t\t/* The triangle above the marker */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 50%;\n\t\t\t\ttop: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);\n\n\t\t\t\ttransform: translateX(-50%);\n\t\t\t\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n\t\t\t\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget that it a drop target.\n\t */\n\t& .ck-widget.ck-clipboard-drop-target-range {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\tzoom: 0.6;\n\t\toutline: none !important;\n\t}\n}\n\n.ck.ck-clipboard-drop-target-line {\n\theight: 0;\n\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\tbackground: var(--ck-clipboard-drop-target-color);\n\tmargin-top: -1px;\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            8343: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck-content pre{background:hsla(0,0%,78%,.3);border:1px solid #c4c4c4;border-radius:2px;color:#353535;direction:ltr;font-style:normal;min-width:200px;padding:1em;tab-size:4;text-align:left;white-space:pre-wrap}.ck-content pre code{background:unset;border-radius:0;padding:0}.ck.ck-editor__editable pre{position:relative}.ck.ck-editor__editable pre[data-language]:after{content:attr(data-language);position:absolute}:root{--ck-color-code-block-label-background:#757575}.ck.ck-editor__editable pre[data-language]:after{background:var(--ck-color-code-block-label-background);color:#fff;font-family:var(--ck-font-face);font-size:10px;line-height:16px;padding:var(--ck-spacing-tiny) var(--ck-spacing-medium);right:10px;top:-1px;white-space:nowrap}.ck.ck-code-block-dropdown .ck-dropdown__panel{max-height:250px;overflow-x:hidden;overflow-y:auto}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-code-block/theme/codeblock.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-code-block/codeblock.css"],
                    names: [],
                    mappings: "AAKA,gBAGC,4BAAiC,CACjC,wBAAiC,CACjC,iBAAkB,CAHlB,aAAwB,CAOxB,aAAc,CAMd,iBAAkB,CAGlB,eAAgB,CAjBhB,WAAY,CAUZ,UAAW,CAHX,eAAgB,CAIhB,oBAaD,CALC,qBACC,gBAAiB,CAEjB,eAAgB,CADhB,SAED,CAGD,4BACC,iBAMD,CAJC,iDACC,2BAA4B,CAC5B,iBACD,CCjCD,MACC,8CACD,CAEA,iDAGC,sDAAuD,CAMvD,UAAuB,CAHvB,+BAAgC,CADhC,cAAe,CAEf,gBAAiB,CACjB,uDAAwD,CANxD,UAAW,CADX,QAAS,CAST,kBACD,CAEA,+CAEC,gBAAiB,CAEjB,iBAAkB,CADlB,eAED",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content pre {\n\tpadding: 1em;\n\tcolor: hsl(0, 0%, 20.8%);\n\tbackground: hsla(0, 0%, 78%, 0.3);\n\tborder: 1px solid hsl(0, 0%, 77%);\n\tborder-radius: 2px;\n\n\t/* Code block are language direction–agnostic. */\n\ttext-align: left;\n\tdirection: ltr;\n\n\ttab-size: 4;\n\twhite-space: pre-wrap;\n\n\t/* Don't inherit the style, e.g. when in a block quote. */\n\tfont-style: normal;\n\n\t/* Don't let the code be squashed e.g. when in a table cell. */\n\tmin-width: 200px;\n\n\t& code {\n\t\tbackground: unset;\n\t\tpadding: 0;\n\t\tborder-radius: 0;\n\t}\n}\n\n.ck.ck-editor__editable pre {\n\tposition: relative;\n\n\t&[data-language]::after {\n\t\tcontent: attr(data-language);\n\t\tposition: absolute;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-code-block-label-background: hsl(0, 0%, 46%);\n}\n\n.ck.ck-editor__editable pre[data-language]::after {\n\ttop: -1px;\n\tright: 10px;\n\tbackground: var(--ck-color-code-block-label-background);\n\n\tfont-size: 10px;\n\tfont-family: var(--ck-font-face);\n\tline-height: 16px;\n\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-medium);\n\tcolor: hsl(0, 0%, 100%);\n\twhite-space: nowrap;\n}\n\n.ck.ck-code-block-dropdown .ck-dropdown__panel {\n\t/* There could be dozens of languages available. Use scroll to prevent a 10e6px dropdown. */\n\tmax-height: 250px;\n\toverflow-y: auto;\n\toverflow-x: hidden;\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            4717: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-engine/theme/placeholder.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"],
                    names: [],
                    mappings: "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\tposition: relative;\n\n\t&::before {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n\tposition: relative;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            9315: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-engine/theme/renderer.css"],
                    names: [],
                    mappings: "AAMA,qDACC,YACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n\tdisplay: none;\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            1896: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck .ck-button.ck-color-table__color-picker,.ck .ck-button.ck-color-table__remove-color{align-items:center;display:flex;width:100%}[dir=rtl] .ck .ck-button.ck-color-table__color-picker,[dir=rtl] .ck .ck-button.ck-color-table__remove-color{justify-content:flex-start}.ck .ck-button.ck-color-table__color-picker{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard)}.ck .ck-button.ck-color-table__color-picker:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck .ck-button.ck-color-table__color-picker .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck .ck-button.ck-color-table__color-picker .ck.ck-icon{margin-left:var(--ck-spacing-standard)}label.ck.ck-color-grid__label{font-weight:unset}.ck.ck-color-picker{padding:8px}.ck.ck-color-picker .hex-color-picker{height:100px;margin:0 0 var(--ck-spacing-large) 0}.ck.ck-color-picker .hex-color-picker::part(saturation){border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0}.ck.ck-color-picker .hex-color-picker::part(hue){border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius)}.ck.ck-color-picker .hex-color-picker::part(hue-pointer),.ck.ck-color-picker .hex-color-picker::part(saturation-pointer){height:15px;width:15px}.ck.ck-color-table_action-bar{display:flex;flex-direction:row;justify-content:space-around;padding:0 8px 8px}.ck.ck-color-table_action-bar .ck-button-cancel,.ck.ck-color-table_action-bar .ck-button-save{flex:1}.ck .ck-button.ck-color-table__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard)}.ck .ck-button.ck-color-table__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-base-border)}[dir=ltr] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-font/theme/fontcolor.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-font/fontcolor.css"],
                    names: [],
                    mappings: "AAOA,wFAGC,kBAAmB,CADnB,YAAa,CAEb,UAKD,CATA,4GAOE,0BAEF,CAEA,4CAEC,2BAA4B,CAC5B,4BAA6B,CAF7B,qEAiBD,CAbC,wDACC,gDACD,CAEA,kEAEE,uCAMF,CARA,kEAME,sCAEF,CAGD,8BACC,iBACD,CAEA,oBACC,WAmBD,CAjBC,sCACC,YAAa,CACb,oCAcD,CAZC,wDACC,iEACD,CACA,iDACC,iEACD,CAEA,yHAGC,WAAY,CADZ,UAED,CAIF,8BACC,YAAa,CACb,kBAAmB,CACnB,4BAA6B,CAC7B,iBAMD,CAJC,8FAEC,MACD,CClED,4CAEC,2BAA4B,CAC5B,4BAA6B,CAF7B,qEAiBD,CAbC,wDACC,mDACD,CAEA,kEAEE,uCAMF,CARA,kEAME,sCAEF",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck .ck-button.ck-color-table__remove-color,\n.ck .ck-button.ck-color-table__color-picker {\n\tdisplay: flex;\n\talign-items: center;\n\twidth: 100%;\n\n\t@mixin ck-dir rtl {\n\t\tjustify-content: flex-start;\n\t}\n}\n\n.ck .ck-button.ck-color-table__color-picker {\n\tpadding: calc(var(--ck-spacing-standard) / 2 ) var(--ck-spacing-standard);\n\tborder-bottom-left-radius: 0;\n\tborder-bottom-right-radius: 0;\n\n\t&:not(:focus) {\n\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n}\n\nlabel.ck.ck-color-grid__label {\n\tfont-weight: unset;\n}\n\n.ck.ck-color-picker {\n\tpadding: 8px;\n\n\t& .hex-color-picker {\n\t\theight: 100px;\n\t\tmargin: 0 0 var(--ck-spacing-large) 0;\n\n\t\t&::part(saturation) {\n\t\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\t\t}\n\t\t&::part(hue) {\n\t\t\tborder-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);\n\t\t}\n\n\t\t&::part(saturation-pointer),\n\t\t&::part(hue-pointer) {\n\t\t\twidth: 15px;\n\t\t\theight: 15px;\n\t\t}\n\t}\n}\n\n.ck.ck-color-table_action-bar {\n\tdisplay: flex;\n\tflex-direction: row;\n\tjustify-content: space-around;\n\tpadding: 0 8px 8px;\n\n\t& .ck-button-save,\n\t& .ck-button-cancel {\n\t\tflex: 1\n\t}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck .ck-button.ck-color-table__remove-color {\n\tpadding: calc(var(--ck-spacing-standard) / 2 ) var(--ck-spacing-standard);\n\tborder-bottom-left-radius: 0;\n\tborder-bottom-right-radius: 0;\n\n\t&:not(:focus) {\n\t\tborder-bottom: 1px solid var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n}\n\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            6007: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck-content .text-tiny{font-size:.7em}.ck-content .text-small{font-size:.85em}.ck-content .text-big{font-size:1.4em}.ck-content .text-huge{font-size:1.8em}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-font/theme/fontsize.css"],
                    names: [],
                    mappings: "AAUC,uBACC,cACD,CAEA,wBACC,eACD,CAEA,sBACC,eACD,CAEA,uBACC,eACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* The values should be synchronized with the "FONT_SIZE_PRESET_UNITS" object in the "/src/fontsize/utils.js" file. */\n\n/* Styles should be prefixed with the `.ck-content` class.\nSee https://github.com/ckeditor/ckeditor5/issues/6636 */\n.ck-content {\n\t& .text-tiny {\n\t\tfont-size: .7em;\n\t}\n\n\t& .text-small {\n\t\tfont-size: .85em;\n\t}\n\n\t& .text-big {\n\t\tfont-size: 1.4em;\n\t}\n\n\t& .text-huge {\n\t\tfont-size: 1.8em;\n\t}\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            8733: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-heading/theme/heading.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"],
                    names: [],
                    mappings: "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n\tfont-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n\tfont-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n\tfont-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n\tfont-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n\t& .ck-dropdown__button .ck-button__label {\n\t\twidth: 8em;\n\t}\n\n\t& .ck-dropdown__panel .ck-list__item {\n\t\tmin-width: 18em;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            2974: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck-editor__editable .ck-horizontal-line{display:flow-root}.ck-content hr{background:#dedede;border:0;height:4px;margin:15px 0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-horizontal-line/theme/horizontalline.css"],
                    names: [],
                    mappings: "AAMA,yCAEC,iBACD,CAEA,eAGC,kBAA2B,CAC3B,QAAS,CAFT,UAAW,CADX,aAID",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n\n.ck-editor__editable .ck-horizontal-line {\n\t/* Necessary to render properly next to floated objects, e.g. side image case. */\n\tdisplay: flow-root;\n}\n\n.ck-content hr {\n\tmargin: 15px 0;\n\theight: 4px;\n\tbackground: hsl(0, 0%, 87%);\n\tborder: 0;\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            3508: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/image.css"],
                    names: [],
                    mappings: "AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBAuBD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content {\n\t& .image {\n\t\tdisplay: table;\n\t\tclear: both;\n\t\ttext-align: center;\n\n\t\t/* Make sure there is some space between the content and the image. Center image by default. */\n\t\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\t \tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\t\tmargin: 0.9em auto;\n\n\t\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n\t\tmin-width: 50px;\n\n\t\t& img {\n\t\t\t/* Prevent unnecessary margins caused by line-height (see #44). */\n\t\t\tdisplay: block;\n\n\t\t\t/* Center the image if its width is smaller than the content\'s width. */\n\t\t\tmargin: 0 auto;\n\n\t\t\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n\t\t\tmax-width: 100%;\n\n\t\t\t/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */\n\t\t\tmin-width: 100%\n\t\t}\n\t}\n\n\t& .image-inline {\n\t\t/*\n\t\t * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).\n\t\t * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.\n\t\t * This strange behavior does not happen with inline-flex.\n\t\t */\n\t\tdisplay: inline-flex;\n\n\t\t/* While being resized, don\'t allow the image to exceed the width of the editing root. */\n\t\tmax-width: 100%;\n\n\t\t/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */\n\t\talign-items: flex-start;\n\n\t\t/* When the picture is present it must act as a flex container to let the img resize properly */\n\t\t& picture {\n\t\t\tdisplay: flex;\n\t\t}\n\n\t\t/* When the picture is present, it must act like a resizable img. */\n\t\t& picture,\n\t\t& img {\n\t\t\t/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */\n\t\t\tflex-grow: 1;\n\t\t\tflex-shrink: 1;\n\n\t\t\t/* Prevents overflowing the editing root boundaries when an inline image is very wide. */\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Inhertit the content styles padding of the <figcaption> in case the integration overrides `text-align: center`\n\t * of `.image` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native\n\t * caret does, and not at the edge of <figcaption>.\n\t */\n\t& .image > figcaption.ck-placeholder::before {\n\t\tpadding-left: inherit;\n\t\tpadding-right: inherit;\n\n\t\t/*\n\t\t * Make sure the image caption placeholder doesn\'t overflow the placeholder area.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\n\t\t */\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n\n\n\t/*\n\t * Make sure the selected inline image always stays on top of its siblings.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9108.\n\t */\n\t& .image.ck-widget_selected {\n\t\tz-index: 1;\n\t}\n\n\t& .image-inline.ck-widget_selected {\n\t\tz-index: 1;\n\n\t\t/*\n\t\t * Make sure the native browser selection style is not displayed.\n\t\t * Inline image widgets have their own styles for the selected state and\n\t\t * leaving this up to the browser is asking for a visual collision.\n\t\t */\n\t\t& ::selection {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t/* The inline image nested in the table should have its original size if not resized.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline img {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            2640: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imagecaption.css"],
                    names: [],
                    mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAMD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-caption-background: hsl(0, 0%, 97%);\n\t--ck-color-image-caption-text: hsl(0, 0%, 20%);\n\t--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .image > figcaption {\n\tdisplay: table-caption;\n\tcaption-side: bottom;\n\tword-break: break-word;\n\tcolor: var(--ck-color-image-caption-text);\n\tbackground-color: var(--ck-color-image-caption-background);\n\tpadding: .6em;\n\tfont-size: .75em;\n\toutline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {\n\tanimation: ck-image-caption-highlight .6s ease-out;\n}\n\n@keyframes ck-image-caption-highlight {\n\t0% {\n\t\tbackground-color: var(--ck-color-image-caption-highligted-background);\n\t}\n\n\t100% {\n\t\tbackground-color: var(--ck-color-image-caption-background);\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            3535: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-image-insert__panel{padding:var(--ck-spacing-large)}.ck.ck-image-insert__ck-finder-button{border:1px solid #ccc;border-radius:var(--ck-border-radius);display:block;margin:var(--ck-spacing-standard) auto;width:100%}.ck.ck-splitbutton>.ck-file-dialog-button.ck-button{border:none;margin:0;padding:0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageinsert.css"],
                    names: [],
                    mappings: "AAKA,2BACC,+BACD,CAEA,sCAIC,qBAAiC,CACjC,qCAAsC,CAJtC,aAAc,CAEd,sCAAuC,CADvC,UAID,CAGA,oDAGC,WAAY,CADZ,QAAS,CADT,SAGD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert__panel {\n\tpadding: var(--ck-spacing-large);\n}\n\n.ck.ck-image-insert__ck-finder-button {\n\tdisplay: block;\n\twidth: 100%;\n\tmargin: var(--ck-spacing-standard) auto;\n\tborder: 1px solid hsl(0, 0%, 80%);\n\tborder-radius: var(--ck-border-radius);\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/7986 */\n.ck.ck-splitbutton > .ck-file-dialog-button.ck-button {\n\tpadding: 0;\n\tmargin: 0;\n\tborder: none;\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            1568: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-image-insert-form:focus{outline:none}.ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-image-insert-form__action-row{margin-top:var(--ck-spacing-standard)}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageinsertformrowview.css"],
                    names: [],
                    mappings: "AAMC,+BAEC,YACD,CAGD,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAmBD,CAhBC,iCACC,WACD,CAEA,kDACC,qCAUD,CARC,sIAEC,sBACD,CAEA,+EACC,0BACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert-form {\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n}\n\n.ck.ck-form__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\tflex-grow: 1;\n\t}\n\n\t&.ck-image-insert-form__action-row {\n\t\tmargin-top: var(--ck-spacing-standard);\n\n\t\t& .ck-button-save,\n\t\t& .ck-button-cancel {\n\t\t\tjustify-content: center;\n\t\t}\n\n\t\t& .ck-button .ck-button__label {\n\t\t\tcolor: var(--ck-color-text);\n\t\t}\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            6270: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageresize.css"],
                    names: [],
                    mappings: "AAKA,iCAQC,qBAAsB,CADtB,aAAc,CANd,cAkBD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAQC,sHACC,cACD,CAIF,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .image.image_resized {\n\tmax-width: 100%;\n\t/*\n\tThe `<figure>` element for resized images must not use `display:table` as browsers do not support `max-width` for it well.\n\tSee https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.\n\tFortunately, since we control the width, there is no risk that the image will look bad.\n\t*/\n\tdisplay: block;\n\tbox-sizing: border-box;\n\n\t& img {\n\t\t/* For resized images it is the `<figure>` element that determines the image width. */\n\t\twidth: 100%;\n\t}\n\n\t& > figcaption {\n\t\t/* The `<figure>` element uses `display:block`, so `<figcaption>` also has to. */\n\t\tdisplay: block;\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/* The resized inline image nested in the table should respect its parent size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline.image_resized img {\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-right: var(--ck-spacing-standard);\n}\n\n[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-left: var(--ck-spacing-standard);\n}\n\n.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {\n\twidth: 4em;\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            5083: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imagestyle.css"],
                    names: [],
                    mappings: "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-image-style-spacing: 1.5em;\n\t--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);\n}\n\n.ck-content {\n\t/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback\n\tconfirming successful application of the style if image width exceeds the editor's size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9342 */\n\t& .image-style-block-align-left,\n\t& .image-style-block-align-right {\n\t\tmax-width: calc(100% - var(--ck-image-style-spacing));\n\t}\n\n\t/* Allows displaying multiple floating images in the same line.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */\n\t& .image-style-align-left,\n\t& .image-style-align-right {\n\t\tclear: none;\n\t}\n\n\t& .image-style-side {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t\tmax-width: 50%;\n\t}\n\n\t& .image-style-align-left {\n\t\tfloat: left;\n\t\tmargin-right: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-align-center {\n\t\tmargin-left: auto;\n\t\tmargin-right: auto;\n\t}\n\n\t& .image-style-align-right {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-block-align-right {\n\t\tmargin-right: 0;\n\t\tmargin-left: auto;\n\t}\n\n\t& .image-style-block-align-left {\n\t\tmargin-left: 0;\n\t\tmargin-right: auto;\n\t}\n\n\t/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */\n\t& p + .image-style-align-left,\n\t& p + .image-style-align-right,\n\t& p + .image-style-side {\n\t\tmargin-top: 0;\n\t}\n\n\t& .image-inline {\n\t\t&.image-style-align-left,\n\t\t&.image-style-align-right {\n\t\t\tmargin-top: var(--ck-inline-image-style-spacing);\n\t\t\tmargin-bottom: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-left {\n\t\t\tmargin-right: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-right {\n\t\t\tmargin-left: var(--ck-inline-image-style-spacing);\n\t\t}\n\t}\n}\n\n.ck.ck-splitbutton {\n\t/* The button should display as a regular drop-down if the action button\n\tis forced to fire the same action as the arrow button. */\n\t&.ck-splitbutton_flatten {\n\t\t&:hover,\n\t\t&.ck-splitbutton_open {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-background);\n\n\t\t\t\t&::after {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t&.ck-splitbutton_open:hover {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-hover-background);\n\t\t\t}\n\t\t}\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            4036: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageuploadicon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"],
                    names: [],
                    mappings: "AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n\tdisplay: block;\n\tposition: absolute;\n\n\t/*\n\t * Smaller images should have the icon closer to the border.\n\t * Match the icon position with the linked image indicator brought by the link image feature.\n\t */\n\ttop: min(var(--ck-spacing-medium), 6%);\n\tright: min(var(--ck-spacing-medium), 6%);\n\tborder-radius: 50%;\n\tz-index: 1;\n\n\t&::after {\n\t\tcontent: "";\n\t\tposition: absolute;\n\t}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n\t--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n\t/* Match the icon size with the linked image indicator brought by the link image feature. */\n\t--ck-image-upload-icon-size: 20;\n\t--ck-image-upload-icon-width: 2px;\n\t--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck-image-upload-complete-icon {\n\topacity: 0;\n\tbackground: var(--ck-color-image-upload-icon-background);\n\tanimation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n\tanimation-fill-mode: forwards, forwards;\n\tanimation-duration: 500ms, 500ms;\n\n\t/* To make animation scalable. */\n\tfont-size: calc(1px * var(--ck-image-upload-icon-size));\n\n\t/* Hide completed upload icon after 3 seconds. */\n\tanimation-delay: 0ms, 3000ms;\n\n\t/*\n\t * Use CSS math to simulate container queries.\n\t * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n\t */\n\toverflow: hidden;\n\twidth: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\theight: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\n\t/* This is check icon element made from border-width mixed with animations. */\n\t&::after {\n\t\t/* Because of border transformation we need to "hard code" left position. */\n\t\tleft: 25%;\n\n\t\ttop: 50%;\n\t\topacity: 0;\n\t\theight: 0;\n\t\twidth: 0;\n\n\t\ttransform: scaleX(-1) rotate(135deg);\n\t\ttransform-origin: left top;\n\t\tborder-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\t\tborder-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n\t\tanimation-name: ck-upload-complete-icon-check;\n\t\tanimation-duration: 500ms;\n\t\tanimation-delay: 500ms;\n\t\tanimation-fill-mode: forwards;\n\n\t\t/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n\t\tbox-sizing: border-box;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-show {\n\tfrom {\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\topacity: 1;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n\tfrom {\n\t\topacity: 1;\n\t}\n\n\tto {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-check {\n\t0% {\n\t\topacity: 1;\n\t\twidth: 0;\n\t\theight: 0;\n\t}\n\t33% {\n\t\twidth: 0.3em;\n\t\theight: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t\twidth: 0.3em;\n\t\theight: 0.45em;\n\t}\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            3773: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageuploadloader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"],
                    names: [],
                    mappings: "AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n\tposition: absolute;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\ttop: 0;\n\tleft: 0;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: relative;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n\t--ck-upload-placeholder-loader-size: 32px;\n\t--ck-upload-placeholder-image-aspect-ratio: 2.8;\n}\n\n.ck .ck-image-upload-placeholder {\n\t/* We need to control the full width of the SVG gray background. */\n\twidth: 100%;\n\tmargin: 0;\n\n\t&.image-inline {\n\t\twidth: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );\n\t}\n\n\t& img {\n\t\t/*\n\t\t * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.\n\t\t * There's nothing special about this number except that it should make the image placeholder look like\n\t\t * a real image during this short period after the upload started and before the image was read from the\n\t\t * file system (and a rich preview was loaded).\n\t\t */\n\t\taspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);\n\t}\n}\n\n.ck .ck-upload-placeholder-loader {\n\twidth: 100%;\n\theight: 100%;\n\n\t&::before {\n\t\twidth: var(--ck-upload-placeholder-loader-size);\n\t\theight: var(--ck-upload-placeholder-loader-size);\n\t\tborder-radius: 50%;\n\t\tborder-top: 3px solid var(--ck-color-upload-placeholder-loader);\n\t\tborder-right: 2px solid transparent;\n\t\tanimation: ck-upload-placeholder-loader 1s linear infinite;\n\t}\n}\n\n@keyframes ck-upload-placeholder-loader {\n\tto {\n\t\ttransform: rotate( 360deg );\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            3689: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageuploadprogress.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"],
                    names: [],
                    mappings: "AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\tposition: relative;\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\t/* Showing animation. */\n\t\t&.ck-appear {\n\t\t\tanimation: fadeIn 700ms;\n\t\t}\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\theight: 2px;\n\t\twidth: 0;\n\t\tbackground: var(--ck-color-upload-bar-background);\n\t\ttransition: width 100ms;\n\t}\n}\n\n@keyframes fadeIn {\n\tfrom { opacity: 0; }\n\tto   { opacity: 1; }\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            1905: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/textalternativeform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"],
                    names: [],
                    mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            4721: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-collapsible.ck-collapsible_collapsed>.ck-collapsible__children{display:none}:root{--ck-collapsible-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-collapsible>.ck.ck-button{border-radius:0;color:inherit;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-collapsible>.ck.ck-button:focus{background:transparent}.ck.ck-collapsible>.ck.ck-button:active,.ck.ck-collapsible>.ck.ck-button:hover:not(:focus),.ck.ck-collapsible>.ck.ck-button:not(:focus){background:transparent;border-color:transparent;box-shadow:none}.ck.ck-collapsible>.ck.ck-button>.ck-icon{margin-right:var(--ck-spacing-medium);width:var(--ck-collapsible-arrow-size)}.ck.ck-collapsible>.ck-collapsible__children{padding:0 var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-collapsible.ck-collapsible_collapsed>.ck.ck-button .ck-icon{transform:rotate(-90deg)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-list/theme/collapsible.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/collapsible.css"],
                    names: [],
                    mappings: "AAMC,sEACC,YACD,CCHD,MACC,yDACD,CAGC,iCAIC,eAAgB,CAChB,aAAc,CAHd,eAAiB,CACjB,wDAAyD,CAFzD,UAoBD,CAdC,uCACC,sBACD,CAEA,wIACC,sBAAuB,CACvB,wBAAyB,CACzB,eACD,CAEA,0CACC,qCAAsC,CACtC,sCACD,CAGD,6CACC,yDACD,CAGC,mEACC,wBACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-collapsible.ck-collapsible_collapsed {\n\t& > .ck-collapsible__children {\n\t\tdisplay: none;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-collapsible-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-collapsible {\n\t& > .ck.ck-button {\n\t\twidth: 100%;\n\t\tfont-weight: bold;\n\t\tpadding: var(--ck-spacing-medium) var(--ck-spacing-large);\n\t\tborder-radius: 0;\n\t\tcolor: inherit;\n\n\t\t&:focus {\n\t\t\tbackground: transparent;\n\t\t}\n\n\t\t&:active, &:not(:focus), &:hover:not(:focus) {\n\t\t\tbackground: transparent;\n\t\t\tborder-color: transparent;\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t& > .ck-icon {\n\t\t\tmargin-right: var(--ck-spacing-medium);\n\t\t\twidth: var(--ck-collapsible-arrow-size);\n\t\t}\n\t}\n\n\t& > .ck-collapsible__children {\n\t\tpadding: 0 var(--ck-spacing-large) var(--ck-spacing-large);\n\t}\n\n\t&.ck-collapsible_collapsed {\n\t\t& > .ck.ck-button .ck-icon {\n\t\t\ttransform: rotate(-90deg);\n\t\t}\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            5730: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck-editor__editable .ck-list-bogus-paragraph{display:block}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-list/theme/documentlist.css"],
                    names: [],
                    mappings: "AAKA,8CACC,aACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-editor__editable .ck-list-bogus-paragraph {\n\tdisplay: block;\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            4564: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:disc}.ck-content ul ul{list-style-type:circle}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-list/theme/list.css"],
                    names: [],
                    mappings: "AAKA,eACC,uBAiBD,CAfC,kBACC,2BAaD,CAXC,qBACC,2BASD,CAPC,wBACC,2BAKD,CAHC,2BACC,2BACD,CAMJ,eACC,oBAaD,CAXC,kBACC,sBASD,CAJE,6CACC,sBACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content ol {\n\tlist-style-type: decimal;\n\n\t& ol {\n\t\tlist-style-type: lower-latin;\n\n\t\t& ol {\n\t\t\tlist-style-type: lower-roman;\n\n\t\t\t& ol {\n\t\t\t\tlist-style-type: upper-latin;\n\n\t\t\t\t& ol {\n\t\t\t\t\tlist-style-type: upper-roman;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck-content ul {\n\tlist-style-type: disc;\n\n\t& ul {\n\t\tlist-style-type: circle;\n\n\t\t& ul {\n\t\t\tlist-style-type: square;\n\n\t\t\t& ul {\n\t\t\t\tlist-style-type: square;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            6082: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-list-properties.ck-list-properties_without-styles{padding:var(--ck-spacing-large)}.ck.ck-list-properties.ck-list-properties_without-styles>*{min-width:14em}.ck.ck-list-properties.ck-list-properties_without-styles>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-list-styles-list{grid-template-columns:repeat(4,auto)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible{border-top:1px solid var(--ck-color-base-border)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*{width:100%}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties .ck.ck-numbered-list-properties__start-index .ck-input{min-width:auto;width:100%}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order{background:transparent;margin-bottom:calc(var(--ck-spacing-tiny)*-1);padding-left:0;padding-right:0}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:active,.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:hover{background:none;border-color:transparent;box-shadow:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/listproperties.css"],
                    names: [],
                    mappings: "AAOC,yDACC,+BASD,CAPC,2DACC,cAKD,CAHC,6DACC,qCACD,CASD,wFACC,oCACD,CAGA,mFACC,gDAWD,CARE,+GACC,UAKD,CAHC,iHACC,qCACD,CAMJ,8EACC,cAAe,CACf,UACD,CAEA,uEACC,sBAAuB,CAGvB,6CAAgD,CAFhD,cAAe,CACf,eAQD,CALC,2JAGC,eAAgB,CADhB,wBAAyB,CADzB,eAGD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-properties {\n\t/* When there are no list styles and there is no collapsible. */\n\t&.ck-list-properties_without-styles {\n\t\tpadding: var(--ck-spacing-large);\n\n\t\t& > * {\n\t\t\tmin-width: 14em;\n\n\t\t\t& + * {\n\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * When the numbered list property fields (start at, reversed) should be displayed,\n\t * more horizontal space is needed. Reconfigure the style grid to create that space.\n\t */\n\t&.ck-list-properties_with-numbered-properties {\n\t\t& > .ck-list-styles-list {\n\t\t\tgrid-template-columns: repeat( 4, auto );\n\t\t}\n\n\t\t/* When list styles are rendered and property fields are in a collapsible. */\n\t\t& > .ck-collapsible {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t\t\t& > .ck-collapsible__children {\n\t\t\t\t& > * {\n\t\t\t\t\twidth: 100%;\n\n\t\t\t\t\t& + * {\n\t\t\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-numbered-list-properties__start-index .ck-input {\n\t\tmin-width: auto;\n\t\twidth: 100%;\n\t}\n\n\t& .ck.ck-numbered-list-properties__reversed-order {\n\t\tbackground: transparent;\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\t\tmargin-bottom: calc(-1 * var(--ck-spacing-tiny));\n\n\t\t&:active, &:hover {\n\t\t\tbox-shadow: none;\n\t\t\tborder-color: transparent;\n\t\t\tbackground: none;\n\t\t}\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            2417: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-list-styles-list{display:grid}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-list{column-gap:var(--ck-spacing-medium);grid-template-columns:repeat(3,auto);padding:var(--ck-spacing-large);row-gap:var(--ck-spacing-medium)}.ck.ck-list-styles-list .ck-button{box-sizing:content-box;margin:0;padding:0}.ck.ck-list-styles-list .ck-button,.ck.ck-list-styles-list .ck-button .ck-icon{height:var(--ck-list-style-button-size);width:var(--ck-list-style-button-size)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-list/theme/liststyles.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css"],
                    names: [],
                    mappings: "AAKA,wBACC,YACD,CCFA,MACC,gCACD,CAEA,wBAGC,mCAAoC,CAFpC,oCAAwC,CAGxC,+BAAgC,CAFhC,gCA4BD,CAxBC,mCAiBC,sBAAuB,CAPvB,QAAS,CANT,SAmBD,CAJC,+EAhBA,uCAAwC,CADxC,sCAoBA",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-styles-list {\n\tdisplay: grid;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-list-style-button-size: 44px;\n}\n\n.ck.ck-list-styles-list {\n\tgrid-template-columns: repeat( 3, auto );\n\trow-gap: var(--ck-spacing-medium);\n\tcolumn-gap: var(--ck-spacing-medium);\n\tpadding: var(--ck-spacing-large);\n\n\t& .ck-button {\n\t\t/* Make the button look like a thumbnail (the icon "takes it all"). */\n\t\twidth: var(--ck-list-style-button-size);\n\t\theight: var(--ck-list-style-button-size);\n\t\tpadding: 0;\n\n\t\t/*\n\t\t * Buttons are aligned by the grid so disable default button margins to not collide with the\n\t\t * gaps in the grid.\n\t\t */\n\t\tmargin: 0;\n\n\t\t/*\n\t\t * Make sure the button border (which is displayed on focus, BTW) does not steal pixels\n\t\t * from the button dimensions and, as a result, decrease the size of the icon\n\t\t * (which becomes blurry as it scales down).\n\t\t */\n\t\tbox-sizing: content-box;\n\n\t\t& .ck-icon {\n\t\t\twidth: var(--ck-list-style-button-size);\n\t\t\theight: var(--ck-list-style-button-size);\n\t\t}\n\t}\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            1199: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ':root{--ck-todo-list-checkmark-size:16px}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-content .todo-list .todo-list__label>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out,background .25s ease-in-out,border .25s ease-in-out;width:100%}.ck-content .todo-list .todo-list__label>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-content .todo-list .todo-list__label>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-content .todo-list .todo-list__label>input[checked]:after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}[dir=rtl] .todo-list .todo-list__label>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-editor__editable .todo-list .todo-list__label>input{cursor:pointer}.ck-editor__editable .todo-list .todo-list__label>input:hover:before{box-shadow:0 0 0 5px rgba(0,0,0,.1)}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-list/theme/todolist.css"],
                    names: [],
                    mappings: "AAKA,MACC,kCACD,CAEA,uBACC,eA0ED,CAxEC,0BACC,iBAKD,CAHC,qCACC,cACD,CAIA,+CACC,uBAAwB,CAQxB,QAAS,CAPT,oBAAqB,CAGrB,yCAA0C,CAO1C,UAAW,CAGX,aAAc,CAFd,kBAAmB,CAVnB,iBAAkB,CAWlB,OAAQ,CARR,qBAAsB,CAFtB,wCAqDD,CAxCC,sDAOC,qBAAiC,CACjC,iBAAkB,CALlB,qBAAsB,CACtB,UAAW,CAHX,aAAc,CAKd,WAAY,CAJZ,iBAAkB,CAOlB,0FAAgG,CAJhG,UAKD,CAEA,qDAaC,wBAAyB,CADzB,kBAAmB,CAEnB,sGAA+G,CAX/G,sBAAuB,CAEvB,UAAW,CAJX,aAAc,CAUd,mDAAwD,CAHxD,+CAAoD,CAJpD,mBAAoB,CAFpB,iBAAkB,CAOlB,gDAAqD,CAMrD,uBAAwB,CALxB,kDAMD,CAGC,+DACC,kBAA8B,CAC9B,oBACD,CAEA,8DACC,iBACD,CAIF,wEACC,qBACD,CAKF,6CACC,MAAO,CAGP,iBAAkB,CAFlB,cAAe,CACf,WAED,CAMA,wDACC,cAKD,CAHC,qEACC,mCACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-todo-list-checkmark-size: 16px;\n}\n\n.ck-content .todo-list {\n\tlist-style: none;\n\n\t& li {\n\t\tmargin-bottom: 5px;\n\n\t\t& .todo-list {\n\t\t\tmargin-top: 5px;\n\t\t}\n\t}\n\n\t& .todo-list__label {\n\t\t& > input {\n\t\t\t-webkit-appearance: none;\n\t\t\tdisplay: inline-block;\n\t\t\tposition: relative;\n\t\t\twidth: var(--ck-todo-list-checkmark-size);\n\t\t\theight: var(--ck-todo-list-checkmark-size);\n\t\t\tvertical-align: middle;\n\n\t\t\t/* Needed on iOS */\n\t\t\tborder: 0;\n\n\t\t\t/* LTR styles */\n\t\t\tleft: -25px;\n\t\t\tmargin-right: -15px;\n\t\t\tright: 0;\n\t\t\tmargin-left: 0;\n\n\t\t\t&::before {\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tbox-sizing: border-box;\n\t\t\t\tcontent: '';\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t\tborder: 1px solid hsl(0, 0%, 20%);\n\t\t\t\tborder-radius: 2px;\n\t\t\t\ttransition: 250ms ease-in-out box-shadow, 250ms ease-in-out background, 250ms ease-in-out border;\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tbox-sizing: content-box;\n\t\t\t\tpointer-events: none;\n\t\t\t\tcontent: '';\n\n\t\t\t\t/* Calculate tick position, size and border-width proportional to the checkmark size. */\n\t\t\t\tleft: calc( var(--ck-todo-list-checkmark-size) / 3 );\n\t\t\t\ttop: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\n\t\t\t\twidth: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\n\t\t\t\theight: calc( var(--ck-todo-list-checkmark-size) / 2.6 );\n\t\t\t\tborder-style: solid;\n\t\t\t\tborder-color: transparent;\n\t\t\t\tborder-width: 0 calc( var(--ck-todo-list-checkmark-size) / 8 ) calc( var(--ck-todo-list-checkmark-size) / 8 ) 0;\n\t\t\t\ttransform: rotate(45deg);\n\t\t\t}\n\n\t\t\t&[checked] {\n\t\t\t\t&::before {\n\t\t\t\t\tbackground: hsl(126, 64%, 41%);\n\t\t\t\t\tborder-color: hsl(126, 64%, 41%);\n\t\t\t\t}\n\n\t\t\t\t&::after {\n\t\t\t\t\tborder-color: hsl(0, 0%, 100%);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& .todo-list__label__description {\n\t\t\tvertical-align: middle;\n\t\t}\n\t}\n}\n\n/* RTL styles */\n[dir=\"rtl\"] .todo-list .todo-list__label > input {\n\tleft: 0;\n\tmargin-right: 0;\n\tright: -25px;\n\tmargin-left: -15px;\n}\n\n/*\n * To-do list should be interactive only during the editing\n * (https://github.com/ckeditor/ckeditor5/issues/2090).\n */\n.ck-editor__editable .todo-list .todo-list__label > input {\n\tcursor: pointer;\n\n\t&:hover::before {\n\t\tbox-shadow: 0 0 0 5px hsla(0, 0%, 0%, 0.1);\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            7368: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-input-color{display:flex;flex-direction:row-reverse;width:100%}.ck.ck-input-color>input.ck.ck-input-text{flex-grow:1;min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button{display:flex}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{overflow:hidden;position:relative}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{display:block;position:absolute}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-input-color>.ck.ck-input-text:focus{z-index:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-left-radius:0;border-top-left-radius:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-left:1px solid transparent}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-right:1px solid transparent}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border:1px solid var(--ck-color-input-border);height:20px;width:20px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{background:red;border-radius:2px;height:150%;left:50%;top:-30%;transform:rotate(45deg);transform-origin:50%;width:8%}.ck.ck-input-color .ck.ck-input-color__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);width:100%}.ck.ck-input-color .ck.ck-input-color__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-input-border)}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard);margin-right:0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/colorinput.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/colorinput.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAKA,mBAEC,YAAa,CACb,0BAA2B,CAF3B,UAgCD,CA5BC,0CAEC,WAAY,CADZ,cAED,CAEA,sCACC,cAMD,CAHC,kFACC,YACD,CAGD,8CAEC,YAWD,CATC,kFAEC,eAAgB,CADhB,iBAOD,CAJC,0IAEC,aAAc,CADd,iBAED,CC1BF,+CAGE,4BAA6B,CAD7B,yBAcF,CAhBA,+CAQE,2BAA4B,CAD5B,wBASF,CAHC,2CACC,SACD,CAIA,wEACC,SA0CD,CA3CA,kFAKE,2BAA4B,CAD5B,wBAuCF,CApCE,8FACC,iCACD,CATF,kFAcE,4BAA6B,CAD7B,yBA8BF,CA3BE,8FACC,kCACD,CAGD,oFACC,oDACD,CAEA,4GC1CF,eD2DE,CAjBA,+PCtCD,qCDuDC,CAjBA,4GAKC,6CAA8C,CAD9C,WAAY,CADZ,UAcD,CAVC,oKAKC,cAA6B,CAC7B,iBAAkB,CAHlB,WAAY,CADZ,QAAS,CADT,QAAS,CAMT,uBAAwB,CACxB,oBAAqB,CAJrB,QAKD,CAKH,oDAIC,2BAA4B,CAC5B,4BAA6B,CAH7B,qEAAwE,CADxE,UA0BD,CApBC,gEACC,oDACD,CATD,8DAYE,yBAeF,CA3BA,8DAgBE,wBAWF,CARC,gEACC,uCAMD,CAPA,0EAKE,sCAAuC,CADvC,cAGF",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-input-color {\n\twidth: 100%;\n\tdisplay: flex;\n\tflex-direction: row-reverse;\n\n\t& > input.ck.ck-input-text {\n\t\tmin-width: auto;\n\t\tflex-grow: 1;\n\t}\n\n\t& > div.ck.ck-dropdown {\n\t\tmin-width: auto;\n\n\t\t/* This dropdown has no arrow but a color preview instead. */\n\t\t& > .ck-input-color__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck.ck-input-color__button {\n\t\t/* Resolving issue with misaligned buttons on Safari (see #10589) */\n\t\tdisplay: flex;\n\n\t\t& .ck.ck-input-color__button__preview {\n\t\t\tposition: relative;\n\t\t\toverflow: hidden;\n\n\t\t\t& > .ck.ck-input-color__button__preview__no-color-indicator {\n\t\t\t\tposition: absolute;\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_rounded.css";\n\n.ck.ck-input-color {\n\t& > .ck.ck-input-text {\n\t\t@mixin ck-dir ltr {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* Make sure the focused input is always on top of the dropdown button so its\n\t\t   outline and border are never cropped (also when the input is read-only). */\n\t\t&:focus {\n\t\t\tz-index: 0;\n\t\t}\n\t}\n\n\t& > .ck.ck-dropdown {\n\t\t& > .ck.ck-button.ck-input-color__button {\n\t\t\tpadding: 0;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\n\t\t\t\t&:not(:focus) {\n\t\t\t\t\tborder-left: 1px solid transparent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\n\t\t\t\t&:not(:focus) {\n\t\t\t\t\tborder-right: 1px solid transparent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t&.ck-disabled {\n\t\t\t\tbackground: var(--ck-color-input-disabled-background);\n\t\t\t}\n\n\t\t\t& > .ck.ck-input-color__button__preview {\n\t\t\t\t@mixin ck-rounded-corners;\n\n\t\t\t\twidth: 20px;\n\t\t\t\theight: 20px;\n\t\t\t\tborder: 1px solid var(--ck-color-input-border);\n\n\t\t\t\t& > .ck.ck-input-color__button__preview__no-color-indicator {\n\t\t\t\t\ttop: -30%;\n\t\t\t\t\tleft: 50%;\n\t\t\t\t\theight: 150%;\n\t\t\t\t\twidth: 8%;\n\t\t\t\t\tbackground: hsl(0, 100%, 50%);\n\t\t\t\t\tborder-radius: 2px;\n\t\t\t\t\ttransform: rotate(45deg);\n\t\t\t\t\ttransform-origin: 50%;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-input-color__remove-color {\n\t\twidth: 100%;\n\t\tpadding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);\n\n\t\tborder-bottom-left-radius: 0;\n\t\tborder-bottom-right-radius: 0;\n\n\t\t&:not(:focus) {\n\t\t\tborder-bottom: 1px solid var(--ck-color-input-border);\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\tborder-top-right-radius: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tborder-top-left-radius: 0;\n\t\t}\n\n\t\t& .ck.ck-icon {\n\t\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: 0;\n\t\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            4070: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/form.css"],
                    names: [],
                    mappings: "AAKA,YACC,mCAyBD,CAvBC,kBAEC,YACD,CAEA,8BACC,cAAe,CACf,OACD,CAEA,4BACC,cAWD,CARE,6DACC,4CACD,CAEA,mEACC,UACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form {\n\tpadding: 0 0 var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t& .ck.ck-input-text {\n\t\tmin-width: 100%;\n\t\twidth: 0;\n\t}\n\n\t& .ck.ck-dropdown {\n\t\tmin-width: 100%;\n\n\t\t& .ck-dropdown__button {\n\t\t\t&:not(:focus) {\n\t\t\t\tborder: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t& .ck-button__label {\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            9247: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{min-width:100%;width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/formrow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/formrow.css"],
                    names: [],
                    mappings: "AAKA,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAaD,CAVC,iCACC,WACD,CAGC,wHAEC,sBACD,CCbF,iBACC,4DA2BD,CAvBE,6CAEE,mCAMF,CARA,6CAME,oCAEF,CAGD,2BAEC,cAAe,CADf,UAED,CAEA,2CACC,kCAKD,CAHC,wEACC,0BACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\tflex-grow: 1;\n\t}\n\n\t&.ck-table-form__action-row {\n\t\t& .ck-button-save,\n\t\t& .ck-button-cancel {\n\t\t\tjustify-content: center;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-form__row {\n\tpadding: var(--ck-spacing-standard) var(--ck-spacing-large) 0;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\t& + * {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck-label {\n\t\twidth: 100%;\n\t\tmin-width: 100%;\n\t}\n\n\t&.ck-table-form__action-row {\n\t\tmargin-top: var(--ck-spacing-large);\n\n\t\t& .ck-button .ck-button__label {\n\t\t\tcolor: var(--ck-color-text);\n\t\t}\n\t}\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            1613: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/inserttable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css"],
                    names: [],
                    mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,mFAEC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAFlB,iDAAkD,CADlD,qDAAsD,CADtD,mDAAoD,CAKpD,YAAa,CACb,eAUD,CARC,6CACC,eACD,CAEA,6CAEC,6CAA8C,CAD9C,yCAED",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-insert-table-dropdown__grid {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: wrap;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-insert-table-dropdown-padding: 10px;\n\t--ck-insert-table-dropdown-box-height: 11px;\n\t--ck-insert-table-dropdown-box-width: 12px;\n\t--ck-insert-table-dropdown-box-margin: 1px;\n}\n\n.ck .ck-insert-table-dropdown__grid {\n\t/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */\n\twidth: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);\n\tpadding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;\n}\n\n.ck .ck-insert-table-dropdown__label,\n.ck[dir=rtl] .ck-insert-table-dropdown__label {\n\ttext-align: center;\n}\n\n.ck .ck-insert-table-dropdown-grid-box {\n\tmin-width: var(--ck-insert-table-dropdown-box-width);\n\tmin-height: var(--ck-insert-table-dropdown-box-height);\n\tmargin: var(--ck-insert-table-dropdown-box-margin);\n\tborder: 1px solid var(--ck-color-base-border);\n\tborder-radius: 1px;\n\toutline: none;\n\ttransition: none;\n\n\t&:focus {\n\t\tbox-shadow: none;\n\t}\n\n\t&.ck-on {\n\t\tborder-color: var(--ck-color-focus-border);\n\t\tbackground: var(--ck-color-focus-outer-shadow);\n\t}\n}\n\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            6306: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/table.css"],
                    names: [],
                    mappings: "AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .table {\n\t/* Give the table widget some air and center it horizontally */\n\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\tmargin: 0.9em auto;\n\tdisplay: table;\n\n\t& table {\n\t\t/* The table cells should have slight borders */\n\t\tborder-collapse: collapse;\n\t\tborder-spacing: 0;\n\n\t\t/* Table width and height are set on the parent <figure>. Make sure the table inside stretches\n\t\tto the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */\n\t\twidth: 100%;\n\t\theight: 100%;\n\n\t\t/* The outer border of the table should be slightly darker than the inner lines.\n\t\tAlso see https://github.com/ckeditor/ckeditor5-table/issues/50. */\n\t\tborder: 1px double hsl(0, 0%, 70%);\n\n\t\t& td,\n\t\t& th {\n\t\t\tmin-width: 2em;\n\t\t\tpadding: .4em;\n\n\t\t\t/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it\'s not necessary here.\n\t\t\tHowever, the border is a content style, so it should use .ck-content (so it works outside the editor).\n\t\t\tHence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */\n\t\t\tborder: 1px solid hsl(0, 0%, 75%);\n\t\t}\n\n\t\t& th {\n\t\t\tfont-weight: bold;\n\t\t\tbackground: hsla(0, 0%, 0%, 5%);\n\t\t}\n\t}\n}\n\n/* Text alignment of the table header should match the editor settings and override the native browser styling,\nwhen content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */\n.ck-content[dir="rtl"] .table th {\n\ttext-align: right;\n}\n\n.ck-content[dir="ltr"] .table th {\n\ttext-align: left;\n}\n\n.ck-editor__editable .ck-table-bogus-paragraph {\n\t/*\n\t * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.\n\t * See https://github.com/ckeditor/ckeditor5/issues/6062.\n\t */\n\tdisplay: inline-block;\n\n\t/*\n\t * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9117.\n\t */\n\twidth: 100%;\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            2128: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ":root{--ck-color-table-caption-background:#f7f7f7;--ck-color-table-caption-text:#333;--ck-color-table-caption-highlighted-background:#fd0}.ck-content .table>figcaption{background-color:var(--ck-color-table-caption-background);caption-side:top;color:var(--ck-color-table-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;text-align:center;word-break:break-word}.ck.ck-editor__editable .table>figcaption.table__caption_highlighted{animation:ck-table-caption-highlight .6s ease-out}.ck.ck-editor__editable .table>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}@keyframes ck-table-caption-highlight{0%{background-color:var(--ck-color-table-caption-highlighted-background)}to{background-color:var(--ck-color-table-caption-background)}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tablecaption.css"],
                    names: [],
                    mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,oDACD,CAGA,8BAMC,yDAA0D,CAJ1D,gBAAiB,CAGjB,wCAAyC,CAJzC,qBAAsB,CAOtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,iBAAkB,CADlB,qBAOD,CAIC,qEACC,iDACD,CAEA,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAGD,sCACC,GACC,qEACD,CAEA,GACC,yDACD,CACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-table-caption-background: hsl(0, 0%, 97%);\n\t--ck-color-table-caption-text: hsl(0, 0%, 20%);\n\t--ck-color-table-caption-highlighted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .table > figcaption {\n\tdisplay: table-caption;\n\tcaption-side: top;\n\tword-break: break-word;\n\ttext-align: center;\n\tcolor: var(--ck-color-table-caption-text);\n\tbackground-color: var(--ck-color-table-caption-background);\n\tpadding: .6em;\n\tfont-size: .75em;\n\toutline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .table > figcaption {\n\t&.table__caption_highlighted {\n\t\tanimation: ck-table-caption-highlight .6s ease-out;\n\t}\n\n\t&.ck-placeholder::before {\n\t\tpadding-left: inherit;\n\t\tpadding-right: inherit;\n\n\t\t/*\n\t\t * Make sure the table caption placeholder doesn't overflow the placeholder area.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\n\t\t */\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n}\n\n@keyframes ck-table-caption-highlight {\n\t0% {\n\t\tbackground-color: var(--ck-color-table-caption-highlighted-background);\n\t}\n\n\t100% {\n\t\tbackground-color: var(--ck-color-table-caption-background);\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            5087: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:first-of-type{flex-grow:0.57}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:last-of-type{flex-grow:0.43}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar .ck-button{flex-grow:1}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{align-self:flex-end;padding:0;width:25%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tablecellproperties.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tablecellproperties.css"],
                    names: [],
                    mappings: "AAOE,6FACC,cAiBD,CAdE,0HAEC,cACD,CAEA,yHAEC,cACD,CAEA,uHACC,WACD,CClBJ,kCACC,WAkBD,CAfE,2FACC,mBAAoB,CACpB,SAAU,CACV,SACD,CAGC,4GACC,eAAgB,CAGhB,qCACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-cell-properties-form {\n\t& .ck-form__row {\n\t\t&.ck-table-cell-properties-form__alignment-row {\n\t\t\tflex-wrap: wrap;\n\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\t&:first-of-type {\n\t\t\t\t\t/* 4 buttons out of 7 (h-alignment + v-alignment) = 0.57 */\n\t\t\t\t\tflex-grow: 0.57;\n\t\t\t\t}\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\t/* 3 buttons out of 7 (h-alignment + v-alignment) = 0.43 */\n\t\t\t\t\tflex-grow: 0.43;\n\t\t\t\t}\n\n\t\t\t\t& .ck-button {\n\t\t\t\t\tflex-grow: 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-cell-properties-form {\n\twidth: 320px;\n\n\t& .ck-form__row {\n\t\t&.ck-table-cell-properties-form__padding-row {\n\t\t\talign-self: flex-end;\n\t\t\tpadding: 0;\n\t\t\twidth: 25%;\n\t\t}\n\n\t\t&.ck-table-cell-properties-form__alignment-row {\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\tbackground: none;\n\n\t\t\t\t/* Compensate for missing input label that would push the margin (toolbar has no inputs). */\n\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            4101: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ":root{--ck-color-table-column-resizer-hover:var(--ck-color-base-active);--ck-table-column-resizer-width:7px;--ck-table-column-resizer-position-offset:calc(var(--ck-table-column-resizer-width)*-0.5 - 0.5px)}.ck-content .table .ck-table-resized{table-layout:fixed}.ck-content .table table{overflow:hidden}.ck-content .table td,.ck-content .table th{overflow-wrap:break-word;position:relative}.ck.ck-editor__editable .table .ck-table-column-resizer{bottom:-999999px;cursor:col-resize;position:absolute;right:var(--ck-table-column-resizer-position-offset);top:-999999px;user-select:none;width:var(--ck-table-column-resizer-width);z-index:var(--ck-z-default)}.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer,.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer{display:none}.ck.ck-editor__editable .table .ck-table-column-resizer:hover,.ck.ck-editor__editable .table .ck-table-column-resizer__active{background-color:var(--ck-color-table-column-resizer-hover);opacity:.25}.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer{left:var(--ck-table-column-resizer-position-offset);right:unset}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tablecolumnresize.css"],
                    names: [],
                    mappings: "AAKA,MACC,iEAAkE,CAClE,mCAAoC,CAIpC,iGACD,CAEA,qCACC,kBACD,CAEA,yBACC,eACD,CAEA,4CAIC,wBAAyB,CACzB,iBACD,CAEA,wDAOC,gBAAiB,CAGjB,iBAAkB,CATlB,iBAAkB,CAOlB,oDAAqD,CAFrD,aAAc,CAKd,gBAAiB,CAFjB,0CAA2C,CAG3C,2BACD,CAQA,qJACC,YACD,CAEA,8HAEC,2DAA4D,CAC5D,WACD,CAEA,iEACC,mDAAoD,CACpD,WACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-table-column-resizer-hover: var(--ck-color-base-active);\n\t--ck-table-column-resizer-width: 7px;\n\n\t/* The offset used for absolute positioning of the resizer element, so that it is placed exactly above the cell border.\n\t   The value is: minus half the width of the resizer decreased additionaly by the half the width of the border (0.5px). */\n\t--ck-table-column-resizer-position-offset: calc(var(--ck-table-column-resizer-width) * -0.5 - 0.5px);\n}\n\n.ck-content .table .ck-table-resized {\n\ttable-layout: fixed;\n}\n\n.ck-content .table table {\n\toverflow: hidden;\n}\n\n.ck-content .table td,\n.ck-content .table th {\n\t/* To prevent text overflowing beyond its cell when columns are resized by resize handler\n\t(https://github.com/ckeditor/ckeditor5/pull/14379#issuecomment-1589460978). */\n\toverflow-wrap: break-word;\n\tposition: relative;\n}\n\n.ck.ck-editor__editable .table .ck-table-column-resizer {\n\tposition: absolute;\n\t/* The resizer element resides in each cell so to occupy the entire height of the table, which is unknown from a CSS point of view,\n\t   it is extended to an extremely high height. Even for screens with a very high pixel density, the resizer will fulfill its role as\n\t   it should, i.e. for a screen of 476 ppi the total height of the resizer will take over 350 sheets of A4 format, which is totally\n\t   unrealistic height for a single table. */\n\ttop: -999999px;\n\tbottom: -999999px;\n\tright: var(--ck-table-column-resizer-position-offset);\n\twidth: var(--ck-table-column-resizer-width);\n\tcursor: col-resize;\n\tuser-select: none;\n\tz-index: var(--ck-z-default);\n}\n\n.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer {\n\tdisplay: none;\n}\n\n/* The resizer elements, which are extended to an extremely high height, break the drag & drop feature in Chrome. To make it work again,\n   all resizers must be hidden while the table is dragged. */\n.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer {\n\tdisplay: none;\n}\n\n.ck.ck-editor__editable .table .ck-table-column-resizer:hover,\n.ck.ck-editor__editable .table .ck-table-column-resizer__active {\n\tbackground-color: var(--ck-color-table-column-resizer-hover);\n\topacity: 0.25;\n}\n\n.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer {\n\tleft: var(--ck-table-column-resizer-position-offset);\n\tright: unset;\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            3881: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ":root{--ck-color-table-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css"],
                    names: [],
                    mappings: "AAKA,MACC,6DACD,CAKE,8QAGC,wDAAyD,CAKzD,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-table-focused-cell-background: hsla(212, 90%, 80%, .3);\n}\n\n.ck-widget.table {\n\t& td,\n\t& th {\n\t\t&.ck-editor__nested-editable.ck-editor__nested-editable_focused,\n\t\t&.ck-editor__nested-editable:focus {\n\t\t\t/* A very slight background to highlight the focused cell */\n\t\t\tbackground: var(--ck-color-table-focused-cell-background);\n\n\t\t\t/* Fixes the problem where surrounding cells cover the focused cell's border.\n\t\t\tIt does not fix the problem in all places but the UX is improved.\n\t\t\tSee https://github.com/ckeditor/ckeditor5-table/issues/29. */\n\t\t\tborder-style: none;\n\t\t\toutline: 1px solid var(--ck-color-focus-border);\n\t\t\toutline-offset: -1px; /* progressive enhancement - no IE support */\n\t\t}\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            6237: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, '.ck.ck-table-form .ck-form__row.ck-table-form__background-row,.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{align-items:center;flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{align-items:center;display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{bottom:calc(var(--ck-table-properties-error-arrow-size)*-1);left:50%;position:absolute;transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";left:50%;position:absolute;top:calc(var(--ck-table-properties-error-arrow-size)*-1);transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{max-width:80px;min-width:80px;width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:flex-end;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view{padding-top:var(--ck-spacing-standard)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);min-width:var(--ck-table-properties-min-error-width);padding:var(--ck-spacing-small) var(--ck-spacing-medium);text-align:center}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-color:transparent transparent var(--ck-color-base-error) transparent;border-style:solid;border-width:0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tableform.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableform.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAWE,wHACC,cACD,CAEA,8DAEC,kBAAmB,CADnB,cAgBD,CAbC,qFAGC,kBAAmB,CAFnB,YAAa,CACb,6BAMD,CAEA,sMACC,WACD,CAIF,4CAEC,iBAoBD,CAlBC,8EAGC,2DAAgE,CADhE,QAAS,CADT,iBAAkB,CAGlB,8BAA+B,CAG/B,SAUD,CAPC,oFACC,UAAW,CAGX,QAAS,CAFT,iBAAkB,CAClB,wDAA6D,CAE7D,0BACD,CChDH,MACC,0CAA2C,CAC3C,2CACD,CAMI,2FACC,kCAAmC,CACnC,iBACD,CAGD,8KAIC,cAAe,CADf,cAAe,CADf,UAGD,CAGD,8DACC,SAcD,CAZC,yMAEC,QACD,CAEA,iGACC,mBAAoB,CACpB,oBAAqB,CACrB,wCAAyC,CACzC,6CAA8C,CAC9C,gCACD,CAIF,4CACC,sCAyBD,CAvBC,8ECxCD,eDyDC,CAjBA,mMCpCA,qCDqDA,CAjBA,8EAGC,qCAAsC,CACtC,qCAAsC,CAEtC,oDAAqD,CADrD,wDAAyD,CAEzD,iBAUD,CAPC,oFACC,2EAA4E,CAE5E,kBAAmB,CADnB,kJAED,CAdD,8EAgBC,iEACD,CAGA,6GACC,YACD,CAIF,oDACC,GACC,SACD,CAEA,GACC,SACD,CACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-form {\n\t& .ck-form__row {\n\t\t&.ck-table-form__border-row {\n\t\t\tflex-wrap: wrap;\n\t\t}\n\n\t\t&.ck-table-form__background-row {\n\t\t\tflex-wrap: wrap;\n\t\t}\n\n\t\t&.ck-table-form__dimensions-row {\n\t\t\tflex-wrap: wrap;\n\t\t\talign-items: center;\n\n\t\t\t& .ck-labeled-field-view {\n\t\t\t\tdisplay: flex;\n\t\t\t\tflex-direction: column-reverse;\n\t\t\t\talign-items: center;\n\n\t\t\t\t& .ck.ck-dropdown {\n\t\t\t\t\tflex-grow: 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& .ck-table-form__dimension-operator {\n\t\t\t\tflex-grow: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-labeled-field-view {\n\t\t/* Allow absolute positioning of the status (error) balloons. */\n\t\tposition: relative;\n\n\t\t& .ck.ck-labeled-field-view__status {\n\t\t\tposition: absolute;\n\t\t\tleft: 50%;\n\t\t\tbottom: calc( -1 * var(--ck-table-properties-error-arrow-size) );\n\t\t\ttransform: translate(-50%,100%);\n\n\t\t\t/* Make sure the balloon status stays on top of other form elements. */\n\t\t\tz-index: 1;\n\n\t\t\t/* The arrow pointing towards the field. */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: calc( -1 * var(--ck-table-properties-error-arrow-size) );\n\t\t\t\tleft: 50%;\n\t\t\t\ttransform: translateX( -50% );\n\t\t\t}\n\t\t}\n\t}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n:root {\n\t--ck-table-properties-error-arrow-size: 6px;\n\t--ck-table-properties-min-error-width: 150px;\n}\n\n.ck.ck-table-form {\n\t& .ck-form__row {\n\t\t&.ck-table-form__border-row {\n\t\t\t& .ck-labeled-field-view {\n\t\t\t\t& > .ck-label {\n\t\t\t\t\tfont-size: var(--ck-font-size-tiny);\n\t\t\t\t\ttext-align: center;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& .ck-table-form__border-style,\n\t\t\t& .ck-table-form__border-width {\n\t\t\t\twidth: 80px;\n\t\t\t\tmin-width: 80px;\n\t\t\t\tmax-width: 80px;\n\t\t\t}\n\t\t}\n\n\t\t&.ck-table-form__dimensions-row {\n\t\t\tpadding: 0;\n\n\t\t\t& .ck-table-form__dimensions-row__width,\n\t\t\t& .ck-table-form__dimensions-row__height {\n\t\t\t\tmargin: 0\n\t\t\t}\n\n\t\t\t& .ck-table-form__dimension-operator {\n\t\t\t\talign-self: flex-end;\n\t\t\t\tdisplay: inline-block;\n\t\t\t\theight: var(--ck-ui-component-min-height);\n\t\t\t\tline-height: var(--ck-ui-component-min-height);\n\t\t\t\tmargin: 0 var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-labeled-field-view {\n\t\tpadding-top: var(--ck-spacing-standard);\n\n\t\t& .ck.ck-labeled-field-view__status {\n\t\t\t@mixin ck-rounded-corners;\n\n\t\t\tbackground: var(--ck-color-base-error);\n\t\t\tcolor: var(--ck-color-base-background);\n\t\t\tpadding: var(--ck-spacing-small) var(--ck-spacing-medium);\n\t\t\tmin-width: var(--ck-table-properties-min-error-width);\n\t\t\ttext-align: center;\n\n\t\t\t/* The arrow pointing towards the field. */\n\t\t\t&::after {\n\t\t\t\tborder-color: transparent transparent var(--ck-color-base-error) transparent;\n\t\t\t\tborder-width: 0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size);\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\n\t\t\tanimation: ck-table-form-labeled-view-status-appear .15s ease both;\n\t\t}\n\n\t\t/* Hide the error balloon when the field is blurred. Makes the experience much more clear. */\n\t\t& .ck-input.ck-error:not(:focus) + .ck.ck-labeled-field-view__status {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n@keyframes ck-table-form-labeled-view-status-appear {\n\t0% {\n\t\topacity: 0;\n\t}\n\n\t100% {\n\t\topacity: 1;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            7341: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-content:baseline;flex-basis:0;flex-wrap:wrap}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-self:flex-end;padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tableproperties.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableproperties.css"],
                    names: [],
                    mappings: "AAOE,mFAGC,sBAAuB,CADvB,YAAa,CADb,cAOD,CAHC,qHACC,gBACD,CCTH,6BACC,WAmBD,CAhBE,mFACC,mBAAoB,CACpB,SAYD,CAVC,kGACC,eAAgB,CAGhB,qCAKD,CAHC,uHACC,UACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-properties-form {\n\t& .ck-form__row {\n\t\t&.ck-table-properties-form__alignment-row {\n\t\t\tflex-wrap: wrap;\n\t\t\tflex-basis: 0;\n\t\t\talign-content: baseline;\n\n\t\t\t& .ck.ck-toolbar .ck-toolbar__items {\n\t\t\t\tflex-wrap: nowrap;\n\t\t\t}\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-properties-form {\n\twidth: 320px;\n\n\t& .ck-form__row {\n\t\t&.ck-table-properties-form__alignment-row {\n\t\t\talign-self: flex-end;\n\t\t\tpadding: 0;\n\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\tbackground: none;\n\n\t\t\t\t/* Compensate for missing input label that would push the margin (toolbar has no inputs). */\n\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\n\t\t\t\t& .ck-toolbar__items > * {\n\t\t\t\t\twidth: 40px;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            6945: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css"],
                    names: [],
                    mappings: "AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck.ck-editor__editable .table table {\n\t& td.ck-editor__editable_selected,\n\t& th.ck-editor__editable_selected {\n\t\tposition: relative;\n\t\tcaret-color: transparent;\n\t\toutline: unset;\n\t\tbox-shadow: unset;\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/6446 */\n\t\t&:after {\n\t\t\tcontent: '';\n\t\t\tpointer-events: none;\n\t\t\tbackground-color: var(--ck-table-selected-cell-background);\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t& ::selection,\n\t\t&:focus {\n\t\t\tbackground-color: transparent;\n\t\t}\n\n\t\t/*\n\t\t * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9491.\n\t\t */\n\t\t& .ck-widget {\n\t\t\toutline: unset;\n\n\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            4906: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/button/button.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"],
                    names: [],
                    mappings: "AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\n\t\tcolor: var(--ck-color-button-on-color);\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            5332: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"],
                    names: [],
                    mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2px /* Border */\n\t);\n\t--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t/* Unlike a regular button, the switch button text color and background should never change.\n\t * Changing toggle switch (background, outline) is enough to carry the information about the\n\t * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)\n\t */\n\t&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {\n\t\tcolor: inherit;\n\t\tbackground: transparent;\n\t}\n\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Apply some smooth transition to the box-shadow and border. */\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\n\t\tborder: 1px solid transparent;\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: var(--ck-switch-button-inner-hover-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t/* Overriding default .ck-button:focus styles + an outline around the toogle */\n\t&:focus {\n\t\tborder-color: transparent;\n\t\toutline: none;\n\t\tbox-shadow: none;\n\n\t\t& .ck-button__toggle {\n\t\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\n\t\t\toutline-offset: 1px;\n\t\t\toutline: var(--ck-focus-ring);\n\t\t}\n\t}\n\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-on {\n\t\t& .ck-button__toggle {\n\t\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t\t&:hover {\n\t\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t\t}\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\t/*\n\t\t\t\t* Move the toggle switch to the right. It will be animated.\n\t\t\t\t*/\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            6781: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"],
                    names: [],
                    mappings: "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-table__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            3398: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".color-picker-hex-input{width:max-content}.color-picker-hex-input .ck.ck-input{min-width:unset}.ck.ck-color-picker__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-color-picker__row .ck-color-picker__hash-view{padding-right:var(--ck-spacing-medium);padding-top:var(--ck-spacing-tiny)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/colorpicker/colorpicker.css"],
                    names: [],
                    mappings: "AAKA,wBACC,iBAKD,CAHC,qCACC,eACD,CAGD,yBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAMD,CAJC,qDAEC,sCAAuC,CADvC,kCAED",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.color-picker-hex-input {\n\twidth: max-content;\n\n\t& .ck.ck-input {\n\t\tmin-width: unset;\n\t}\n}\n\n.ck.ck-color-picker__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\n\t& .ck-color-picker__hash-view {\n\t\tpadding-top: var(--ck-spacing-tiny);\n\t\tpadding-right: var(--ck-spacing-medium);\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            5485: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\t}\n\n\t& .ck-dropdown__panel {\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\t\tmax-width: var(--ck-dropdown-max-width);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_n,\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_nme {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw,\n\t\t&.ck-dropdown__panel_smw,\n\t\t&.ck-dropdown__panel_sme,\n\t\t&.ck-dropdown__panel_s {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_s,\n\t\t&.ck-dropdown__panel_n {\n\t\t\t/* Positioning panels relative to the center of the button */\n\t\t\tleft: 50%;\n\t\t\ttransform: translateX(-50%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_smw {\n\t\t\t/* Positioning panels relative to the middle-west of the button */\n\t\t\tleft: 75%;\n\t\t\ttransform: translateX(-75%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nme,\n\t\t&.ck-dropdown__panel_sme {\n\t\t\t/* Positioning panels relative to the middle-east of the button */\n\t\t\tleft: 25%;\n\t\t\ttransform: translateX(-25%);\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\n\t\t&.ck-off:active,\n\t\t&.ck-on:active {\n\t\t\tbox-shadow: none;\n\t\t\t\n\t\t\t&:focus {\n\t\t\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            3949: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            7686: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n}\n\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t&:hover > .ck-splitbutton__action,\n\t&.ck-splitbutton_open > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* Make sure the divider stretches 100% height of the button\n\thttps://github.com/ckeditor/ckeditor5/issues/10936 */\n\t& > .ck-splitbutton__arrow:not(:focus) {\n\t\tborder-top-width: 0px;\n\t\tborder-bottom-width: 0px;\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t/* Splitbutton separator needs to be set with the ::after pseudoselector\n\t\tto display properly the borders on focus */\n\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\tcontent: \'\';\n\t\t\tposition: absolute;\n\t\t\twidth: 1px;\n\t\t\theight: 100%;\n\t\t\tbackground-color: var(--ck-color-split-button-hover-border);\n\t\t}\n\n\t\t/* Make sure the divider between the buttons looks fine when the button is focused */\n\t\t& > .ck-splitbutton__arrow:focus::after {\n\t\t\t--ck-color-split-button-hover-border: var(--ck-color-focus-border);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tleft: -1px;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tright: -1px;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            7339: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"],
                    names: [],
                    mappings: "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\twidth: max-content;\n\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t& .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            9688: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\t/*\n\t\t * This value should match with the default margins of the block elements (like .media or .image)\n\t\t * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n\t\t */\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-base-foreground);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-base-foreground);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            8847: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/formheader/formheader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"],
                    names: [],
                    mappings: "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BACD,CCNA,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            6574: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/icon/icon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"],
                    names: [],
                    mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\t}\n\n\t/* Allows dynamic coloring of an icon by inheriting its color from the parent. */\n\t&.ck-icon_inherit-color {\n\t\tcolor: inherit;\n\n\t\t& * {\n\t\t\tcolor: inherit;\n\n\t\t\t&:not([fill]) {\n\t\t\t\t/* Needed by FF. */\n\t\t\t\tfill: currentColor;\n\t\t\t}\n\t\t}\n\t}\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            4879: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-width: 18em;\n\n\t/* Backward compatibility. */\n\t--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            3662: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/label/label.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"],
                    names: [],
                    mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            2577: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\t\t\ttransform-origin: 0 0;\n\n\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            1046: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/list/list.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-switchbutton):not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            8793: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-border-width: 1px;\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t\tmargin-top: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t\tmargin-bottom: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_e"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-border);\n\t\t\tmargin-right: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-background);\n\t\t\tmargin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_w"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent var(--ck-color-panel-border) transparent transparent;\n\t\t\tmargin-left: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent var(--ck-color-panel-background) transparent transparent;\n\t\t\tmargin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_e {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_w {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            4650: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"],
                    names: [],
                    mappings: "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            7676: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            5868: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            6764: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"],
                    names: [],
                    mappings: "AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button {\n\t&::after {\n\t\tcontent: "";\n\t\twidth: 0;\n\t\tposition: absolute;\n\t\tright: -1px;\n\t\ttop: -1px;\n\t\tbottom: -1px;\n\t\tz-index: 1;\n\t}\n\n\t&:focus::after {\n\t\tdisplay: none;\n\t}\n}\n\n.ck.ck-responsive-form {\n\t@mixin ck-media-phone {\n\t\t& .ck-button {\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: -1px;\n\t\t\t\ttop: -1px;\n\t\t\t\tbottom: -1px;\n\t\t\t\tz-index: 1;\n\t\t\t}\n\n\t\t\t&:focus::after {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n\tborder-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n\tpadding: var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\t\twidth: calc(.8 * var(--ck-input-width));\n\n\t\t& .ck-labeled-field-view {\n\t\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t/* Let the long error messages wrap in the narrow form. */\n\t\t\t& .ck-labeled-field-view__error {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\t\t}\n\n\t\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\t&::after {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button:nth-last-child(1),\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-large);\n\t\t\tborder-radius: 0;\n\n\t\t\t&:not(:focus) {\n\t\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            9695: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/blocktoolbar.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css"],
                    names: [],
                    mappings: "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n\tposition: absolute;\n\tz-index: var(--ck-z-default);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-block-toolbar-button: var(--ck-color-text);\n\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n\tcolor: var(--ck-color-block-toolbar-button);\n\tfont-size: var(--ck-block-toolbar-size);\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            5542: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck.ck-toolbar:focus{outline:none}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDwGD,CA3GA,qECOE,qCDoGF,CA3GA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAuGD,CApGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAGD,qBACC,YACD,CAtGD,qCAyGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t/* A drop-down containing the nested toolbar with configured items. */\n\t& .ck-toolbar__nested-toolbar-dropdown {\n\t\t/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */\n\t\t& > .ck-dropdown__panel {\n\t\t\tmin-width: auto;\n\t\t}\n\n\t\t& > .ck-button > .ck-button__label {\n\t\t\tmax-width: 7em;\n\t\t\twidth: auto;\n\t\t}\n\t}\n\n\t&:focus {\n\t\toutline: none;\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            3332: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css"],
                    names: [],
                    mappings: "AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDPnC,mBAAoB,CAEpB,qCACD,CCMC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAbD,gCAgBC,eAMD,CAHC,uCACC,YACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t/* Keep tooltips transparent for any interactions. */\n\tpointer-events: none;\n\n\tz-index: calc( var(--ck-z-modal) + 100 );\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t--ck-balloon-border-width: 0px;\n\t--ck-balloon-arrow-offset: 0px;\n\t--ck-balloon-arrow-half-width: 4px;\n\t--ck-balloon-arrow-height: 4px;\n\t--ck-color-panel-background: var(--ck-color-tooltip-background);\n\n\tpadding: 0 var(--ck-spacing-medium);\n\n\t& .ck-tooltip__text {\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t}\n\n\t/* Reset balloon panel styles */\n\tbox-shadow: none;\n\n\t/* Hide the default shadow of the .ck-balloon-panel tip */\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            4793: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-powered-by-line-height:10px;--ck-powered-by-padding-vertical:2px;--ck-powered-by-padding-horizontal:4px;--ck-powered-by-text-color:#4f4f4f;--ck-powered-by-border-radius:var(--ck-border-radius);--ck-powered-by-background:#fff;--ck-powered-by-border-color:var(--ck-color-focus-border)}.ck.ck-balloon-panel.ck-powered-by-balloon{--ck-border-radius:var(--ck-powered-by-border-radius);background:var(--ck-powered-by-background);box-shadow:none;min-height:unset;z-index:calc(var(--ck-z-modal) - 1)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by{line-height:var(--ck-powered-by-line-height)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by a{align-items:center;cursor:pointer;display:flex;filter:grayscale(80%);line-height:var(--ck-powered-by-line-height);opacity:.66;padding:var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-powered-by__label{color:var(--ck-powered-by-text-color);cursor:pointer;font-size:7.5px;font-weight:700;letter-spacing:-.2px;line-height:normal;margin-right:4px;padding-left:2px;text-transform:uppercase}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-icon{cursor:pointer;display:block}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by:hover a{filter:grayscale(0);opacity:1}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_inside]{border-color:transparent}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_border]{border:var(--ck-focus-ring);border-color:var(--ck-powered-by-border-color)}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/globals/_hidden.css", "webpack://./../ckeditor5-ui/theme/globals/_reset.css", "webpack://./../ckeditor5-ui/theme/globals/_zindex.css", "webpack://./../ckeditor5-ui/theme/globals/_transition.css", "webpack://./../ckeditor5-ui/theme/globals/_poweredby.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"],
                    names: [],
                    mappings: "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,gCAAiC,CACjC,oCAAqC,CACrC,sCAAuC,CACvC,kCAA2C,CAC3C,qDAAsD,CACtD,+BAA4C,CAC5C,yDACD,CAEA,2CACC,qDAAsD,CAGtD,0CAA2C,CAD3C,eAAgB,CAEhB,gBAAiB,CACjB,mCAiDD,CA/CC,6DACC,4CAoCD,CAlCC,+DAGC,kBAAmB,CAFnB,cAAe,CACf,YAAa,CAGb,qBAAsB,CACtB,4CAA6C,CAF7C,WAAY,CAGZ,qFACD,CAEA,mFASC,qCAAsC,CAFtC,cAAe,CANf,eAAgB,CAIhB,eAAiB,CAHjB,oBAAqB,CAMrB,kBAAmB,CAFnB,gBAAiB,CAHjB,gBAAiB,CACjB,wBAOD,CAEA,sEAEC,cAAe,CADf,aAED,CAGC,qEACC,mBAAqB,CACrB,SACD,CAIF,mEACC,wBACD,CAEA,mEACC,2BAA4B,CAC5B,8CACD,CChED,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-powered-by-line-height: 10px;\n\t--ck-powered-by-padding-vertical: 2px;\n\t--ck-powered-by-padding-horizontal: 4px;\n\t--ck-powered-by-text-color: hsl(0, 0%, 31%);\n\t--ck-powered-by-border-radius: var(--ck-border-radius);\n\t--ck-powered-by-background: hsl(0, 0%, 100%);\n\t--ck-powered-by-border-color: var(--ck-color-focus-border);\n}\n\n.ck.ck-balloon-panel.ck-powered-by-balloon {\n\t--ck-border-radius: var(--ck-powered-by-border-radius);\n\n\tbox-shadow: none;\n\tbackground: var(--ck-powered-by-background);\n\tmin-height: unset;\n\tz-index: calc( var(--ck-z-modal) - 1 );\n\n\t& .ck.ck-powered-by {\n\t\tline-height: var(--ck-powered-by-line-height);\n\n\t\t& a {\n\t\t\tcursor: pointer;\n\t\t\tdisplay: flex;\n\t\t\talign-items: center;\n\t\t\topacity: .66;\n\t\t\tfilter: grayscale(80%);\n\t\t\tline-height: var(--ck-powered-by-line-height);\n\t\t\tpadding: var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal);\n\t\t}\n\n\t\t& .ck-powered-by__label {\n\t\t\tfont-size: 7.5px;\n\t\t\tletter-spacing: -.2px;\n\t\t\tpadding-left: 2px;\n\t\t\ttext-transform: uppercase;\n\t\t\tfont-weight: bold;\n\t\t\tmargin-right: 4px;\n\t\t\tcursor: pointer;\n\t\t\tline-height: normal;\n\t\t\tcolor: var(--ck-powered-by-text-color);\n\n\t\t}\n\n\t\t& .ck-icon {\n\t\t\tdisplay: block;\n\t\t\tcursor: pointer;\n\t\t}\n\n\t\t&:hover {\n\t\t\t& a {\n\t\t\t\tfilter: grayscale(0%);\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[class*="position_inside"] {\n\t\tborder-color: transparent;\n\t}\n\n\t&[class*="position_border"] {\n\t\tborder: var(--ck-focus-ring);\n\t\tborder-color: var(--ck-powered-by-border-color);\n\t}\n}\n\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(220, 6%, 81%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 50.2%, 42.5%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(218.2, 100%, 52.5%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t218, 81.8%, 56.9%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(212.4, 89.3%, 89%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(212, 100%, 97.1%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(211, 15%, 95%);\n\t--ck-color-button-on-color:\t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 57.6%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 49%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n\n\t/* -- Search result highlight ---------------------------------------------------------------- */\n\n\t--ck-color-highlight-background:\t\t\t\t\t\t\thsl(60, 100%, 50%)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck-reset_all {\n\t& .ck-rtl *:not(.ck-reset_all-excluded *) {\n\t\ttext-align: right;\n\t}\n\n\t& iframe:not(.ck-reset_all-excluded *) {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *) {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *),\n\t& input[type="text"]:not(.ck-reset_all-excluded *),\n\t& input[type="password"]:not(.ck-reset_all-excluded *) {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n\t\tcursor: default;\n\t}\n\n\t& fieldset:not(.ck-reset_all-excluded *) {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            3488: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-widget/theme/widget.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n\t--ck-resizer-border-radius: var(--ck-border-radius);\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n\n\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: 0 var(--ck-spacing-small);\n\theight: var(--ck-resizer-tooltip-height);\n\tline-height: var(--ck-resizer-tooltip-height);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left,\n\t&.ck-orientation-above-center {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t/* Class applied if the widget is too small to contain the size label */\n\t&.ck-orientation-above-center {\n\t\ttop: calc(var(--ck-resizer-tooltip-height) * -1);\n\t\tleft: 50%;\n\t\ttransform: translate(-50%);\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\t\ttop: 0;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& > .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& > .ck-widget__selection-handle,\n\t\t\t& > .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            8506: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-widget/theme/widgetresize.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css"],
                    names: [],
                    mappings: "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD",
                    sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\t&.ck-widget__resizer__handle-top-left,\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right,\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tcursor: nesw-resize;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-resizer-size: 10px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\t--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n}\n"],
                    sourceRoot: ""
                }]);
                const a = s
            },
            4921: (t, e, n) => {
                "use strict";
                n.d(e, {
                    Z: () => a
                });
                var o = n(1799),
                    i = n.n(o),
                    r = n(2609),
                    s = n.n(r)()(i());
                s.push([t.id, '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-widget/theme/widgettypearound.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"],
                    names: [],
                    mappings: "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD",
                    sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n'],
                    sourceRoot: ""
                }]);
                const a = s
            },
            2609: t => {
                "use strict";
                t.exports = function(t) {
                    var e = [];
                    return e.toString = function() {
                        return this.map((function(e) {
                            var n = t(e);
                            return e[2] ? "@media ".concat(e[2], " {").concat(n, "}") : n
                        })).join("")
                    }, e.i = function(t, n, o) {
                        "string" == typeof t && (t = [
                            [null, t, ""]
                        ]);
                        var i = {};
                        if (o)
                            for (var r = 0; r < this.length; r++) {
                                var s = this[r][0];
                                null != s && (i[s] = !0)
                            }
                        for (var a = 0; a < t.length; a++) {
                            var l = [].concat(t[a]);
                            o && i[l[0]] || (n && (l[2] ? l[2] = "".concat(n, " and ").concat(l[2]) : l[2] = n), e.push(l))
                        }
                    }, e
                }
            },
            1799: t => {
                "use strict";

                function e(t, e) {
                    return function(t) {
                        if (Array.isArray(t)) return t
                    }(t) || function(t, e) {
                        var n = t && ("undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]);
                        if (null == n) return;
                        var o, i, r = [],
                            s = !0,
                            a = !1;
                        try {
                            for (n = n.call(t); !(s = (o = n.next()).done) && (r.push(o.value), !e || r.length !== e); s = !0);
                        } catch (t) {
                            a = !0, i = t
                        } finally {
                            try {
                                s || null == n.return || n.return()
                            } finally {
                                if (a) throw i
                            }
                        }
                        return r
                    }(t, e) || function(t, e) {
                        if (!t) return;
                        if ("string" == typeof t) return n(t, e);
                        var o = Object.prototype.toString.call(t).slice(8, -1);
                        "Object" === o && t.constructor && (o = t.constructor.name);
                        if ("Map" === o || "Set" === o) return Array.from(t);
                        if ("Arguments" === o || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)) return n(t, e)
                    }(t, e) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function n(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
                    return o
                }
                t.exports = function(t) {
                    var n = e(t, 4),
                        o = n[1],
                        i = n[3];
                    if (!i) return o;
                    if ("function" == typeof btoa) {
                        var r = btoa(unescape(encodeURIComponent(JSON.stringify(i)))),
                            s = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(r),
                            a = "/*# ".concat(s, " */"),
                            l = i.sources.map((function(t) {
                                return "/*# sourceURL=".concat(i.sourceRoot || "").concat(t, " */")
                            }));
                        return [o].concat(l).concat([a]).join("\n")
                    }
                    return [o].join("\n")
                }
            },
            6062: (t, e, n) => {
                "use strict";
                var o, i = function() {
                        return void 0 === o && (o = Boolean(window && document && document.all && !window.atob)), o
                    },
                    r = function() {
                        var t = {};
                        return function(e) {
                            if (void 0 === t[e]) {
                                var n = document.querySelector(e);
                                if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement) try {
                                    n = n.contentDocument.head
                                } catch (t) {
                                    n = null
                                }
                                t[e] = n
                            }
                            return t[e]
                        }
                    }(),
                    s = [];

                function a(t) {
                    for (var e = -1, n = 0; n < s.length; n++)
                        if (s[n].identifier === t) {
                            e = n;
                            break
                        } return e
                }

                function l(t, e) {
                    for (var n = {}, o = [], i = 0; i < t.length; i++) {
                        var r = t[i],
                            l = e.base ? r[0] + e.base : r[0],
                            c = n[l] || 0,
                            d = "".concat(l, " ").concat(c);
                        n[l] = c + 1;
                        var h = a(d),
                            u = {
                                css: r[1],
                                media: r[2],
                                sourceMap: r[3]
                            }; - 1 !== h ? (s[h].references++, s[h].updater(u)) : s.push({
                            identifier: d,
                            updater: f(u, e),
                            references: 1
                        }), o.push(d)
                    }
                    return o
                }

                function c(t) {
                    var e = document.createElement("style"),
                        o = t.attributes || {};
                    if (void 0 === o.nonce) {
                        var i = n.nc;
                        i && (o.nonce = i)
                    }
                    if (Object.keys(o).forEach((function(t) {
                            e.setAttribute(t, o[t])
                        })), "function" == typeof t.insert) t.insert(e);
                    else {
                        var s = r(t.insert || "head");
                        if (!s) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                        s.appendChild(e)
                    }
                    return e
                }
                var d, h = (d = [], function(t, e) {
                    return d[t] = e, d.filter(Boolean).join("\n")
                });

                function u(t, e, n, o) {
                    var i = n ? "" : o.media ? "@media ".concat(o.media, " {").concat(o.css, "}") : o.css;
                    if (t.styleSheet) t.styleSheet.cssText = h(e, i);
                    else {
                        var r = document.createTextNode(i),
                            s = t.childNodes;
                        s[e] && t.removeChild(s[e]), s.length ? t.insertBefore(r, s[e]) : t.appendChild(r)
                    }
                }

                function g(t, e, n) {
                    var o = n.css,
                        i = n.media,
                        r = n.sourceMap;
                    if (i ? t.setAttribute("media", i) : t.removeAttribute("media"), r && "undefined" != typeof btoa && (o += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r)))), " */")), t.styleSheet) t.styleSheet.cssText = o;
                    else {
                        for (; t.firstChild;) t.removeChild(t.firstChild);
                        t.appendChild(document.createTextNode(o))
                    }
                }
                var m = null,
                    p = 0;

                function f(t, e) {
                    var n, o, i;
                    if (e.singleton) {
                        var r = p++;
                        n = m || (m = c(e)), o = u.bind(null, n, r, !1), i = u.bind(null, n, r, !0)
                    } else n = c(e), o = g.bind(null, n, e), i = function() {
                        ! function(t) {
                            if (null === t.parentNode) return !1;
                            t.parentNode.removeChild(t)
                        }(n)
                    };
                    return o(t),
                        function(e) {
                            if (e) {
                                if (e.css === t.css && e.media === t.media && e.sourceMap === t.sourceMap) return;
                                o(t = e)
                            } else i()
                        }
                }
                t.exports = function(t, e) {
                    (e = e || {}).singleton || "boolean" == typeof e.singleton || (e.singleton = i());
                    var n = l(t = t || [], e);
                    return function(t) {
                        if (t = t || [], "[object Array]" === Object.prototype.toString.call(t)) {
                            for (var o = 0; o < n.length; o++) {
                                var i = a(n[o]);
                                s[i].references--
                            }
                            for (var r = l(t, e), c = 0; c < n.length; c++) {
                                var d = a(n[c]);
                                0 === s[d].references && (s[d].updater(), s.splice(d, 1))
                            }
                            n = r
                        }
                    }
                }
            }
        },
        e = {};

    function n(o) {
        var i = e[o];
        if (void 0 !== i) return i.exports;
        var r = e[o] = {
            id: o,
            exports: {}
        };
        return t[o](r, r.exports, n), r.exports
    }
    n.n = t => {
        var e = t && t.__esModule ? () => t.default : () => t;
        return n.d(e, {
            a: e
        }), e
    }, n.d = (t, e) => {
        for (var o in e) n.o(e, o) && !n.o(t, o) && Object.defineProperty(t, o, {
            enumerable: !0,
            get: e[o]
        })
    }, n.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (t) {
            if ("object" == typeof window) return window
        }
    }(), n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), n.nc = void 0;
    var o = {};
    return (() => {
        "use strict";
        n.d(o, {
            default: () => xP
        });
        const t = function() {
            try {
                return navigator.userAgent.toLowerCase()
            } catch (t) {
                return ""
            }
        }();
        var e;
        const i = {
            isMac: r(t),
            isWindows: (e = t, e.indexOf("windows") > -1),
            isGecko: function(t) {
                return !!t.match(/gecko\/\d+/)
            }(t),
            isSafari: function(t) {
                return t.indexOf(" applewebkit/") > -1 && -1 === t.indexOf("chrome")
            }(t),
            isiOS: function(t) {
                return !!t.match(/iphone|ipad/i) || r(t) && navigator.maxTouchPoints > 0
            }(t),
            isAndroid: function(t) {
                return t.indexOf("android") > -1
            }(t),
            isBlink: function(t) {
                return t.indexOf("chrome/") > -1 && t.indexOf("edge/") < 0
            }(t),
            features: {
                isRegExpUnicodePropertySupported: function() {
                    let t = !1;
                    try {
                        t = 0 === "ć".search(new RegExp("[\\p{L}]", "u"))
                    } catch (t) {}
                    return t
                }()
            }
        };

        function r(t) {
            return t.indexOf("macintosh") > -1
        }

        function s(t, e, n, o) {
            n = n || function(t, e) {
                return t === e
            };
            const i = Array.isArray(t) ? t : Array.prototype.slice.call(t),
                r = Array.isArray(e) ? e : Array.prototype.slice.call(e),
                s = function(t, e, n) {
                    const o = a(t, e, n);
                    if (-1 === o) return {
                        firstIndex: -1,
                        lastIndexOld: -1,
                        lastIndexNew: -1
                    };
                    const i = l(t, o),
                        r = l(e, o),
                        s = a(i, r, n),
                        c = t.length - s,
                        d = e.length - s;
                    return {
                        firstIndex: o,
                        lastIndexOld: c,
                        lastIndexNew: d
                    }
                }(i, r, n),
                c = o ? function(t, e) {
                    const {
                        firstIndex: n,
                        lastIndexOld: o,
                        lastIndexNew: i
                    } = t;
                    if (-1 === n) return Array(e).fill("equal");
                    let r = [];
                    n > 0 && (r = r.concat(Array(n).fill("equal")));
                    i - n > 0 && (r = r.concat(Array(i - n).fill("insert")));
                    o - n > 0 && (r = r.concat(Array(o - n).fill("delete")));
                    i < e && (r = r.concat(Array(e - i).fill("equal")));
                    return r
                }(s, r.length) : function(t, e) {
                    const n = [],
                        {
                            firstIndex: o,
                            lastIndexOld: i,
                            lastIndexNew: r
                        } = e;
                    r - o > 0 && n.push({
                        index: o,
                        type: "insert",
                        values: t.slice(o, r)
                    });
                    i - o > 0 && n.push({
                        index: o + (r - o),
                        type: "delete",
                        howMany: i - o
                    });
                    return n
                }(r, s);
            return c
        }

        function a(t, e, n) {
            for (let o = 0; o < Math.max(t.length, e.length); o++)
                if (void 0 === t[o] || void 0 === e[o] || !n(t[o], e[o])) return o;
            return -1
        }

        function l(t, e) {
            return t.slice(e).reverse()
        }

        function c(t, e, n) {
            n = n || function(t, e) {
                return t === e
            };
            const o = t.length,
                i = e.length;
            if (o > 200 || i > 200 || o + i > 300) return c.fastDiff(t, e, n, !0);
            let r, s;
            if (i < o) {
                const n = t;
                t = e, e = n, r = "delete", s = "insert"
            } else r = "insert", s = "delete";
            const a = t.length,
                l = e.length,
                d = l - a,
                h = {},
                u = {};

            function g(o) {
                const i = (void 0 !== u[o - 1] ? u[o - 1] : -1) + 1,
                    c = void 0 !== u[o + 1] ? u[o + 1] : -1,
                    d = i > c ? -1 : 1;
                h[o + d] && (h[o] = h[o + d].slice(0)), h[o] || (h[o] = []), h[o].push(i > c ? r : s);
                let g = Math.max(i, c),
                    m = g - o;
                for (; m < a && g < l && n(t[m], e[g]);) m++, g++, h[o].push("equal");
                return g
            }
            let m, p = 0;
            do {
                for (m = -p; m < d; m++) u[m] = g(m);
                for (m = d + p; m > d; m--) u[m] = g(m);
                u[d] = g(d), p++
            } while (u[d] !== l);
            return h[d].slice(1)
        }
        c.fastDiff = s;
        const d = function() {
            return function t() {
                t.called = !0
            }
        };
        class h {
            constructor(t, e) {
                this.source = t, this.name = e, this.path = [], this.stop = d(), this.off = d()
            }
        }
        const u = new Array(256).fill("").map(((t, e) => ("0" + e.toString(16)).slice(-2)));

        function g() {
            const t = 4294967296 * Math.random() >>> 0,
                e = 4294967296 * Math.random() >>> 0,
                n = 4294967296 * Math.random() >>> 0,
                o = 4294967296 * Math.random() >>> 0;
            return "e" + u[t >> 0 & 255] + u[t >> 8 & 255] + u[t >> 16 & 255] + u[t >> 24 & 255] + u[e >> 0 & 255] + u[e >> 8 & 255] + u[e >> 16 & 255] + u[e >> 24 & 255] + u[n >> 0 & 255] + u[n >> 8 & 255] + u[n >> 16 & 255] + u[n >> 24 & 255] + u[o >> 0 & 255] + u[o >> 8 & 255] + u[o >> 16 & 255] + u[o >> 24 & 255]
        }
        const m = {
            get(t = "normal") {
                return "number" != typeof t ? this[t] || this.normal : t
            },
            highest: 1e5,
            high: 1e3,
            normal: 0,
            low: -1e3,
            lowest: -1e5
        };

        function p(t, e) {
            const n = m.get(e.priority);
            for (let o = 0; o < t.length; o++)
                if (m.get(t[o].priority) < n) return void t.splice(o, 0, e);
            t.push(e)
        }
        const f = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
        class b extends Error {
            constructor(t, e, n) {
                super(function(t, e) {
                    const n = new WeakSet,
                        o = (t, e) => {
                            if ("object" == typeof e && null !== e) {
                                if (n.has(e)) return `[object ${e.constructor.name}]`;
                                n.add(e)
                            }
                            return e
                        },
                        i = e ? ` ${JSON.stringify(e,o)}` : "",
                        r = w(t);
                    return t + i + r
                }(t, n)), this.name = "CKEditorError", this.context = e, this.data = n
            }
            is(t) {
                return "CKEditorError" === t
            }
            static rethrowUnexpectedError(t, e) {
                if (t.is && t.is("CKEditorError")) throw t;
                const n = new b(t.message, e);
                throw n.stack = t.stack, n
            }
        }

        function k(t, e) {
            console.warn(...A(t, e))
        }

        function w(t) {
            return `\nRead more: ${f}#error-${t}`
        }

        function A(t, e) {
            const n = w(t);
            return e ? [t, e, n] : [t, n]
        }
        const C = "38.1.1",
            _ = new Date(2023, 6, 11),
            v = "object" == typeof window ? window : n.g;
        if (v.CKEDITOR_VERSION) throw new b("ckeditor-duplicated-modules", null);
        v.CKEDITOR_VERSION = C;
        const y = Symbol("listeningTo"),
            x = Symbol("emitterId"),
            E = Symbol("delegations"),
            D = S(Object);

        function S(t) {
            if (!t) return D;
            return class extends t {
                on(t, e, n) {
                    this.listenTo(this, t, e, n)
                }
                once(t, e, n) {
                    let o = !1;
                    this.listenTo(this, t, ((t, ...n) => {
                        o || (o = !0, t.off(), e.call(this, t, ...n))
                    }), n)
                }
                off(t, e) {
                    this.stopListening(this, t, e)
                }
                listenTo(t, e, n, o = {}) {
                    let i, r;
                    this[y] || (this[y] = {});
                    const s = this[y];
                    B(t) || T(t);
                    const a = B(t);
                    (i = s[a]) || (i = s[a] = {
                        emitter: t,
                        callbacks: {}
                    }), (r = i.callbacks[e]) || (r = i.callbacks[e] = []), r.push(n),
                        function(t, e, n, o, i) {
                            e._addEventListener ? e._addEventListener(n, o, i) : t._addEventListener.call(e, n, o, i)
                        }(this, t, e, n, o)
                }
                stopListening(t, e, n) {
                    const o = this[y];
                    let i = t && B(t);
                    const r = o && i ? o[i] : void 0,
                        s = r && e ? r.callbacks[e] : void 0;
                    if (!(!o || t && !r || e && !s))
                        if (n) {
                            V(this, t, e, n); - 1 !== s.indexOf(n) && (1 === s.length ? delete r.callbacks[e] : V(this, t, e, n))
                        } else if (s) {
                        for (; n = s.pop();) V(this, t, e, n);
                        delete r.callbacks[e]
                    } else if (r) {
                        for (e in r.callbacks) this.stopListening(t, e);
                        delete o[i]
                    } else {
                        for (i in o) this.stopListening(o[i].emitter);
                        delete this[y]
                    }
                }
                fire(t, ...e) {
                    try {
                        const n = t instanceof h ? t : new h(this, t),
                            o = n.name;
                        let i = R(this, o);
                        if (n.path.push(this), i) {
                            const t = [n, ...e];
                            i = Array.from(i);
                            for (let e = 0; e < i.length && (i[e].callback.apply(this, t), n.off.called && (delete n.off.called, this._removeEventListener(o, i[e].callback)), !n.stop.called); e++);
                        }
                        const r = this[E];
                        if (r) {
                            const t = r.get(o),
                                i = r.get("*");
                            t && z(t, n, e), i && z(i, n, e)
                        }
                        return n.return
                    } catch (t) {
                        b.rethrowUnexpectedError(t, this)
                    }
                }
                delegate(...t) {
                    return {
                        to: (e, n) => {
                            this[E] || (this[E] = new Map), t.forEach((t => {
                                const o = this[E].get(t);
                                o ? o.set(e, n) : this[E].set(t, new Map([
                                    [e, n]
                                ]))
                            }))
                        }
                    }
                }
                stopDelegating(t, e) {
                    if (this[E])
                        if (t)
                            if (e) {
                                const n = this[E].get(t);
                                n && n.delete(e)
                            } else this[E].delete(t);
                    else this[E].clear()
                }
                _addEventListener(t, e, n) {
                    ! function(t, e) {
                        const n = I(t);
                        if (n[e]) return;
                        let o = e,
                            i = null;
                        const r = [];
                        for (;
                            "" !== o && !n[o];) n[o] = {
                            callbacks: [],
                            childEvents: []
                        }, r.push(n[o]), i && n[o].childEvents.push(i), i = o, o = o.substr(0, o.lastIndexOf(":"));
                        if ("" !== o) {
                            for (const t of r) t.callbacks = n[o].callbacks.slice();
                            n[o].childEvents.push(i)
                        }
                    }(this, t);
                    const o = P(this, t),
                        i = {
                            callback: e,
                            priority: m.get(n.priority)
                        };
                    for (const t of o) p(t, i)
                }
                _removeEventListener(t, e) {
                    const n = P(this, t);
                    for (const t of n)
                        for (let n = 0; n < t.length; n++) t[n].callback == e && (t.splice(n, 1), n--)
                }
            }
        }

        function T(t, e) {
            t[x] || (t[x] = e || g())
        }

        function B(t) {
            return t[x]
        }

        function I(t) {
            return t._events || Object.defineProperty(t, "_events", {
                value: {}
            }), t._events
        }

        function P(t, e) {
            const n = I(t)[e];
            if (!n) return [];
            let o = [n.callbacks];
            for (let e = 0; e < n.childEvents.length; e++) {
                const i = P(t, n.childEvents[e]);
                o = o.concat(i)
            }
            return o
        }

        function R(t, e) {
            let n;
            return t._events && (n = t._events[e]) && n.callbacks.length ? n.callbacks : e.indexOf(":") > -1 ? R(t, e.substr(0, e.lastIndexOf(":"))) : null
        }

        function z(t, e, n) {
            for (let [o, i] of t) {
                i ? "function" == typeof i && (i = i(e.name)) : i = e.name;
                const t = new h(e.source, i);
                t.path = [...e.path], o.fire(t, ...n)
            }
        }

        function V(t, e, n, o) {
            e._removeEventListener ? e._removeEventListener(n, o) : t._removeEventListener.call(e, n, o)
        } ["on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => {
            S[t] = D.prototype[t]
        }));
        const O = function(t) {
                var e = typeof t;
                return null != t && ("object" == e || "function" == e)
            },
            F = Symbol("observableProperties"),
            M = Symbol("boundObservables"),
            N = Symbol("boundProperties"),
            L = Symbol("decoratedMethods"),
            H = Symbol("decoratedOriginal"),
            j = q(S());

        function q(t) {
            if (!t) return j;
            return class extends t {
                set(t, e) {
                    if (O(t)) return void Object.keys(t).forEach((e => {
                        this.set(e, t[e])
                    }), this);
                    W(this);
                    const n = this[F];
                    if (t in this && !n.has(t)) throw new b("observable-set-cannot-override", this);
                    Object.defineProperty(this, t, {
                        enumerable: !0,
                        configurable: !0,
                        get: () => n.get(t),
                        set(e) {
                            const o = n.get(t);
                            let i = this.fire(`set:${t}`, t, e, o);
                            void 0 === i && (i = e), o === i && n.has(t) || (n.set(t, i), this.fire(`change:${t}`, t, i, o))
                        }
                    }), this[t] = e
                }
                bind(...t) {
                    if (!t.length || !K(t)) throw new b("observable-bind-wrong-properties", this);
                    if (new Set(t).size !== t.length) throw new b("observable-bind-duplicate-properties", this);
                    W(this);
                    const e = this[N];
                    t.forEach((t => {
                        if (e.has(t)) throw new b("observable-bind-rebind", this)
                    }));
                    const n = new Map;
                    return t.forEach((t => {
                        const o = {
                            property: t,
                            to: []
                        };
                        e.set(t, o), n.set(t, o)
                    })), {
                        to: U,
                        toMany: G,
                        _observable: this,
                        _bindProperties: t,
                        _to: [],
                        _bindings: n
                    }
                }
                unbind(...t) {
                    if (!this[F]) return;
                    const e = this[N],
                        n = this[M];
                    if (t.length) {
                        if (!K(t)) throw new b("observable-unbind-wrong-properties", this);
                        t.forEach((t => {
                            const o = e.get(t);
                            o && (o.to.forEach((([t, e]) => {
                                const i = n.get(t),
                                    r = i[e];
                                r.delete(o), r.size || delete i[e], Object.keys(i).length || (n.delete(t), this.stopListening(t, "change"))
                            })), e.delete(t))
                        }))
                    } else n.forEach(((t, e) => {
                        this.stopListening(e, "change")
                    })), n.clear(), e.clear()
                }
                decorate(t) {
                    W(this);
                    const e = this[t];
                    if (!e) throw new b("observablemixin-cannot-decorate-undefined", this, {
                        object: this,
                        methodName: t
                    });
                    this.on(t, ((t, n) => {
                        t.return = e.apply(this, n)
                    })), this[t] = function(...e) {
                        return this.fire(t, e)
                    }, this[t][H] = e, this[L] || (this[L] = []), this[L].push(t)
                }
                stopListening(t, e, n) {
                    if (!t && this[L]) {
                        for (const t of this[L]) this[t] = this[t][H];
                        delete this[L]
                    }
                    super.stopListening(t, e, n)
                }
            }
        }

        function W(t) {
            t[F] || (Object.defineProperty(t, F, {
                value: new Map
            }), Object.defineProperty(t, M, {
                value: new Map
            }), Object.defineProperty(t, N, {
                value: new Map
            }))
        }

        function U(...t) {
            const e = function(...t) {
                    if (!t.length) throw new b("observable-bind-to-parse-error", null);
                    const e = {
                        to: []
                    };
                    let n;
                    "function" == typeof t[t.length - 1] && (e.callback = t.pop());
                    return t.forEach((t => {
                        if ("string" == typeof t) n.properties.push(t);
                        else {
                            if ("object" != typeof t) throw new b("observable-bind-to-parse-error", null);
                            n = {
                                observable: t,
                                properties: []
                            }, e.to.push(n)
                        }
                    })), e
                }(...t),
                n = Array.from(this._bindings.keys()),
                o = n.length;
            if (!e.callback && e.to.length > 1) throw new b("observable-bind-to-no-callback", this);
            if (o > 1 && e.callback) throw new b("observable-bind-to-extra-callback", this);
            var i;
            e.to.forEach((t => {
                    if (t.properties.length && t.properties.length !== o) throw new b("observable-bind-to-properties-length", this);
                    t.properties.length || (t.properties = this._bindProperties)
                })), this._to = e.to, e.callback && (this._bindings.get(n[0]).callback = e.callback), i = this._observable, this._to.forEach((t => {
                    const e = i[M];
                    let n;
                    e.get(t.observable) || i.listenTo(t.observable, "change", ((o, r) => {
                        n = e.get(t.observable)[r], n && n.forEach((t => {
                            Z(i, t.property)
                        }))
                    }))
                })),
                function(t) {
                    let e;
                    t._bindings.forEach(((n, o) => {
                        t._to.forEach((i => {
                            e = i.properties[n.callback ? 0 : t._bindProperties.indexOf(o)], n.to.push([i.observable, e]),
                                function(t, e, n, o) {
                                    const i = t[M],
                                        r = i.get(n),
                                        s = r || {};
                                    s[o] || (s[o] = new Set);
                                    s[o].add(e), r || i.set(n, s)
                                }(t._observable, n, i.observable, e)
                        }))
                    }))
                }(this), this._bindProperties.forEach((t => {
                    Z(this._observable, t)
                }))
        }

        function G(t, e, n) {
            if (this._bindings.size > 1) throw new b("observable-bind-to-many-not-one-binding", this);
            this.to(... function(t, e) {
                const n = t.map((t => [t, e]));
                return Array.prototype.concat.apply([], n)
            }(t, e), n)
        }

        function K(t) {
            return t.every((t => "string" == typeof t))
        }

        function Z(t, e) {
            const n = t[N].get(e);
            let o;
            n.callback ? o = n.callback.apply(t, n.to.map((t => t[0][t[1]]))) : (o = n.to[0], o = o[0][o[1]]), Object.prototype.hasOwnProperty.call(t, e) ? t[e] = o : t.set(e, o)
        }

        function J(t) {
            let e = 0;
            for (const n of t) e++;
            return e
        }

        function Y(t, e) {
            const n = Math.min(t.length, e.length);
            for (let o = 0; o < n; o++)
                if (t[o] != e[o]) return o;
            return t.length == e.length ? "same" : t.length < e.length ? "prefix" : "extension"
        }

        function Q(t) {
            return !(!t || !t[Symbol.iterator])
        } ["set", "bind", "unbind", "decorate", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => {
            q[t] = j.prototype[t]
        }));
        const X = "object" == typeof global && global && global.Object === Object && global;
        var tt = "object" == typeof self && self && self.Object === Object && self;
        const et = X || tt || Function("return this")();
        const nt = et.Symbol;
        var ot = Object.prototype,
            it = ot.hasOwnProperty,
            rt = ot.toString,
            st = nt ? nt.toStringTag : void 0;
        const at = function(t) {
            var e = it.call(t, st),
                n = t[st];
            try {
                t[st] = void 0;
                var o = !0
            } catch (t) {}
            var i = rt.call(t);
            return o && (e ? t[st] = n : delete t[st]), i
        };
        var lt = Object.prototype.toString;
        const ct = function(t) {
            return lt.call(t)
        };
        var dt = nt ? nt.toStringTag : void 0;
        const ht = function(t) {
            return null == t ? void 0 === t ? "[object Undefined]" : "[object Null]" : dt && dt in Object(t) ? at(t) : ct(t)
        };
        const ut = Array.isArray;
        const gt = function(t) {
            return null != t && "object" == typeof t
        };
        const mt = function(t) {
            return "string" == typeof t || !ut(t) && gt(t) && "[object String]" == ht(t)
        };

        function pt(t, e, n = {}, o = []) {
            const i = n && n.xmlns,
                r = i ? t.createElementNS(i, e) : t.createElement(e);
            for (const t in n) r.setAttribute(t, n[t]);
            !mt(o) && Q(o) || (o = [o]);
            for (let e of o) mt(e) && (e = t.createTextNode(e)), r.appendChild(e);
            return r
        }
        const ft = function(t, e) {
            return function(n) {
                return t(e(n))
            }
        };
        const bt = ft(Object.getPrototypeOf, Object);
        var kt = Function.prototype,
            wt = Object.prototype,
            At = kt.toString,
            Ct = wt.hasOwnProperty,
            _t = At.call(Object);
        const vt = function(t) {
            if (!gt(t) || "[object Object]" != ht(t)) return !1;
            var e = bt(t);
            if (null === e) return !0;
            var n = Ct.call(e, "constructor") && e.constructor;
            return "function" == typeof n && n instanceof n && At.call(n) == _t
        };
        const yt = function() {
            this.__data__ = [], this.size = 0
        };
        const xt = function(t, e) {
            return t === e || t != t && e != e
        };
        const Et = function(t, e) {
            for (var n = t.length; n--;)
                if (xt(t[n][0], e)) return n;
            return -1
        };
        var Dt = Array.prototype.splice;
        const St = function(t) {
            var e = this.__data__,
                n = Et(e, t);
            return !(n < 0) && (n == e.length - 1 ? e.pop() : Dt.call(e, n, 1), --this.size, !0)
        };
        const Tt = function(t) {
            var e = this.__data__,
                n = Et(e, t);
            return n < 0 ? void 0 : e[n][1]
        };
        const Bt = function(t) {
            return Et(this.__data__, t) > -1
        };
        const It = function(t, e) {
            var n = this.__data__,
                o = Et(n, t);
            return o < 0 ? (++this.size, n.push([t, e])) : n[o][1] = e, this
        };

        function Pt(t) {
            var e = -1,
                n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n;) {
                var o = t[e];
                this.set(o[0], o[1])
            }
        }
        Pt.prototype.clear = yt, Pt.prototype.delete = St, Pt.prototype.get = Tt, Pt.prototype.has = Bt, Pt.prototype.set = It;
        const Rt = Pt;
        const zt = function() {
            this.__data__ = new Rt, this.size = 0
        };
        const Vt = function(t) {
            var e = this.__data__,
                n = e.delete(t);
            return this.size = e.size, n
        };
        const Ot = function(t) {
            return this.__data__.get(t)
        };
        const Ft = function(t) {
            return this.__data__.has(t)
        };
        const Mt = function(t) {
            if (!O(t)) return !1;
            var e = ht(t);
            return "[object Function]" == e || "[object GeneratorFunction]" == e || "[object AsyncFunction]" == e || "[object Proxy]" == e
        };
        const Nt = et["__core-js_shared__"];
        var Lt = function() {
            var t = /[^.]+$/.exec(Nt && Nt.keys && Nt.keys.IE_PROTO || "");
            return t ? "Symbol(src)_1." + t : ""
        }();
        const Ht = function(t) {
            return !!Lt && Lt in t
        };
        var jt = Function.prototype.toString;
        const qt = function(t) {
            if (null != t) {
                try {
                    return jt.call(t)
                } catch (t) {}
                try {
                    return t + ""
                } catch (t) {}
            }
            return ""
        };
        var Wt = /^\[object .+?Constructor\]$/,
            Ut = Function.prototype,
            $t = Object.prototype,
            Gt = Ut.toString,
            Kt = $t.hasOwnProperty,
            Zt = RegExp("^" + Gt.call(Kt).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        const Jt = function(t) {
            return !(!O(t) || Ht(t)) && (Mt(t) ? Zt : Wt).test(qt(t))
        };
        const Yt = function(t, e) {
            return null == t ? void 0 : t[e]
        };
        const Qt = function(t, e) {
            var n = Yt(t, e);
            return Jt(n) ? n : void 0
        };
        const Xt = Qt(et, "Map");
        const te = Qt(Object, "create");
        const ee = function() {
            this.__data__ = te ? te(null) : {}, this.size = 0
        };
        const ne = function(t) {
            var e = this.has(t) && delete this.__data__[t];
            return this.size -= e ? 1 : 0, e
        };
        var oe = Object.prototype.hasOwnProperty;
        const ie = function(t) {
            var e = this.__data__;
            if (te) {
                var n = e[t];
                return "__lodash_hash_undefined__" === n ? void 0 : n
            }
            return oe.call(e, t) ? e[t] : void 0
        };
        var re = Object.prototype.hasOwnProperty;
        const se = function(t) {
            var e = this.__data__;
            return te ? void 0 !== e[t] : re.call(e, t)
        };
        const ae = function(t, e) {
            var n = this.__data__;
            return this.size += this.has(t) ? 0 : 1, n[t] = te && void 0 === e ? "__lodash_hash_undefined__" : e, this
        };

        function le(t) {
            var e = -1,
                n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n;) {
                var o = t[e];
                this.set(o[0], o[1])
            }
        }
        le.prototype.clear = ee, le.prototype.delete = ne, le.prototype.get = ie, le.prototype.has = se, le.prototype.set = ae;
        const ce = le;
        const de = function() {
            this.size = 0, this.__data__ = {
                hash: new ce,
                map: new(Xt || Rt),
                string: new ce
            }
        };
        const he = function(t) {
            var e = typeof t;
            return "string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== t : null === t
        };
        const ue = function(t, e) {
            var n = t.__data__;
            return he(e) ? n["string" == typeof e ? "string" : "hash"] : n.map
        };
        const ge = function(t) {
            var e = ue(this, t).delete(t);
            return this.size -= e ? 1 : 0, e
        };
        const me = function(t) {
            return ue(this, t).get(t)
        };
        const pe = function(t) {
            return ue(this, t).has(t)
        };
        const fe = function(t, e) {
            var n = ue(this, t),
                o = n.size;
            return n.set(t, e), this.size += n.size == o ? 0 : 1, this
        };

        function be(t) {
            var e = -1,
                n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n;) {
                var o = t[e];
                this.set(o[0], o[1])
            }
        }
        be.prototype.clear = de, be.prototype.delete = ge, be.prototype.get = me, be.prototype.has = pe, be.prototype.set = fe;
        const ke = be;
        const we = function(t, e) {
            var n = this.__data__;
            if (n instanceof Rt) {
                var o = n.__data__;
                if (!Xt || o.length < 199) return o.push([t, e]), this.size = ++n.size, this;
                n = this.__data__ = new ke(o)
            }
            return n.set(t, e), this.size = n.size, this
        };

        function Ae(t) {
            var e = this.__data__ = new Rt(t);
            this.size = e.size
        }
        Ae.prototype.clear = zt, Ae.prototype.delete = Vt, Ae.prototype.get = Ot, Ae.prototype.has = Ft, Ae.prototype.set = we;
        const Ce = Ae;
        const _e = function(t, e) {
            for (var n = -1, o = null == t ? 0 : t.length; ++n < o && !1 !== e(t[n], n, t););
            return t
        };
        const ve = function() {
            try {
                var t = Qt(Object, "defineProperty");
                return t({}, "", {}), t
            } catch (t) {}
        }();
        const ye = function(t, e, n) {
            "__proto__" == e && ve ? ve(t, e, {
                configurable: !0,
                enumerable: !0,
                value: n,
                writable: !0
            }) : t[e] = n
        };
        var xe = Object.prototype.hasOwnProperty;
        const Ee = function(t, e, n) {
            var o = t[e];
            xe.call(t, e) && xt(o, n) && (void 0 !== n || e in t) || ye(t, e, n)
        };
        const De = function(t, e, n, o) {
            var i = !n;
            n || (n = {});
            for (var r = -1, s = e.length; ++r < s;) {
                var a = e[r],
                    l = o ? o(n[a], t[a], a, n, t) : void 0;
                void 0 === l && (l = t[a]), i ? ye(n, a, l) : Ee(n, a, l)
            }
            return n
        };
        const Se = function(t, e) {
            for (var n = -1, o = Array(t); ++n < t;) o[n] = e(n);
            return o
        };
        const Te = function(t) {
            return gt(t) && "[object Arguments]" == ht(t)
        };
        var Be = Object.prototype,
            Ie = Be.hasOwnProperty,
            Pe = Be.propertyIsEnumerable;
        const Re = Te(function() {
            return arguments
        }()) ? Te : function(t) {
            return gt(t) && Ie.call(t, "callee") && !Pe.call(t, "callee")
        };
        const ze = function() {
            return !1
        };
        var Ve = "object" == typeof exports && exports && !exports.nodeType && exports,
            Oe = Ve && "object" == typeof module && module && !module.nodeType && module,
            Fe = Oe && Oe.exports === Ve ? et.Buffer : void 0;
        const Me = (Fe ? Fe.isBuffer : void 0) || ze;
        var Ne = /^(?:0|[1-9]\d*)$/;
        const Le = function(t, e) {
            var n = typeof t;
            return !!(e = null == e ? 9007199254740991 : e) && ("number" == n || "symbol" != n && Ne.test(t)) && t > -1 && t % 1 == 0 && t < e
        };
        const He = function(t) {
            return "number" == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991
        };
        var je = {};
        je["[object Float32Array]"] = je["[object Float64Array]"] = je["[object Int8Array]"] = je["[object Int16Array]"] = je["[object Int32Array]"] = je["[object Uint8Array]"] = je["[object Uint8ClampedArray]"] = je["[object Uint16Array]"] = je["[object Uint32Array]"] = !0, je["[object Arguments]"] = je["[object Array]"] = je["[object ArrayBuffer]"] = je["[object Boolean]"] = je["[object DataView]"] = je["[object Date]"] = je["[object Error]"] = je["[object Function]"] = je["[object Map]"] = je["[object Number]"] = je["[object Object]"] = je["[object RegExp]"] = je["[object Set]"] = je["[object String]"] = je["[object WeakMap]"] = !1;
        const qe = function(t) {
            return gt(t) && He(t.length) && !!je[ht(t)]
        };
        const We = function(t) {
            return function(e) {
                return t(e)
            }
        };
        var Ue = "object" == typeof exports && exports && !exports.nodeType && exports,
            $e = Ue && "object" == typeof module && module && !module.nodeType && module,
            Ge = $e && $e.exports === Ue && X.process;
        const Ke = function() {
            try {
                var t = $e && $e.require && $e.require("util").types;
                return t || Ge && Ge.binding && Ge.binding("util")
            } catch (t) {}
        }();
        var Ze = Ke && Ke.isTypedArray;
        const Je = Ze ? We(Ze) : qe;
        var Ye = Object.prototype.hasOwnProperty;
        const Qe = function(t, e) {
            var n = ut(t),
                o = !n && Re(t),
                i = !n && !o && Me(t),
                r = !n && !o && !i && Je(t),
                s = n || o || i || r,
                a = s ? Se(t.length, String) : [],
                l = a.length;
            for (var c in t) !e && !Ye.call(t, c) || s && ("length" == c || i && ("offset" == c || "parent" == c) || r && ("buffer" == c || "byteLength" == c || "byteOffset" == c) || Le(c, l)) || a.push(c);
            return a
        };
        var Xe = Object.prototype;
        const tn = function(t) {
            var e = t && t.constructor;
            return t === ("function" == typeof e && e.prototype || Xe)
        };
        const en = ft(Object.keys, Object);
        var nn = Object.prototype.hasOwnProperty;
        const on = function(t) {
            if (!tn(t)) return en(t);
            var e = [];
            for (var n in Object(t)) nn.call(t, n) && "constructor" != n && e.push(n);
            return e
        };
        const rn = function(t) {
            return null != t && He(t.length) && !Mt(t)
        };
        const sn = function(t) {
            return rn(t) ? Qe(t) : on(t)
        };
        const an = function(t, e) {
            return t && De(e, sn(e), t)
        };
        const ln = function(t) {
            var e = [];
            if (null != t)
                for (var n in Object(t)) e.push(n);
            return e
        };
        var cn = Object.prototype.hasOwnProperty;
        const dn = function(t) {
            if (!O(t)) return ln(t);
            var e = tn(t),
                n = [];
            for (var o in t)("constructor" != o || !e && cn.call(t, o)) && n.push(o);
            return n
        };
        const hn = function(t) {
            return rn(t) ? Qe(t, !0) : dn(t)
        };
        const un = function(t, e) {
            return t && De(e, hn(e), t)
        };
        var gn = "object" == typeof exports && exports && !exports.nodeType && exports,
            mn = gn && "object" == typeof module && module && !module.nodeType && module,
            pn = mn && mn.exports === gn ? et.Buffer : void 0,
            fn = pn ? pn.allocUnsafe : void 0;
        const bn = function(t, e) {
            if (e) return t.slice();
            var n = t.length,
                o = fn ? fn(n) : new t.constructor(n);
            return t.copy(o), o
        };
        const kn = function(t, e) {
            var n = -1,
                o = t.length;
            for (e || (e = Array(o)); ++n < o;) e[n] = t[n];
            return e
        };
        const wn = function(t, e) {
            for (var n = -1, o = null == t ? 0 : t.length, i = 0, r = []; ++n < o;) {
                var s = t[n];
                e(s, n, t) && (r[i++] = s)
            }
            return r
        };
        const An = function() {
            return []
        };
        var Cn = Object.prototype.propertyIsEnumerable,
            _n = Object.getOwnPropertySymbols;
        const vn = _n ? function(t) {
            return null == t ? [] : (t = Object(t), wn(_n(t), (function(e) {
                return Cn.call(t, e)
            })))
        } : An;
        const yn = function(t, e) {
            return De(t, vn(t), e)
        };
        const xn = function(t, e) {
            for (var n = -1, o = e.length, i = t.length; ++n < o;) t[i + n] = e[n];
            return t
        };
        const En = Object.getOwnPropertySymbols ? function(t) {
            for (var e = []; t;) xn(e, vn(t)), t = bt(t);
            return e
        } : An;
        const Dn = function(t, e) {
            return De(t, En(t), e)
        };
        const Sn = function(t, e, n) {
            var o = e(t);
            return ut(t) ? o : xn(o, n(t))
        };
        const Tn = function(t) {
            return Sn(t, sn, vn)
        };
        const Bn = function(t) {
            return Sn(t, hn, En)
        };
        const In = Qt(et, "DataView");
        const Pn = Qt(et, "Promise");
        const Rn = Qt(et, "Set");
        const zn = Qt(et, "WeakMap");
        var Vn = "[object Map]",
            On = "[object Promise]",
            Fn = "[object Set]",
            Mn = "[object WeakMap]",
            Nn = "[object DataView]",
            Ln = qt(In),
            Hn = qt(Xt),
            jn = qt(Pn),
            qn = qt(Rn),
            Wn = qt(zn),
            Un = ht;
        (In && Un(new In(new ArrayBuffer(1))) != Nn || Xt && Un(new Xt) != Vn || Pn && Un(Pn.resolve()) != On || Rn && Un(new Rn) != Fn || zn && Un(new zn) != Mn) && (Un = function(t) {
            var e = ht(t),
                n = "[object Object]" == e ? t.constructor : void 0,
                o = n ? qt(n) : "";
            if (o) switch (o) {
                case Ln:
                    return Nn;
                case Hn:
                    return Vn;
                case jn:
                    return On;
                case qn:
                    return Fn;
                case Wn:
                    return Mn
            }
            return e
        });
        const $n = Un;
        var Gn = Object.prototype.hasOwnProperty;
        const Kn = function(t) {
            var e = t.length,
                n = new t.constructor(e);
            return e && "string" == typeof t[0] && Gn.call(t, "index") && (n.index = t.index, n.input = t.input), n
        };
        const Zn = et.Uint8Array;
        const Jn = function(t) {
            var e = new t.constructor(t.byteLength);
            return new Zn(e).set(new Zn(t)), e
        };
        const Yn = function(t, e) {
            var n = e ? Jn(t.buffer) : t.buffer;
            return new t.constructor(n, t.byteOffset, t.byteLength)
        };
        var Qn = /\w*$/;
        const Xn = function(t) {
            var e = new t.constructor(t.source, Qn.exec(t));
            return e.lastIndex = t.lastIndex, e
        };
        var to = nt ? nt.prototype : void 0,
            eo = to ? to.valueOf : void 0;
        const no = function(t) {
            return eo ? Object(eo.call(t)) : {}
        };
        const oo = function(t, e) {
            var n = e ? Jn(t.buffer) : t.buffer;
            return new t.constructor(n, t.byteOffset, t.length)
        };
        const io = function(t, e, n) {
            var o = t.constructor;
            switch (e) {
                case "[object ArrayBuffer]":
                    return Jn(t);
                case "[object Boolean]":
                case "[object Date]":
                    return new o(+t);
                case "[object DataView]":
                    return Yn(t, n);
                case "[object Float32Array]":
                case "[object Float64Array]":
                case "[object Int8Array]":
                case "[object Int16Array]":
                case "[object Int32Array]":
                case "[object Uint8Array]":
                case "[object Uint8ClampedArray]":
                case "[object Uint16Array]":
                case "[object Uint32Array]":
                    return oo(t, n);
                case "[object Map]":
                case "[object Set]":
                    return new o;
                case "[object Number]":
                case "[object String]":
                    return new o(t);
                case "[object RegExp]":
                    return Xn(t);
                case "[object Symbol]":
                    return no(t)
            }
        };
        var ro = Object.create;
        const so = function() {
            function t() {}
            return function(e) {
                if (!O(e)) return {};
                if (ro) return ro(e);
                t.prototype = e;
                var n = new t;
                return t.prototype = void 0, n
            }
        }();
        const ao = function(t) {
            return "function" != typeof t.constructor || tn(t) ? {} : so(bt(t))
        };
        const lo = function(t) {
            return gt(t) && "[object Map]" == $n(t)
        };
        var co = Ke && Ke.isMap;
        const ho = co ? We(co) : lo;
        const uo = function(t) {
            return gt(t) && "[object Set]" == $n(t)
        };
        var go = Ke && Ke.isSet;
        const mo = go ? We(go) : uo;
        var po = "[object Arguments]",
            fo = "[object Function]",
            bo = "[object Object]",
            ko = {};
        ko[po] = ko["[object Array]"] = ko["[object ArrayBuffer]"] = ko["[object DataView]"] = ko["[object Boolean]"] = ko["[object Date]"] = ko["[object Float32Array]"] = ko["[object Float64Array]"] = ko["[object Int8Array]"] = ko["[object Int16Array]"] = ko["[object Int32Array]"] = ko["[object Map]"] = ko["[object Number]"] = ko[bo] = ko["[object RegExp]"] = ko["[object Set]"] = ko["[object String]"] = ko["[object Symbol]"] = ko["[object Uint8Array]"] = ko["[object Uint8ClampedArray]"] = ko["[object Uint16Array]"] = ko["[object Uint32Array]"] = !0, ko["[object Error]"] = ko[fo] = ko["[object WeakMap]"] = !1;
        const wo = function t(e, n, o, i, r, s) {
            var a, l = 1 & n,
                c = 2 & n,
                d = 4 & n;
            if (o && (a = r ? o(e, i, r, s) : o(e)), void 0 !== a) return a;
            if (!O(e)) return e;
            var h = ut(e);
            if (h) {
                if (a = Kn(e), !l) return kn(e, a)
            } else {
                var u = $n(e),
                    g = u == fo || "[object GeneratorFunction]" == u;
                if (Me(e)) return bn(e, l);
                if (u == bo || u == po || g && !r) {
                    if (a = c || g ? {} : ao(e), !l) return c ? Dn(e, un(a, e)) : yn(e, an(a, e))
                } else {
                    if (!ko[u]) return r ? e : {};
                    a = io(e, u, l)
                }
            }
            s || (s = new Ce);
            var m = s.get(e);
            if (m) return m;
            s.set(e, a), mo(e) ? e.forEach((function(i) {
                a.add(t(i, n, o, i, e, s))
            })) : ho(e) && e.forEach((function(i, r) {
                a.set(r, t(i, n, o, r, e, s))
            }));
            var p = h ? void 0 : (d ? c ? Bn : Tn : c ? hn : sn)(e);
            return _e(p || e, (function(i, r) {
                p && (i = e[r = i]), Ee(a, r, t(i, n, o, r, e, s))
            })), a
        };
        const Ao = function(t, e) {
            return wo(t, 5, e = "function" == typeof e ? e : void 0)
        };
        const Co = function(t) {
            return gt(t) && 1 === t.nodeType && !vt(t)
        };
        class _o {
            constructor(t, e) {
                this._config = {}, e && this.define(vo(e)), t && this._setObjectToTarget(this._config, t)
            }
            set(t, e) {
                this._setToTarget(this._config, t, e)
            }
            define(t, e) {
                this._setToTarget(this._config, t, e, !0)
            }
            get(t) {
                return this._getFromSource(this._config, t)
            }* names() {
                for (const t of Object.keys(this._config)) yield t
            }
            _setToTarget(t, e, n, o = !1) {
                if (vt(e)) return void this._setObjectToTarget(t, e, o);
                const i = e.split(".");
                e = i.pop();
                for (const e of i) vt(t[e]) || (t[e] = {}), t = t[e];
                if (vt(n)) return vt(t[e]) || (t[e] = {}), t = t[e], void this._setObjectToTarget(t, n, o);
                o && void 0 !== t[e] || (t[e] = n)
            }
            _getFromSource(t, e) {
                const n = e.split(".");
                e = n.pop();
                for (const e of n) {
                    if (!vt(t[e])) {
                        t = null;
                        break
                    }
                    t = t[e]
                }
                return t ? vo(t[e]) : void 0
            }
            _setObjectToTarget(t, e, n) {
                Object.keys(e).forEach((o => {
                    this._setToTarget(t, o, e[o], n)
                }))
            }
        }

        function vo(t) {
            return Ao(t, yo)
        }

        function yo(t) {
            return Co(t) ? t : void 0
        }

        function xo(t) {
            if (t) {
                if (t.defaultView) return t instanceof t.defaultView.Document;
                if (t.ownerDocument && t.ownerDocument.defaultView) return t instanceof t.ownerDocument.defaultView.Node
            }
            return !1
        }

        function Eo(t) {
            const e = Object.prototype.toString.apply(t);
            return "[object Window]" == e || "[object global]" == e
        }
        const Do = So(S());

        function So(t) {
            if (!t) return Do;
            return class extends t {
                listenTo(t, e, n, o = {}) {
                    if (xo(t) || Eo(t)) {
                        const i = {
                                capture: !!o.useCapture,
                                passive: !!o.usePassive
                            },
                            r = this._getProxyEmitter(t, i) || new To(t, i);
                        this.listenTo(r, e, n, o)
                    } else super.listenTo(t, e, n, o)
                }
                stopListening(t, e, n) {
                    if (xo(t) || Eo(t)) {
                        const o = this._getAllProxyEmitters(t);
                        for (const t of o) this.stopListening(t, e, n)
                    } else super.stopListening(t, e, n)
                }
                _getProxyEmitter(t, e) {
                    return function(t, e) {
                        const n = t[y];
                        return n && n[e] ? n[e].emitter : null
                    }(this, Bo(t, e))
                }
                _getAllProxyEmitters(t) {
                    return [{
                        capture: !1,
                        passive: !1
                    }, {
                        capture: !1,
                        passive: !0
                    }, {
                        capture: !0,
                        passive: !1
                    }, {
                        capture: !0,
                        passive: !0
                    }].map((e => this._getProxyEmitter(t, e))).filter((t => !!t))
                }
            }
        } ["_getProxyEmitter", "_getAllProxyEmitters", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => {
            So[t] = Do.prototype[t]
        }));
        class To extends(S()) {
            constructor(t, e) {
                super(), T(this, Bo(t, e)), this._domNode = t, this._options = e
            }
            attach(t) {
                if (this._domListeners && this._domListeners[t]) return;
                const e = this._createDomListener(t);
                this._domNode.addEventListener(t, e, this._options), this._domListeners || (this._domListeners = {}), this._domListeners[t] = e
            }
            detach(t) {
                let e;
                !this._domListeners[t] || (e = this._events[t]) && e.callbacks.length || this._domListeners[t].removeListener()
            }
            _addEventListener(t, e, n) {
                this.attach(t), S().prototype._addEventListener.call(this, t, e, n)
            }
            _removeEventListener(t, e) {
                S().prototype._removeEventListener.call(this, t, e), this.detach(t)
            }
            _createDomListener(t) {
                const e = e => {
                    this.fire(t, e)
                };
                return e.removeListener = () => {
                    this._domNode.removeEventListener(t, e, this._options), delete this._domListeners[t]
                }, e
            }
        }

        function Bo(t, e) {
            let n = function(t) {
                return t["data-ck-expando"] || (t["data-ck-expando"] = g())
            }(t);
            for (const t of Object.keys(e).sort()) e[t] && (n += "-" + t);
            return n
        }
        let Io;
        try {
            Io = {
                window,
                document
            }
        } catch (t) {
            Io = {
                window: {},
                document: {}
            }
        }
        const Po = Io;

        function Ro(t) {
            const e = [];
            let n = t;
            for (; n && n.nodeType != Node.DOCUMENT_NODE;) e.unshift(n), n = n.parentNode;
            return e
        }

        function zo(t) {
            return "[object Text]" == Object.prototype.toString.call(t)
        }

        function Vo(t) {
            return "[object Range]" == Object.prototype.toString.apply(t)
        }

        function Oo(t) {
            const e = t.ownerDocument.defaultView.getComputedStyle(t);
            return {
                top: parseInt(e.borderTopWidth, 10),
                right: parseInt(e.borderRightWidth, 10),
                bottom: parseInt(e.borderBottomWidth, 10),
                left: parseInt(e.borderLeftWidth, 10)
            }
        }
        const Fo = ["top", "right", "bottom", "left", "width", "height"];
        class Mo {
            constructor(t) {
                const e = Vo(t);
                if (Object.defineProperty(this, "_source", {
                        value: t._source || t,
                        writable: !0,
                        enumerable: !1
                    }), Ho(t) || e)
                    if (e) {
                        const e = Mo.getDomRangeRects(t);
                        No(this, Mo.getBoundingRect(e))
                    } else No(this, t.getBoundingClientRect());
                else if (Eo(t)) {
                    const {
                        innerWidth: e,
                        innerHeight: n
                    } = t;
                    No(this, {
                        top: 0,
                        right: e,
                        bottom: n,
                        left: 0,
                        width: e,
                        height: n
                    })
                } else No(this, t)
            }
            clone() {
                return new Mo(this)
            }
            moveTo(t, e) {
                return this.top = e, this.right = t + this.width, this.bottom = e + this.height, this.left = t, this
            }
            moveBy(t, e) {
                return this.top += e, this.right += t, this.left += t, this.bottom += e, this
            }
            getIntersection(t) {
                const e = {
                    top: Math.max(this.top, t.top),
                    right: Math.min(this.right, t.right),
                    bottom: Math.min(this.bottom, t.bottom),
                    left: Math.max(this.left, t.left),
                    width: 0,
                    height: 0
                };
                return e.width = e.right - e.left, e.height = e.bottom - e.top, e.width < 0 || e.height < 0 ? null : new Mo(e)
            }
            getIntersectionArea(t) {
                const e = this.getIntersection(t);
                return e ? e.getArea() : 0
            }
            getArea() {
                return this.width * this.height
            }
            getVisible() {
                const t = this._source;
                let e = this.clone();
                if (Lo(t)) return e;
                let n, o = t,
                    i = t.parentNode || t.commonAncestorContainer;
                for (; i && !Lo(i);) {
                    if (o instanceof HTMLElement && "absolute" === jo(o) && (n = o), n && ("relative" !== jo(i) || "visible" === (r = i).ownerDocument.defaultView.getComputedStyle(r).overflow)) {
                        o = i, i = i.parentNode;
                        continue
                    }
                    const t = new Mo(i),
                        s = e.getIntersection(t);
                    if (!s) return null;
                    s.getArea() < e.getArea() && (e = s), o = i, i = i.parentNode
                }
                var r;
                return e
            }
            isEqual(t) {
                for (const e of Fo)
                    if (this[e] !== t[e]) return !1;
                return !0
            }
            contains(t) {
                const e = this.getIntersection(t);
                return !(!e || !e.isEqual(t))
            }
            excludeScrollbarsAndBorders() {
                const t = this._source;
                let e, n, o;
                if (Eo(t)) e = t.innerWidth - t.document.documentElement.clientWidth, n = t.innerHeight - t.document.documentElement.clientHeight, o = t.getComputedStyle(t.document.documentElement).direction;
                else {
                    const i = Oo(t);
                    e = t.offsetWidth - t.clientWidth - i.left - i.right, n = t.offsetHeight - t.clientHeight - i.top - i.bottom, o = t.ownerDocument.defaultView.getComputedStyle(t).direction, this.left += i.left, this.top += i.top, this.right -= i.right, this.bottom -= i.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top
                }
                return this.width -= e, "ltr" === o ? this.right -= e : this.left += e, this.height -= n, this.bottom -= n, this
            }
            static getDomRangeRects(t) {
                const e = [],
                    n = Array.from(t.getClientRects());
                if (n.length)
                    for (const t of n) e.push(new Mo(t));
                else {
                    let n = t.startContainer;
                    zo(n) && (n = n.parentNode);
                    const o = new Mo(n.getBoundingClientRect());
                    o.right = o.left, o.width = 0, e.push(o)
                }
                return e
            }
            static getBoundingRect(t) {
                const e = {
                    left: Number.POSITIVE_INFINITY,
                    top: Number.POSITIVE_INFINITY,
                    right: Number.NEGATIVE_INFINITY,
                    bottom: Number.NEGATIVE_INFINITY,
                    width: 0,
                    height: 0
                };
                let n = 0;
                for (const o of t) n++, e.left = Math.min(e.left, o.left), e.top = Math.min(e.top, o.top), e.right = Math.max(e.right, o.right), e.bottom = Math.max(e.bottom, o.bottom);
                return 0 == n ? null : (e.width = e.right - e.left, e.height = e.bottom - e.top, new Mo(e))
            }
        }

        function No(t, e) {
            for (const n of Fo) t[n] = e[n]
        }

        function Lo(t) {
            return !!Ho(t) && t === t.ownerDocument.body
        }

        function Ho(t) {
            return null !== t && "object" == typeof t && 1 === t.nodeType && "function" == typeof t.getBoundingClientRect
        }

        function jo(t) {
            return t.ownerDocument.defaultView.getComputedStyle(t).position
        }
        const qo = class {
            constructor(t, e) {
                qo._observerInstance || qo._createObserver(), this._element = t, this._callback = e, qo._addElementCallback(t, e), qo._observerInstance.observe(t)
            }
            get element() {
                return this._element
            }
            destroy() {
                qo._deleteElementCallback(this._element, this._callback)
            }
            static _addElementCallback(t, e) {
                qo._elementCallbacks || (qo._elementCallbacks = new Map);
                let n = qo._elementCallbacks.get(t);
                n || (n = new Set, qo._elementCallbacks.set(t, n)), n.add(e)
            }
            static _deleteElementCallback(t, e) {
                const n = qo._getElementCallbacks(t);
                n && (n.delete(e), n.size || (qo._elementCallbacks.delete(t), qo._observerInstance.unobserve(t))), qo._elementCallbacks && !qo._elementCallbacks.size && (qo._observerInstance = null, qo._elementCallbacks = null)
            }
            static _getElementCallbacks(t) {
                return qo._elementCallbacks ? qo._elementCallbacks.get(t) : null
            }
            static _createObserver() {
                qo._observerInstance = new Po.window.ResizeObserver((t => {
                    for (const e of t) {
                        const t = qo._getElementCallbacks(e.target);
                        if (t)
                            for (const n of t) n(e)
                    }
                }))
            }
        };
        let Wo = qo;

        function Uo(t, e) {
            t instanceof HTMLTextAreaElement && (t.value = e), t.innerHTML = e
        }

        function $o(t) {
            return e => e + t
        }

        function Go(t) {
            let e = 0;
            for (; t.previousSibling;) t = t.previousSibling, e++;
            return e
        }

        function Ko(t, e, n) {
            t.insertBefore(n, t.childNodes[e] || null)
        }

        function Zo(t) {
            return t && t.nodeType === Node.COMMENT_NODE
        }

        function Jo(t) {
            return !!(t && t.getClientRects && t.getClientRects().length)
        }
        Wo._observerInstance = null, Wo._elementCallbacks = null;
        var Yo = Math.pow;

        function Qo({
            element: t,
            target: e,
            positions: n,
            limiter: o,
            fitInViewport: i,
            viewportOffsetConfig: r
        }) {
            Mt(e) && (e = e()), Mt(o) && (o = o());
            const s = function(t) {
                    return t && t.parentNode ? t.offsetParent === Po.document.body ? null : t.offsetParent : null
                }(t),
                a = new Mo(t),
                l = new Mo(e);
            let c;
            const d = i && function(t) {
                    t = Object.assign({
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0
                    }, t);
                    const e = new Mo(Po.window);
                    return e.top += t.top, e.height -= t.top, e.bottom -= t.bottom, e.height -= t.bottom, e
                }(r) || null,
                h = {
                    targetRect: l,
                    elementRect: a,
                    positionedElementAncestor: s,
                    viewportRect: d
                };
            if (o || i) {
                const t = o && new Mo(o).getVisible();
                Object.assign(h, {
                    limiterRect: t,
                    viewportRect: d
                }), c = function(t, e) {
                    const {
                        elementRect: n
                    } = e, o = n.getArea(), i = t.map((t => new ti(t, e))).filter((t => !!t.name));
                    let r = 0,
                        s = null;
                    for (const t of i) {
                        const {
                            limiterIntersectionArea: e,
                            viewportIntersectionArea: n
                        } = t;
                        if (e === o) return t;
                        const i = Yo(n, 2) + Yo(e, 2);
                        i > r && (r = i, s = t)
                    }
                    return s
                }(n, h) || new ti(n[0], h)
            } else c = new ti(n[0], h);
            return c
        }

        function Xo(t) {
            const {
                scrollX: e,
                scrollY: n
            } = Po.window;
            return t.clone().moveBy(e, n)
        }
        class ti {
            constructor(t, e) {
                const n = t(e.targetRect, e.elementRect, e.viewportRect);
                if (!n) return;
                const {
                    left: o,
                    top: i,
                    name: r,
                    config: s
                } = n;
                this.name = r, this.config = s, this._positioningFunctionCorrdinates = {
                    left: o,
                    top: i
                }, this._options = e
            }
            get left() {
                return this._absoluteRect.left
            }
            get top() {
                return this._absoluteRect.top
            }
            get limiterIntersectionArea() {
                const t = this._options.limiterRect;
                if (t) {
                    const e = this._options.viewportRect;
                    if (!e) return t.getIntersectionArea(this._rect);
                    {
                        const n = t.getIntersection(e);
                        if (n) return n.getIntersectionArea(this._rect)
                    }
                }
                return 0
            }
            get viewportIntersectionArea() {
                const t = this._options.viewportRect;
                return t ? t.getIntersectionArea(this._rect) : 0
            }
            get _rect() {
                return this._cachedRect || (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top)), this._cachedRect
            }
            get _absoluteRect() {
                return this._cachedAbsoluteRect || (this._cachedAbsoluteRect = Xo(this._rect), this._options.positionedElementAncestor && function(t, e) {
                    const n = Xo(new Mo(e)),
                        o = Oo(e);
                    let i = 0,
                        r = 0;
                    i -= n.left, r -= n.top, i += e.scrollLeft, r += e.scrollTop, i -= o.left, r -= o.top, t.moveBy(i, r)
                }(this._cachedAbsoluteRect, this._options.positionedElementAncestor)), this._cachedAbsoluteRect
            }
        }

        function ei(t) {
            const e = t.parentNode;
            e && e.removeChild(t)
        }

        function ni({
            target: t,
            viewportOffset: e = 0,
            ancestorOffset: n = 0,
            alignToTop: o,
            forceScroll: i
        }) {
            const r = ci(t);
            let s = r,
                a = null;
            for (e = function(t) {
                    if ("number" == typeof t) return {
                        top: t,
                        bottom: t,
                        left: t,
                        right: t
                    };
                    return t
                }(e); s;) {
                let l;
                l = di(s == r ? t : a), ii({
                    parent: l,
                    getRect: () => hi(t, s),
                    alignToTop: o,
                    ancestorOffset: n,
                    forceScroll: i
                });
                const c = hi(t, s);
                if (oi({
                        window: s,
                        rect: c,
                        viewportOffset: e,
                        alignToTop: o,
                        forceScroll: i
                    }), s.parent != s) {
                    if (a = s.frameElement, s = s.parent, !a) return
                } else s = null
            }
        }

        function oi({
            window: t,
            rect: e,
            alignToTop: n,
            forceScroll: o,
            viewportOffset: i
        }) {
            const r = e.clone().moveBy(0, i.bottom),
                s = e.clone().moveBy(0, -i.top),
                a = new Mo(t).excludeScrollbarsAndBorders(),
                l = n && o,
                c = [s, r].every((t => a.contains(t)));
            let {
                scrollX: d,
                scrollY: h
            } = t;
            const u = d,
                g = h;
            l ? h -= a.top - e.top + i.top : c || (si(s, a) ? h -= a.top - e.top + i.top : ri(r, a) && (h += n ? e.top - a.top - i.top : e.bottom - a.bottom + i.bottom)), c || (ai(e, a) ? d -= a.left - e.left + i.left : li(e, a) && (d += e.right - a.right + i.right)), d == u && h === g || t.scrollTo(d, h)
        }

        function ii({
            parent: t,
            getRect: e,
            alignToTop: n,
            forceScroll: o,
            ancestorOffset: i = 0
        }) {
            const r = ci(t),
                s = n && o;
            let a, l, c;
            for (; t != r.document.body;) l = e(), a = new Mo(t).excludeScrollbarsAndBorders(), c = a.contains(l), s ? t.scrollTop -= a.top - l.top + i : c || (si(l, a) ? t.scrollTop -= a.top - l.top + i : ri(l, a) && (t.scrollTop += n ? l.top - a.top - i : l.bottom - a.bottom + i)), c || (ai(l, a) ? t.scrollLeft -= a.left - l.left + i : li(l, a) && (t.scrollLeft += l.right - a.right + i)), t = t.parentNode
        }

        function ri(t, e) {
            return t.bottom > e.bottom
        }

        function si(t, e) {
            return t.top < e.top
        }

        function ai(t, e) {
            return t.left < e.left
        }

        function li(t, e) {
            return t.right > e.right
        }

        function ci(t) {
            return Vo(t) ? t.startContainer.ownerDocument.defaultView : t.ownerDocument.defaultView
        }

        function di(t) {
            if (Vo(t)) {
                let e = t.commonAncestorContainer;
                return zo(e) && (e = e.parentNode), e
            }
            return t.parentNode
        }

        function hi(t, e) {
            const n = ci(t),
                o = new Mo(t);
            if (n === e) return o;
            {
                let t = n;
                for (; t != e;) {
                    const e = t.frameElement,
                        n = new Mo(e).excludeScrollbarsAndBorders();
                    o.moveBy(n.left, n.top), t = t.parent
                }
            }
            return o
        }
        const ui = {
                ctrl: "⌃",
                cmd: "⌘",
                alt: "⌥",
                shift: "⇧"
            },
            gi = {
                ctrl: "Ctrl+",
                alt: "Alt+",
                shift: "Shift+"
            },
            mi = function() {
                const t = {
                    arrowleft: 37,
                    arrowup: 38,
                    arrowright: 39,
                    arrowdown: 40,
                    backspace: 8,
                    delete: 46,
                    enter: 13,
                    space: 32,
                    esc: 27,
                    tab: 9,
                    ctrl: 1114112,
                    shift: 2228224,
                    alt: 4456448,
                    cmd: 8912896
                };
                for (let e = 65; e <= 90; e++) {
                    t[String.fromCharCode(e).toLowerCase()] = e
                }
                for (let e = 48; e <= 57; e++) t[e - 48] = e;
                for (let e = 112; e <= 123; e++) t["f" + (e - 111)] = e;
                for (const e of "`-=[];',./\\") t[e] = e.charCodeAt(0);
                return t
            }(),
            pi = Object.fromEntries(Object.entries(mi).map((([t, e]) => [e, t.charAt(0).toUpperCase() + t.slice(1)])));

        function fi(t) {
            let e;
            if ("string" == typeof t) {
                if (e = mi[t.toLowerCase()], !e) throw new b("keyboard-unknown-key", null, {
                    key: t
                })
            } else e = t.keyCode + (t.altKey ? mi.alt : 0) + (t.ctrlKey ? mi.ctrl : 0) + (t.shiftKey ? mi.shift : 0) + (t.metaKey ? mi.cmd : 0);
            return e
        }

        function bi(t) {
            return "string" == typeof t && (t = function(t) {
                return t.split("+").map((t => t.trim()))
            }(t)), t.map((t => "string" == typeof t ? function(t) {
                if (t.endsWith("!")) return fi(t.slice(0, -1));
                const e = fi(t);
                return i.isMac && e == mi.ctrl ? mi.cmd : e
            }(t) : t)).reduce(((t, e) => e + t), 0)
        }

        function ki(t) {
            let e = bi(t);
            return Object.entries(i.isMac ? ui : gi).reduce(((t, [n, o]) => (0 != (e & mi[n]) && (e &= ~mi[n], t += o), t)), "") + (e ? pi[e] : "")
        }

        function wi(t, e) {
            const n = "ltr" === e;
            switch (t) {
                case mi.arrowleft:
                    return n ? "left" : "right";
                case mi.arrowright:
                    return n ? "right" : "left";
                case mi.arrowup:
                    return "up";
                case mi.arrowdown:
                    return "down"
            }
        }

        function Ai(t) {
            return Array.isArray(t) ? t : [t]
        }

        function Ci(t, e, n = 1) {
            if ("number" != typeof n) throw new b("translation-service-quantity-not-a-number", null, {
                quantity: n
            });
            const o = Object.keys(Po.window.CKEDITOR_TRANSLATIONS).length;
            1 === o && (t = Object.keys(Po.window.CKEDITOR_TRANSLATIONS)[0]);
            const i = e.id || e.string;
            if (0 === o || ! function(t, e) {
                    return !!Po.window.CKEDITOR_TRANSLATIONS[t] && !!Po.window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
                }(t, i)) return 1 !== n ? e.plural : e.string;
            const r = Po.window.CKEDITOR_TRANSLATIONS[t].dictionary,
                s = Po.window.CKEDITOR_TRANSLATIONS[t].getPluralForm || (t => 1 === t ? 0 : 1),
                a = r[i];
            if ("string" == typeof a) return a;
            return a[Number(s(n))]
        }
        Po.window.CKEDITOR_TRANSLATIONS || (Po.window.CKEDITOR_TRANSLATIONS = {});
        const _i = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"];

        function vi(t) {
            return _i.includes(t) ? "rtl" : "ltr"
        }
        class yi {
            constructor({
                uiLanguage: t = "en",
                contentLanguage: e
            } = {}) {
                this.uiLanguage = t, this.contentLanguage = e || this.uiLanguage, this.uiLanguageDirection = vi(this.uiLanguage), this.contentLanguageDirection = vi(this.contentLanguage), this.t = (t, e) => this._t(t, e)
            }
            get language() {
                return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage
            }
            _t(t, e = []) {
                e = Ai(e), "string" == typeof t && (t = {
                    string: t
                });
                const n = !!t.plural ? e[0] : 1;
                return function(t, e) {
                    return t.replace(/%(\d+)/g, ((t, n) => n < e.length ? e[n] : t))
                }(Ci(this.uiLanguage, t, n), e)
            }
        }
        class xi extends(S()) {
            constructor(t = {}, e = {}) {
                super();
                const n = Q(t);
                if (n || (e = t), this._items = [], this._itemMap = new Map, this._idProperty = e.idProperty || "id", this._bindToExternalToInternalMap = new WeakMap, this._bindToInternalToExternalMap = new WeakMap, this._skippedIndexesFromExternal = [], n)
                    for (const e of t) this._items.push(e), this._itemMap.set(this._getItemIdBeforeAdding(e), e)
            }
            get length() {
                return this._items.length
            }
            get first() {
                return this._items[0] || null
            }
            get last() {
                return this._items[this.length - 1] || null
            }
            add(t, e) {
                return this.addMany([t], e)
            }
            addMany(t, e) {
                if (void 0 === e) e = this._items.length;
                else if (e > this._items.length || e < 0) throw new b("collection-add-item-invalid-index", this);
                let n = 0;
                for (const o of t) {
                    const t = this._getItemIdBeforeAdding(o),
                        i = e + n;
                    this._items.splice(i, 0, o), this._itemMap.set(t, o), this.fire("add", o, i), n++
                }
                return this.fire("change", {
                    added: t,
                    removed: [],
                    index: e
                }), this
            }
            get(t) {
                let e;
                if ("string" == typeof t) e = this._itemMap.get(t);
                else {
                    if ("number" != typeof t) throw new b("collection-get-invalid-arg", this);
                    e = this._items[t]
                }
                return e || null
            }
            has(t) {
                if ("string" == typeof t) return this._itemMap.has(t);
                {
                    const e = t[this._idProperty];
                    return e && this._itemMap.has(e)
                }
            }
            getIndex(t) {
                let e;
                return e = "string" == typeof t ? this._itemMap.get(t) : t, e ? this._items.indexOf(e) : -1
            }
            remove(t) {
                const [e, n] = this._remove(t);
                return this.fire("change", {
                    added: [],
                    removed: [e],
                    index: n
                }), e
            }
            map(t, e) {
                return this._items.map(t, e)
            }
            find(t, e) {
                return this._items.find(t, e)
            }
            filter(t, e) {
                return this._items.filter(t, e)
            }
            clear() {
                this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
                const t = Array.from(this._items);
                for (; this.length;) this._remove(0);
                this.fire("change", {
                    added: [],
                    removed: t,
                    index: 0
                })
            }
            bindTo(t) {
                if (this._bindToCollection) throw new b("collection-bind-to-rebind", this);
                return this._bindToCollection = t, {
                    as: t => {
                        this._setUpBindToBinding((e => new t(e)))
                    },
                    using: t => {
                        "function" == typeof t ? this._setUpBindToBinding(t) : this._setUpBindToBinding((e => e[t]))
                    }
                }
            }
            _setUpBindToBinding(t) {
                const e = this._bindToCollection,
                    n = (n, o, i) => {
                        const r = e._bindToCollection == this,
                            s = e._bindToInternalToExternalMap.get(o);
                        if (r && s) this._bindToExternalToInternalMap.set(o, s), this._bindToInternalToExternalMap.set(s, o);
                        else {
                            const n = t(o);
                            if (!n) return void this._skippedIndexesFromExternal.push(i);
                            let r = i;
                            for (const t of this._skippedIndexesFromExternal) i > t && r--;
                            for (const t of e._skippedIndexesFromExternal) r >= t && r++;
                            this._bindToExternalToInternalMap.set(o, n), this._bindToInternalToExternalMap.set(n, o), this.add(n, r);
                            for (let t = 0; t < e._skippedIndexesFromExternal.length; t++) r <= e._skippedIndexesFromExternal[t] && e._skippedIndexesFromExternal[t]++
                        }
                    };
                for (const t of e) n(0, t, e.getIndex(t));
                this.listenTo(e, "add", n), this.listenTo(e, "remove", ((t, e, n) => {
                    const o = this._bindToExternalToInternalMap.get(e);
                    o && this.remove(o), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce(((t, e) => (n < e && t.push(e - 1), n > e && t.push(e), t)), [])
                }))
            }
            _getItemIdBeforeAdding(t) {
                const e = this._idProperty;
                let n;
                if (e in t) {
                    if (n = t[e], "string" != typeof n) throw new b("collection-add-invalid-id", this);
                    if (this.get(n)) throw new b("collection-add-item-already-exists", this)
                } else t[e] = n = g();
                return n
            }
            _remove(t) {
                let e, n, o, i = !1;
                const r = this._idProperty;
                if ("string" == typeof t ? (n = t, o = this._itemMap.get(n), i = !o, o && (e = this._items.indexOf(o))) : "number" == typeof t ? (e = t, o = this._items[e], i = !o, o && (n = o[r])) : (o = t, n = o[r], e = this._items.indexOf(o), i = -1 == e || !this._itemMap.get(n)), i) throw new b("collection-remove-404", this);
                this._items.splice(e, 1), this._itemMap.delete(n);
                const s = this._bindToInternalToExternalMap.get(o);
                return this._bindToInternalToExternalMap.delete(o), this._bindToExternalToInternalMap.delete(s), this.fire("remove", o, e), [o, e]
            } [Symbol.iterator]() {
                return this._items[Symbol.iterator]()
            }
        }

        function Ei(t) {
            const e = t.next();
            return e.done ? null : e.value
        }
        class Di extends(So(q())) {
            constructor() {
                super(), this._elements = new Set, this._nextEventLoopTimeout = null, this.set("isFocused", !1), this.set("focusedElement", null)
            }
            add(t) {
                if (this._elements.has(t)) throw new b("focustracker-add-element-already-exist", this);
                this.listenTo(t, "focus", (() => this._focus(t)), {
                    useCapture: !0
                }), this.listenTo(t, "blur", (() => this._blur()), {
                    useCapture: !0
                }), this._elements.add(t)
            }
            remove(t) {
                t === this.focusedElement && this._blur(), this._elements.has(t) && (this.stopListening(t), this._elements.delete(t))
            }
            destroy() {
                this.stopListening()
            }
            _focus(t) {
                clearTimeout(this._nextEventLoopTimeout), this.focusedElement = t, this.isFocused = !0
            }
            _blur() {
                clearTimeout(this._nextEventLoopTimeout), this._nextEventLoopTimeout = setTimeout((() => {
                    this.focusedElement = null, this.isFocused = !1
                }), 0)
            }
        }
        class Si {
            constructor() {
                this._listener = new(So())
            }
            listenTo(t) {
                this._listener.listenTo(t, "keydown", ((t, e) => {
                    this._listener.fire("_keydown:" + fi(e), e)
                }))
            }
            set(t, e, n = {}) {
                const o = bi(t),
                    i = n.priority;
                this._listener.listenTo(this._listener, "_keydown:" + o, ((t, n) => {
                    e(n, (() => {
                        n.preventDefault(), n.stopPropagation(), t.stop()
                    })), t.return = !0
                }), {
                    priority: i
                })
            }
            press(t) {
                return !!this._listener.fire("_keydown:" + fi(t), t)
            }
            stopListening(t) {
                this._listener.stopListening(t)
            }
            destroy() {
                this.stopListening()
            }
        }

        function Ti(t) {
            return Q(t) ? new Map(t) : function(t) {
                const e = new Map;
                for (const n in t) e.set(n, t[n]);
                return e
            }(t)
        }

        function Bi(t, e) {
            let n;

            function o(...i) {
                o.cancel(), n = setTimeout((() => t(...i)), e)
            }
            return o.cancel = () => {
                clearTimeout(n)
            }, o
        }

        function Ii(t, e) {
            return !!(n = t.charAt(e - 1)) && 1 == n.length && /[\ud800-\udbff]/.test(n) && function(t) {
                return !!t && 1 == t.length && /[\udc00-\udfff]/.test(t)
            }(t.charAt(e));
            var n
        }

        function Pi(t, e) {
            return !!(n = t.charAt(e)) && 1 == n.length && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(n);
            var n
        }
        const Ri = function() {
            const t = [new RegExp("\\p{Emoji}[\\u{E0020}-\\u{E007E}]+\\u{E007F}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}?\\u{20E3}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}", "u"), new RegExp("(?=\\p{General_Category=Other_Symbol})\\p{Emoji}\\p{Emoji_Modifier}*", "u")],
                e = new RegExp("\\p{Regional_Indicator}{2}", "u").source,
                n = "(?:" + t.map((t => t.source)).join("|") + ")";
            return new RegExp(`${e}|${n}(?:‍${n})*`, "ug")
        }();

        function zi(t, e) {
            const n = String(t).matchAll(Ri);
            return Array.from(n).some((t => t.index < e && e < t.index + t[0].length))
        }
        class Vi extends(q()) {
            constructor(t) {
                super(), this._disableStack = new Set, this.editor = t, this.set("isEnabled", !0)
            }
            forceDisabled(t) {
                this._disableStack.add(t), 1 == this._disableStack.size && (this.on("set:isEnabled", Oi, {
                    priority: "highest"
                }), this.isEnabled = !1)
            }
            clearForceDisabled(t) {
                this._disableStack.delete(t), 0 == this._disableStack.size && (this.off("set:isEnabled", Oi), this.isEnabled = !0)
            }
            destroy() {
                this.stopListening()
            }
            static get isContextPlugin() {
                return !1
            }
        }

        function Oi(t) {
            t.return = !1, t.stop()
        }
        class Fi extends(q()) {
            constructor(t) {
                super(), this.editor = t, this.set("value", void 0), this.set("isEnabled", !1), this._affectsData = !0, this._isEnabledBasedOnSelection = !0, this._disableStack = new Set, this.decorate("execute"), this.listenTo(this.editor.model.document, "change", (() => {
                    this.refresh()
                })), this.listenTo(t, "change:isReadOnly", (() => {
                    this.refresh()
                })), this.on("set:isEnabled", (e => {
                    this.affectsData && (t.isReadOnly || this._isEnabledBasedOnSelection && !t.model.canEditAt(t.model.document.selection)) && (e.return = !1, e.stop())
                }), {
                    priority: "highest"
                }), this.on("execute", (t => {
                    this.isEnabled || t.stop()
                }), {
                    priority: "high"
                })
            }
            get affectsData() {
                return this._affectsData
            }
            set affectsData(t) {
                this._affectsData = t
            }
            refresh() {
                this.isEnabled = !0
            }
            forceDisabled(t) {
                this._disableStack.add(t), 1 == this._disableStack.size && (this.on("set:isEnabled", Mi, {
                    priority: "highest"
                }), this.isEnabled = !1)
            }
            clearForceDisabled(t) {
                this._disableStack.delete(t), 0 == this._disableStack.size && (this.off("set:isEnabled", Mi), this.refresh())
            }
            execute(...t) {}
            destroy() {
                this.stopListening()
            }
        }

        function Mi(t) {
            t.return = !1, t.stop()
        }
        class Ni extends Fi {
            constructor() {
                super(...arguments), this._childCommandsDefinitions = []
            }
            refresh() {}
            execute(...t) {
                const e = this._getFirstEnabledCommand();
                return !!e && e.execute(t)
            }
            registerChildCommand(t, e = {}) {
                p(this._childCommandsDefinitions, {
                    command: t,
                    priority: e.priority || "normal"
                }), t.on("change:isEnabled", (() => this._checkEnabled())), this._checkEnabled()
            }
            _checkEnabled() {
                this.isEnabled = !!this._getFirstEnabledCommand()
            }
            _getFirstEnabledCommand() {
                const t = this._childCommandsDefinitions.find((({
                    command: t
                }) => t.isEnabled));
                return t && t.command
            }
        }
        class Li extends(S()) {
            constructor(t, e = [], n = []) {
                super(), this._plugins = new Map, this._context = t, this._availablePlugins = new Map;
                for (const t of e) t.pluginName && this._availablePlugins.set(t.pluginName, t);
                this._contextPlugins = new Map;
                for (const [t, e] of n) this._contextPlugins.set(t, e), this._contextPlugins.set(e, t), t.pluginName && this._availablePlugins.set(t.pluginName, t)
            }*[Symbol.iterator]() {
                for (const t of this._plugins) "function" == typeof t[0] && (yield t)
            }
            get(t) {
                const e = this._plugins.get(t);
                if (!e) {
                    let e = t;
                    throw "function" == typeof t && (e = t.pluginName || t.name), new b("plugincollection-plugin-not-loaded", this._context, {
                        plugin: e
                    })
                }
                return e
            }
            has(t) {
                return this._plugins.has(t)
            }
            init(t, e = [], n = []) {
                const o = this,
                    i = this._context;
                ! function t(e, n = new Set) {
                    e.forEach((e => {
                        a(e) && (n.has(e) || (n.add(e), e.pluginName && !o._availablePlugins.has(e.pluginName) && o._availablePlugins.set(e.pluginName, e), e.requires && t(e.requires, n)))
                    }))
                }(t), h(t);
                const r = [... function t(e, n = new Set) {
                    return e.map((t => a(t) ? t : o._availablePlugins.get(t))).reduce(((e, o) => n.has(o) ? e : (n.add(o), o.requires && (h(o.requires, o), t(o.requires, n).forEach((t => e.add(t)))), e.add(o))), new Set)
                }(t.filter((t => !c(t, e))))];
                ! function(t, e) {
                    for (const n of e) {
                        if ("function" != typeof n) throw new b("plugincollection-replace-plugin-invalid-type", null, {
                            pluginItem: n
                        });
                        const e = n.pluginName;
                        if (!e) throw new b("plugincollection-replace-plugin-missing-name", null, {
                            pluginItem: n
                        });
                        if (n.requires && n.requires.length) throw new b("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, {
                            pluginName: e
                        });
                        const i = o._availablePlugins.get(e);
                        if (!i) throw new b("plugincollection-plugin-for-replacing-not-exist", null, {
                            pluginName: e
                        });
                        const r = t.indexOf(i);
                        if (-1 === r) {
                            if (o._contextPlugins.has(i)) return;
                            throw new b("plugincollection-plugin-for-replacing-not-loaded", null, {
                                pluginName: e
                            })
                        }
                        if (i.requires && i.requires.length) throw new b("plugincollection-replaced-plugin-cannot-have-dependencies", null, {
                            pluginName: e
                        });
                        t.splice(r, 1, n), o._availablePlugins.set(e, n)
                    }
                }(r, n);
                const s = r.map((t => {
                    let e = o._contextPlugins.get(t);
                    return e = e || new t(i), o._add(t, e), e
                }));
                return u(s, "init").then((() => u(s, "afterInit"))).then((() => s));

                function a(t) {
                    return "function" == typeof t
                }

                function l(t) {
                    return a(t) && !!t.isContextPlugin
                }

                function c(t, e) {
                    return e.some((e => e === t || (d(t) === e || d(e) === t)))
                }

                function d(t) {
                    return a(t) ? t.pluginName || t.name : t
                }

                function h(t, n = null) {
                    t.map((t => a(t) ? t : o._availablePlugins.get(t) || t)).forEach((t => {
                        ! function(t, e) {
                            if (a(t)) return;
                            if (e) throw new b("plugincollection-soft-required", i, {
                                missingPlugin: t,
                                requiredBy: d(e)
                            });
                            throw new b("plugincollection-plugin-not-found", i, {
                                plugin: t
                            })
                        }(t, n),
                        function(t, e) {
                            if (!l(e)) return;
                            if (l(t)) return;
                            throw new b("plugincollection-context-required", i, {
                                plugin: d(t),
                                requiredBy: d(e)
                            })
                        }(t, n),
                        function(t, n) {
                            if (!n) return;
                            if (!c(t, e)) return;
                            throw new b("plugincollection-required", i, {
                                plugin: d(t),
                                requiredBy: d(n)
                            })
                        }(t, n)
                    }))
                }

                function u(t, e) {
                    return t.reduce(((t, n) => n[e] ? o._contextPlugins.has(n) ? t : t.then(n[e].bind(n)) : t), Promise.resolve())
                }
            }
            destroy() {
                const t = [];
                for (const [, e] of this) "function" != typeof e.destroy || this._contextPlugins.has(e) || t.push(e.destroy());
                return Promise.all(t)
            }
            _add(t, e) {
                this._plugins.set(t, e);
                const n = t.pluginName;
                if (n) {
                    if (this._plugins.has(n)) throw new b("plugincollection-plugin-name-conflict", null, {
                        pluginName: n,
                        plugin1: this._plugins.get(n).constructor,
                        plugin2: t
                    });
                    this._plugins.set(n, e)
                }
            }
        }
        class Hi {
            constructor(t) {
                this._contextOwner = null, this.config = new _o(t, this.constructor.defaultConfig);
                const e = this.constructor.builtinPlugins;
                this.config.define("plugins", e), this.plugins = new Li(this, e);
                const n = this.config.get("language") || {};
                this.locale = new yi({
                    uiLanguage: "string" == typeof n ? n : n.ui,
                    contentLanguage: this.config.get("language.content")
                }), this.t = this.locale.t, this.editors = new xi
            }
            initPlugins() {
                const t = this.config.get("plugins") || [],
                    e = this.config.get("substitutePlugins") || [];
                for (const n of t.concat(e)) {
                    if ("function" != typeof n) throw new b("context-initplugins-constructor-only", null, {
                        Plugin: n
                    });
                    if (!0 !== n.isContextPlugin) throw new b("context-initplugins-invalid-plugin", null, {
                        Plugin: n
                    })
                }
                return this.plugins.init(t, [], e)
            }
            destroy() {
                return Promise.all(Array.from(this.editors, (t => t.destroy()))).then((() => this.plugins.destroy()))
            }
            _addEditor(t, e) {
                if (this._contextOwner) throw new b("context-addeditor-private-context");
                this.editors.add(t), e && (this._contextOwner = t)
            }
            _removeEditor(t) {
                return this.editors.has(t) && this.editors.remove(t), this._contextOwner === t ? this.destroy() : Promise.resolve()
            }
            _getEditorConfig() {
                const t = {};
                for (const e of this.config.names())["plugins", "removePlugins", "extraPlugins"].includes(e) || (t[e] = this.config.get(e));
                return t
            }
            static create(t) {
                return new Promise((e => {
                    const n = new this(t);
                    e(n.initPlugins().then((() => n)))
                }))
            }
        }
        class ji extends(q()) {
            constructor(t) {
                super(), this.context = t
            }
            destroy() {
                this.stopListening()
            }
            static get isContextPlugin() {
                return !0
            }
        }
        class qi extends Si {
            constructor(t) {
                super(), this.editor = t
            }
            set(t, e, n = {}) {
                if ("string" == typeof e) {
                    const t = e;
                    e = (e, n) => {
                        this.editor.execute(t), n()
                    }
                }
                super.set(t, e, n)
            }
        }
        var Wi = n(6062),
            Ui = n.n(Wi),
            $i = n(4717),
            Gi = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()($i.Z, Gi);
        $i.Z.locals;
        const Ki = new WeakMap;

        function Zi({
            view: t,
            element: e,
            text: n,
            isDirectHost: o = !0,
            keepOnFocus: i = !1
        }) {
            const r = t.document;
            Ki.has(r) || (Ki.set(r, new Map), r.registerPostFixer((t => Yi(r, t))), r.on("change:isComposing", (() => {
                t.change((t => Yi(r, t)))
            }), {
                priority: "high"
            })), Ki.get(r).set(e, {
                text: n,
                isDirectHost: o,
                keepOnFocus: i,
                hostElement: o ? e : null
            }), t.change((t => Yi(r, t)))
        }

        function Ji(t, e) {
            return !!e.hasClass("ck-placeholder") && (t.removeClass("ck-placeholder", e), !0)
        }

        function Yi(t, e) {
            const n = Ki.get(t),
                o = [];
            let i = !1;
            for (const [t, r] of n) r.isDirectHost && (o.push(t), Qi(e, t, r) && (i = !0));
            for (const [t, r] of n) {
                if (r.isDirectHost) continue;
                const n = Xi(t);
                n && (o.includes(n) || (r.hostElement = n, Qi(e, t, r) && (i = !0)))
            }
            return i
        }

        function Qi(t, e, n) {
            const {
                text: o,
                isDirectHost: i,
                hostElement: r
            } = n;
            let s = !1;
            r.getAttribute("data-placeholder") !== o && (t.setAttribute("data-placeholder", o, r), s = !0);
            return (i || 1 == e.childCount) && function(t, e) {
                if (!t.isAttached()) return !1;
                if (Array.from(t.getChildren()).some((t => !t.is("uiElement")))) return !1;
                const n = t.document,
                    o = n.selection.anchor;
                return !(n.isComposing && o && o.parent === t || !e && n.isFocused && (!o || o.parent === t))
            }(r, n.keepOnFocus) ? function(t, e) {
                return !e.hasClass("ck-placeholder") && (t.addClass("ck-placeholder", e), !0)
            }(t, r) && (s = !0) : Ji(t, r) && (s = !0), s
        }

        function Xi(t) {
            if (t.childCount) {
                const e = t.getChild(0);
                if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement")) return e
            }
            return null
        }
        class tr {
            is() {
                throw new Error("is() method is abstract")
            }
        }
        const er = function(t) {
            return wo(t, 4)
        };
        class nr extends(S(tr)) {
            constructor(t) {
                super(), this.document = t, this.parent = null
            }
            get index() {
                let t;
                if (!this.parent) return null;
                if (-1 == (t = this.parent.getChildIndex(this))) throw new b("view-node-not-found-in-parent", this);
                return t
            }
            get nextSibling() {
                const t = this.index;
                return null !== t && this.parent.getChild(t + 1) || null
            }
            get previousSibling() {
                const t = this.index;
                return null !== t && this.parent.getChild(t - 1) || null
            }
            get root() {
                let t = this;
                for (; t.parent;) t = t.parent;
                return t
            }
            isAttached() {
                return this.root.is("rootElement")
            }
            getPath() {
                const t = [];
                let e = this;
                for (; e.parent;) t.unshift(e.index), e = e.parent;
                return t
            }
            getAncestors(t = {}) {
                const e = [];
                let n = t.includeSelf ? this : this.parent;
                for (; n;) e[t.parentFirst ? "push" : "unshift"](n), n = n.parent;
                return e
            }
            getCommonAncestor(t, e = {}) {
                const n = this.getAncestors(e),
                    o = t.getAncestors(e);
                let i = 0;
                for (; n[i] == o[i] && n[i];) i++;
                return 0 === i ? null : n[i - 1]
            }
            isBefore(t) {
                if (this == t) return !1;
                if (this.root !== t.root) return !1;
                const e = this.getPath(),
                    n = t.getPath(),
                    o = Y(e, n);
                switch (o) {
                    case "prefix":
                        return !0;
                    case "extension":
                        return !1;
                    default:
                        return e[o] < n[o]
                }
            }
            isAfter(t) {
                return this != t && (this.root === t.root && !this.isBefore(t))
            }
            _remove() {
                this.parent._removeChildren(this.index)
            }
            _fireChange(t, e) {
                this.fire(`change:${t}`, e), this.parent && this.parent._fireChange(t, e)
            }
            toJSON() {
                const t = er(this);
                return delete t.parent, t
            }
        }
        nr.prototype.is = function(t) {
            return "node" === t || "view:node" === t
        };
        class or extends nr {
            constructor(t, e) {
                super(t), this._textData = e
            }
            get data() {
                return this._textData
            }
            get _data() {
                return this.data
            }
            set _data(t) {
                this._fireChange("text", this), this._textData = t
            }
            isSimilar(t) {
                return t instanceof or && (this === t || this.data === t.data)
            }
            _clone() {
                return new or(this.document, this.data)
            }
        }
        or.prototype.is = function(t) {
            return "$text" === t || "view:$text" === t || "text" === t || "view:text" === t || "node" === t || "view:node" === t
        };
        class ir extends tr {
            constructor(t, e, n) {
                if (super(), this.textNode = t, e < 0 || e > t.data.length) throw new b("view-textproxy-wrong-offsetintext", this);
                if (n < 0 || e + n > t.data.length) throw new b("view-textproxy-wrong-length", this);
                this.data = t.data.substring(e, e + n), this.offsetInText = e
            }
            get offsetSize() {
                return this.data.length
            }
            get isPartial() {
                return this.data.length !== this.textNode.data.length
            }
            get parent() {
                return this.textNode.parent
            }
            get root() {
                return this.textNode.root
            }
            get document() {
                return this.textNode.document
            }
            getAncestors(t = {}) {
                const e = [];
                let n = t.includeSelf ? this.textNode : this.parent;
                for (; null !== n;) e[t.parentFirst ? "push" : "unshift"](n), n = n.parent;
                return e
            }
        }
        ir.prototype.is = function(t) {
            return "$textProxy" === t || "view:$textProxy" === t || "textProxy" === t || "view:textProxy" === t
        };
        class rr {
            constructor(...t) {
                this._patterns = [], this.add(...t)
            }
            add(...t) {
                for (let e of t)("string" == typeof e || e instanceof RegExp) && (e = {
                    name: e
                }), this._patterns.push(e)
            }
            match(...t) {
                for (const e of t)
                    for (const t of this._patterns) {
                        const n = sr(e, t);
                        if (n) return {
                            element: e,
                            pattern: t,
                            match: n
                        }
                    }
                return null
            }
            matchAll(...t) {
                const e = [];
                for (const n of t)
                    for (const t of this._patterns) {
                        const o = sr(n, t);
                        o && e.push({
                            element: n,
                            pattern: t,
                            match: o
                        })
                    }
                return e.length > 0 ? e : null
            }
            getElementName() {
                if (1 !== this._patterns.length) return null;
                const t = this._patterns[0],
                    e = t.name;
                return "function" == typeof t || !e || e instanceof RegExp ? null : e
            }
        }

        function sr(t, e) {
            if ("function" == typeof e) return e(t);
            const n = {};
            return e.name && (n.name = function(t, e) {
                if (t instanceof RegExp) return !!e.match(t);
                return t === e
            }(e.name, t.name), !n.name) || e.attributes && (n.attributes = function(t, e) {
                const n = new Set(e.getAttributeKeys());
                vt(t) ? (void 0 !== t.style && k("matcher-pattern-deprecated-attributes-style-key", t), void 0 !== t.class && k("matcher-pattern-deprecated-attributes-class-key", t)) : (n.delete("style"), n.delete("class"));
                return ar(t, n, (t => e.getAttribute(t)))
            }(e.attributes, t), !n.attributes) || e.classes && (n.classes = function(t, e) {
                return ar(t, e.getClassNames(), (() => {}))
            }(e.classes, t), !n.classes) || e.styles && (n.styles = function(t, e) {
                return ar(t, e.getStyleNames(!0), (t => e.getStyle(t)))
            }(e.styles, t), !n.styles) ? null : n
        }

        function ar(t, e, n) {
            const o = function(t) {
                    if (Array.isArray(t)) return t.map((t => vt(t) ? (void 0 !== t.key && void 0 !== t.value || k("matcher-pattern-missing-key-or-value", t), [t.key, t.value]) : [t, !0]));
                    if (vt(t)) return Object.entries(t);
                    return [
                        [t, !0]
                    ]
                }(t),
                i = Array.from(e),
                r = [];
            if (o.forEach((([t, e]) => {
                    i.forEach((o => {
                        (function(t, e) {
                            return !0 === t || t === e || t instanceof RegExp && e.match(t)
                        })(t, o) && function(t, e, n) {
                            if (!0 === t) return !0;
                            const o = n(e);
                            return t === o || t instanceof RegExp && !!String(o).match(t)
                        }(e, o, n) && r.push(o)
                    }))
                })), o.length && !(r.length < o.length)) return r
        }
        const lr = function(t) {
            return "symbol" == typeof t || gt(t) && "[object Symbol]" == ht(t)
        };
        var cr = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            dr = /^\w*$/;
        const hr = function(t, e) {
            if (ut(t)) return !1;
            var n = typeof t;
            return !("number" != n && "symbol" != n && "boolean" != n && null != t && !lr(t)) || (dr.test(t) || !cr.test(t) || null != e && t in Object(e))
        };

        function ur(t, e) {
            if ("function" != typeof t || null != e && "function" != typeof e) throw new TypeError("Expected a function");
            var n = function() {
                var o = arguments,
                    i = e ? e.apply(this, o) : o[0],
                    r = n.cache;
                if (r.has(i)) return r.get(i);
                var s = t.apply(this, o);
                return n.cache = r.set(i, s) || r, s
            };
            return n.cache = new(ur.Cache || ke), n
        }
        ur.Cache = ke;
        const gr = ur;
        const mr = function(t) {
            var e = gr(t, (function(t) {
                    return 500 === n.size && n.clear(), t
                })),
                n = e.cache;
            return e
        };
        var pr = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
            fr = /\\(\\)?/g,
            br = mr((function(t) {
                var e = [];
                return 46 === t.charCodeAt(0) && e.push(""), t.replace(pr, (function(t, n, o, i) {
                    e.push(o ? i.replace(fr, "$1") : n || t)
                })), e
            }));
        const kr = br;
        const wr = function(t, e) {
            for (var n = -1, o = null == t ? 0 : t.length, i = Array(o); ++n < o;) i[n] = e(t[n], n, t);
            return i
        };
        var Ar = nt ? nt.prototype : void 0,
            Cr = Ar ? Ar.toString : void 0;
        const _r = function t(e) {
            if ("string" == typeof e) return e;
            if (ut(e)) return wr(e, t) + "";
            if (lr(e)) return Cr ? Cr.call(e) : "";
            var n = e + "";
            return "0" == n && 1 / e == -Infinity ? "-0" : n
        };
        const vr = function(t) {
            return null == t ? "" : _r(t)
        };
        const yr = function(t, e) {
            return ut(t) ? t : hr(t, e) ? [t] : kr(vr(t))
        };
        const xr = function(t) {
            var e = null == t ? 0 : t.length;
            return e ? t[e - 1] : void 0
        };
        const Er = function(t) {
            if ("string" == typeof t || lr(t)) return t;
            var e = t + "";
            return "0" == e && 1 / t == -Infinity ? "-0" : e
        };
        const Dr = function(t, e) {
            for (var n = 0, o = (e = yr(e, t)).length; null != t && n < o;) t = t[Er(e[n++])];
            return n && n == o ? t : void 0
        };
        const Sr = function(t, e, n) {
            var o = -1,
                i = t.length;
            e < 0 && (e = -e > i ? 0 : i + e), (n = n > i ? i : n) < 0 && (n += i), i = e > n ? 0 : n - e >>> 0, e >>>= 0;
            for (var r = Array(i); ++o < i;) r[o] = t[o + e];
            return r
        };
        const Tr = function(t, e) {
            return e.length < 2 ? t : Dr(t, Sr(e, 0, -1))
        };
        const Br = function(t, e) {
            return e = yr(e, t), null == (t = Tr(t, e)) || delete t[Er(xr(e))]
        };
        const Ir = function(t, e) {
            return null == t || Br(t, e)
        };
        const Pr = function(t, e, n) {
            var o = null == t ? void 0 : Dr(t, e);
            return void 0 === o ? n : o
        };
        const Rr = function(t, e, n) {
            (void 0 !== n && !xt(t[e], n) || void 0 === n && !(e in t)) && ye(t, e, n)
        };
        const zr = function(t) {
            return function(e, n, o) {
                for (var i = -1, r = Object(e), s = o(e), a = s.length; a--;) {
                    var l = s[t ? a : ++i];
                    if (!1 === n(r[l], l, r)) break
                }
                return e
            }
        }();
        const Vr = function(t) {
            return gt(t) && rn(t)
        };
        const Or = function(t, e) {
            if (("constructor" !== e || "function" != typeof t[e]) && "__proto__" != e) return t[e]
        };
        const Fr = function(t) {
            return De(t, hn(t))
        };
        const Mr = function(t, e, n, o, i, r, s) {
            var a = Or(t, n),
                l = Or(e, n),
                c = s.get(l);
            if (c) Rr(t, n, c);
            else {
                var d = r ? r(a, l, n + "", t, e, s) : void 0,
                    h = void 0 === d;
                if (h) {
                    var u = ut(l),
                        g = !u && Me(l),
                        m = !u && !g && Je(l);
                    d = l, u || g || m ? ut(a) ? d = a : Vr(a) ? d = kn(a) : g ? (h = !1, d = bn(l, !0)) : m ? (h = !1, d = oo(l, !0)) : d = [] : vt(l) || Re(l) ? (d = a, Re(a) ? d = Fr(a) : O(a) && !Mt(a) || (d = ao(l))) : h = !1
                }
                h && (s.set(l, d), i(d, l, o, r, s), s.delete(l)), Rr(t, n, d)
            }
        };
        const Nr = function t(e, n, o, i, r) {
            e !== n && zr(n, (function(s, a) {
                if (r || (r = new Ce), O(s)) Mr(e, n, a, o, t, i, r);
                else {
                    var l = i ? i(Or(e, a), s, a + "", e, n, r) : void 0;
                    void 0 === l && (l = s), Rr(e, a, l)
                }
            }), hn)
        };
        const Lr = function(t) {
            return t
        };
        const Hr = function(t, e, n) {
            switch (n.length) {
                case 0:
                    return t.call(e);
                case 1:
                    return t.call(e, n[0]);
                case 2:
                    return t.call(e, n[0], n[1]);
                case 3:
                    return t.call(e, n[0], n[1], n[2])
            }
            return t.apply(e, n)
        };
        var jr = Math.max;
        const qr = function(t, e, n) {
            return e = jr(void 0 === e ? t.length - 1 : e, 0),
                function() {
                    for (var o = arguments, i = -1, r = jr(o.length - e, 0), s = Array(r); ++i < r;) s[i] = o[e + i];
                    i = -1;
                    for (var a = Array(e + 1); ++i < e;) a[i] = o[i];
                    return a[e] = n(s), Hr(t, this, a)
                }
        };
        const Wr = function(t) {
            return function() {
                return t
            }
        };
        const Ur = ve ? function(t, e) {
            return ve(t, "toString", {
                configurable: !0,
                enumerable: !1,
                value: Wr(e),
                writable: !0
            })
        } : Lr;
        var $r = Date.now;
        const Gr = function(t) {
            var e = 0,
                n = 0;
            return function() {
                var o = $r(),
                    i = 16 - (o - n);
                if (n = o, i > 0) {
                    if (++e >= 800) return arguments[0]
                } else e = 0;
                return t.apply(void 0, arguments)
            }
        };
        const Kr = Gr(Ur);
        const Zr = function(t, e) {
            return Kr(qr(t, e, Lr), t + "")
        };
        const Jr = function(t, e, n) {
            if (!O(n)) return !1;
            var o = typeof e;
            return !!("number" == o ? rn(n) && Le(e, n.length) : "string" == o && e in n) && xt(n[e], t)
        };
        const Yr = function(t) {
            return Zr((function(e, n) {
                var o = -1,
                    i = n.length,
                    r = i > 1 ? n[i - 1] : void 0,
                    s = i > 2 ? n[2] : void 0;
                for (r = t.length > 3 && "function" == typeof r ? (i--, r) : void 0, s && Jr(n[0], n[1], s) && (r = i < 3 ? void 0 : r, i = 1), e = Object(e); ++o < i;) {
                    var a = n[o];
                    a && t(e, a, o, r)
                }
                return e
            }))
        };
        const Qr = Yr((function(t, e, n) {
            Nr(t, e, n)
        }));
        const Xr = function(t, e, n, o) {
            if (!O(t)) return t;
            for (var i = -1, r = (e = yr(e, t)).length, s = r - 1, a = t; null != a && ++i < r;) {
                var l = Er(e[i]),
                    c = n;
                if ("__proto__" === l || "constructor" === l || "prototype" === l) return t;
                if (i != s) {
                    var d = a[l];
                    void 0 === (c = o ? o(d, l, a) : void 0) && (c = O(d) ? d : Le(e[i + 1]) ? [] : {})
                }
                Ee(a, l, c), a = a[l]
            }
            return t
        };
        const ts = function(t, e, n) {
            return null == t ? t : Xr(t, e, n)
        };
        class es {
            constructor(t) {
                this._styles = {}, this._styleProcessor = t
            }
            get isEmpty() {
                const t = Object.entries(this._styles);
                return !Array.from(t).length
            }
            get size() {
                return this.isEmpty ? 0 : this.getStyleNames().length
            }
            setTo(t) {
                this.clear();
                const e = Array.from(function(t) {
                    let e = null,
                        n = 0,
                        o = 0,
                        i = null;
                    const r = new Map;
                    if ("" === t) return r;
                    ";" != t.charAt(t.length - 1) && (t += ";");
                    for (let s = 0; s < t.length; s++) {
                        const a = t.charAt(s);
                        if (null === e) switch (a) {
                            case ":":
                                i || (i = t.substr(n, s - n), o = s + 1);
                                break;
                            case '"':
                            case "'":
                                e = a;
                                break;
                            case ";": {
                                const e = t.substr(o, s - o);
                                i && r.set(i.trim(), e.trim()), i = null, n = s + 1;
                                break
                            }
                        } else a === e && (e = null)
                    }
                    return r
                }(t).entries());
                for (const [t, n] of e) this._styleProcessor.toNormalizedForm(t, n, this._styles)
            }
            has(t) {
                if (this.isEmpty) return !1;
                const e = this._styleProcessor.getReducedForm(t, this._styles).find((([e]) => e === t));
                return Array.isArray(e)
            }
            set(t, e) {
                if (O(t))
                    for (const [e, n] of Object.entries(t)) this._styleProcessor.toNormalizedForm(e, n, this._styles);
                else this._styleProcessor.toNormalizedForm(t, e, this._styles)
            }
            remove(t) {
                const e = os(t);
                Ir(this._styles, e), delete this._styles[t], this._cleanEmptyObjectsOnPath(e)
            }
            getNormalized(t) {
                return this._styleProcessor.getNormalized(t, this._styles)
            }
            toString() {
                return this.isEmpty ? "" : this._getStylesEntries().map((t => t.join(":"))).sort().join(";") + ";"
            }
            getAsString(t) {
                if (this.isEmpty) return;
                if (this._styles[t] && !O(this._styles[t])) return this._styles[t];
                const e = this._styleProcessor.getReducedForm(t, this._styles).find((([e]) => e === t));
                return Array.isArray(e) ? e[1] : void 0
            }
            getStyleNames(t = !1) {
                if (this.isEmpty) return [];
                if (t) return this._styleProcessor.getStyleNames(this._styles);
                return this._getStylesEntries().map((([t]) => t))
            }
            clear() {
                this._styles = {}
            }
            _getStylesEntries() {
                const t = [],
                    e = Object.keys(this._styles);
                for (const n of e) t.push(...this._styleProcessor.getReducedForm(n, this._styles));
                return t
            }
            _cleanEmptyObjectsOnPath(t) {
                const e = t.split(".");
                if (!(e.length > 1)) return;
                const n = e.splice(0, e.length - 1).join("."),
                    o = Pr(this._styles, n);
                if (!o) return;
                !Array.from(Object.keys(o)).length && this.remove(n)
            }
        }
        class ns {
            constructor() {
                this._normalizers = new Map, this._extractors = new Map, this._reducers = new Map, this._consumables = new Map
            }
            toNormalizedForm(t, e, n) {
                if (O(e)) is(n, os(t), e);
                else if (this._normalizers.has(t)) {
                    const o = this._normalizers.get(t),
                        {
                            path: i,
                            value: r
                        } = o(e);
                    is(n, i, r)
                } else is(n, t, e)
            }
            getNormalized(t, e) {
                if (!t) return Qr({}, e);
                if (void 0 !== e[t]) return e[t];
                if (this._extractors.has(t)) {
                    const n = this._extractors.get(t);
                    if ("string" == typeof n) return Pr(e, n);
                    const o = n(t, e);
                    if (o) return o
                }
                return Pr(e, os(t))
            }
            getReducedForm(t, e) {
                const n = this.getNormalized(t, e);
                if (void 0 === n) return [];
                if (this._reducers.has(t)) {
                    return this._reducers.get(t)(n)
                }
                return [
                    [t, n]
                ]
            }
            getStyleNames(t) {
                const e = Array.from(this._consumables.keys()).filter((e => {
                        const n = this.getNormalized(e, t);
                        return n && "object" == typeof n ? Object.keys(n).length : n
                    })),
                    n = new Set([...e, ...Object.keys(t)]);
                return Array.from(n.values())
            }
            getRelatedStyles(t) {
                return this._consumables.get(t) || []
            }
            setNormalizer(t, e) {
                this._normalizers.set(t, e)
            }
            setExtractor(t, e) {
                this._extractors.set(t, e)
            }
            setReducer(t, e) {
                this._reducers.set(t, e)
            }
            setStyleRelation(t, e) {
                this._mapStyleNames(t, e);
                for (const n of e) this._mapStyleNames(n, [t])
            }
            _mapStyleNames(t, e) {
                this._consumables.has(t) || this._consumables.set(t, []), this._consumables.get(t).push(...e)
            }
        }

        function os(t) {
            return t.replace("-", ".")
        }

        function is(t, e, n) {
            let o = n;
            O(n) && (o = Qr({}, Pr(t, e), n)), ts(t, e, o)
        }
        class rs extends nr {
            constructor(t, e, n, o) {
                if (super(t), this._unsafeAttributesToRender = [], this._customProperties = new Map, this.name = e, this._attrs = function(t) {
                        const e = Ti(t);
                        for (const [t, n] of e) null === n ? e.delete(t) : "string" != typeof n && e.set(t, String(n));
                        return e
                    }(n), this._children = [], o && this._insertChild(0, o), this._classes = new Set, this._attrs.has("class")) {
                    const t = this._attrs.get("class");
                    ss(this._classes, t), this._attrs.delete("class")
                }
                this._styles = new es(this.document.stylesProcessor), this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")), this._attrs.delete("style"))
            }
            get childCount() {
                return this._children.length
            }
            get isEmpty() {
                return 0 === this._children.length
            }
            getChild(t) {
                return this._children[t]
            }
            getChildIndex(t) {
                return this._children.indexOf(t)
            }
            getChildren() {
                return this._children[Symbol.iterator]()
            }* getAttributeKeys() {
                this._classes.size > 0 && (yield "class"), this._styles.isEmpty || (yield "style"), yield* this._attrs.keys()
            }* getAttributes() {
                yield* this._attrs.entries(), this._classes.size > 0 && (yield ["class", this.getAttribute("class")]), this._styles.isEmpty || (yield ["style", this.getAttribute("style")])
            }
            getAttribute(t) {
                if ("class" == t) return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
                if ("style" == t) {
                    const t = this._styles.toString();
                    return "" == t ? void 0 : t
                }
                return this._attrs.get(t)
            }
            hasAttribute(t) {
                return "class" == t ? this._classes.size > 0 : "style" == t ? !this._styles.isEmpty : this._attrs.has(t)
            }
            isSimilar(t) {
                if (!(t instanceof rs)) return !1;
                if (this === t) return !0;
                if (this.name != t.name) return !1;
                if (this._attrs.size !== t._attrs.size || this._classes.size !== t._classes.size || this._styles.size !== t._styles.size) return !1;
                for (const [e, n] of this._attrs)
                    if (!t._attrs.has(e) || t._attrs.get(e) !== n) return !1;
                for (const e of this._classes)
                    if (!t._classes.has(e)) return !1;
                for (const e of this._styles.getStyleNames())
                    if (!t._styles.has(e) || t._styles.getAsString(e) !== this._styles.getAsString(e)) return !1;
                return !0
            }
            hasClass(...t) {
                for (const e of t)
                    if (!this._classes.has(e)) return !1;
                return !0
            }
            getClassNames() {
                return this._classes.keys()
            }
            getStyle(t) {
                return this._styles.getAsString(t)
            }
            getNormalizedStyle(t) {
                return this._styles.getNormalized(t)
            }
            getStyleNames(t) {
                return this._styles.getStyleNames(t)
            }
            hasStyle(...t) {
                for (const e of t)
                    if (!this._styles.has(e)) return !1;
                return !0
            }
            findAncestor(...t) {
                const e = new rr(...t);
                let n = this.parent;
                for (; n && !n.is("documentFragment");) {
                    if (e.match(n)) return n;
                    n = n.parent
                }
                return null
            }
            getCustomProperty(t) {
                return this._customProperties.get(t)
            }* getCustomProperties() {
                yield* this._customProperties.entries()
            }
            getIdentity() {
                const t = Array.from(this._classes).sort().join(","),
                    e = this._styles.toString(),
                    n = Array.from(this._attrs).map((t => `${t[0]}="${t[1]}"`)).sort().join(" ");
                return this.name + ("" == t ? "" : ` class="${t}"`) + (e ? ` style="${e}"` : "") + ("" == n ? "" : ` ${n}`)
            }
            shouldRenderUnsafeAttribute(t) {
                return this._unsafeAttributesToRender.includes(t)
            }
            _clone(t = !1) {
                const e = [];
                if (t)
                    for (const n of this.getChildren()) e.push(n._clone(t));
                const n = new this.constructor(this.document, this.name, this._attrs, e);
                return n._classes = new Set(this._classes), n._styles.set(this._styles.getNormalized()), n._customProperties = new Map(this._customProperties), n.getFillerOffset = this.getFillerOffset, n._unsafeAttributesToRender = this._unsafeAttributesToRender, n
            }
            _appendChild(t) {
                return this._insertChild(this.childCount, t)
            }
            _insertChild(t, e) {
                this._fireChange("children", this);
                let n = 0;
                const o = function(t, e) {
                    if ("string" == typeof e) return [new or(t, e)];
                    Q(e) || (e = [e]);
                    return Array.from(e).map((e => "string" == typeof e ? new or(t, e) : e instanceof ir ? new or(t, e.data) : e))
                }(this.document, e);
                for (const e of o) null !== e.parent && e._remove(), e.parent = this, e.document = this.document, this._children.splice(t, 0, e), t++, n++;
                return n
            }
            _removeChildren(t, e = 1) {
                this._fireChange("children", this);
                for (let n = t; n < t + e; n++) this._children[n].parent = null;
                return this._children.splice(t, e)
            }
            _setAttribute(t, e) {
                const n = String(e);
                this._fireChange("attributes", this), "class" == t ? ss(this._classes, n) : "style" == t ? this._styles.setTo(n) : this._attrs.set(t, n)
            }
            _removeAttribute(t) {
                return this._fireChange("attributes", this), "class" == t ? this._classes.size > 0 && (this._classes.clear(), !0) : "style" == t ? !this._styles.isEmpty && (this._styles.clear(), !0) : this._attrs.delete(t)
            }
            _addClass(t) {
                this._fireChange("attributes", this);
                for (const e of Ai(t)) this._classes.add(e)
            }
            _removeClass(t) {
                this._fireChange("attributes", this);
                for (const e of Ai(t)) this._classes.delete(e)
            }
            _setStyle(t, e) {
                this._fireChange("attributes", this), "string" != typeof t ? this._styles.set(t) : this._styles.set(t, e)
            }
            _removeStyle(t) {
                this._fireChange("attributes", this);
                for (const e of Ai(t)) this._styles.remove(e)
            }
            _setCustomProperty(t, e) {
                this._customProperties.set(t, e)
            }
            _removeCustomProperty(t) {
                return this._customProperties.delete(t)
            }
        }

        function ss(t, e) {
            const n = e.split(/\s+/);
            t.clear(), n.forEach((e => t.add(e)))
        }
        rs.prototype.is = function(t, e) {
            return e ? e === this.name && ("element" === t || "view:element" === t) : "element" === t || "view:element" === t || "node" === t || "view:node" === t
        };
        class as extends rs {
            constructor(t, e, n, o) {
                super(t, e, n, o), this.getFillerOffset = ls
            }
        }

        function ls() {
            const t = [...this.getChildren()],
                e = t[this.childCount - 1];
            if (e && e.is("element", "br")) return this.childCount;
            for (const e of t)
                if (!e.is("uiElement")) return null;
            return this.childCount
        }
        as.prototype.is = function(t, e) {
            return e ? e === this.name && ("containerElement" === t || "view:containerElement" === t || "element" === t || "view:element" === t) : "containerElement" === t || "view:containerElement" === t || "element" === t || "view:element" === t || "node" === t || "view:node" === t
        };
        class cs extends(q(as)) {
            constructor(t, e, n, o) {
                super(t, e, n, o), this.set("isReadOnly", !1), this.set("isFocused", !1), this.bind("isReadOnly").to(t), this.bind("isFocused").to(t, "isFocused", (e => e && t.selection.editableElement == this)), this.listenTo(t.selection, "change", (() => {
                    this.isFocused = t.isFocused && t.selection.editableElement == this
                }))
            }
            destroy() {
                this.stopListening()
            }
        }
        cs.prototype.is = function(t, e) {
            return e ? e === this.name && ("editableElement" === t || "view:editableElement" === t || "containerElement" === t || "view:containerElement" === t || "element" === t || "view:element" === t) : "editableElement" === t || "view:editableElement" === t || "containerElement" === t || "view:containerElement" === t || "element" === t || "view:element" === t || "node" === t || "view:node" === t
        };
        const ds = Symbol("rootName");
        class hs extends cs {
            constructor(t, e) {
                super(t, e), this.rootName = "main"
            }
            get rootName() {
                return this.getCustomProperty(ds)
            }
            set rootName(t) {
                this._setCustomProperty(ds, t)
            }
            set _name(t) {
                this.name = t
            }
        }
        hs.prototype.is = function(t, e) {
            return e ? e === this.name && ("rootElement" === t || "view:rootElement" === t || "editableElement" === t || "view:editableElement" === t || "containerElement" === t || "view:containerElement" === t || "element" === t || "view:element" === t) : "rootElement" === t || "view:rootElement" === t || "editableElement" === t || "view:editableElement" === t || "containerElement" === t || "view:containerElement" === t || "element" === t || "view:element" === t || "node" === t || "view:node" === t
        };
        class us {
            constructor(t = {}) {
                if (!t.boundaries && !t.startPosition) throw new b("view-tree-walker-no-start-position", null);
                if (t.direction && "forward" != t.direction && "backward" != t.direction) throw new b("view-tree-walker-unknown-direction", t.startPosition, {
                    direction: t.direction
                });
                this.boundaries = t.boundaries || null, t.startPosition ? this._position = gs._createAt(t.startPosition) : this._position = gs._createAt(t.boundaries["backward" == t.direction ? "end" : "start"]), this.direction = t.direction || "forward", this.singleCharacters = !!t.singleCharacters, this.shallow = !!t.shallow, this.ignoreElementEnd = !!t.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null
            } [Symbol.iterator]() {
                return this
            }
            get position() {
                return this._position
            }
            skip(t) {
                let e, n;
                do {
                    n = this.position, e = this.next()
                } while (!e.done && t(e.value));
                e.done || (this._position = n)
            }
            next() {
                return "forward" == this.direction ? this._next() : this._previous()
            }
            _next() {
                let t = this.position.clone();
                const e = this.position,
                    n = t.parent;
                if (null === n.parent && t.offset === n.childCount) return {
                    done: !0,
                    value: void 0
                };
                if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset) return {
                    done: !0,
                    value: void 0
                };
                let o;
                if (n instanceof or) {
                    if (t.isAtEnd) return this._position = gs._createAfter(n), this._next();
                    o = n.data[t.offset]
                } else o = n.getChild(t.offset);
                if (o instanceof rs) {
                    if (this.shallow) {
                        if (this.boundaries && this.boundaries.end.isBefore(t)) return {
                            done: !0,
                            value: void 0
                        };
                        t.offset++
                    } else t = new gs(o, 0);
                    return this._position = t, this._formatReturnValue("elementStart", o, e, t, 1)
                }
                if (o instanceof or) {
                    if (this.singleCharacters) return t = new gs(o, 0), this._position = t, this._next();
                    let n, i = o.data.length;
                    return o == this._boundaryEndParent ? (i = this.boundaries.end.offset, n = new ir(o, 0, i), t = gs._createAfter(n)) : (n = new ir(o, 0, o.data.length), t.offset++), this._position = t, this._formatReturnValue("text", n, e, t, i)
                }
                if ("string" == typeof o) {
                    let o;
                    if (this.singleCharacters) o = 1;
                    else {
                        o = (n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length) - t.offset
                    }
                    const i = new ir(n, t.offset, o);
                    return t.offset += o, this._position = t, this._formatReturnValue("text", i, e, t, o)
                }
                return t = gs._createAfter(n), this._position = t, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", n, e, t)
            }
            _previous() {
                let t = this.position.clone();
                const e = this.position,
                    n = t.parent;
                if (null === n.parent && 0 === t.offset) return {
                    done: !0,
                    value: void 0
                };
                if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset) return {
                    done: !0,
                    value: void 0
                };
                let o;
                if (n instanceof or) {
                    if (t.isAtStart) return this._position = gs._createBefore(n), this._previous();
                    o = n.data[t.offset - 1]
                } else o = n.getChild(t.offset - 1);
                if (o instanceof rs) return this.shallow ? (t.offset--, this._position = t, this._formatReturnValue("elementStart", o, e, t, 1)) : (t = new gs(o, o.childCount), this._position = t, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", o, e, t));
                if (o instanceof or) {
                    if (this.singleCharacters) return t = new gs(o, o.data.length), this._position = t, this._previous();
                    let n, i = o.data.length;
                    if (o == this._boundaryStartParent) {
                        const e = this.boundaries.start.offset;
                        n = new ir(o, e, o.data.length - e), i = n.data.length, t = gs._createBefore(n)
                    } else n = new ir(o, 0, o.data.length), t.offset--;
                    return this._position = t, this._formatReturnValue("text", n, e, t, i)
                }
                if ("string" == typeof o) {
                    let o;
                    if (this.singleCharacters) o = 1;
                    else {
                        const e = n === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                        o = t.offset - e
                    }
                    t.offset -= o;
                    const i = new ir(n, t.offset, o);
                    return this._position = t, this._formatReturnValue("text", i, e, t, o)
                }
                return t = gs._createBefore(n), this._position = t, this._formatReturnValue("elementStart", n, e, t, 1)
            }
            _formatReturnValue(t, e, n, o, i) {
                return e instanceof ir && (e.offsetInText + e.data.length == e.textNode.data.length && ("forward" != this.direction || this.boundaries && this.boundaries.end.isEqual(this.position) ? n = gs._createAfter(e.textNode) : (o = gs._createAfter(e.textNode), this._position = o)), 0 === e.offsetInText && ("backward" != this.direction || this.boundaries && this.boundaries.start.isEqual(this.position) ? n = gs._createBefore(e.textNode) : (o = gs._createBefore(e.textNode), this._position = o))), {
                    done: !1,
                    value: {
                        type: t,
                        item: e,
                        previousPosition: n,
                        nextPosition: o,
                        length: i
                    }
                }
            }
        }
        class gs extends tr {
            constructor(t, e) {
                super(), this.parent = t, this.offset = e
            }
            get nodeAfter() {
                return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null
            }
            get nodeBefore() {
                return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null
            }
            get isAtStart() {
                return 0 === this.offset
            }
            get isAtEnd() {
                const t = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
                return this.offset === t
            }
            get root() {
                return this.parent.root
            }
            get editableElement() {
                let t = this.parent;
                for (; !(t instanceof cs);) {
                    if (!t.parent) return null;
                    t = t.parent
                }
                return t
            }
            getShiftedBy(t) {
                const e = gs._createAt(this),
                    n = e.offset + t;
                return e.offset = n < 0 ? 0 : n, e
            }
            getLastMatchingPosition(t, e = {}) {
                e.startPosition = this;
                const n = new us(e);
                return n.skip(t), n.position
            }
            getAncestors() {
                return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({
                    includeSelf: !0
                })
            }
            getCommonAncestor(t) {
                const e = this.getAncestors(),
                    n = t.getAncestors();
                let o = 0;
                for (; e[o] == n[o] && e[o];) o++;
                return 0 === o ? null : e[o - 1]
            }
            isEqual(t) {
                return this.parent == t.parent && this.offset == t.offset
            }
            isBefore(t) {
                return "before" == this.compareWith(t)
            }
            isAfter(t) {
                return "after" == this.compareWith(t)
            }
            compareWith(t) {
                if (this.root !== t.root) return "different";
                if (this.isEqual(t)) return "same";
                const e = this.parent.is("node") ? this.parent.getPath() : [],
                    n = t.parent.is("node") ? t.parent.getPath() : [];
                e.push(this.offset), n.push(t.offset);
                const o = Y(e, n);
                switch (o) {
                    case "prefix":
                        return "before";
                    case "extension":
                        return "after";
                    default:
                        return e[o] < n[o] ? "before" : "after"
                }
            }
            getWalker(t = {}) {
                return t.startPosition = this, new us(t)
            }
            clone() {
                return new gs(this.parent, this.offset)
            }
            static _createAt(t, e) {
                if (t instanceof gs) return new this(t.parent, t.offset);
                {
                    const n = t;
                    if ("end" == e) e = n.is("$text") ? n.data.length : n.childCount;
                    else {
                        if ("before" == e) return this._createBefore(n);
                        if ("after" == e) return this._createAfter(n);
                        if (0 !== e && !e) throw new b("view-createpositionat-offset-required", n)
                    }
                    return new gs(n, e)
                }
            }
            static _createAfter(t) {
                if (t.is("$textProxy")) return new gs(t.textNode, t.offsetInText + t.data.length);
                if (!t.parent) throw new b("view-position-after-root", t, {
                    root: t
                });
                return new gs(t.parent, t.index + 1)
            }
            static _createBefore(t) {
                if (t.is("$textProxy")) return new gs(t.textNode, t.offsetInText);
                if (!t.parent) throw new b("view-position-before-root", t, {
                    root: t
                });
                return new gs(t.parent, t.index)
            }
        }
        gs.prototype.is = function(t) {
            return "position" === t || "view:position" === t
        };
        class ms extends tr {
            constructor(t, e = null) {
                super(), this.start = t.clone(), this.end = e ? e.clone() : t.clone()
            }*[Symbol.iterator]() {
                yield* new us({
                    boundaries: this,
                    ignoreElementEnd: !0
                })
            }
            get isCollapsed() {
                return this.start.isEqual(this.end)
            }
            get isFlat() {
                return this.start.parent === this.end.parent
            }
            get root() {
                return this.start.root
            }
            getEnlarged() {
                let t = this.start.getLastMatchingPosition(ps, {
                        direction: "backward"
                    }),
                    e = this.end.getLastMatchingPosition(ps);
                return t.parent.is("$text") && t.isAtStart && (t = gs._createBefore(t.parent)), e.parent.is("$text") && e.isAtEnd && (e = gs._createAfter(e.parent)), new ms(t, e)
            }
            getTrimmed() {
                let t = this.start.getLastMatchingPosition(ps);
                if (t.isAfter(this.end) || t.isEqual(this.end)) return new ms(t, t);
                let e = this.end.getLastMatchingPosition(ps, {
                    direction: "backward"
                });
                const n = t.nodeAfter,
                    o = e.nodeBefore;
                return n && n.is("$text") && (t = new gs(n, 0)), o && o.is("$text") && (e = new gs(o, o.data.length)), new ms(t, e)
            }
            isEqual(t) {
                return this == t || this.start.isEqual(t.start) && this.end.isEqual(t.end)
            }
            containsPosition(t) {
                return t.isAfter(this.start) && t.isBefore(this.end)
            }
            containsRange(t, e = !1) {
                t.isCollapsed && (e = !1);
                const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start),
                    o = this.containsPosition(t.end) || e && this.end.isEqual(t.end);
                return n && o
            }
            getDifference(t) {
                const e = [];
                return this.isIntersecting(t) ? (this.containsPosition(t.start) && e.push(new ms(this.start, t.start)), this.containsPosition(t.end) && e.push(new ms(t.end, this.end))) : e.push(this.clone()), e
            }
            getIntersection(t) {
                if (this.isIntersecting(t)) {
                    let e = this.start,
                        n = this.end;
                    return this.containsPosition(t.start) && (e = t.start), this.containsPosition(t.end) && (n = t.end), new ms(e, n)
                }
                return null
            }
            getWalker(t = {}) {
                return t.boundaries = this, new us(t)
            }
            getCommonAncestor() {
                return this.start.getCommonAncestor(this.end)
            }
            getContainedElement() {
                if (this.isCollapsed) return null;
                let t = this.start.nodeAfter,
                    e = this.end.nodeBefore;
                return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (t = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (e = this.end.parent.previousSibling), t && t.is("element") && t === e ? t : null
            }
            clone() {
                return new ms(this.start, this.end)
            }* getItems(t = {}) {
                t.boundaries = this, t.ignoreElementEnd = !0;
                const e = new us(t);
                for (const t of e) yield t.item
            }* getPositions(t = {}) {
                t.boundaries = this;
                const e = new us(t);
                yield e.position;
                for (const t of e) yield t.nextPosition
            }
            isIntersecting(t) {
                return this.start.isBefore(t.end) && this.end.isAfter(t.start)
            }
            static _createFromParentsAndOffsets(t, e, n, o) {
                return new this(new gs(t, e), new gs(n, o))
            }
            static _createFromPositionAndShift(t, e) {
                const n = t,
                    o = t.getShiftedBy(e);
                return e > 0 ? new this(n, o) : new this(o, n)
            }
            static _createIn(t) {
                return this._createFromParentsAndOffsets(t, 0, t, t.childCount)
            }
            static _createOn(t) {
                const e = t.is("$textProxy") ? t.offsetSize : 1;
                return this._createFromPositionAndShift(gs._createBefore(t), e)
            }
        }

        function ps(t) {
            return !(!t.item.is("attributeElement") && !t.item.is("uiElement"))
        }
        ms.prototype.is = function(t) {
            return "range" === t || "view:range" === t
        };
        class fs extends(S(tr)) {
            constructor(...t) {
                super(), this._ranges = [], this._lastRangeBackward = !1, this._isFake = !1, this._fakeSelectionLabel = "", t.length && this.setTo(...t)
            }
            get isFake() {
                return this._isFake
            }
            get fakeSelectionLabel() {
                return this._fakeSelectionLabel
            }
            get anchor() {
                if (!this._ranges.length) return null;
                const t = this._ranges[this._ranges.length - 1];
                return (this._lastRangeBackward ? t.end : t.start).clone()
            }
            get focus() {
                if (!this._ranges.length) return null;
                const t = this._ranges[this._ranges.length - 1];
                return (this._lastRangeBackward ? t.start : t.end).clone()
            }
            get isCollapsed() {
                return 1 === this.rangeCount && this._ranges[0].isCollapsed
            }
            get rangeCount() {
                return this._ranges.length
            }
            get isBackward() {
                return !this.isCollapsed && this._lastRangeBackward
            }
            get editableElement() {
                return this.anchor ? this.anchor.editableElement : null
            }* getRanges() {
                for (const t of this._ranges) yield t.clone()
            }
            getFirstRange() {
                let t = null;
                for (const e of this._ranges) t && !e.start.isBefore(t.start) || (t = e);
                return t ? t.clone() : null
            }
            getLastRange() {
                let t = null;
                for (const e of this._ranges) t && !e.end.isAfter(t.end) || (t = e);
                return t ? t.clone() : null
            }
            getFirstPosition() {
                const t = this.getFirstRange();
                return t ? t.start.clone() : null
            }
            getLastPosition() {
                const t = this.getLastRange();
                return t ? t.end.clone() : null
            }
            isEqual(t) {
                if (this.isFake != t.isFake) return !1;
                if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) return !1;
                if (this.rangeCount != t.rangeCount) return !1;
                if (0 === this.rangeCount) return !0;
                if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) return !1;
                for (const e of this._ranges) {
                    let n = !1;
                    for (const o of t._ranges)
                        if (e.isEqual(o)) {
                            n = !0;
                            break
                        } if (!n) return !1
                }
                return !0
            }
            isSimilar(t) {
                if (this.isBackward != t.isBackward) return !1;
                const e = J(this.getRanges());
                if (e != J(t.getRanges())) return !1;
                if (0 == e) return !0;
                for (let e of this.getRanges()) {
                    e = e.getTrimmed();
                    let n = !1;
                    for (let o of t.getRanges())
                        if (o = o.getTrimmed(), e.start.isEqual(o.start) && e.end.isEqual(o.end)) {
                            n = !0;
                            break
                        } if (!n) return !1
                }
                return !0
            }
            getSelectedElement() {
                return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement()
            }
            setTo(...t) {
                let [e, n, o] = t;
                if ("object" == typeof n && (o = n, n = void 0), null === e) this._setRanges([]), this._setFakeOptions(o);
                else if (e instanceof fs || e instanceof bs) this._setRanges(e.getRanges(), e.isBackward), this._setFakeOptions({
                    fake: e.isFake,
                    label: e.fakeSelectionLabel
                });
                else if (e instanceof ms) this._setRanges([e], o && o.backward), this._setFakeOptions(o);
                else if (e instanceof gs) this._setRanges([new ms(e)]), this._setFakeOptions(o);
                else if (e instanceof nr) {
                    const t = !!o && !!o.backward;
                    let i;
                    if (void 0 === n) throw new b("view-selection-setto-required-second-parameter", this);
                    i = "in" == n ? ms._createIn(e) : "on" == n ? ms._createOn(e) : new ms(gs._createAt(e, n)), this._setRanges([i], t), this._setFakeOptions(o)
                } else {
                    if (!Q(e)) throw new b("view-selection-setto-not-selectable", this);
                    this._setRanges(e, o && o.backward), this._setFakeOptions(o)
                }
                this.fire("change")
            }
            setFocus(t, e) {
                if (null === this.anchor) throw new b("view-selection-setfocus-no-ranges", this);
                const n = gs._createAt(t, e);
                if ("same" == n.compareWith(this.focus)) return;
                const o = this.anchor;
                this._ranges.pop(), "before" == n.compareWith(o) ? this._addRange(new ms(n, o), !0) : this._addRange(new ms(o, n)), this.fire("change")
            }
            _setRanges(t, e = !1) {
                t = Array.from(t), this._ranges = [];
                for (const e of t) this._addRange(e);
                this._lastRangeBackward = !!e
            }
            _setFakeOptions(t = {}) {
                this._isFake = !!t.fake, this._fakeSelectionLabel = t.fake && t.label || ""
            }
            _addRange(t, e = !1) {
                if (!(t instanceof ms)) throw new b("view-selection-add-range-not-range", this);
                this._pushRange(t), this._lastRangeBackward = !!e
            }
            _pushRange(t) {
                for (const e of this._ranges)
                    if (t.isIntersecting(e)) throw new b("view-selection-range-intersects", this, {
                        addedRange: t,
                        intersectingRange: e
                    });
                this._ranges.push(new ms(t.start, t.end))
            }
        }
        fs.prototype.is = function(t) {
            return "selection" === t || "view:selection" === t
        };
        class bs extends(S(tr)) {
            constructor(...t) {
                super(), this._selection = new fs, this._selection.delegate("change").to(this), t.length && this._selection.setTo(...t)
            }
            get isFake() {
                return this._selection.isFake
            }
            get fakeSelectionLabel() {
                return this._selection.fakeSelectionLabel
            }
            get anchor() {
                return this._selection.anchor
            }
            get focus() {
                return this._selection.focus
            }
            get isCollapsed() {
                return this._selection.isCollapsed
            }
            get rangeCount() {
                return this._selection.rangeCount
            }
            get isBackward() {
                return this._selection.isBackward
            }
            get editableElement() {
                return this._selection.editableElement
            }
            get _ranges() {
                return this._selection._ranges
            }* getRanges() {
                yield* this._selection.getRanges()
            }
            getFirstRange() {
                return this._selection.getFirstRange()
            }
            getLastRange() {
                return this._selection.getLastRange()
            }
            getFirstPosition() {
                return this._selection.getFirstPosition()
            }
            getLastPosition() {
                return this._selection.getLastPosition()
            }
            getSelectedElement() {
                return this._selection.getSelectedElement()
            }
            isEqual(t) {
                return this._selection.isEqual(t)
            }
            isSimilar(t) {
                return this._selection.isSimilar(t)
            }
            _setTo(...t) {
                this._selection.setTo(...t)
            }
            _setFocus(t, e) {
                this._selection.setFocus(t, e)
            }
        }
        bs.prototype.is = function(t) {
            return "selection" === t || "documentSelection" == t || "view:selection" == t || "view:documentSelection" == t
        };
        class ks extends h {
            constructor(t, e, n) {
                super(t, e), this.startRange = n, this._eventPhase = "none", this._currentTarget = null
            }
            get eventPhase() {
                return this._eventPhase
            }
            get currentTarget() {
                return this._currentTarget
            }
        }
        const ws = Symbol("bubbling contexts");

        function As(t) {
            return class extends t {
                fire(t, ...e) {
                    try {
                        const n = t instanceof h ? t : new h(this, t),
                            o = ys(this);
                        if (!o.size) return;
                        if (Cs(n, "capturing", this), _s(o, "$capture", n, ...e)) return n.return;
                        const i = n.startRange || this.selection.getFirstRange(),
                            r = i ? i.getContainedElement() : null,
                            s = !!r && Boolean(vs(o, r));
                        let a = r || function(t) {
                            if (!t) return null;
                            const e = t.start.parent,
                                n = t.end.parent,
                                o = e.getPath(),
                                i = n.getPath();
                            return o.length > i.length ? e : n
                        }(i);
                        if (Cs(n, "atTarget", a), !s) {
                            if (_s(o, "$text", n, ...e)) return n.return;
                            Cs(n, "bubbling", a)
                        }
                        for (; a;) {
                            if (a.is("rootElement")) {
                                if (_s(o, "$root", n, ...e)) return n.return
                            } else if (a.is("element") && _s(o, a.name, n, ...e)) return n.return;
                            if (_s(o, a, n, ...e)) return n.return;
                            a = a.parent, Cs(n, "bubbling", a)
                        }
                        return Cs(n, "bubbling", this), _s(o, "$document", n, ...e), n.return
                    } catch (t) {
                        b.rethrowUnexpectedError(t, this)
                    }
                }
                _addEventListener(t, e, n) {
                    const o = Ai(n.context || "$document"),
                        i = ys(this);
                    for (const r of o) {
                        let o = i.get(r);
                        o || (o = new(S()), i.set(r, o)), this.listenTo(o, t, e, n)
                    }
                }
                _removeEventListener(t, e) {
                    const n = ys(this);
                    for (const o of n.values()) this.stopListening(o, t, e)
                }
            }
        } {
            const t = As(Object);
            ["fire", "_addEventListener", "_removeEventListener"].forEach((e => {
                As[e] = t.prototype[e]
            }))
        }

        function Cs(t, e, n) {
            t instanceof ks && (t._eventPhase = e, t._currentTarget = n)
        }

        function _s(t, e, n, ...o) {
            const i = "string" == typeof e ? t.get(e) : vs(t, e);
            return !!i && (i.fire(n, ...o), n.stop.called)
        }

        function vs(t, e) {
            for (const [n, o] of t)
                if ("function" == typeof n && n(e)) return o;
            return null
        }

        function ys(t) {
            return t[ws] || (t[ws] = new Map), t[ws]
        }
        class xs extends(As(q())) {
            constructor(t) {
                super(), this._postFixers = new Set, this.selection = new bs, this.roots = new xi({
                    idProperty: "rootName"
                }), this.stylesProcessor = t, this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("isSelecting", !1), this.set("isComposing", !1)
            }
            getRoot(t = "main") {
                return this.roots.get(t)
            }
            registerPostFixer(t) {
                this._postFixers.add(t)
            }
            destroy() {
                this.roots.map((t => t.destroy())), this.stopListening()
            }
            _callPostFixers(t) {
                let e = !1;
                do {
                    for (const n of this._postFixers)
                        if (e = n(t), e) break
                } while (e)
            }
        }
        class Es extends rs {
            constructor(t, e, n, o) {
                super(t, e, n, o), this._priority = 10, this._id = null, this._clonesGroup = null, this.getFillerOffset = Ds
            }
            get priority() {
                return this._priority
            }
            get id() {
                return this._id
            }
            getElementsWithSameId() {
                if (null === this.id) throw new b("attribute-element-get-elements-with-same-id-no-id", this);
                return new Set(this._clonesGroup)
            }
            isSimilar(t) {
                return null !== this.id || null !== t.id ? this.id === t.id : super.isSimilar(t) && this.priority == t.priority
            }
            _clone(t = !1) {
                const e = super._clone(t);
                return e._priority = this._priority, e._id = this._id, e
            }
        }

        function Ds() {
            if (Ss(this)) return null;
            let t = this.parent;
            for (; t && t.is("attributeElement");) {
                if (Ss(t) > 1) return null;
                t = t.parent
            }
            return !t || Ss(t) > 1 ? null : this.childCount
        }

        function Ss(t) {
            return Array.from(t.getChildren()).filter((t => !t.is("uiElement"))).length
        }
        Es.DEFAULT_PRIORITY = 10, Es.prototype.is = function(t, e) {
            return e ? e === this.name && ("attributeElement" === t || "view:attributeElement" === t || "element" === t || "view:element" === t) : "attributeElement" === t || "view:attributeElement" === t || "element" === t || "view:element" === t || "node" === t || "view:node" === t
        };
        class Ts extends rs {
            constructor(t, e, n, o) {
                super(t, e, n, o), this.getFillerOffset = Bs
            }
            _insertChild(t, e) {
                if (e && (e instanceof nr || Array.from(e).length > 0)) throw new b("view-emptyelement-cannot-add", [this, e]);
                return 0
            }
        }

        function Bs() {
            return null
        }
        Ts.prototype.is = function(t, e) {
            return e ? e === this.name && ("emptyElement" === t || "view:emptyElement" === t || "element" === t || "view:element" === t) : "emptyElement" === t || "view:emptyElement" === t || "element" === t || "view:element" === t || "node" === t || "view:node" === t
        };
        class Is extends rs {
            constructor(t, e, n, o) {
                super(t, e, n, o), this.getFillerOffset = Rs
            }
            _insertChild(t, e) {
                if (e && (e instanceof nr || Array.from(e).length > 0)) throw new b("view-uielement-cannot-add", [this, e]);
                return 0
            }
            render(t, e) {
                return this.toDomElement(t)
            }
            toDomElement(t) {
                const e = t.createElement(this.name);
                for (const t of this.getAttributeKeys()) e.setAttribute(t, this.getAttribute(t));
                return e
            }
        }

        function Ps(t) {
            t.document.on("arrowKey", ((e, n) => function(t, e, n) {
                if (e.keyCode == mi.arrowright) {
                    const t = e.domTarget.ownerDocument.defaultView.getSelection(),
                        o = 1 == t.rangeCount && t.getRangeAt(0).collapsed;
                    if (o || e.shiftKey) {
                        const e = t.focusNode,
                            i = t.focusOffset,
                            r = n.domPositionToView(e, i);
                        if (null === r) return;
                        let s = !1;
                        const a = r.getLastMatchingPosition((t => (t.item.is("uiElement") && (s = !0), !(!t.item.is("uiElement") && !t.item.is("attributeElement")))));
                        if (s) {
                            const e = n.viewPositionToDom(a);
                            o ? t.collapse(e.parent, e.offset) : t.extend(e.parent, e.offset)
                        }
                    }
                }
            }(0, n, t.domConverter)), {
                priority: "low"
            })
        }

        function Rs() {
            return null
        }
        Is.prototype.is = function(t, e) {
            return e ? e === this.name && ("uiElement" === t || "view:uiElement" === t || "element" === t || "view:element" === t) : "uiElement" === t || "view:uiElement" === t || "element" === t || "view:element" === t || "node" === t || "view:node" === t
        };
        class zs extends rs {
            constructor(t, e, n, o) {
                super(t, e, n, o), this.getFillerOffset = Vs
            }
            _insertChild(t, e) {
                if (e && (e instanceof nr || Array.from(e).length > 0)) throw new b("view-rawelement-cannot-add", [this, e]);
                return 0
            }
            render(t, e) {}
        }

        function Vs() {
            return null
        }
        zs.prototype.is = function(t, e) {
            return e ? e === this.name && ("rawElement" === t || "view:rawElement" === t || "element" === t || "view:element" === t) : "rawElement" === t || "view:rawElement" === t || t === this.name || t === "view:" + this.name || "element" === t || "view:element" === t || "node" === t || "view:node" === t
        };
        class Os extends(S(tr)) {
            constructor(t, e) {
                super(), this._children = [], this._customProperties = new Map, this.document = t, e && this._insertChild(0, e)
            } [Symbol.iterator]() {
                return this._children[Symbol.iterator]()
            }
            get childCount() {
                return this._children.length
            }
            get isEmpty() {
                return 0 === this.childCount
            }
            get root() {
                return this
            }
            get parent() {
                return null
            }
            get name() {}
            getCustomProperty(t) {
                return this._customProperties.get(t)
            }* getCustomProperties() {
                yield* this._customProperties.entries()
            }
            _appendChild(t) {
                return this._insertChild(this.childCount, t)
            }
            getChild(t) {
                return this._children[t]
            }
            getChildIndex(t) {
                return this._children.indexOf(t)
            }
            getChildren() {
                return this._children[Symbol.iterator]()
            }
            _insertChild(t, e) {
                this._fireChange("children", this);
                let n = 0;
                const o = function(t, e) {
                    if ("string" == typeof e) return [new or(t, e)];
                    Q(e) || (e = [e]);
                    return Array.from(e).map((e => "string" == typeof e ? new or(t, e) : e instanceof ir ? new or(t, e.data) : e))
                }(this.document, e);
                for (const e of o) null !== e.parent && e._remove(), e.parent = this, this._children.splice(t, 0, e), t++, n++;
                return n
            }
            _removeChildren(t, e = 1) {
                this._fireChange("children", this);
                for (let n = t; n < t + e; n++) this._children[n].parent = null;
                return this._children.splice(t, e)
            }
            _fireChange(t, e) {
                this.fire("change:" + t, e)
            }
            _setCustomProperty(t, e) {
                this._customProperties.set(t, e)
            }
            _removeCustomProperty(t) {
                return this._customProperties.delete(t)
            }
        }
        Os.prototype.is = function(t) {
            return "documentFragment" === t || "view:documentFragment" === t
        };
        class Fs {
            constructor(t) {
                this._cloneGroups = new Map, this._slotFactory = null, this.document = t
            }
            setSelection(...t) {
                this.document.selection._setTo(...t)
            }
            setSelectionFocus(t, e) {
                this.document.selection._setFocus(t, e)
            }
            createDocumentFragment(t) {
                return new Os(this.document, t)
            }
            createText(t) {
                return new or(this.document, t)
            }
            createAttributeElement(t, e, n = {}) {
                const o = new Es(this.document, t, e);
                return "number" == typeof n.priority && (o._priority = n.priority), n.id && (o._id = n.id), n.renderUnsafeAttributes && o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), o
            }
            createContainerElement(t, e, n = {}, o = {}) {
                let i = null;
                vt(n) ? o = n : i = n;
                const r = new as(this.document, t, e, i);
                return o.renderUnsafeAttributes && r._unsafeAttributesToRender.push(...o.renderUnsafeAttributes), r
            }
            createEditableElement(t, e, n = {}) {
                const o = new cs(this.document, t, e);
                return n.renderUnsafeAttributes && o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), o
            }
            createEmptyElement(t, e, n = {}) {
                const o = new Ts(this.document, t, e);
                return n.renderUnsafeAttributes && o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), o
            }
            createUIElement(t, e, n) {
                const o = new Is(this.document, t, e);
                return n && (o.render = n), o
            }
            createRawElement(t, e, n, o = {}) {
                const i = new zs(this.document, t, e);
                return n && (i.render = n), o.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...o.renderUnsafeAttributes), i
            }
            setAttribute(t, e, n) {
                n._setAttribute(t, e)
            }
            removeAttribute(t, e) {
                e._removeAttribute(t)
            }
            addClass(t, e) {
                e._addClass(t)
            }
            removeClass(t, e) {
                e._removeClass(t)
            }
            setStyle(t, e, n) {
                vt(t) && void 0 === n ? e._setStyle(t) : n._setStyle(t, e)
            }
            removeStyle(t, e) {
                e._removeStyle(t)
            }
            setCustomProperty(t, e, n) {
                n._setCustomProperty(t, e)
            }
            removeCustomProperty(t, e) {
                return e._removeCustomProperty(t)
            }
            breakAttributes(t) {
                return t instanceof gs ? this._breakAttributes(t) : this._breakAttributesRange(t)
            }
            breakContainer(t) {
                const e = t.parent;
                if (!e.is("containerElement")) throw new b("view-writer-break-non-container-element", this.document);
                if (!e.parent) throw new b("view-writer-break-root", this.document);
                if (t.isAtStart) return gs._createBefore(e);
                if (!t.isAtEnd) {
                    const n = e._clone(!1);
                    this.insert(gs._createAfter(e), n);
                    const o = new ms(t, gs._createAt(e, "end")),
                        i = new gs(n, 0);
                    this.move(o, i)
                }
                return gs._createAfter(e)
            }
            mergeAttributes(t) {
                const e = t.offset,
                    n = t.parent;
                if (n.is("$text")) return t;
                if (n.is("attributeElement") && 0 === n.childCount) {
                    const t = n.parent,
                        e = n.index;
                    return n._remove(), this._removeFromClonedElementsGroup(n), this.mergeAttributes(new gs(t, e))
                }
                const o = n.getChild(e - 1),
                    i = n.getChild(e);
                if (!o || !i) return t;
                if (o.is("$text") && i.is("$text")) return js(o, i);
                if (o.is("attributeElement") && i.is("attributeElement") && o.isSimilar(i)) {
                    const t = o.childCount;
                    return o._appendChild(i.getChildren()), i._remove(), this._removeFromClonedElementsGroup(i), this.mergeAttributes(new gs(o, t))
                }
                return t
            }
            mergeContainers(t) {
                const e = t.nodeBefore,
                    n = t.nodeAfter;
                if (!(e && n && e.is("containerElement") && n.is("containerElement"))) throw new b("view-writer-merge-containers-invalid-position", this.document);
                const o = e.getChild(e.childCount - 1),
                    i = o instanceof or ? gs._createAt(o, "end") : gs._createAt(e, "end");
                return this.move(ms._createIn(n), gs._createAt(e, "end")), this.remove(ms._createOn(n)), i
            }
            insert(t, e) {
                Ws(e = Q(e) ? [...e] : [e], this.document);
                const n = e.reduce(((t, e) => {
                    const n = t[t.length - 1],
                        o = !e.is("uiElement");
                    return n && n.breakAttributes == o ? n.nodes.push(e) : t.push({
                        breakAttributes: o,
                        nodes: [e]
                    }), t
                }), []);
                let o = null,
                    i = t;
                for (const {
                        nodes: t,
                        breakAttributes: e
                    }
                    of n) {
                    const n = this._insertNodes(i, t, e);
                    o || (o = n.start), i = n.end
                }
                return o ? new ms(o, i) : new ms(t)
            }
            remove(t) {
                const e = t instanceof ms ? t : ms._createOn(t);
                if ($s(e, this.document), e.isCollapsed) return new Os(this.document);
                const {
                    start: n,
                    end: o
                } = this._breakAttributesRange(e, !0), i = n.parent, r = o.offset - n.offset, s = i._removeChildren(n.offset, r);
                for (const t of s) this._removeFromClonedElementsGroup(t);
                const a = this.mergeAttributes(n);
                return e.start = a, e.end = a.clone(), new Os(this.document, s)
            }
            clear(t, e) {
                $s(t, this.document);
                const n = t.getWalker({
                    direction: "backward",
                    ignoreElementEnd: !0
                });
                for (const o of n) {
                    const n = o.item;
                    let i;
                    if (n.is("element") && e.isSimilar(n)) i = ms._createOn(n);
                    else if (!o.nextPosition.isAfter(t.start) && n.is("$textProxy")) {
                        const t = n.getAncestors().find((t => t.is("element") && e.isSimilar(t)));
                        t && (i = ms._createIn(t))
                    }
                    i && (i.end.isAfter(t.end) && (i.end = t.end), i.start.isBefore(t.start) && (i.start = t.start), this.remove(i))
                }
            }
            move(t, e) {
                let n;
                if (e.isAfter(t.end)) {
                    const o = (e = this._breakAttributes(e, !0)).parent,
                        i = o.childCount;
                    t = this._breakAttributesRange(t, !0), n = this.remove(t), e.offset += o.childCount - i
                } else n = this.remove(t);
                return this.insert(e, n)
            }
            wrap(t, e) {
                if (!(e instanceof Es)) throw new b("view-writer-wrap-invalid-attribute", this.document);
                if ($s(t, this.document), t.isCollapsed) {
                    let o = t.start;
                    o.parent.is("element") && (n = o.parent, !Array.from(n.getChildren()).some((t => !t.is("uiElement")))) && (o = o.getLastMatchingPosition((t => t.item.is("uiElement")))), o = this._wrapPosition(o, e);
                    const i = this.document.selection;
                    return i.isCollapsed && i.getFirstPosition().isEqual(t.start) && this.setSelection(o), new ms(o)
                }
                return this._wrapRange(t, e);
                var n
            }
            unwrap(t, e) {
                if (!(e instanceof Es)) throw new b("view-writer-unwrap-invalid-attribute", this.document);
                if ($s(t, this.document), t.isCollapsed) return t;
                const {
                    start: n,
                    end: o
                } = this._breakAttributesRange(t, !0), i = n.parent, r = this._unwrapChildren(i, n.offset, o.offset, e), s = this.mergeAttributes(r.start);
                s.isEqual(r.start) || r.end.offset--;
                const a = this.mergeAttributes(r.end);
                return new ms(s, a)
            }
            rename(t, e) {
                const n = new as(this.document, t, e.getAttributes());
                return this.insert(gs._createAfter(e), n), this.move(ms._createIn(e), gs._createAt(n, 0)), this.remove(ms._createOn(e)), n
            }
            clearClonedElementsGroup(t) {
                this._cloneGroups.delete(t)
            }
            createPositionAt(t, e) {
                return gs._createAt(t, e)
            }
            createPositionAfter(t) {
                return gs._createAfter(t)
            }
            createPositionBefore(t) {
                return gs._createBefore(t)
            }
            createRange(t, e) {
                return new ms(t, e)
            }
            createRangeOn(t) {
                return ms._createOn(t)
            }
            createRangeIn(t) {
                return ms._createIn(t)
            }
            createSelection(...t) {
                return new fs(...t)
            }
            createSlot(t = "children") {
                if (!this._slotFactory) throw new b("view-writer-invalid-create-slot-context", this.document);
                return this._slotFactory(this, t)
            }
            _registerSlotFactory(t) {
                this._slotFactory = t
            }
            _clearSlotFactory() {
                this._slotFactory = null
            }
            _insertNodes(t, e, n) {
                let o, i;
                if (o = n ? Ms(t) : t.parent.is("$text") ? t.parent.parent : t.parent, !o) throw new b("view-writer-invalid-position-container", this.document);
                i = n ? this._breakAttributes(t, !0) : t.parent.is("$text") ? Hs(t) : t;
                const r = o._insertChild(i.offset, e);
                for (const t of e) this._addToClonedElementsGroup(t);
                const s = i.getShiftedBy(r),
                    a = this.mergeAttributes(i);
                a.isEqual(i) || s.offset--;
                const l = this.mergeAttributes(s);
                return new ms(a, l)
            }
            _wrapChildren(t, e, n, o) {
                let i = e;
                const r = [];
                for (; i < n;) {
                    const e = t.getChild(i),
                        n = e.is("$text"),
                        s = e.is("attributeElement");
                    if (s && this._wrapAttributeElement(o, e)) r.push(new gs(t, i));
                    else if (n || !s || Ns(o, e)) {
                        const n = o._clone();
                        e._remove(), n._appendChild(e), t._insertChild(i, n), this._addToClonedElementsGroup(n), r.push(new gs(t, i))
                    } else this._wrapChildren(e, 0, e.childCount, o);
                    i++
                }
                let s = 0;
                for (const t of r) {
                    if (t.offset -= s, t.offset == e) continue;
                    this.mergeAttributes(t).isEqual(t) || (s++, n--)
                }
                return ms._createFromParentsAndOffsets(t, e, t, n)
            }
            _unwrapChildren(t, e, n, o) {
                let i = e;
                const r = [];
                for (; i < n;) {
                    const e = t.getChild(i);
                    if (e.is("attributeElement"))
                        if (e.isSimilar(o)) {
                            const o = e.getChildren(),
                                s = e.childCount;
                            e._remove(), t._insertChild(i, o), this._removeFromClonedElementsGroup(e), r.push(new gs(t, i), new gs(t, i + s)), i += s, n += s - 1
                        } else this._unwrapAttributeElement(o, e) ? (r.push(new gs(t, i), new gs(t, i + 1)), i++) : (this._unwrapChildren(e, 0, e.childCount, o), i++);
                    else i++
                }
                let s = 0;
                for (const t of r) {
                    if (t.offset -= s, t.offset == e || t.offset == n) continue;
                    this.mergeAttributes(t).isEqual(t) || (s++, n--)
                }
                return ms._createFromParentsAndOffsets(t, e, t, n)
            }
            _wrapRange(t, e) {
                const {
                    start: n,
                    end: o
                } = this._breakAttributesRange(t, !0), i = n.parent, r = this._wrapChildren(i, n.offset, o.offset, e), s = this.mergeAttributes(r.start);
                s.isEqual(r.start) || r.end.offset--;
                const a = this.mergeAttributes(r.end);
                return new ms(s, a)
            }
            _wrapPosition(t, e) {
                if (e.isSimilar(t.parent)) return Ls(t.clone());
                t.parent.is("$text") && (t = Hs(t));
                const n = this.createAttributeElement("_wrapPosition-fake-element");
                n._priority = Number.POSITIVE_INFINITY, n.isSimilar = () => !1, t.parent._insertChild(t.offset, n);
                const o = new ms(t, t.getShiftedBy(1));
                this.wrap(o, e);
                const i = new gs(n.parent, n.index);
                n._remove();
                const r = i.nodeBefore,
                    s = i.nodeAfter;
                return r instanceof or && s instanceof or ? js(r, s) : Ls(i)
            }
            _wrapAttributeElement(t, e) {
                if (!Gs(t, e)) return !1;
                if (t.name !== e.name || t.priority !== e.priority) return !1;
                for (const n of t.getAttributeKeys())
                    if ("class" !== n && "style" !== n && e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n)) return !1;
                for (const n of t.getStyleNames())
                    if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) return !1;
                for (const n of t.getAttributeKeys()) "class" !== n && "style" !== n && (e.hasAttribute(n) || this.setAttribute(n, t.getAttribute(n), e));
                for (const n of t.getStyleNames()) e.hasStyle(n) || this.setStyle(n, t.getStyle(n), e);
                for (const n of t.getClassNames()) e.hasClass(n) || this.addClass(n, e);
                return !0
            }
            _unwrapAttributeElement(t, e) {
                if (!Gs(t, e)) return !1;
                if (t.name !== e.name || t.priority !== e.priority) return !1;
                for (const n of t.getAttributeKeys())
                    if ("class" !== n && "style" !== n && (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n))) return !1;
                if (!e.hasClass(...t.getClassNames())) return !1;
                for (const n of t.getStyleNames())
                    if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) return !1;
                for (const n of t.getAttributeKeys()) "class" !== n && "style" !== n && this.removeAttribute(n, e);
                return this.removeClass(Array.from(t.getClassNames()), e), this.removeStyle(Array.from(t.getStyleNames()), e), !0
            }
            _breakAttributesRange(t, e = !1) {
                const n = t.start,
                    o = t.end;
                if ($s(t, this.document), t.isCollapsed) {
                    const n = this._breakAttributes(t.start, e);
                    return new ms(n, n)
                }
                const i = this._breakAttributes(o, e),
                    r = i.parent.childCount,
                    s = this._breakAttributes(n, e);
                return i.offset += i.parent.childCount - r, new ms(s, i)
            }
            _breakAttributes(t, e = !1) {
                const n = t.offset,
                    o = t.parent;
                if (t.parent.is("emptyElement")) throw new b("view-writer-cannot-break-empty-element", this.document);
                if (t.parent.is("uiElement")) throw new b("view-writer-cannot-break-ui-element", this.document);
                if (t.parent.is("rawElement")) throw new b("view-writer-cannot-break-raw-element", this.document);
                if (!e && o.is("$text") && Us(o.parent)) return t.clone();
                if (Us(o)) return t.clone();
                if (o.is("$text")) return this._breakAttributes(Hs(t), e);
                if (n == o.childCount) {
                    const t = new gs(o.parent, o.index + 1);
                    return this._breakAttributes(t, e)
                }
                if (0 === n) {
                    const t = new gs(o.parent, o.index);
                    return this._breakAttributes(t, e)
                } {
                    const t = o.index + 1,
                        i = o._clone();
                    o.parent._insertChild(t, i), this._addToClonedElementsGroup(i);
                    const r = o.childCount - n,
                        s = o._removeChildren(n, r);
                    i._appendChild(s);
                    const a = new gs(o.parent, t);
                    return this._breakAttributes(a, e)
                }
            }
            _addToClonedElementsGroup(t) {
                if (!t.root.is("rootElement")) return;
                if (t.is("element"))
                    for (const e of t.getChildren()) this._addToClonedElementsGroup(e);
                const e = t.id;
                if (!e) return;
                let n = this._cloneGroups.get(e);
                n || (n = new Set, this._cloneGroups.set(e, n)), n.add(t), t._clonesGroup = n
            }
            _removeFromClonedElementsGroup(t) {
                if (t.is("element"))
                    for (const e of t.getChildren()) this._removeFromClonedElementsGroup(e);
                const e = t.id;
                if (!e) return;
                const n = this._cloneGroups.get(e);
                n && n.delete(t)
            }
        }

        function Ms(t) {
            let e = t.parent;
            for (; !Us(e);) {
                if (!e) return;
                e = e.parent
            }
            return e
        }

        function Ns(t, e) {
            return t.priority < e.priority || !(t.priority > e.priority) && t.getIdentity() < e.getIdentity()
        }

        function Ls(t) {
            const e = t.nodeBefore;
            if (e && e.is("$text")) return new gs(e, e.data.length);
            const n = t.nodeAfter;
            return n && n.is("$text") ? new gs(n, 0) : t
        }

        function Hs(t) {
            if (t.offset == t.parent.data.length) return new gs(t.parent.parent, t.parent.index + 1);
            if (0 === t.offset) return new gs(t.parent.parent, t.parent.index);
            const e = t.parent.data.slice(t.offset);
            return t.parent._data = t.parent.data.slice(0, t.offset), t.parent.parent._insertChild(t.parent.index + 1, new or(t.root.document, e)), new gs(t.parent.parent, t.parent.index + 1)
        }

        function js(t, e) {
            const n = t.data.length;
            return t._data += e.data, e._remove(), new gs(t, n)
        }
        const qs = [or, Es, as, Ts, zs, Is];

        function Ws(t, e) {
            for (const n of t) {
                if (!qs.some((t => n instanceof t))) throw new b("view-writer-insert-invalid-node-type", e);
                n.is("$text") || Ws(n.getChildren(), e)
            }
        }

        function Us(t) {
            return t && (t.is("containerElement") || t.is("documentFragment"))
        }

        function $s(t, e) {
            const n = Ms(t.start),
                o = Ms(t.end);
            if (!n || !o || n !== o) throw new b("view-writer-invalid-range-container", e)
        }

        function Gs(t, e) {
            return null === t.id && null === e.id
        }
        const Ks = t => t.createTextNode(" "),
            Zs = t => {
                const e = t.createElement("span");
                return e.dataset.ckeFiller = "true", e.innerText = " ", e
            },
            Js = t => {
                const e = t.createElement("br");
                return e.dataset.ckeFiller = "true", e
            },
            Ys = 7,
            Qs = "⁠".repeat(Ys);

        function Xs(t) {
            return zo(t) && t.data.substr(0, Ys) === Qs
        }

        function ta(t) {
            return t.data.length == Ys && Xs(t)
        }

        function ea(t) {
            return Xs(t) ? t.data.slice(Ys) : t.data
        }

        function na(t, e) {
            if (e.keyCode == mi.arrowleft) {
                const t = e.domTarget.ownerDocument.defaultView.getSelection();
                if (1 == t.rangeCount && t.getRangeAt(0).collapsed) {
                    const e = t.getRangeAt(0).startContainer,
                        n = t.getRangeAt(0).startOffset;
                    Xs(e) && n <= Ys && t.collapse(e, 0)
                }
            }
        }
        var oa = n(9315),
            ia = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(oa.Z, ia);
        oa.Z.locals;
        class ra extends(q()) {
            constructor(t, e) {
                super(), this.domDocuments = new Set, this.markedAttributes = new Set, this.markedChildren = new Set, this.markedTexts = new Set, this._inlineFiller = null, this._fakeSelectionContainer = null, this.domConverter = t, this.selection = e, this.set("isFocused", !1), this.set("isSelecting", !1), i.isBlink && !i.isAndroid && this.on("change:isSelecting", (() => {
                    this.isSelecting || this.render()
                })), this.set("isComposing", !1), this.on("change:isComposing", (() => {
                    this.isComposing || this.render()
                }))
            }
            markToSync(t, e) {
                if ("text" === t) this.domConverter.mapViewToDom(e.parent) && this.markedTexts.add(e);
                else {
                    if (!this.domConverter.mapViewToDom(e)) return;
                    if ("attributes" === t) this.markedAttributes.add(e);
                    else {
                        if ("children" !== t) {
                            throw new b("view-renderer-unknown-type", this)
                        }
                        this.markedChildren.add(e)
                    }
                }
            }
            render() {
                if (this.isComposing && !i.isAndroid) return;
                let t = null;
                const e = !(i.isBlink && !i.isAndroid) || !this.isSelecting;
                for (const t of this.markedChildren) this._updateChildrenMappings(t);
                e ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? t = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (t = this.selection.getFirstPosition(), this.markedChildren.add(t.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (t = this.domConverter.domPositionToView(this._inlineFiller), t && t.parent.is("$text") && (t = gs._createBefore(t.parent)));
                for (const t of this.markedAttributes) this._updateAttrs(t);
                for (const e of this.markedChildren) this._updateChildren(e, {
                    inlineFillerPosition: t
                });
                for (const e of this.markedTexts) !this.markedChildren.has(e.parent) && this.domConverter.mapViewToDom(e.parent) && this._updateText(e, {
                    inlineFillerPosition: t
                });
                if (e)
                    if (t) {
                        const e = this.domConverter.viewPositionToDom(t),
                            n = e.parent.ownerDocument;
                        Xs(e.parent) ? this._inlineFiller = e.parent : this._inlineFiller = sa(n, e.parent, e.offset)
                    } else this._inlineFiller = null;
                this._updateFocus(), this._updateSelection(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear()
            }
            _updateChildrenMappings(t) {
                if (!this.domConverter.mapViewToDom(t)) return;
                const e = Array.from(this.domConverter.mapViewToDom(t).childNodes),
                    n = Array.from(this.domConverter.viewChildrenToDom(t, {
                        withChildren: !1
                    })),
                    o = this._diffNodeLists(e, n),
                    i = this._findUpdateActions(o, e, n, aa);
                if (-1 !== i.indexOf("update")) {
                    const o = {
                        equal: 0,
                        insert: 0,
                        delete: 0
                    };
                    for (const r of i)
                        if ("update" === r) {
                            const i = o.equal + o.insert,
                                r = o.equal + o.delete,
                                s = t.getChild(i);
                            !s || s.is("uiElement") || s.is("rawElement") || this._updateElementMappings(s, e[r]), ei(n[i]), o.equal++
                        } else o[r]++
                }
            }
            _updateElementMappings(t, e) {
                this.domConverter.unbindDomElement(e), this.domConverter.bindElements(e, t), this.markedChildren.add(t), this.markedAttributes.add(t)
            }
            _getInlineFillerPosition() {
                const t = this.selection.getFirstPosition();
                return t.parent.is("$text") ? gs._createBefore(t.parent) : t
            }
            _isSelectionInInlineFiller() {
                if (1 != this.selection.rangeCount || !this.selection.isCollapsed) return !1;
                const t = this.selection.getFirstPosition(),
                    e = this.domConverter.viewPositionToDom(t);
                return !!(e && zo(e.parent) && Xs(e.parent))
            }
            _removeInlineFiller() {
                const t = this._inlineFiller;
                if (!Xs(t)) throw new b("view-renderer-filler-was-lost", this);
                ta(t) ? t.remove() : t.data = t.data.substr(Ys), this._inlineFiller = null
            }
            _needsInlineFillerAtSelection() {
                if (1 != this.selection.rangeCount || !this.selection.isCollapsed) return !1;
                const t = this.selection.getFirstPosition(),
                    e = t.parent,
                    n = t.offset;
                if (!this.domConverter.mapViewToDom(e.root)) return !1;
                if (!e.is("element")) return !1;
                if (! function(t) {
                        if ("false" == t.getAttribute("contenteditable")) return !1;
                        const e = t.findAncestor((t => t.hasAttribute("contenteditable")));
                        return !e || "true" == e.getAttribute("contenteditable")
                    }(e)) return !1;
                if (n === e.getFillerOffset()) return !1;
                const o = t.nodeBefore,
                    r = t.nodeAfter;
                return !(o instanceof or || r instanceof or) && (!i.isAndroid || !o && !r)
            }
            _updateText(t, e) {
                const n = this.domConverter.findCorrespondingDomText(t);
                let o = this.domConverter.viewToDom(t).data;
                const i = e.inlineFillerPosition;
                i && i.parent == t.parent && i.offset == t.index && (o = Qs + o), da(n, o)
            }
            _updateAttrs(t) {
                const e = this.domConverter.mapViewToDom(t);
                if (!e) return;
                const n = Array.from(e.attributes).map((t => t.name)),
                    o = t.getAttributeKeys();
                for (const n of o) this.domConverter.setDomElementAttribute(e, n, t.getAttribute(n), t);
                for (const o of n) t.hasAttribute(o) || this.domConverter.removeDomElementAttribute(e, o)
            }
            _updateChildren(t, e) {
                const n = this.domConverter.mapViewToDom(t);
                if (!n) return;
                if (i.isAndroid) {
                    let t = null;
                    for (const e of Array.from(n.childNodes)) {
                        if (t && zo(t) && zo(e)) {
                            n.normalize();
                            break
                        }
                        t = e
                    }
                }
                const o = e.inlineFillerPosition,
                    r = n.childNodes,
                    s = Array.from(this.domConverter.viewChildrenToDom(t, {
                        bind: !0
                    }));
                o && o.parent === t && sa(n.ownerDocument, s, o.offset);
                const a = this._diffNodeLists(r, s),
                    l = this._findUpdateActions(a, r, s, la);
                let c = 0;
                const d = new Set;
                for (const t of l) "delete" === t ? (d.add(r[c]), ei(r[c])) : "equal" !== t && "update" !== t || c++;
                c = 0;
                for (const t of l) "insert" === t ? (Ko(n, c, s[c]), c++) : "update" === t ? (da(r[c], s[c].data), c++) : "equal" === t && (this._markDescendantTextToSync(this.domConverter.domToView(s[c])), c++);
                for (const t of d) t.parentNode || this.domConverter.unbindDomElement(t)
            }
            _diffNodeLists(t, e) {
                return t = function(t, e) {
                    const n = Array.from(t);
                    if (0 == n.length || !e) return n;
                    const o = n[n.length - 1];
                    o == e && n.pop();
                    return n
                }(t, this._fakeSelectionContainer), c(t, e, ca.bind(null, this.domConverter))
            }
            _findUpdateActions(t, e, n, o) {
                if (-1 === t.indexOf("insert") || -1 === t.indexOf("delete")) return t;
                let i = [],
                    r = [],
                    s = [];
                const a = {
                    equal: 0,
                    insert: 0,
                    delete: 0
                };
                for (const l of t) "insert" === l ? s.push(n[a.equal + a.insert]) : "delete" === l ? r.push(e[a.equal + a.delete]) : (i = i.concat(c(r, s, o).map((t => "equal" === t ? "update" : t))), i.push("equal"), r = [], s = []), a[l]++;
                return i.concat(c(r, s, o).map((t => "equal" === t ? "update" : t)))
            }
            _markDescendantTextToSync(t) {
                if (t)
                    if (t.is("$text")) this.markedTexts.add(t);
                    else if (t.is("element"))
                    for (const e of t.getChildren()) this._markDescendantTextToSync(e)
            }
            _updateSelection() {
                if (i.isBlink && !i.isAndroid && this.isSelecting && !this.markedChildren.size) return;
                if (0 === this.selection.rangeCount) return this._removeDomSelection(), void this._removeFakeSelection();
                const t = this.domConverter.mapViewToDom(this.selection.editableElement);
                this.isFocused && t && (this.selection.isFake ? this._updateFakeSelection(t) : this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected ? (this._removeFakeSelection(), this._updateDomSelection(t)) : this.isComposing && i.isAndroid || this._updateDomSelection(t))
            }
            _updateFakeSelection(t) {
                const e = t.ownerDocument;
                this._fakeSelectionContainer || (this._fakeSelectionContainer = function(t) {
                    const e = t.createElement("div");
                    return e.className = "ck-fake-selection-container", Object.assign(e.style, {
                        position: "fixed",
                        top: 0,
                        left: "-9999px",
                        width: "42px"
                    }), e.textContent = " ", e
                }(e));
                const n = this._fakeSelectionContainer;
                if (this.domConverter.bindFakeSelection(n, this.selection), !this._fakeSelectionNeedsUpdate(t)) return;
                n.parentElement && n.parentElement == t || t.appendChild(n), n.textContent = this.selection.fakeSelectionLabel || " ";
                const o = e.getSelection(),
                    i = e.createRange();
                o.removeAllRanges(), i.selectNodeContents(n), o.addRange(i)
            }
            _updateDomSelection(t) {
                const e = t.ownerDocument.defaultView.getSelection();
                if (!this._domSelectionNeedsUpdate(e)) return;
                const n = this.domConverter.viewPositionToDom(this.selection.anchor),
                    o = this.domConverter.viewPositionToDom(this.selection.focus);
                e.collapse(n.parent, n.offset), e.extend(o.parent, o.offset), i.isGecko && function(t, e) {
                    const n = t.parent;
                    if (n.nodeType != Node.ELEMENT_NODE || t.offset != n.childNodes.length - 1) return;
                    const o = n.childNodes[t.offset];
                    o && "BR" == o.tagName && e.addRange(e.getRangeAt(0))
                }(o, e)
            }
            _domSelectionNeedsUpdate(t) {
                if (!this.domConverter.isDomSelectionCorrect(t)) return !0;
                const e = t && this.domConverter.domSelectionToView(t);
                return (!e || !this.selection.isEqual(e)) && !(!this.selection.isCollapsed && this.selection.isSimilar(e))
            }
            _fakeSelectionNeedsUpdate(t) {
                const e = this._fakeSelectionContainer,
                    n = t.ownerDocument.getSelection();
                return !e || e.parentElement !== t || (n.anchorNode !== e && !e.contains(n.anchorNode) || e.textContent !== this.selection.fakeSelectionLabel)
            }
            _removeDomSelection() {
                for (const t of this.domDocuments) {
                    const e = t.getSelection();
                    if (e.rangeCount) {
                        const n = t.activeElement,
                            o = this.domConverter.mapDomToView(n);
                        n && o && e.removeAllRanges()
                    }
                }
            }
            _removeFakeSelection() {
                const t = this._fakeSelectionContainer;
                t && t.remove()
            }
            _updateFocus() {
                if (this.isFocused) {
                    const t = this.selection.editableElement;
                    t && this.domConverter.focus(t)
                }
            }
        }

        function sa(t, e, n) {
            const o = e instanceof Array ? e : e.childNodes,
                i = o[n];
            if (zo(i)) return i.data = Qs + i.data, i;
            {
                const i = t.createTextNode(Qs);
                return Array.isArray(e) ? o.splice(n, 0, i) : Ko(e, n, i), i
            }
        }

        function aa(t, e) {
            return xo(t) && xo(e) && !zo(t) && !zo(e) && !Zo(t) && !Zo(e) && t.tagName.toLowerCase() === e.tagName.toLowerCase()
        }

        function la(t, e) {
            return xo(t) && xo(e) && zo(t) && zo(e)
        }

        function ca(t, e, n) {
            return e === n || (zo(e) && zo(n) ? e.data === n.data : !(!t.isBlockFiller(e) || !t.isBlockFiller(n)))
        }

        function da(t, e) {
            const n = t.data;
            if (n == e) return;
            const o = s(n, e);
            for (const e of o) "insert" === e.type ? t.insertData(e.index, e.values.join("")) : t.deleteData(e.index, e.howMany)
        }
        const ha = Js(Po.document),
            ua = Ks(Po.document),
            ga = Zs(Po.document),
            ma = "data-ck-unsafe-attribute-",
            pa = "data-ck-unsafe-element";
        class fa {
            constructor(t, {
                blockFillerMode: e,
                renderingMode: n = "editing"
            } = {}) {
                this._domToViewMapping = new WeakMap, this._viewToDomMapping = new WeakMap, this._fakeSelectionMapping = new WeakMap, this._rawContentElementMatcher = new rr, this._encounteredRawContentDomNodes = new WeakSet, this.document = t, this.renderingMode = n, this.blockFillerMode = e || ("editing" === n ? "br" : "nbsp"), this.preElements = ["pre"], this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"], this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"], this.unsafeElements = ["script", "style"], this._domDocument = "editing" === this.renderingMode ? Po.document : Po.document.implementation.createHTMLDocument("")
            }
            bindFakeSelection(t, e) {
                this._fakeSelectionMapping.set(t, new fs(e))
            }
            fakeSelectionToView(t) {
                return this._fakeSelectionMapping.get(t)
            }
            bindElements(t, e) {
                this._domToViewMapping.set(t, e), this._viewToDomMapping.set(e, t)
            }
            unbindDomElement(t) {
                const e = this._domToViewMapping.get(t);
                if (e) {
                    this._domToViewMapping.delete(t), this._viewToDomMapping.delete(e);
                    for (const e of Array.from(t.children)) this.unbindDomElement(e)
                }
            }
            bindDocumentFragments(t, e) {
                this._domToViewMapping.set(t, e), this._viewToDomMapping.set(e, t)
            }
            shouldRenderAttribute(t, e, n) {
                return "data" === this.renderingMode || !(t = t.toLowerCase()).startsWith("on") && (("srcdoc" !== t || !e.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) && ("img" === n && ("src" === t || "srcset" === t) || ("source" === n && "srcset" === t || !e.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i))))
            }
            setContentOf(t, e) {
                if ("data" === this.renderingMode) return void(t.innerHTML = e);
                const n = (new DOMParser).parseFromString(e, "text/html"),
                    o = n.createDocumentFragment(),
                    i = n.body.childNodes;
                for (; i.length > 0;) o.appendChild(i[0]);
                const r = n.createTreeWalker(o, NodeFilter.SHOW_ELEMENT),
                    s = [];
                let a;
                for (; a = r.nextNode();) s.push(a);
                for (const t of s) {
                    for (const e of t.getAttributeNames()) this.setDomElementAttribute(t, e, t.getAttribute(e));
                    const e = t.tagName.toLowerCase();
                    this._shouldRenameElement(e) && (wa(e), t.replaceWith(this._createReplacementDomElement(e, t)))
                }
                for (; t.firstChild;) t.firstChild.remove();
                t.append(o)
            }
            viewToDom(t, e = {}) {
                if (t.is("$text")) {
                    const e = this._processDataFromViewText(t);
                    return this._domDocument.createTextNode(e)
                } {
                    if (this.mapViewToDom(t)) return this.mapViewToDom(t);
                    let n;
                    if (t.is("documentFragment")) n = this._domDocument.createDocumentFragment(), e.bind && this.bindDocumentFragments(n, t);
                    else {
                        if (t.is("uiElement")) return n = "$comment" === t.name ? this._domDocument.createComment(t.getCustomProperty("$rawContent")) : t.render(this._domDocument, this), e.bind && this.bindElements(n, t), n;
                        this._shouldRenameElement(t.name) ? (wa(t.name), n = this._createReplacementDomElement(t.name)) : n = t.hasAttribute("xmlns") ? this._domDocument.createElementNS(t.getAttribute("xmlns"), t.name) : this._domDocument.createElement(t.name), t.is("rawElement") && t.render(n, this), e.bind && this.bindElements(n, t);
                        for (const e of t.getAttributeKeys()) this.setDomElementAttribute(n, e, t.getAttribute(e), t)
                    }
                    if (!1 !== e.withChildren)
                        for (const o of this.viewChildrenToDom(t, e)) n.appendChild(o);
                    return n
                }
            }
            setDomElementAttribute(t, e, n, o) {
                const i = this.shouldRenderAttribute(e, n, t.tagName.toLowerCase()) || o && o.shouldRenderUnsafeAttribute(e);
                i || k("domconverter-unsafe-attribute-detected", {
                        domElement: t,
                        key: e,
                        value: n
                    }),
                    function(t) {
                        try {
                            Po.document.createAttribute(t)
                        } catch (t) {
                            return !1
                        }
                        return !0
                    }(e) ? (t.hasAttribute(e) && !i ? t.removeAttribute(e) : t.hasAttribute(ma + e) && i && t.removeAttribute(ma + e), t.setAttribute(i ? e : ma + e, n)) : k("domconverter-invalid-attribute-detected", {
                        domElement: t,
                        key: e,
                        value: n
                    })
            }
            removeDomElementAttribute(t, e) {
                e != pa && (t.removeAttribute(e), t.removeAttribute(ma + e))
            }* viewChildrenToDom(t, e = {}) {
                const n = t.getFillerOffset && t.getFillerOffset();
                let o = 0;
                for (const i of t.getChildren()) {
                    n === o && (yield this._getBlockFiller());
                    const t = i.is("element") && !!i.getCustomProperty("dataPipeline:transparentRendering") && !Ei(i.getAttributes());
                    t && "data" == this.renderingMode ? yield* this.viewChildrenToDom(i, e): (t && k("domconverter-transparent-rendering-unsupported-in-editing-pipeline", {
                        viewElement: i
                    }), yield this.viewToDom(i, e)), o++
                }
                n === o && (yield this._getBlockFiller())
            }
            viewRangeToDom(t) {
                const e = this.viewPositionToDom(t.start),
                    n = this.viewPositionToDom(t.end),
                    o = this._domDocument.createRange();
                return o.setStart(e.parent, e.offset), o.setEnd(n.parent, n.offset), o
            }
            viewPositionToDom(t) {
                const e = t.parent;
                if (e.is("$text")) {
                    const n = this.findCorrespondingDomText(e);
                    if (!n) return null;
                    let o = t.offset;
                    return Xs(n) && (o += Ys), {
                        parent: n,
                        offset: o
                    }
                } {
                    let n, o, i;
                    if (0 === t.offset) {
                        if (n = this.mapViewToDom(e), !n) return null;
                        i = n.childNodes[0]
                    } else {
                        const e = t.nodeBefore;
                        if (o = e.is("$text") ? this.findCorrespondingDomText(e) : this.mapViewToDom(e), !o) return null;
                        n = o.parentNode, i = o.nextSibling
                    }
                    if (zo(i) && Xs(i)) return {
                        parent: i,
                        offset: Ys
                    };
                    return {
                        parent: n,
                        offset: o ? Go(o) + 1 : 0
                    }
                }
            }
            domToView(t, e = {}) {
                if (this.isBlockFiller(t)) return null;
                const n = this.getHostViewElement(t);
                if (n) return n;
                if (Zo(t) && e.skipComments) return null;
                if (zo(t)) {
                    if (ta(t)) return null;
                    {
                        const e = this._processDataFromDomText(t);
                        return "" === e ? null : new or(this.document, e)
                    }
                } {
                    if (this.mapDomToView(t)) return this.mapDomToView(t);
                    let n;
                    if (this.isDocumentFragment(t)) n = new Os(this.document), e.bind && this.bindDocumentFragments(t, n);
                    else {
                        n = this._createViewElement(t, e), e.bind && this.bindElements(t, n);
                        const o = t.attributes;
                        if (o)
                            for (let t = o.length, e = 0; e < t; e++) n._setAttribute(o[e].name, o[e].value);
                        if (this._isViewElementWithRawContent(n, e) || Zo(t)) {
                            const e = Zo(t) ? t.data : t.innerHTML;
                            return n._setCustomProperty("$rawContent", e), this._encounteredRawContentDomNodes.add(t), n
                        }
                    }
                    if (!1 !== e.withChildren)
                        for (const o of this.domChildrenToView(t, e)) n._appendChild(o);
                    return n
                }
            }* domChildrenToView(t, e) {
                for (let n = 0; n < t.childNodes.length; n++) {
                    const o = t.childNodes[n],
                        i = this.domToView(o, e);
                    null !== i && (yield i)
                }
            }
            domSelectionToView(t) {
                if (1 === t.rangeCount) {
                    let e = t.getRangeAt(0).startContainer;
                    zo(e) && (e = e.parentNode);
                    const n = this.fakeSelectionToView(e);
                    if (n) return n
                }
                const e = this.isDomSelectionBackward(t),
                    n = [];
                for (let e = 0; e < t.rangeCount; e++) {
                    const o = t.getRangeAt(e),
                        i = this.domRangeToView(o);
                    i && n.push(i)
                }
                return new fs(n, {
                    backward: e
                })
            }
            domRangeToView(t) {
                const e = this.domPositionToView(t.startContainer, t.startOffset),
                    n = this.domPositionToView(t.endContainer, t.endOffset);
                return e && n ? new ms(e, n) : null
            }
            domPositionToView(t, e = 0) {
                if (this.isBlockFiller(t)) return this.domPositionToView(t.parentNode, Go(t));
                const n = this.mapDomToView(t);
                if (n && (n.is("uiElement") || n.is("rawElement"))) return gs._createBefore(n);
                if (zo(t)) {
                    if (ta(t)) return this.domPositionToView(t.parentNode, Go(t));
                    const n = this.findCorrespondingViewText(t);
                    let o = e;
                    return n ? (Xs(t) && (o -= Ys, o = o < 0 ? 0 : o), new gs(n, o)) : null
                }
                if (0 === e) {
                    const e = this.mapDomToView(t);
                    if (e) return new gs(e, 0)
                } else {
                    const n = t.childNodes[e - 1];
                    if (zo(n) && ta(n) || n && this.isBlockFiller(n)) return this.domPositionToView(n.parentNode, Go(n));
                    const o = zo(n) ? this.findCorrespondingViewText(n) : this.mapDomToView(n);
                    if (o && o.parent) return new gs(o.parent, o.index + 1)
                }
                return null
            }
            mapDomToView(t) {
                return this.getHostViewElement(t) || this._domToViewMapping.get(t)
            }
            findCorrespondingViewText(t) {
                if (ta(t)) return null;
                const e = this.getHostViewElement(t);
                if (e) return e;
                const n = t.previousSibling;
                if (n) {
                    if (!this.isElement(n)) return null;
                    const t = this.mapDomToView(n);
                    if (t) {
                        const e = t.nextSibling;
                        return e instanceof or ? e : null
                    }
                } else {
                    const e = this.mapDomToView(t.parentNode);
                    if (e) {
                        const t = e.getChild(0);
                        return t instanceof or ? t : null
                    }
                }
                return null
            }
            mapViewToDom(t) {
                return this._viewToDomMapping.get(t)
            }
            findCorrespondingDomText(t) {
                const e = t.previousSibling;
                return e && this.mapViewToDom(e) ? this.mapViewToDom(e).nextSibling : !e && t.parent && this.mapViewToDom(t.parent) ? this.mapViewToDom(t.parent).childNodes[0] : null
            }
            focus(t) {
                const e = this.mapViewToDom(t);
                if (e && e.ownerDocument.activeElement !== e) {
                    const {
                        scrollX: t,
                        scrollY: n
                    } = Po.window, o = [];
                    ba(e, (t => {
                        const {
                            scrollLeft: e,
                            scrollTop: n
                        } = t;
                        o.push([e, n])
                    })), e.focus(), ba(e, (t => {
                        const [e, n] = o.shift();
                        t.scrollLeft = e, t.scrollTop = n
                    })), Po.window.scrollTo(t, n)
                }
            }
            isElement(t) {
                return t && t.nodeType == Node.ELEMENT_NODE
            }
            isDocumentFragment(t) {
                return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE
            }
            isBlockFiller(t) {
                return "br" == this.blockFillerMode ? t.isEqualNode(ha) : !("BR" !== t.tagName || !ka(t, this.blockElements) || 1 !== t.parentNode.childNodes.length) || (t.isEqualNode(ga) || function(t, e) {
                    const n = t.isEqualNode(ua);
                    return n && ka(t, e) && 1 === t.parentNode.childNodes.length
                }(t, this.blockElements))
            }
            isDomSelectionBackward(t) {
                if (t.isCollapsed) return !1;
                const e = this._domDocument.createRange();
                try {
                    e.setStart(t.anchorNode, t.anchorOffset), e.setEnd(t.focusNode, t.focusOffset)
                } catch (t) {
                    return !1
                }
                const n = e.collapsed;
                return e.detach(), n
            }
            getHostViewElement(t) {
                const e = Ro(t);
                for (e.pop(); e.length;) {
                    const t = e.pop(),
                        n = this._domToViewMapping.get(t);
                    if (n && (n.is("uiElement") || n.is("rawElement"))) return n
                }
                return null
            }
            isDomSelectionCorrect(t) {
                return this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) && this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
            }
            registerRawContentMatcher(t) {
                this._rawContentElementMatcher.add(t)
            }
            _getBlockFiller() {
                switch (this.blockFillerMode) {
                    case "nbsp":
                        return Ks(this._domDocument);
                    case "markedNbsp":
                        return Zs(this._domDocument);
                    case "br":
                        return Js(this._domDocument)
                }
            }
            _isDomSelectionPositionCorrect(t, e) {
                if (zo(t) && Xs(t) && e < Ys) return !1;
                if (this.isElement(t) && Xs(t.childNodes[e])) return !1;
                const n = this.mapDomToView(t);
                return !n || !n.is("uiElement") && !n.is("rawElement")
            }
            _processDataFromViewText(t) {
                let e = t.data;
                if (t.getAncestors().some((t => this.preElements.includes(t.name)))) return e;
                if (" " == e.charAt(0)) {
                    const n = this._getTouchingInlineViewNode(t, !1);
                    !(n && n.is("$textProxy") && this._nodeEndsWithSpace(n)) && n || (e = " " + e.substr(1))
                }
                if (" " == e.charAt(e.length - 1)) {
                    const n = this._getTouchingInlineViewNode(t, !0),
                        o = n && n.is("$textProxy") && " " == n.data.charAt(0);
                    " " != e.charAt(e.length - 2) && n && !o || (e = e.substr(0, e.length - 1) + " ")
                }
                return e.replace(/ {2}/g, "  ")
            }
            _nodeEndsWithSpace(t) {
                if (t.getAncestors().some((t => this.preElements.includes(t.name)))) return !1;
                const e = this._processDataFromViewText(t);
                return " " == e.charAt(e.length - 1)
            }
            _processDataFromDomText(t) {
                let e = t.data;
                if (function(t, e) {
                        const n = Ro(t);
                        return n.some((t => t.tagName && e.includes(t.tagName.toLowerCase())))
                    }(t, this.preElements)) return ea(t);
                e = e.replace(/[ \n\t\r]{1,}/g, " ");
                const n = this._getTouchingInlineDomNode(t, !1),
                    o = this._getTouchingInlineDomNode(t, !0),
                    i = this._checkShouldLeftTrimDomText(t, n),
                    r = this._checkShouldRightTrimDomText(t, o);
                i && (e = e.replace(/^ /, "")), r && (e = e.replace(/ $/, "")), e = ea(new Text(e)), e = e.replace(/ \u00A0/g, "  ");
                const s = o && this.isElement(o) && "BR" != o.tagName,
                    a = o && zo(o) && " " == o.data.charAt(0);
                return (/( |\u00A0)\u00A0$/.test(e) || !o || s || a) && (e = e.replace(/\u00A0$/, " ")), (i || n && this.isElement(n) && "BR" != n.tagName) && (e = e.replace(/^\u00A0/, " ")), e
            }
            _checkShouldLeftTrimDomText(t, e) {
                return !e || (this.isElement(e) ? "BR" === e.tagName : !this._encounteredRawContentDomNodes.has(t.previousSibling) && /[^\S\u00A0]/.test(e.data.charAt(e.data.length - 1)))
            }
            _checkShouldRightTrimDomText(t, e) {
                return !e && !Xs(t)
            }
            _getTouchingInlineViewNode(t, e) {
                const n = new us({
                    startPosition: e ? gs._createAfter(t) : gs._createBefore(t),
                    direction: e ? "forward" : "backward"
                });
                for (const t of n) {
                    if (t.item.is("element") && this.inlineObjectElements.includes(t.item.name)) return t.item;
                    if (t.item.is("containerElement")) return null;
                    if (t.item.is("element", "br")) return null;
                    if (t.item.is("$textProxy")) return t.item
                }
                return null
            }
            _getTouchingInlineDomNode(t, e) {
                if (!t.parentNode) return null;
                const n = e ? "firstChild" : "lastChild",
                    o = e ? "nextSibling" : "previousSibling";
                let i = !0,
                    r = t;
                do {
                    if (!i && r[n] ? r = r[n] : r[o] ? (r = r[o], i = !1) : (r = r.parentNode, i = !0), !r || this._isBlockElement(r)) return null
                } while (!zo(r) && "BR" != r.tagName && !this._isInlineObjectElement(r));
                return r
            }
            _isBlockElement(t) {
                return this.isElement(t) && this.blockElements.includes(t.tagName.toLowerCase())
            }
            _isInlineObjectElement(t) {
                return this.isElement(t) && this.inlineObjectElements.includes(t.tagName.toLowerCase())
            }
            _createViewElement(t, e) {
                if (Zo(t)) return new Is(this.document, "$comment");
                const n = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase();
                return new rs(this.document, n)
            }
            _isViewElementWithRawContent(t, e) {
                return !1 !== e.withChildren && !!this._rawContentElementMatcher.match(t)
            }
            _shouldRenameElement(t) {
                const e = t.toLowerCase();
                return "editing" === this.renderingMode && this.unsafeElements.includes(e)
            }
            _createReplacementDomElement(t, e) {
                const n = this._domDocument.createElement("span");
                if (n.setAttribute(pa, t), e) {
                    for (; e.firstChild;) n.appendChild(e.firstChild);
                    for (const t of e.getAttributeNames()) n.setAttribute(t, e.getAttribute(t))
                }
                return n
            }
        }

        function ba(t, e) {
            let n = t;
            for (; n;) e(n), n = n.parentElement
        }

        function ka(t, e) {
            const n = t.parentNode;
            return !!n && !!n.tagName && e.includes(n.tagName.toLowerCase())
        }

        function wa(t) {
            "script" === t && k("domconverter-unsafe-script-element-detected"), "style" === t && k("domconverter-unsafe-style-element-detected")
        }
        class Aa extends(So()) {
            constructor(t) {
                super(), this._isEnabled = !1, this.view = t, this.document = t.document
            }
            get isEnabled() {
                return this._isEnabled
            }
            enable() {
                this._isEnabled = !0
            }
            disable() {
                this._isEnabled = !1
            }
            destroy() {
                this.disable(), this.stopListening()
            }
            checkShouldIgnoreEventFromTarget(t) {
                return t && 3 === t.nodeType && (t = t.parentNode), !(!t || 1 !== t.nodeType) && t.matches("[data-cke-ignore-events], [data-cke-ignore-events] *")
            }
        }
        const Ca = Yr((function(t, e) {
            De(e, hn(e), t)
        }));
        class _a {
            constructor(t, e, n) {
                this.view = t, this.document = t.document, this.domEvent = e, this.domTarget = e.target, Ca(this, n)
            }
            get target() {
                return this.view.domConverter.mapDomToView(this.domTarget)
            }
            preventDefault() {
                this.domEvent.preventDefault()
            }
            stopPropagation() {
                this.domEvent.stopPropagation()
            }
        }
        class va extends Aa {
            constructor() {
                super(...arguments), this.useCapture = !1
            }
            observe(t) {
                ("string" == typeof this.domEventType ? [this.domEventType] : this.domEventType).forEach((e => {
                    this.listenTo(t, e, ((t, e) => {
                        this.isEnabled && !this.checkShouldIgnoreEventFromTarget(e.target) && this.onDomEvent(e)
                    }), {
                        useCapture: this.useCapture
                    })
                }))
            }
            stopObserving(t) {
                this.stopListening(t)
            }
            fire(t, e, n) {
                this.isEnabled && this.document.fire(t, new _a(this.view, e, n))
            }
        }
        class ya extends va {
            constructor() {
                super(...arguments), this.domEventType = ["keydown", "keyup"]
            }
            onDomEvent(t) {
                const e = {
                    keyCode: t.keyCode,
                    altKey: t.altKey,
                    ctrlKey: t.ctrlKey,
                    shiftKey: t.shiftKey,
                    metaKey: t.metaKey,
                    get keystroke() {
                        return fi(this)
                    }
                };
                this.fire(t.type, t, e)
            }
        }
        const xa = function() {
            return et.Date.now()
        };
        var Ea = /\s/;
        const Da = function(t) {
            for (var e = t.length; e-- && Ea.test(t.charAt(e)););
            return e
        };
        var Sa = /^\s+/;
        const Ta = function(t) {
            return t ? t.slice(0, Da(t) + 1).replace(Sa, "") : t
        };
        var Ba = /^[-+]0x[0-9a-f]+$/i,
            Ia = /^0b[01]+$/i,
            Pa = /^0o[0-7]+$/i,
            Ra = parseInt;
        const za = function(t) {
            if ("number" == typeof t) return t;
            if (lr(t)) return NaN;
            if (O(t)) {
                var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                t = O(e) ? e + "" : e
            }
            if ("string" != typeof t) return 0 === t ? t : +t;
            t = Ta(t);
            var n = Ia.test(t);
            return n || Pa.test(t) ? Ra(t.slice(2), n ? 2 : 8) : Ba.test(t) ? NaN : +t
        };
        var Va = Math.max,
            Oa = Math.min;
        const Fa = function(t, e, n) {
            var o, i, r, s, a, l, c = 0,
                d = !1,
                h = !1,
                u = !0;
            if ("function" != typeof t) throw new TypeError("Expected a function");

            function g(e) {
                var n = o,
                    r = i;
                return o = i = void 0, c = e, s = t.apply(r, n)
            }

            function m(t) {
                var n = t - l;
                return void 0 === l || n >= e || n < 0 || h && t - c >= r
            }

            function p() {
                var t = xa();
                if (m(t)) return f(t);
                a = setTimeout(p, function(t) {
                    var n = e - (t - l);
                    return h ? Oa(n, r - (t - c)) : n
                }(t))
            }

            function f(t) {
                return a = void 0, u && o ? g(t) : (o = i = void 0, s)
            }

            function b() {
                var t = xa(),
                    n = m(t);
                if (o = arguments, i = this, l = t, n) {
                    if (void 0 === a) return function(t) {
                        return c = t, a = setTimeout(p, e), d ? g(t) : s
                    }(l);
                    if (h) return clearTimeout(a), a = setTimeout(p, e), g(l)
                }
                return void 0 === a && (a = setTimeout(p, e)), s
            }
            return e = za(e) || 0, O(n) && (d = !!n.leading, r = (h = "maxWait" in n) ? Va(za(n.maxWait) || 0, e) : r, u = "trailing" in n ? !!n.trailing : u), b.cancel = function() {
                void 0 !== a && clearTimeout(a), c = 0, o = l = i = a = void 0
            }, b.flush = function() {
                return void 0 === a ? s : f(xa())
            }, b
        };
        class Ma extends Aa {
            constructor(t) {
                super(t), this._fireSelectionChangeDoneDebounced = Fa((t => {
                    this.document.fire("selectionChangeDone", t)
                }), 200)
            }
            observe() {
                const t = this.document;
                t.on("arrowKey", ((e, n) => {
                    t.selection.isFake && this.isEnabled && n.preventDefault()
                }), {
                    context: "$capture"
                }), t.on("arrowKey", ((e, n) => {
                    t.selection.isFake && this.isEnabled && this._handleSelectionMove(n.keyCode)
                }), {
                    priority: "lowest"
                })
            }
            stopObserving() {}
            destroy() {
                super.destroy(), this._fireSelectionChangeDoneDebounced.cancel()
            }
            _handleSelectionMove(t) {
                const e = this.document.selection,
                    n = new fs(e.getRanges(), {
                        backward: e.isBackward,
                        fake: !1
                    });
                t != mi.arrowleft && t != mi.arrowup || n.setTo(n.getFirstPosition()), t != mi.arrowright && t != mi.arrowdown || n.setTo(n.getLastPosition());
                const o = {
                    oldSelection: e,
                    newSelection: n,
                    domSelection: null
                };
                this.document.fire("selectionChange", o), this._fireSelectionChangeDoneDebounced(o)
            }
        }
        const Na = function(t) {
            return this.__data__.set(t, "__lodash_hash_undefined__"), this
        };
        const La = function(t) {
            return this.__data__.has(t)
        };

        function Ha(t) {
            var e = -1,
                n = null == t ? 0 : t.length;
            for (this.__data__ = new ke; ++e < n;) this.add(t[e])
        }
        Ha.prototype.add = Ha.prototype.push = Na, Ha.prototype.has = La;
        const ja = Ha;
        const qa = function(t, e) {
            for (var n = -1, o = null == t ? 0 : t.length; ++n < o;)
                if (e(t[n], n, t)) return !0;
            return !1
        };
        const Wa = function(t, e) {
            return t.has(e)
        };
        const Ua = function(t, e, n, o, i, r) {
            var s = 1 & n,
                a = t.length,
                l = e.length;
            if (a != l && !(s && l > a)) return !1;
            var c = r.get(t),
                d = r.get(e);
            if (c && d) return c == e && d == t;
            var h = -1,
                u = !0,
                g = 2 & n ? new ja : void 0;
            for (r.set(t, e), r.set(e, t); ++h < a;) {
                var m = t[h],
                    p = e[h];
                if (o) var f = s ? o(p, m, h, e, t, r) : o(m, p, h, t, e, r);
                if (void 0 !== f) {
                    if (f) continue;
                    u = !1;
                    break
                }
                if (g) {
                    if (!qa(e, (function(t, e) {
                            if (!Wa(g, e) && (m === t || i(m, t, n, o, r))) return g.push(e)
                        }))) {
                        u = !1;
                        break
                    }
                } else if (m !== p && !i(m, p, n, o, r)) {
                    u = !1;
                    break
                }
            }
            return r.delete(t), r.delete(e), u
        };
        const $a = function(t) {
            var e = -1,
                n = Array(t.size);
            return t.forEach((function(t, o) {
                n[++e] = [o, t]
            })), n
        };
        const Ga = function(t) {
            var e = -1,
                n = Array(t.size);
            return t.forEach((function(t) {
                n[++e] = t
            })), n
        };
        var Ka = nt ? nt.prototype : void 0,
            Za = Ka ? Ka.valueOf : void 0;
        const Ja = function(t, e, n, o, i, r, s) {
            switch (n) {
                case "[object DataView]":
                    if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
                    t = t.buffer, e = e.buffer;
                case "[object ArrayBuffer]":
                    return !(t.byteLength != e.byteLength || !r(new Zn(t), new Zn(e)));
                case "[object Boolean]":
                case "[object Date]":
                case "[object Number]":
                    return xt(+t, +e);
                case "[object Error]":
                    return t.name == e.name && t.message == e.message;
                case "[object RegExp]":
                case "[object String]":
                    return t == e + "";
                case "[object Map]":
                    var a = $a;
                case "[object Set]":
                    var l = 1 & o;
                    if (a || (a = Ga), t.size != e.size && !l) return !1;
                    var c = s.get(t);
                    if (c) return c == e;
                    o |= 2, s.set(t, e);
                    var d = Ua(a(t), a(e), o, i, r, s);
                    return s.delete(t), d;
                case "[object Symbol]":
                    if (Za) return Za.call(t) == Za.call(e)
            }
            return !1
        };
        var Ya = Object.prototype.hasOwnProperty;
        const Qa = function(t, e, n, o, i, r) {
            var s = 1 & n,
                a = Tn(t),
                l = a.length;
            if (l != Tn(e).length && !s) return !1;
            for (var c = l; c--;) {
                var d = a[c];
                if (!(s ? d in e : Ya.call(e, d))) return !1
            }
            var h = r.get(t),
                u = r.get(e);
            if (h && u) return h == e && u == t;
            var g = !0;
            r.set(t, e), r.set(e, t);
            for (var m = s; ++c < l;) {
                var p = t[d = a[c]],
                    f = e[d];
                if (o) var b = s ? o(f, p, d, e, t, r) : o(p, f, d, t, e, r);
                if (!(void 0 === b ? p === f || i(p, f, n, o, r) : b)) {
                    g = !1;
                    break
                }
                m || (m = "constructor" == d)
            }
            if (g && !m) {
                var k = t.constructor,
                    w = e.constructor;
                k == w || !("constructor" in t) || !("constructor" in e) || "function" == typeof k && k instanceof k && "function" == typeof w && w instanceof w || (g = !1)
            }
            return r.delete(t), r.delete(e), g
        };
        var Xa = "[object Arguments]",
            tl = "[object Array]",
            el = "[object Object]",
            nl = Object.prototype.hasOwnProperty;
        const ol = function(t, e, n, o, i, r) {
            var s = ut(t),
                a = ut(e),
                l = s ? tl : $n(t),
                c = a ? tl : $n(e),
                d = (l = l == Xa ? el : l) == el,
                h = (c = c == Xa ? el : c) == el,
                u = l == c;
            if (u && Me(t)) {
                if (!Me(e)) return !1;
                s = !0, d = !1
            }
            if (u && !d) return r || (r = new Ce), s || Je(t) ? Ua(t, e, n, o, i, r) : Ja(t, e, l, n, o, i, r);
            if (!(1 & n)) {
                var g = d && nl.call(t, "__wrapped__"),
                    m = h && nl.call(e, "__wrapped__");
                if (g || m) {
                    var p = g ? t.value() : t,
                        f = m ? e.value() : e;
                    return r || (r = new Ce), i(p, f, n, o, r)
                }
            }
            return !!u && (r || (r = new Ce), Qa(t, e, n, o, i, r))
        };
        const il = function t(e, n, o, i, r) {
            return e === n || (null == e || null == n || !gt(e) && !gt(n) ? e != e && n != n : ol(e, n, o, i, t, r))
        };
        const rl = function(t, e, n) {
            var o = (n = "function" == typeof n ? n : void 0) ? n(t, e) : void 0;
            return void 0 === o ? il(t, e, void 0, n) : !!o
        };
        class sl extends Aa {
            constructor(t) {
                super(t), this._config = {
                    childList: !0,
                    characterData: !0,
                    subtree: !0
                }, this.domConverter = t.domConverter, this.renderer = t._renderer, this._domElements = new Set, this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this))
            }
            flush() {
                this._onMutations(this._mutationObserver.takeRecords())
            }
            observe(t) {
                this._domElements.add(t), this.isEnabled && this._mutationObserver.observe(t, this._config)
            }
            stopObserving(t) {
                if (this._domElements.delete(t), this.isEnabled) {
                    this._mutationObserver.disconnect();
                    for (const t of this._domElements) this._mutationObserver.observe(t, this._config)
                }
            }
            enable() {
                super.enable();
                for (const t of this._domElements) this._mutationObserver.observe(t, this._config)
            }
            disable() {
                super.disable(), this._mutationObserver.disconnect()
            }
            destroy() {
                super.destroy(), this._mutationObserver.disconnect()
            }
            _onMutations(t) {
                if (0 === t.length) return;
                const e = this.domConverter,
                    n = new Set,
                    o = new Set;
                for (const n of t) {
                    const t = e.mapDomToView(n.target);
                    t && (t.is("uiElement") || t.is("rawElement") || "childList" !== n.type || this._isBogusBrMutation(n) || o.add(t))
                }
                for (const i of t) {
                    const t = e.mapDomToView(i.target);
                    if ((!t || !t.is("uiElement") && !t.is("rawElement")) && "characterData" === i.type) {
                        const t = e.findCorrespondingViewText(i.target);
                        t && !o.has(t.parent) ? n.add(t) : !t && Xs(i.target) && o.add(e.mapDomToView(i.target.parentNode))
                    }
                }
                let i = !1;
                for (const t of n) i = !0, this.renderer.markToSync("text", t);
                for (const t of o) {
                    const n = e.mapViewToDom(t),
                        o = Array.from(t.getChildren()),
                        r = Array.from(e.domChildrenToView(n, {
                            withChildren: !1
                        }));
                    rl(o, r, al) || (i = !0, this.renderer.markToSync("children", t))
                }
                i && this.view.forceRender()
            }
            _isBogusBrMutation(t) {
                let e = null;
                return null === t.nextSibling && 0 === t.removedNodes.length && 1 == t.addedNodes.length && (e = this.domConverter.domToView(t.addedNodes[0], {
                    withChildren: !1
                })), e && e.is("element", "br")
            }
        }

        function al(t, e) {
            if (!Array.isArray(t)) return t === e || !(!t.is("$text") || !e.is("$text")) && t.data === e.data
        }
        class ll extends va {
            constructor(t) {
                super(t), this._isFocusChanging = !1, this.domEventType = ["focus", "blur"], this.useCapture = !0;
                const e = this.document;
                e.on("focus", (() => {
                    this._isFocusChanging = !0, this._renderTimeoutId = setTimeout((() => {
                        this.flush(), t.change((() => {}))
                    }), 50)
                })), e.on("blur", ((n, o) => {
                    const i = e.selection.editableElement;
                    null !== i && i !== o.target || (e.isFocused = !1, this._isFocusChanging = !1, t.change((() => {})))
                }))
            }
            flush() {
                this._isFocusChanging && (this._isFocusChanging = !1, this.document.isFocused = !0)
            }
            onDomEvent(t) {
                this.fire(t.type, t)
            }
            destroy() {
                this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy()
            }
        }
        class cl extends Aa {
            constructor(t) {
                super(t), this.mutationObserver = t.getObserver(sl), this.focusObserver = t.getObserver(ll), this.selection = this.document.selection, this.domConverter = t.domConverter, this._documents = new WeakSet, this._fireSelectionChangeDoneDebounced = Fa((t => {
                    this.document.fire("selectionChangeDone", t)
                }), 200), this._clearInfiniteLoopInterval = setInterval((() => this._clearInfiniteLoop()), 1e3), this._documentIsSelectingInactivityTimeoutDebounced = Fa((() => this.document.isSelecting = !1), 5e3), this._loopbackCounter = 0
            }
            observe(t) {
                const e = t.ownerDocument,
                    n = () => {
                        this.document.isSelecting && (this._handleSelectionChange(null, e), this.document.isSelecting = !1, this._documentIsSelectingInactivityTimeoutDebounced.cancel())
                    };
                this.listenTo(t, "selectstart", (() => {
                    this.document.isSelecting = !0, this._documentIsSelectingInactivityTimeoutDebounced()
                }), {
                    priority: "highest"
                }), this.listenTo(t, "keydown", n, {
                    priority: "highest",
                    useCapture: !0
                }), this.listenTo(t, "keyup", n, {
                    priority: "highest",
                    useCapture: !0
                }), this._documents.has(e) || (this.listenTo(e, "mouseup", n, {
                    priority: "highest",
                    useCapture: !0
                }), this.listenTo(e, "selectionchange", ((t, n) => {
                    this.document.isComposing && !i.isAndroid || (this._handleSelectionChange(n, e), this._documentIsSelectingInactivityTimeoutDebounced())
                })), this._documents.add(e))
            }
            stopObserving(t) {
                this.stopListening(t)
            }
            destroy() {
                super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel(), this._documentIsSelectingInactivityTimeoutDebounced.cancel()
            }
            _reportInfiniteLoop() {}
            _handleSelectionChange(t, e) {
                if (!this.isEnabled) return;
                const n = e.defaultView.getSelection();
                if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) return;
                this.mutationObserver.flush();
                const o = this.domConverter.domSelectionToView(n);
                if (0 != o.rangeCount) {
                    if (this.view.hasDomSelection = !0, !this.selection.isEqual(o) || !this.domConverter.isDomSelectionCorrect(n))
                        if (++this._loopbackCounter > 60) this._reportInfiniteLoop();
                        else if (this.focusObserver.flush(), this.selection.isSimilar(o)) this.view.forceRender();
                    else {
                        const t = {
                            oldSelection: this.selection,
                            newSelection: o,
                            domSelection: n
                        };
                        this.document.fire("selectionChange", t), this._fireSelectionChangeDoneDebounced(t)
                    }
                } else this.view.hasDomSelection = !1
            }
            _clearInfiniteLoop() {
                this._loopbackCounter = 0
            }
        }
        class dl extends va {
            constructor(t) {
                super(t), this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
                const e = this.document;
                e.on("compositionstart", (() => {
                    e.isComposing = !0
                }), {
                    priority: "low"
                }), e.on("compositionend", (() => {
                    e.isComposing = !1
                }), {
                    priority: "low"
                })
            }
            onDomEvent(t) {
                this.fire(t.type, t, {
                    data: t.data
                })
            }
        }
        class hl {
            constructor(t, e = {}) {
                this._files = e.cacheFiles ? ul(t) : null, this._native = t
            }
            get files() {
                return this._files || (this._files = ul(this._native)), this._files
            }
            get types() {
                return this._native.types
            }
            getData(t) {
                return this._native.getData(t)
            }
            setData(t, e) {
                this._native.setData(t, e)
            }
            set effectAllowed(t) {
                this._native.effectAllowed = t
            }
            get effectAllowed() {
                return this._native.effectAllowed
            }
            set dropEffect(t) {
                this._native.dropEffect = t
            }
            get dropEffect() {
                return this._native.dropEffect
            }
            setDragImage(t, e, n) {
                this._native.setDragImage(t, e, n)
            }
            get isCanceled() {
                return "none" == this._native.dropEffect || !!this._native.mozUserCancelled
            }
        }

        function ul(t) {
            const e = Array.from(t.files || []),
                n = Array.from(t.items || []);
            return e.length ? e : n.filter((t => "file" === t.kind)).map((t => t.getAsFile()))
        }
        class gl extends va {
            constructor() {
                super(...arguments), this.domEventType = "beforeinput"
            }
            onDomEvent(t) {
                const e = t.getTargetRanges(),
                    n = this.view,
                    o = n.document;
                let r = null,
                    s = null,
                    a = [];
                if (t.dataTransfer && (r = new hl(t.dataTransfer)), null !== t.data ? s = t.data : r && (s = r.getData("text/plain")), o.selection.isFake) a = Array.from(o.selection.getRanges());
                else if (e.length) a = e.map((t => {
                    const e = n.domConverter.domPositionToView(t.startContainer, t.startOffset),
                        o = n.domConverter.domPositionToView(t.endContainer, t.endOffset);
                    return e ? n.createRange(e, o) : o ? n.createRange(o) : void 0
                })).filter((t => !!t));
                else if (i.isAndroid) {
                    const e = t.target.ownerDocument.defaultView.getSelection();
                    a = Array.from(n.domConverter.domSelectionToView(e).getRanges())
                }
                if (i.isAndroid && "insertCompositionText" == t.inputType && s && s.endsWith("\n")) this.fire(t.type, t, {
                    inputType: "insertParagraph",
                    targetRanges: [n.createRange(a[0].end)]
                });
                else if ("insertText" == t.inputType && s && s.includes("\n")) {
                    const e = s.split(/\n{1,2}/g);
                    let n = a;
                    for (let i = 0; i < e.length; i++) {
                        const s = e[i];
                        "" != s && (this.fire(t.type, t, {
                            data: s,
                            dataTransfer: r,
                            targetRanges: n,
                            inputType: t.inputType,
                            isComposing: t.isComposing
                        }), n = [o.selection.getFirstRange()]), i + 1 < e.length && (this.fire(t.type, t, {
                            inputType: "insertParagraph",
                            targetRanges: n
                        }), n = [o.selection.getFirstRange()])
                    }
                } else this.fire(t.type, t, {
                    data: s,
                    dataTransfer: r,
                    targetRanges: a,
                    inputType: t.inputType,
                    isComposing: t.isComposing
                })
            }
        }
        class ml extends Aa {
            constructor(t) {
                super(t), this.document.on("keydown", ((t, e) => {
                    if (this.isEnabled && ((n = e.keyCode) == mi.arrowright || n == mi.arrowleft || n == mi.arrowup || n == mi.arrowdown)) {
                        const n = new ks(this.document, "arrowKey", this.document.selection.getFirstRange());
                        this.document.fire(n, e), n.stop.called && t.stop()
                    }
                    var n
                }))
            }
            observe() {}
            stopObserving() {}
        }
        class pl extends Aa {
            constructor(t) {
                super(t);
                const e = this.document;
                e.on("keydown", ((t, n) => {
                    if (!this.isEnabled || n.keyCode != mi.tab || n.ctrlKey) return;
                    const o = new ks(e, "tab", e.selection.getFirstRange());
                    e.fire(o, n), o.stop.called && t.stop()
                }))
            }
            observe() {}
            stopObserving() {}
        }
        const fl = function(t) {
            return wo(t, 5)
        };
        class bl extends(q()) {
            constructor(t) {
                super(), this.domRoots = new Map, this._initialDomRootAttributes = new WeakMap, this._observers = new Map, this._ongoingChange = !1, this._postFixersInProgress = !1, this._renderingDisabled = !1, this._hasChangedSinceTheLastRendering = !1, this.document = new xs(t), this.domConverter = new fa(this.document), this.set("isRenderingInProgress", !1), this.set("hasDomSelection", !1), this._renderer = new ra(this.domConverter, this.document.selection), this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"), this._writer = new Fs(this.document), this.addObserver(sl), this.addObserver(ll), this.addObserver(cl), this.addObserver(ya), this.addObserver(Ma), this.addObserver(dl), this.addObserver(ml), this.addObserver(gl), this.addObserver(pl), this.document.on("arrowKey", na, {
                    priority: "low"
                }), Ps(this), this.on("render", (() => {
                    this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = !1
                })), this.listenTo(this.document.selection, "change", (() => {
                    this._hasChangedSinceTheLastRendering = !0
                })), this.listenTo(this.document, "change:isFocused", (() => {
                    this._hasChangedSinceTheLastRendering = !0
                }))
            }
            attachDomRoot(t, e = "main") {
                const n = this.document.getRoot(e);
                n._name = t.tagName.toLowerCase();
                const o = {};
                for (const {
                        name: e,
                        value: i
                    }
                    of Array.from(t.attributes)) o[e] = i, "class" === e ? this._writer.addClass(i.split(" "), n) : this._writer.setAttribute(e, i, n);
                this._initialDomRootAttributes.set(t, o);
                const i = () => {
                    this._writer.setAttribute("contenteditable", (!n.isReadOnly).toString(), n), n.isReadOnly ? this._writer.addClass("ck-read-only", n) : this._writer.removeClass("ck-read-only", n)
                };
                i(), this.domRoots.set(e, t), this.domConverter.bindElements(t, n), this._renderer.markToSync("children", n), this._renderer.markToSync("attributes", n), this._renderer.domDocuments.add(t.ownerDocument), n.on("change:children", ((t, e) => this._renderer.markToSync("children", e))), n.on("change:attributes", ((t, e) => this._renderer.markToSync("attributes", e))), n.on("change:text", ((t, e) => this._renderer.markToSync("text", e))), n.on("change:isReadOnly", (() => this.change(i))), n.on("change", (() => {
                    this._hasChangedSinceTheLastRendering = !0
                }));
                for (const n of this._observers.values()) n.observe(t, e)
            }
            detachDomRoot(t) {
                const e = this.domRoots.get(t);
                Array.from(e.attributes).forEach((({
                    name: t
                }) => e.removeAttribute(t)));
                const n = this._initialDomRootAttributes.get(e);
                for (const t in n) e.setAttribute(t, n[t]);
                this.domRoots.delete(t), this.domConverter.unbindDomElement(e);
                for (const t of this._observers.values()) t.stopObserving(e)
            }
            getDomRoot(t = "main") {
                return this.domRoots.get(t)
            }
            addObserver(t) {
                let e = this._observers.get(t);
                if (e) return e;
                e = new t(this), this._observers.set(t, e);
                for (const [t, n] of this.domRoots) e.observe(n, t);
                return e.enable(), e
            }
            getObserver(t) {
                return this._observers.get(t)
            }
            disableObservers() {
                for (const t of this._observers.values()) t.disable()
            }
            enableObservers() {
                for (const t of this._observers.values()) t.enable()
            }
            scrollToTheSelection({
                alignToTop: t,
                forceScroll: e,
                viewportOffset: n = 20,
                ancestorOffset: o = 20
            } = {}) {
                const i = this.document.selection.getFirstRange();
                if (!i) return;
                const r = fl({
                    alignToTop: t,
                    forceScroll: e,
                    viewportOffset: n,
                    ancestorOffset: o
                });
                "number" == typeof n && (n = {
                    top: n,
                    bottom: n,
                    left: n,
                    right: n
                });
                const s = {
                    target: this.domConverter.viewRangeToDom(i),
                    viewportOffset: n,
                    ancestorOffset: o,
                    alignToTop: t,
                    forceScroll: e
                };
                this.fire("scrollToTheSelection", s, r), ni(s)
            }
            focus() {
                if (!this.document.isFocused) {
                    const t = this.document.selection.editableElement;
                    t && (this.domConverter.focus(t), this.forceRender())
                }
            }
            change(t) {
                if (this.isRenderingInProgress || this._postFixersInProgress) throw new b("cannot-change-view-tree", this);
                try {
                    if (this._ongoingChange) return t(this._writer);
                    this._ongoingChange = !0;
                    const e = t(this._writer);
                    return this._ongoingChange = !1, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = !0, this.document._callPostFixers(this._writer), this._postFixersInProgress = !1, this.fire("render")), e
                } catch (t) {
                    b.rethrowUnexpectedError(t, this)
                }
            }
            forceRender() {
                this._hasChangedSinceTheLastRendering = !0, this.getObserver(ll).flush(), this.change((() => {}))
            }
            destroy() {
                for (const t of this._observers.values()) t.destroy();
                this.document.destroy(), this.stopListening()
            }
            createPositionAt(t, e) {
                return gs._createAt(t, e)
            }
            createPositionAfter(t) {
                return gs._createAfter(t)
            }
            createPositionBefore(t) {
                return gs._createBefore(t)
            }
            createRange(t, e) {
                return new ms(t, e)
            }
            createRangeOn(t) {
                return ms._createOn(t)
            }
            createRangeIn(t) {
                return ms._createIn(t)
            }
            createSelection(...t) {
                return new fs(...t)
            }
            _disableRendering(t) {
                this._renderingDisabled = t, 0 == t && this.change((() => {}))
            }
            _render() {
                this.isRenderingInProgress = !0, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = !1
            }
        }
        class kl {
            is() {
                throw new Error("is() method is abstract")
            }
        }
        class wl extends kl {
            constructor(t) {
                super(), this.parent = null, this._attrs = Ti(t)
            }
            get document() {
                return null
            }
            get index() {
                let t;
                if (!this.parent) return null;
                if (null === (t = this.parent.getChildIndex(this))) throw new b("model-node-not-found-in-parent", this);
                return t
            }
            get startOffset() {
                let t;
                if (!this.parent) return null;
                if (null === (t = this.parent.getChildStartOffset(this))) throw new b("model-node-not-found-in-parent", this);
                return t
            }
            get offsetSize() {
                return 1
            }
            get endOffset() {
                return this.parent ? this.startOffset + this.offsetSize : null
            }
            get nextSibling() {
                const t = this.index;
                return null !== t && this.parent.getChild(t + 1) || null
            }
            get previousSibling() {
                const t = this.index;
                return null !== t && this.parent.getChild(t - 1) || null
            }
            get root() {
                let t = this;
                for (; t.parent;) t = t.parent;
                return t
            }
            isAttached() {
                return null !== this.parent && this.root.isAttached()
            }
            getPath() {
                const t = [];
                let e = this;
                for (; e.parent;) t.unshift(e.startOffset), e = e.parent;
                return t
            }
            getAncestors(t = {}) {
                const e = [];
                let n = t.includeSelf ? this : this.parent;
                for (; n;) e[t.parentFirst ? "push" : "unshift"](n), n = n.parent;
                return e
            }
            getCommonAncestor(t, e = {}) {
                const n = this.getAncestors(e),
                    o = t.getAncestors(e);
                let i = 0;
                for (; n[i] == o[i] && n[i];) i++;
                return 0 === i ? null : n[i - 1]
            }
            isBefore(t) {
                if (this == t) return !1;
                if (this.root !== t.root) return !1;
                const e = this.getPath(),
                    n = t.getPath(),
                    o = Y(e, n);
                switch (o) {
                    case "prefix":
                        return !0;
                    case "extension":
                        return !1;
                    default:
                        return e[o] < n[o]
                }
            }
            isAfter(t) {
                return this != t && (this.root === t.root && !this.isBefore(t))
            }
            hasAttribute(t) {
                return this._attrs.has(t)
            }
            getAttribute(t) {
                return this._attrs.get(t)
            }
            getAttributes() {
                return this._attrs.entries()
            }
            getAttributeKeys() {
                return this._attrs.keys()
            }
            toJSON() {
                const t = {};
                return this._attrs.size && (t.attributes = Array.from(this._attrs).reduce(((t, e) => (t[e[0]] = e[1], t)), {})), t
            }
            _clone(t) {
                return new this.constructor(this._attrs)
            }
            _remove() {
                this.parent._removeChildren(this.index)
            }
            _setAttribute(t, e) {
                this._attrs.set(t, e)
            }
            _setAttributesTo(t) {
                this._attrs = Ti(t)
            }
            _removeAttribute(t) {
                return this._attrs.delete(t)
            }
            _clearAttributes() {
                this._attrs.clear()
            }
        }
        wl.prototype.is = function(t) {
            return "node" === t || "model:node" === t
        };
        class Al {
            constructor(t) {
                this._nodes = [], t && this._insertNodes(0, t)
            } [Symbol.iterator]() {
                return this._nodes[Symbol.iterator]()
            }
            get length() {
                return this._nodes.length
            }
            get maxOffset() {
                return this._nodes.reduce(((t, e) => t + e.offsetSize), 0)
            }
            getNode(t) {
                return this._nodes[t] || null
            }
            getNodeIndex(t) {
                const e = this._nodes.indexOf(t);
                return -1 == e ? null : e
            }
            getNodeStartOffset(t) {
                const e = this.getNodeIndex(t);
                return null === e ? null : this._nodes.slice(0, e).reduce(((t, e) => t + e.offsetSize), 0)
            }
            indexToOffset(t) {
                if (t == this._nodes.length) return this.maxOffset;
                const e = this._nodes[t];
                if (!e) throw new b("model-nodelist-index-out-of-bounds", this);
                return this.getNodeStartOffset(e)
            }
            offsetToIndex(t) {
                let e = 0;
                for (const n of this._nodes) {
                    if (t >= e && t < e + n.offsetSize) return this.getNodeIndex(n);
                    e += n.offsetSize
                }
                if (e != t) throw new b("model-nodelist-offset-out-of-bounds", this, {
                    offset: t,
                    nodeList: this
                });
                return this.length
            }
            _insertNodes(t, e) {
                for (const t of e)
                    if (!(t instanceof wl)) throw new b("model-nodelist-insertnodes-not-node", this);
                this._nodes = function(t, e, n, o) {
                    if (Math.max(e.length, t.length) > 1e4) return t.slice(0, n).concat(e).concat(t.slice(n + o, t.length));
                    {
                        const i = Array.from(t);
                        return i.splice(n, o, ...e), i
                    }
                }(this._nodes, Array.from(e), t, 0)
            }
            _removeNodes(t, e = 1) {
                return this._nodes.splice(t, e)
            }
            toJSON() {
                return this._nodes.map((t => t.toJSON()))
            }
        }
        class Cl extends wl {
            constructor(t, e) {
                super(e), this._data = t || ""
            }
            get offsetSize() {
                return this.data.length
            }
            get data() {
                return this._data
            }
            toJSON() {
                const t = super.toJSON();
                return t.data = this.data, t
            }
            _clone() {
                return new Cl(this.data, this.getAttributes())
            }
            static fromJSON(t) {
                return new Cl(t.data, t.attributes)
            }
        }
        Cl.prototype.is = function(t) {
            return "$text" === t || "model:$text" === t || "text" === t || "model:text" === t || "node" === t || "model:node" === t
        };
        class _l extends kl {
            constructor(t, e, n) {
                if (super(), this.textNode = t, e < 0 || e > t.offsetSize) throw new b("model-textproxy-wrong-offsetintext", this);
                if (n < 0 || e + n > t.offsetSize) throw new b("model-textproxy-wrong-length", this);
                this.data = t.data.substring(e, e + n), this.offsetInText = e
            }
            get startOffset() {
                return null !== this.textNode.startOffset ? this.textNode.startOffset + this.offsetInText : null
            }
            get offsetSize() {
                return this.data.length
            }
            get endOffset() {
                return null !== this.startOffset ? this.startOffset + this.offsetSize : null
            }
            get isPartial() {
                return this.offsetSize !== this.textNode.offsetSize
            }
            get parent() {
                return this.textNode.parent
            }
            get root() {
                return this.textNode.root
            }
            getPath() {
                const t = this.textNode.getPath();
                return t.length > 0 && (t[t.length - 1] += this.offsetInText), t
            }
            getAncestors(t = {}) {
                const e = [];
                let n = t.includeSelf ? this : this.parent;
                for (; n;) e[t.parentFirst ? "push" : "unshift"](n), n = n.parent;
                return e
            }
            hasAttribute(t) {
                return this.textNode.hasAttribute(t)
            }
            getAttribute(t) {
                return this.textNode.getAttribute(t)
            }
            getAttributes() {
                return this.textNode.getAttributes()
            }
            getAttributeKeys() {
                return this.textNode.getAttributeKeys()
            }
        }
        _l.prototype.is = function(t) {
            return "$textProxy" === t || "model:$textProxy" === t || "textProxy" === t || "model:textProxy" === t
        };
        class vl extends wl {
            constructor(t, e, n) {
                super(e), this._children = new Al, this.name = t, n && this._insertChild(0, n)
            }
            get childCount() {
                return this._children.length
            }
            get maxOffset() {
                return this._children.maxOffset
            }
            get isEmpty() {
                return 0 === this.childCount
            }
            getChild(t) {
                return this._children.getNode(t)
            }
            getChildren() {
                return this._children[Symbol.iterator]()
            }
            getChildIndex(t) {
                return this._children.getNodeIndex(t)
            }
            getChildStartOffset(t) {
                return this._children.getNodeStartOffset(t)
            }
            offsetToIndex(t) {
                return this._children.offsetToIndex(t)
            }
            getNodeByPath(t) {
                let e = this;
                for (const n of t) e = e.getChild(e.offsetToIndex(n));
                return e
            }
            findAncestor(t, e = {}) {
                let n = e.includeSelf ? this : this.parent;
                for (; n;) {
                    if (n.name === t) return n;
                    n = n.parent
                }
                return null
            }
            toJSON() {
                const t = super.toJSON();
                if (t.name = this.name, this._children.length > 0) {
                    t.children = [];
                    for (const e of this._children) t.children.push(e.toJSON())
                }
                return t
            }
            _clone(t = !1) {
                const e = t ? Array.from(this._children).map((t => t._clone(!0))) : void 0;
                return new vl(this.name, this.getAttributes(), e)
            }
            _appendChild(t) {
                this._insertChild(this.childCount, t)
            }
            _insertChild(t, e) {
                const n = function(t) {
                    if ("string" == typeof t) return [new Cl(t)];
                    Q(t) || (t = [t]);
                    return Array.from(t).map((t => "string" == typeof t ? new Cl(t) : t instanceof _l ? new Cl(t.data, t.getAttributes()) : t))
                }(e);
                for (const t of n) null !== t.parent && t._remove(), t.parent = this;
                this._children._insertNodes(t, n)
            }
            _removeChildren(t, e = 1) {
                const n = this._children._removeNodes(t, e);
                for (const t of n) t.parent = null;
                return n
            }
            static fromJSON(t) {
                let e;
                if (t.children) {
                    e = [];
                    for (const n of t.children) n.name ? e.push(vl.fromJSON(n)) : e.push(Cl.fromJSON(n))
                }
                return new vl(t.name, t.attributes, e)
            }
        }
        vl.prototype.is = function(t, e) {
            return e ? e === this.name && ("element" === t || "model:element" === t) : "element" === t || "model:element" === t || "node" === t || "model:node" === t
        };
        class yl {
            constructor(t) {
                if (!t || !t.boundaries && !t.startPosition) throw new b("model-tree-walker-no-start-position", null);
                const e = t.direction || "forward";
                if ("forward" != e && "backward" != e) throw new b("model-tree-walker-unknown-direction", t, {
                    direction: e
                });
                this.direction = e, this.boundaries = t.boundaries || null, t.startPosition ? this._position = t.startPosition.clone() : this._position = El._createAt(this.boundaries["backward" == this.direction ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!t.singleCharacters, this.shallow = !!t.shallow, this.ignoreElementEnd = !!t.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent
            } [Symbol.iterator]() {
                return this
            }
            get position() {
                return this._position
            }
            skip(t) {
                let e, n, o, i;
                do {
                    o = this.position, i = this._visitedParent, ({
                        done: e,
                        value: n
                    } = this.next())
                } while (!e && t(n));
                e || (this._position = o, this._visitedParent = i)
            }
            next() {
                return "forward" == this.direction ? this._next() : this._previous()
            }
            _next() {
                const t = this.position,
                    e = this.position.clone(),
                    n = this._visitedParent;
                if (null === n.parent && e.offset === n.maxOffset) return {
                    done: !0,
                    value: void 0
                };
                if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset) return {
                    done: !0,
                    value: void 0
                };
                const o = Dl(e, n),
                    i = o || Sl(e, n, o);
                if (i instanceof vl) {
                    if (this.shallow) {
                        if (this.boundaries && this.boundaries.end.isBefore(e)) return {
                            done: !0,
                            value: void 0
                        };
                        e.offset++
                    } else e.path.push(0), this._visitedParent = i;
                    return this._position = e, xl("elementStart", i, t, e, 1)
                }
                if (i instanceof Cl) {
                    let o;
                    if (this.singleCharacters) o = 1;
                    else {
                        let t = i.endOffset;
                        this._boundaryEndParent == n && this.boundaries.end.offset < t && (t = this.boundaries.end.offset), o = t - e.offset
                    }
                    const r = e.offset - i.startOffset,
                        s = new _l(i, r, o);
                    return e.offset += o, this._position = e, xl("text", s, t, e, o)
                }
                return e.path.pop(), e.offset++, this._position = e, this._visitedParent = n.parent, this.ignoreElementEnd ? this._next() : xl("elementEnd", n, t, e)
            }
            _previous() {
                const t = this.position,
                    e = this.position.clone(),
                    n = this._visitedParent;
                if (null === n.parent && 0 === e.offset) return {
                    done: !0,
                    value: void 0
                };
                if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset) return {
                    done: !0,
                    value: void 0
                };
                const o = e.parent,
                    i = Dl(e, o),
                    r = i || Tl(e, o, i);
                if (r instanceof vl) return e.offset--, this.shallow ? (this._position = e, xl("elementStart", r, t, e, 1)) : (e.path.push(r.maxOffset), this._position = e, this._visitedParent = r, this.ignoreElementEnd ? this._previous() : xl("elementEnd", r, t, e));
                if (r instanceof Cl) {
                    let o;
                    if (this.singleCharacters) o = 1;
                    else {
                        let t = r.startOffset;
                        this._boundaryStartParent == n && this.boundaries.start.offset > t && (t = this.boundaries.start.offset), o = e.offset - t
                    }
                    const i = e.offset - r.startOffset,
                        s = new _l(r, i - o, o);
                    return e.offset -= o, this._position = e, xl("text", s, t, e, o)
                }
                return e.path.pop(), this._position = e, this._visitedParent = n.parent, xl("elementStart", n, t, e, 1)
            }
        }

        function xl(t, e, n, o, i) {
            return {
                done: !1,
                value: {
                    type: t,
                    item: e,
                    previousPosition: n,
                    nextPosition: o,
                    length: i
                }
            }
        }
        class El extends kl {
            constructor(t, e, n = "toNone") {
                if (super(), !t.is("element") && !t.is("documentFragment")) throw new b("model-position-root-invalid", t);
                if (!(e instanceof Array) || 0 === e.length) throw new b("model-position-path-incorrect-format", t, {
                    path: e
                });
                t.is("rootElement") ? e = e.slice() : (e = [...t.getPath(), ...e], t = t.root), this.root = t, this.path = e, this.stickiness = n
            }
            get offset() {
                return this.path[this.path.length - 1]
            }
            set offset(t) {
                this.path[this.path.length - 1] = t
            }
            get parent() {
                let t = this.root;
                for (let e = 0; e < this.path.length - 1; e++)
                    if (t = t.getChild(t.offsetToIndex(this.path[e])), !t) throw new b("model-position-path-incorrect", this, {
                        position: this
                    });
                if (t.is("$text")) throw new b("model-position-path-incorrect", this, {
                    position: this
                });
                return t
            }
            get index() {
                return this.parent.offsetToIndex(this.offset)
            }
            get textNode() {
                return Dl(this, this.parent)
            }
            get nodeAfter() {
                const t = this.parent;
                return Sl(this, t, Dl(this, t))
            }
            get nodeBefore() {
                const t = this.parent;
                return Tl(this, t, Dl(this, t))
            }
            get isAtStart() {
                return 0 === this.offset
            }
            get isAtEnd() {
                return this.offset == this.parent.maxOffset
            }
            compareWith(t) {
                if (this.root != t.root) return "different";
                const e = Y(this.path, t.path);
                switch (e) {
                    case "same":
                        return "same";
                    case "prefix":
                        return "before";
                    case "extension":
                        return "after";
                    default:
                        return this.path[e] < t.path[e] ? "before" : "after"
                }
            }
            getLastMatchingPosition(t, e = {}) {
                e.startPosition = this;
                const n = new yl(e);
                return n.skip(t), n.position
            }
            getParentPath() {
                return this.path.slice(0, -1)
            }
            getAncestors() {
                const t = this.parent;
                return t.is("documentFragment") ? [t] : t.getAncestors({
                    includeSelf: !0
                })
            }
            findAncestor(t) {
                const e = this.parent;
                return e.is("element") ? e.findAncestor(t, {
                    includeSelf: !0
                }) : null
            }
            getCommonPath(t) {
                if (this.root != t.root) return [];
                const e = Y(this.path, t.path),
                    n = "string" == typeof e ? Math.min(this.path.length, t.path.length) : e;
                return this.path.slice(0, n)
            }
            getCommonAncestor(t) {
                const e = this.getAncestors(),
                    n = t.getAncestors();
                let o = 0;
                for (; e[o] == n[o] && e[o];) o++;
                return 0 === o ? null : e[o - 1]
            }
            getShiftedBy(t) {
                const e = this.clone(),
                    n = e.offset + t;
                return e.offset = n < 0 ? 0 : n, e
            }
            isAfter(t) {
                return "after" == this.compareWith(t)
            }
            isBefore(t) {
                return "before" == this.compareWith(t)
            }
            isEqual(t) {
                return "same" == this.compareWith(t)
            }
            isTouching(t) {
                if (this.root !== t.root) return !1;
                const e = Math.min(this.path.length, t.path.length);
                for (let n = 0; n < e; n++) {
                    const e = this.path[n] - t.path[n];
                    if (e < -1 || e > 1) return !1;
                    if (1 === e) return Bl(t, this, n);
                    if (-1 === e) return Bl(this, t, n)
                }
                return this.path.length === t.path.length || (this.path.length > t.path.length ? Il(this.path, e) : Il(t.path, e))
            }
            hasSameParentAs(t) {
                if (this.root !== t.root) return !1;
                return "same" == Y(this.getParentPath(), t.getParentPath())
            }
            getTransformedByOperation(t) {
                let e;
                switch (t.type) {
                    case "insert":
                        e = this._getTransformedByInsertOperation(t);
                        break;
                    case "move":
                    case "remove":
                    case "reinsert":
                        e = this._getTransformedByMoveOperation(t);
                        break;
                    case "split":
                        e = this._getTransformedBySplitOperation(t);
                        break;
                    case "merge":
                        e = this._getTransformedByMergeOperation(t);
                        break;
                    default:
                        e = El._createAt(this)
                }
                return e
            }
            _getTransformedByInsertOperation(t) {
                return this._getTransformedByInsertion(t.position, t.howMany)
            }
            _getTransformedByMoveOperation(t) {
                return this._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany)
            }
            _getTransformedBySplitOperation(t) {
                const e = t.movedRange;
                return e.containsPosition(this) || e.start.isEqual(this) && "toNext" == this.stickiness ? this._getCombined(t.splitPosition, t.moveTargetPosition) : t.graveyardPosition ? this._getTransformedByMove(t.graveyardPosition, t.insertionPosition, 1) : this._getTransformedByInsertion(t.insertionPosition, 1)
            }
            _getTransformedByMergeOperation(t) {
                const e = t.movedRange;
                let n;
                return e.containsPosition(this) || e.start.isEqual(this) ? (n = this._getCombined(t.sourcePosition, t.targetPosition), t.sourcePosition.isBefore(t.targetPosition) && (n = n._getTransformedByDeletion(t.deletionPosition, 1))) : n = this.isEqual(t.deletionPosition) ? El._createAt(t.deletionPosition) : this._getTransformedByMove(t.deletionPosition, t.graveyardPosition, 1), n
            }
            _getTransformedByDeletion(t, e) {
                const n = El._createAt(this);
                if (this.root != t.root) return n;
                if ("same" == Y(t.getParentPath(), this.getParentPath())) {
                    if (t.offset < this.offset) {
                        if (t.offset + e > this.offset) return null;
                        n.offset -= e
                    }
                } else if ("prefix" == Y(t.getParentPath(), this.getParentPath())) {
                    const o = t.path.length - 1;
                    if (t.offset <= this.path[o]) {
                        if (t.offset + e > this.path[o]) return null;
                        n.path[o] -= e
                    }
                }
                return n
            }
            _getTransformedByInsertion(t, e) {
                const n = El._createAt(this);
                if (this.root != t.root) return n;
                if ("same" == Y(t.getParentPath(), this.getParentPath()))(t.offset < this.offset || t.offset == this.offset && "toPrevious" != this.stickiness) && (n.offset += e);
                else if ("prefix" == Y(t.getParentPath(), this.getParentPath())) {
                    const o = t.path.length - 1;
                    t.offset <= this.path[o] && (n.path[o] += e)
                }
                return n
            }
            _getTransformedByMove(t, e, n) {
                if (e = e._getTransformedByDeletion(t, n), t.isEqual(e)) return El._createAt(this);
                const o = this._getTransformedByDeletion(t, n);
                return null === o || t.isEqual(this) && "toNext" == this.stickiness || t.getShiftedBy(n).isEqual(this) && "toPrevious" == this.stickiness ? this._getCombined(t, e) : o._getTransformedByInsertion(e, n)
            }
            _getCombined(t, e) {
                const n = t.path.length - 1,
                    o = El._createAt(e);
                return o.stickiness = this.stickiness, o.offset = o.offset + this.path[n] - t.offset, o.path = [...o.path, ...this.path.slice(n + 1)], o
            }
            toJSON() {
                return {
                    root: this.root.toJSON(),
                    path: Array.from(this.path),
                    stickiness: this.stickiness
                }
            }
            clone() {
                return new this.constructor(this.root, this.path, this.stickiness)
            }
            static _createAt(t, e, n = "toNone") {
                if (t instanceof El) return new El(t.root, t.path, t.stickiness);
                {
                    const o = t;
                    if ("end" == e) e = o.maxOffset;
                    else {
                        if ("before" == e) return this._createBefore(o, n);
                        if ("after" == e) return this._createAfter(o, n);
                        if (0 !== e && !e) throw new b("model-createpositionat-offset-required", [this, t])
                    }
                    if (!o.is("element") && !o.is("documentFragment")) throw new b("model-position-parent-incorrect", [this, t]);
                    const i = o.getPath();
                    return i.push(e), new this(o.root, i, n)
                }
            }
            static _createAfter(t, e) {
                if (!t.parent) throw new b("model-position-after-root", [this, t], {
                    root: t
                });
                return this._createAt(t.parent, t.endOffset, e)
            }
            static _createBefore(t, e) {
                if (!t.parent) throw new b("model-position-before-root", t, {
                    root: t
                });
                return this._createAt(t.parent, t.startOffset, e)
            }
            static fromJSON(t, e) {
                if ("$graveyard" === t.root) {
                    const n = new El(e.graveyard, t.path);
                    return n.stickiness = t.stickiness, n
                }
                if (!e.getRoot(t.root)) throw new b("model-position-fromjson-no-root", e, {
                    rootName: t.root
                });
                return new El(e.getRoot(t.root), t.path, t.stickiness)
            }
        }

        function Dl(t, e) {
            const n = e.getChild(e.offsetToIndex(t.offset));
            return n && n.is("$text") && n.startOffset < t.offset ? n : null
        }

        function Sl(t, e, n) {
            return null !== n ? null : e.getChild(e.offsetToIndex(t.offset))
        }

        function Tl(t, e, n) {
            return null !== n ? null : e.getChild(e.offsetToIndex(t.offset) - 1)
        }

        function Bl(t, e, n) {
            return n + 1 !== t.path.length && (!!Il(e.path, n + 1) && !! function(t, e) {
                let n = t.parent,
                    o = t.path.length - 1,
                    i = 0;
                for (; o >= e;) {
                    if (t.path[o] + i !== n.maxOffset) return !1;
                    i = 1, o--, n = n.parent
                }
                return !0
            }(t, n + 1))
        }

        function Il(t, e) {
            for (; e < t.length;) {
                if (0 !== t[e]) return !1;
                e++
            }
            return !0
        }
        El.prototype.is = function(t) {
            return "position" === t || "model:position" === t
        };
        class Pl extends kl {
            constructor(t, e) {
                super(), this.start = El._createAt(t), this.end = e ? El._createAt(e) : El._createAt(t), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious"
            }*[Symbol.iterator]() {
                yield* new yl({
                    boundaries: this,
                    ignoreElementEnd: !0
                })
            }
            get isCollapsed() {
                return this.start.isEqual(this.end)
            }
            get isFlat() {
                return "same" == Y(this.start.getParentPath(), this.end.getParentPath())
            }
            get root() {
                return this.start.root
            }
            containsPosition(t) {
                return t.isAfter(this.start) && t.isBefore(this.end)
            }
            containsRange(t, e = !1) {
                t.isCollapsed && (e = !1);
                const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start),
                    o = this.containsPosition(t.end) || e && this.end.isEqual(t.end);
                return n && o
            }
            containsItem(t) {
                const e = El._createBefore(t);
                return this.containsPosition(e) || this.start.isEqual(e)
            }
            isEqual(t) {
                return this.start.isEqual(t.start) && this.end.isEqual(t.end)
            }
            isIntersecting(t) {
                return this.start.isBefore(t.end) && this.end.isAfter(t.start)
            }
            getDifference(t) {
                const e = [];
                return this.isIntersecting(t) ? (this.containsPosition(t.start) && e.push(new Pl(this.start, t.start)), this.containsPosition(t.end) && e.push(new Pl(t.end, this.end))) : e.push(new Pl(this.start, this.end)), e
            }
            getIntersection(t) {
                if (this.isIntersecting(t)) {
                    let e = this.start,
                        n = this.end;
                    return this.containsPosition(t.start) && (e = t.start), this.containsPosition(t.end) && (n = t.end), new Pl(e, n)
                }
                return null
            }
            getJoined(t, e = !1) {
                let n = this.isIntersecting(t);
                if (n || (n = this.start.isBefore(t.start) ? e ? this.end.isTouching(t.start) : this.end.isEqual(t.start) : e ? t.end.isTouching(this.start) : t.end.isEqual(this.start)), !n) return null;
                let o = this.start,
                    i = this.end;
                return t.start.isBefore(o) && (o = t.start), t.end.isAfter(i) && (i = t.end), new Pl(o, i)
            }
            getMinimalFlatRanges() {
                const t = [],
                    e = this.start.getCommonPath(this.end).length,
                    n = El._createAt(this.start);
                let o = n.parent;
                for (; n.path.length > e + 1;) {
                    const e = o.maxOffset - n.offset;
                    0 !== e && t.push(new Pl(n, n.getShiftedBy(e))), n.path = n.path.slice(0, -1), n.offset++, o = o.parent
                }
                for (; n.path.length <= this.end.path.length;) {
                    const e = this.end.path[n.path.length - 1],
                        o = e - n.offset;
                    0 !== o && t.push(new Pl(n, n.getShiftedBy(o))), n.offset = e, n.path.push(0)
                }
                return t
            }
            getWalker(t = {}) {
                return t.boundaries = this, new yl(t)
            }* getItems(t = {}) {
                t.boundaries = this, t.ignoreElementEnd = !0;
                const e = new yl(t);
                for (const t of e) yield t.item
            }* getPositions(t = {}) {
                t.boundaries = this;
                const e = new yl(t);
                yield e.position;
                for (const t of e) yield t.nextPosition
            }
            getTransformedByOperation(t) {
                switch (t.type) {
                    case "insert":
                        return this._getTransformedByInsertOperation(t);
                    case "move":
                    case "remove":
                    case "reinsert":
                        return this._getTransformedByMoveOperation(t);
                    case "split":
                        return [this._getTransformedBySplitOperation(t)];
                    case "merge":
                        return [this._getTransformedByMergeOperation(t)]
                }
                return [new Pl(this.start, this.end)]
            }
            getTransformedByOperations(t) {
                const e = [new Pl(this.start, this.end)];
                for (const n of t)
                    for (let t = 0; t < e.length; t++) {
                        const o = e[t].getTransformedByOperation(n);
                        e.splice(t, 1, ...o), t += o.length - 1
                    }
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    for (let o = t + 1; o < e.length; o++) {
                        const t = e[o];
                        (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) && e.splice(o, 1)
                    }
                }
                return e
            }
            getCommonAncestor() {
                return this.start.getCommonAncestor(this.end)
            }
            getContainedElement() {
                if (this.isCollapsed) return null;
                const t = this.start.nodeAfter,
                    e = this.end.nodeBefore;
                return t && t.is("element") && t === e ? t : null
            }
            toJSON() {
                return {
                    start: this.start.toJSON(),
                    end: this.end.toJSON()
                }
            }
            clone() {
                return new this.constructor(this.start, this.end)
            }
            _getTransformedByInsertOperation(t, e = !1) {
                return this._getTransformedByInsertion(t.position, t.howMany, e)
            }
            _getTransformedByMoveOperation(t, e = !1) {
                const n = t.sourcePosition,
                    o = t.howMany,
                    i = t.targetPosition;
                return this._getTransformedByMove(n, i, o, e)
            }
            _getTransformedBySplitOperation(t) {
                const e = this.start._getTransformedBySplitOperation(t);
                let n = this.end._getTransformedBySplitOperation(t);
                return this.end.isEqual(t.insertionPosition) && (n = this.end.getShiftedBy(1)), e.root != n.root && (n = this.end.getShiftedBy(-1)), new Pl(e, n)
            }
            _getTransformedByMergeOperation(t) {
                if (this.start.isEqual(t.targetPosition) && this.end.isEqual(t.deletionPosition)) return new Pl(this.start);
                let e = this.start._getTransformedByMergeOperation(t),
                    n = this.end._getTransformedByMergeOperation(t);
                return e.root != n.root && (n = this.end.getShiftedBy(-1)), e.isAfter(n) ? (t.sourcePosition.isBefore(t.targetPosition) ? (e = El._createAt(n), e.offset = 0) : (t.deletionPosition.isEqual(e) || (n = t.deletionPosition), e = t.targetPosition), new Pl(e, n)) : new Pl(e, n)
            }
            _getTransformedByInsertion(t, e, n = !1) {
                if (n && this.containsPosition(t)) return [new Pl(this.start, t), new Pl(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e))];
                {
                    const n = new Pl(this.start, this.end);
                    return n.start = n.start._getTransformedByInsertion(t, e), n.end = n.end._getTransformedByInsertion(t, e), [n]
                }
            }
            _getTransformedByMove(t, e, n, o = !1) {
                if (this.isCollapsed) {
                    const o = this.start._getTransformedByMove(t, e, n);
                    return [new Pl(o)]
                }
                const i = Pl._createFromPositionAndShift(t, n),
                    r = e._getTransformedByDeletion(t, n);
                if (this.containsPosition(e) && !o && (i.containsPosition(this.start) || i.containsPosition(this.end))) {
                    const o = this.start._getTransformedByMove(t, e, n),
                        i = this.end._getTransformedByMove(t, e, n);
                    return [new Pl(o, i)]
                }
                let s;
                const a = this.getDifference(i);
                let l = null;
                const c = this.getIntersection(i);
                if (1 == a.length ? l = new Pl(a[0].start._getTransformedByDeletion(t, n), a[0].end._getTransformedByDeletion(t, n)) : 2 == a.length && (l = new Pl(this.start, this.end._getTransformedByDeletion(t, n))), s = l ? l._getTransformedByInsertion(r, n, null !== c || o) : [], c) {
                    const t = new Pl(c.start._getCombined(i.start, r), c.end._getCombined(i.start, r));
                    2 == s.length ? s.splice(1, 0, t) : s.push(t)
                }
                return s
            }
            _getTransformedByDeletion(t, e) {
                let n = this.start._getTransformedByDeletion(t, e),
                    o = this.end._getTransformedByDeletion(t, e);
                return null == n && null == o ? null : (null == n && (n = t), null == o && (o = t), new Pl(n, o))
            }
            static _createFromPositionAndShift(t, e) {
                const n = t,
                    o = t.getShiftedBy(e);
                return e > 0 ? new this(n, o) : new this(o, n)
            }
            static _createIn(t) {
                return new this(El._createAt(t, 0), El._createAt(t, t.maxOffset))
            }
            static _createOn(t) {
                return this._createFromPositionAndShift(El._createBefore(t), t.offsetSize)
            }
            static _createFromRanges(t) {
                if (0 === t.length) throw new b("range-create-from-ranges-empty-array", null);
                if (1 == t.length) return t[0].clone();
                const e = t[0];
                t.sort(((t, e) => t.start.isAfter(e.start) ? 1 : -1));
                const n = t.indexOf(e),
                    o = new this(e.start, e.end);
                if (n > 0)
                    for (let e = n - 1; t[e].end.isEqual(o.start); e++) o.start = El._createAt(t[e].start);
                for (let e = n + 1; e < t.length && t[e].start.isEqual(o.end); e++) o.end = El._createAt(t[e].end);
                return o
            }
            static fromJSON(t, e) {
                return new this(El.fromJSON(t.start, e), El.fromJSON(t.end, e))
            }
        }
        Pl.prototype.is = function(t) {
            return "range" === t || "model:range" === t
        };
        class Rl extends(S()) {
            constructor() {
                super(), this._modelToViewMapping = new WeakMap, this._viewToModelMapping = new WeakMap, this._viewToModelLengthCallbacks = new Map, this._markerNameToElements = new Map, this._elementToMarkerNames = new Map, this._deferredBindingRemovals = new Map, this._unboundMarkerNames = new Set, this.on("modelToViewPosition", ((t, e) => {
                    if (e.viewPosition) return;
                    const n = this._modelToViewMapping.get(e.modelPosition.parent);
                    if (!n) throw new b("mapping-model-position-view-parent-not-found", this, {
                        modelPosition: e.modelPosition
                    });
                    e.viewPosition = this.findPositionIn(n, e.modelPosition.offset)
                }), {
                    priority: "low"
                }), this.on("viewToModelPosition", ((t, e) => {
                    if (e.modelPosition) return;
                    const n = this.findMappedViewAncestor(e.viewPosition),
                        o = this._viewToModelMapping.get(n),
                        i = this._toModelOffset(e.viewPosition.parent, e.viewPosition.offset, n);
                    e.modelPosition = El._createAt(o, i)
                }), {
                    priority: "low"
                })
            }
            bindElements(t, e) {
                this._modelToViewMapping.set(t, e), this._viewToModelMapping.set(e, t)
            }
            unbindViewElement(t, e = {}) {
                const n = this.toModelElement(t);
                if (this._elementToMarkerNames.has(t))
                    for (const e of this._elementToMarkerNames.get(t)) this._unboundMarkerNames.add(e);
                e.defer ? this._deferredBindingRemovals.set(t, t.root) : (this._viewToModelMapping.delete(t), this._modelToViewMapping.get(n) == t && this._modelToViewMapping.delete(n))
            }
            unbindModelElement(t) {
                const e = this.toViewElement(t);
                this._modelToViewMapping.delete(t), this._viewToModelMapping.get(e) == t && this._viewToModelMapping.delete(e)
            }
            bindElementToMarker(t, e) {
                const n = this._markerNameToElements.get(e) || new Set;
                n.add(t);
                const o = this._elementToMarkerNames.get(t) || new Set;
                o.add(e), this._markerNameToElements.set(e, n), this._elementToMarkerNames.set(t, o)
            }
            unbindElementFromMarkerName(t, e) {
                const n = this._markerNameToElements.get(e);
                n && (n.delete(t), 0 == n.size && this._markerNameToElements.delete(e));
                const o = this._elementToMarkerNames.get(t);
                o && (o.delete(e), 0 == o.size && this._elementToMarkerNames.delete(t))
            }
            flushUnboundMarkerNames() {
                const t = Array.from(this._unboundMarkerNames);
                return this._unboundMarkerNames.clear(), t
            }
            flushDeferredBindings() {
                for (const [t, e] of this._deferredBindingRemovals) t.root == e && this.unbindViewElement(t);
                this._deferredBindingRemovals = new Map
            }
            clearBindings() {
                this._modelToViewMapping = new WeakMap, this._viewToModelMapping = new WeakMap, this._markerNameToElements = new Map, this._elementToMarkerNames = new Map, this._unboundMarkerNames = new Set, this._deferredBindingRemovals = new Map
            }
            toModelElement(t) {
                return this._viewToModelMapping.get(t)
            }
            toViewElement(t) {
                return this._modelToViewMapping.get(t)
            }
            toModelRange(t) {
                return new Pl(this.toModelPosition(t.start), this.toModelPosition(t.end))
            }
            toViewRange(t) {
                return new ms(this.toViewPosition(t.start), this.toViewPosition(t.end))
            }
            toModelPosition(t) {
                const e = {
                    viewPosition: t,
                    mapper: this
                };
                return this.fire("viewToModelPosition", e), e.modelPosition
            }
            toViewPosition(t, e = {}) {
                const n = {
                    modelPosition: t,
                    mapper: this,
                    isPhantom: e.isPhantom
                };
                return this.fire("modelToViewPosition", n), n.viewPosition
            }
            markerNameToElements(t) {
                const e = this._markerNameToElements.get(t);
                if (!e) return null;
                const n = new Set;
                for (const t of e)
                    if (t.is("attributeElement"))
                        for (const e of t.getElementsWithSameId()) n.add(e);
                    else n.add(t);
                return n
            }
            registerViewToModelLength(t, e) {
                this._viewToModelLengthCallbacks.set(t, e)
            }
            findMappedViewAncestor(t) {
                let e = t.parent;
                for (; !this._viewToModelMapping.has(e);) e = e.parent;
                return e
            }
            _toModelOffset(t, e, n) {
                if (n != t) {
                    return this._toModelOffset(t.parent, t.index, n) + this._toModelOffset(t, e, t)
                }
                if (t.is("$text")) return e;
                let o = 0;
                for (let n = 0; n < e; n++) o += this.getModelLength(t.getChild(n));
                return o
            }
            getModelLength(t) {
                if (this._viewToModelLengthCallbacks.get(t.name)) {
                    return this._viewToModelLengthCallbacks.get(t.name)(t)
                }
                if (this._viewToModelMapping.has(t)) return 1;
                if (t.is("$text")) return t.data.length;
                if (t.is("uiElement")) return 0;
                {
                    let e = 0;
                    for (const n of t.getChildren()) e += this.getModelLength(n);
                    return e
                }
            }
            findPositionIn(t, e) {
                let n, o = 0,
                    i = 0,
                    r = 0;
                if (t.is("$text")) return new gs(t, e);
                for (; i < e;) n = t.getChild(r), o = this.getModelLength(n), i += o, r++;
                return i == e ? this._moveViewPositionToTextNode(new gs(t, r)) : this.findPositionIn(n, e - (i - o))
            }
            _moveViewPositionToTextNode(t) {
                const e = t.nodeBefore,
                    n = t.nodeAfter;
                return e instanceof or ? new gs(e, e.data.length) : n instanceof or ? new gs(n, 0) : t
            }
        }
        class zl {
            constructor() {
                this._consumable = new Map, this._textProxyRegistry = new Map
            }
            add(t, e) {
                e = Vl(e), t instanceof _l && (t = this._getSymbolForTextProxy(t)), this._consumable.has(t) || this._consumable.set(t, new Map), this._consumable.get(t).set(e, !0)
            }
            consume(t, e) {
                return e = Vl(e), t instanceof _l && (t = this._getSymbolForTextProxy(t)), !!this.test(t, e) && (this._consumable.get(t).set(e, !1), !0)
            }
            test(t, e) {
                e = Vl(e), t instanceof _l && (t = this._getSymbolForTextProxy(t));
                const n = this._consumable.get(t);
                if (void 0 === n) return null;
                const o = n.get(e);
                return void 0 === o ? null : o
            }
            revert(t, e) {
                e = Vl(e), t instanceof _l && (t = this._getSymbolForTextProxy(t));
                const n = this.test(t, e);
                return !1 === n ? (this._consumable.get(t).set(e, !0), !0) : !0 !== n && null
            }
            verifyAllConsumed(t) {
                const e = [];
                for (const [n, o] of this._consumable)
                    for (const [i, r] of o) {
                        const o = i.split(":")[0];
                        r && t == o && e.push({
                            event: i,
                            item: n.name || n.description
                        })
                    }
                if (e.length) throw new b("conversion-model-consumable-not-consumed", null, {
                    items: e
                })
            }
            _getSymbolForTextProxy(t) {
                let e = null;
                const n = this._textProxyRegistry.get(t.startOffset);
                if (n) {
                    const o = n.get(t.endOffset);
                    o && (e = o.get(t.parent))
                }
                return e || (e = this._addSymbolForTextProxy(t)), e
            }
            _addSymbolForTextProxy(t) {
                const e = t.startOffset,
                    n = t.endOffset,
                    o = t.parent,
                    i = Symbol("$textProxy:" + t.data);
                let r, s;
                return r = this._textProxyRegistry.get(e), r || (r = new Map, this._textProxyRegistry.set(e, r)), s = r.get(n), s || (s = new Map, r.set(n, s)), s.set(o, i), i
            }
        }

        function Vl(t) {
            const e = t.split(":");
            return "insert" == e[0] ? e[0] : "addMarker" == e[0] || "removeMarker" == e[0] ? t : e.length > 1 ? e[0] + ":" + e[1] : e[0]
        }
        var Ol = Object.defineProperty,
            Fl = Object.defineProperties,
            Ml = Object.getOwnPropertyDescriptors,
            Nl = Object.getOwnPropertySymbols,
            Ll = Object.prototype.hasOwnProperty,
            Hl = Object.prototype.propertyIsEnumerable,
            jl = (t, e, n) => e in t ? Ol(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n,
            ql = (t, e) => {
                for (var n in e || (e = {})) Ll.call(e, n) && jl(t, n, e[n]);
                if (Nl)
                    for (var n of Nl(e)) Hl.call(e, n) && jl(t, n, e[n]);
                return t
            },
            Wl = (t, e) => Fl(t, Ml(e));
        class Ul extends(S()) {
            constructor(t) {
                super(), this._conversionApi = ql({
                    dispatcher: this
                }, t), this._firedEventsMap = new WeakMap
            }
            convertChanges(t, e, n) {
                const o = this._createConversionApi(n, t.getRefreshedItems());
                for (const e of t.getMarkersToRemove()) this._convertMarkerRemove(e.name, e.range, o);
                const i = this._reduceChanges(t.getChanges());
                for (const t of i) "insert" === t.type ? this._convertInsert(Pl._createFromPositionAndShift(t.position, t.length), o) : "reinsert" === t.type ? this._convertReinsert(Pl._createFromPositionAndShift(t.position, t.length), o) : "remove" === t.type ? this._convertRemove(t.position, t.length, t.name, o) : this._convertAttribute(t.range, t.attributeKey, t.attributeOldValue, t.attributeNewValue, o);
                for (const t of o.mapper.flushUnboundMarkerNames()) {
                    const n = e.get(t).getRange();
                    this._convertMarkerRemove(t, n, o), this._convertMarkerAdd(t, n, o)
                }
                for (const e of t.getMarkersToAdd()) this._convertMarkerAdd(e.name, e.range, o);
                o.mapper.flushDeferredBindings(), o.consumable.verifyAllConsumed("insert")
            }
            convert(t, e, n, o = {}) {
                const i = this._createConversionApi(n, void 0, o);
                this._convertInsert(t, i);
                for (const [t, n] of e) this._convertMarkerAdd(t, n, i);
                i.consumable.verifyAllConsumed("insert")
            }
            convertSelection(t, e, n) {
                const o = Array.from(e.getMarkersAtPosition(t.getFirstPosition())),
                    i = this._createConversionApi(n);
                if (this._addConsumablesForSelection(i.consumable, t, o), this.fire("selection", {
                        selection: t
                    }, i), t.isCollapsed) {
                    for (const e of o) {
                        const n = e.getRange();
                        if (!$l(t.getFirstPosition(), e, i.mapper)) continue;
                        const o = {
                            item: t,
                            markerName: e.name,
                            markerRange: n
                        };
                        i.consumable.test(t, "addMarker:" + e.name) && this.fire(`addMarker:${e.name}`, o, i)
                    }
                    for (const e of t.getAttributeKeys()) {
                        const n = {
                            item: t,
                            range: t.getFirstRange(),
                            attributeKey: e,
                            attributeOldValue: null,
                            attributeNewValue: t.getAttribute(e)
                        };
                        i.consumable.test(t, "attribute:" + n.attributeKey) && this.fire(`attribute:${n.attributeKey}:$text`, n, i)
                    }
                }
            }
            _convertInsert(t, e, n = {}) {
                n.doNotAddConsumables || this._addConsumablesForInsert(e.consumable, Array.from(t));
                for (const n of Array.from(t.getWalker({
                        shallow: !0
                    })).map(Gl)) this._testAndFire("insert", n, e)
            }
            _convertRemove(t, e, n, o) {
                this.fire(`remove:${n}`, {
                    position: t,
                    length: e
                }, o)
            }
            _convertAttribute(t, e, n, o, i) {
                this._addConsumablesForRange(i.consumable, t, `attribute:${e}`);
                for (const r of t) {
                    const t = {
                        item: r.item,
                        range: Pl._createFromPositionAndShift(r.previousPosition, r.length),
                        attributeKey: e,
                        attributeOldValue: n,
                        attributeNewValue: o
                    };
                    this._testAndFire(`attribute:${e}`, t, i)
                }
            }
            _convertReinsert(t, e) {
                const n = Array.from(t.getWalker({
                    shallow: !0
                }));
                this._addConsumablesForInsert(e.consumable, n);
                for (const t of n.map(Gl)) this._testAndFire("insert", Wl(ql({}, t), {
                    reconversion: !0
                }), e)
            }
            _convertMarkerAdd(t, e, n) {
                if ("$graveyard" == e.root.rootName) return;
                const o = `addMarker:${t}`;
                if (n.consumable.add(e, o), this.fire(o, {
                        markerName: t,
                        markerRange: e
                    }, n), n.consumable.consume(e, o)) {
                    this._addConsumablesForRange(n.consumable, e, o);
                    for (const i of e.getItems()) {
                        if (!n.consumable.test(i, o)) continue;
                        const r = {
                            item: i,
                            range: Pl._createOn(i),
                            markerName: t,
                            markerRange: e
                        };
                        this.fire(o, r, n)
                    }
                }
            }
            _convertMarkerRemove(t, e, n) {
                "$graveyard" != e.root.rootName && this.fire(`removeMarker:${t}`, {
                    markerName: t,
                    markerRange: e
                }, n)
            }
            _reduceChanges(t) {
                const e = {
                    changes: t
                };
                return this.fire("reduceChanges", e), e.changes
            }
            _addConsumablesForInsert(t, e) {
                for (const n of e) {
                    const e = n.item;
                    if (null === t.test(e, "insert")) {
                        t.add(e, "insert");
                        for (const n of e.getAttributeKeys()) t.add(e, "attribute:" + n)
                    }
                }
                return t
            }
            _addConsumablesForRange(t, e, n) {
                for (const o of e.getItems()) t.add(o, n);
                return t
            }
            _addConsumablesForSelection(t, e, n) {
                t.add(e, "selection");
                for (const o of n) t.add(e, "addMarker:" + o.name);
                for (const n of e.getAttributeKeys()) t.add(e, "attribute:" + n);
                return t
            }
            _testAndFire(t, e, n) {
                const o = function(t, e) {
                        const n = e.item.is("element") ? e.item.name : "$text";
                        return `${t}:${n}`
                    }(t, e),
                    i = e.item.is("$textProxy") ? n.consumable._getSymbolForTextProxy(e.item) : e.item,
                    r = this._firedEventsMap.get(n),
                    s = r.get(i);
                if (s) {
                    if (s.has(o)) return;
                    s.add(o)
                } else r.set(i, new Set([o]));
                this.fire(o, e, n)
            }
            _testAndFireAddAttributes(t, e) {
                const n = {
                    item: t,
                    range: Pl._createOn(t)
                };
                for (const t of n.item.getAttributeKeys()) n.attributeKey = t, n.attributeOldValue = null, n.attributeNewValue = n.item.getAttribute(t), this._testAndFire(`attribute:${t}`, n, e)
            }
            _createConversionApi(t, e = new Set, n = {}) {
                const o = Wl(ql({}, this._conversionApi), {
                    consumable: new zl,
                    writer: t,
                    options: n,
                    convertItem: t => this._convertInsert(Pl._createOn(t), o),
                    convertChildren: t => this._convertInsert(Pl._createIn(t), o, {
                        doNotAddConsumables: !0
                    }),
                    convertAttributes: t => this._testAndFireAddAttributes(t, o),
                    canReuseView: t => !e.has(o.mapper.toModelElement(t))
                });
                return this._firedEventsMap.set(o, new Map), o
            }
        }

        function $l(t, e, n) {
            const o = e.getRange(),
                i = Array.from(t.getAncestors());
            i.shift(), i.reverse();
            return !i.some((t => {
                if (o.containsItem(t)) {
                    return !!n.toViewElement(t).getCustomProperty("addHighlight")
                }
            }))
        }

        function Gl(t) {
            return {
                item: t.item,
                range: Pl._createFromPositionAndShift(t.previousPosition, t.length)
            }
        }
        class Kl extends(S(kl)) {
            constructor(...t) {
                super(), this._lastRangeBackward = !1, this._attrs = new Map, this._ranges = [], t.length && this.setTo(...t)
            }
            get anchor() {
                if (this._ranges.length > 0) {
                    const t = this._ranges[this._ranges.length - 1];
                    return this._lastRangeBackward ? t.end : t.start
                }
                return null
            }
            get focus() {
                if (this._ranges.length > 0) {
                    const t = this._ranges[this._ranges.length - 1];
                    return this._lastRangeBackward ? t.start : t.end
                }
                return null
            }
            get isCollapsed() {
                return 1 === this._ranges.length && this._ranges[0].isCollapsed
            }
            get rangeCount() {
                return this._ranges.length
            }
            get isBackward() {
                return !this.isCollapsed && this._lastRangeBackward
            }
            isEqual(t) {
                if (this.rangeCount != t.rangeCount) return !1;
                if (0 === this.rangeCount) return !0;
                if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) return !1;
                for (const e of this._ranges) {
                    let n = !1;
                    for (const o of t._ranges)
                        if (e.isEqual(o)) {
                            n = !0;
                            break
                        } if (!n) return !1
                }
                return !0
            }* getRanges() {
                for (const t of this._ranges) yield new Pl(t.start, t.end)
            }
            getFirstRange() {
                let t = null;
                for (const e of this._ranges) t && !e.start.isBefore(t.start) || (t = e);
                return t ? new Pl(t.start, t.end) : null
            }
            getLastRange() {
                let t = null;
                for (const e of this._ranges) t && !e.end.isAfter(t.end) || (t = e);
                return t ? new Pl(t.start, t.end) : null
            }
            getFirstPosition() {
                const t = this.getFirstRange();
                return t ? t.start.clone() : null
            }
            getLastPosition() {
                const t = this.getLastRange();
                return t ? t.end.clone() : null
            }
            setTo(...t) {
                let [e, n, o] = t;
                if ("object" == typeof n && (o = n, n = void 0), null === e) this._setRanges([]);
                else if (e instanceof Kl) this._setRanges(e.getRanges(), e.isBackward);
                else if (e && "function" == typeof e.getRanges) this._setRanges(e.getRanges(), e.isBackward);
                else if (e instanceof Pl) this._setRanges([e], !!o && !!o.backward);
                else if (e instanceof El) this._setRanges([new Pl(e)]);
                else if (e instanceof wl) {
                    const t = !!o && !!o.backward;
                    let i;
                    if ("in" == n) i = Pl._createIn(e);
                    else if ("on" == n) i = Pl._createOn(e);
                    else {
                        if (void 0 === n) throw new b("model-selection-setto-required-second-parameter", [this, e]);
                        i = new Pl(El._createAt(e, n))
                    }
                    this._setRanges([i], t)
                } else {
                    if (!Q(e)) throw new b("model-selection-setto-not-selectable", [this, e]);
                    this._setRanges(e, o && !!o.backward)
                }
            }
            _setRanges(t, e = !1) {
                const n = Array.from(t),
                    o = n.some((e => {
                        if (!(e instanceof Pl)) throw new b("model-selection-set-ranges-not-range", [this, t]);
                        return this._ranges.every((t => !t.isEqual(e)))
                    }));
                (n.length !== this._ranges.length || o) && (this._replaceAllRanges(n), this._lastRangeBackward = !!e, this.fire("change:range", {
                    directChange: !0
                }))
            }
            setFocus(t, e) {
                if (null === this.anchor) throw new b("model-selection-setfocus-no-ranges", [this, t]);
                const n = El._createAt(t, e);
                if ("same" == n.compareWith(this.focus)) return;
                const o = this.anchor;
                this._ranges.length && this._popRange(), "before" == n.compareWith(o) ? (this._pushRange(new Pl(n, o)), this._lastRangeBackward = !0) : (this._pushRange(new Pl(o, n)), this._lastRangeBackward = !1), this.fire("change:range", {
                    directChange: !0
                })
            }
            getAttribute(t) {
                return this._attrs.get(t)
            }
            getAttributes() {
                return this._attrs.entries()
            }
            getAttributeKeys() {
                return this._attrs.keys()
            }
            hasAttribute(t) {
                return this._attrs.has(t)
            }
            removeAttribute(t) {
                this.hasAttribute(t) && (this._attrs.delete(t), this.fire("change:attribute", {
                    attributeKeys: [t],
                    directChange: !0
                }))
            }
            setAttribute(t, e) {
                this.getAttribute(t) !== e && (this._attrs.set(t, e), this.fire("change:attribute", {
                    attributeKeys: [t],
                    directChange: !0
                }))
            }
            getSelectedElement() {
                return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement()
            }* getSelectedBlocks() {
                const t = new WeakSet;
                for (const e of this.getRanges()) {
                    const n = Yl(e.start, t);
                    Xl(n, e) && (yield n);
                    for (const n of e.getWalker()) {
                        const o = n.item;
                        "elementEnd" == n.type && Jl(o, t, e) && (yield o)
                    }
                    const o = Yl(e.end, t);
                    tc(o, e) && (yield o)
                }
            }
            containsEntireContent(t = this.anchor.root) {
                const e = El._createAt(t, 0),
                    n = El._createAt(t, "end");
                return e.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition())
            }
            _pushRange(t) {
                this._checkRange(t), this._ranges.push(new Pl(t.start, t.end))
            }
            _checkRange(t) {
                for (let e = 0; e < this._ranges.length; e++)
                    if (t.isIntersecting(this._ranges[e])) throw new b("model-selection-range-intersects", [this, t], {
                        addedRange: t,
                        intersectingRange: this._ranges[e]
                    })
            }
            _replaceAllRanges(t) {
                this._removeAllRanges();
                for (const e of t) this._pushRange(e)
            }
            _removeAllRanges() {
                for (; this._ranges.length > 0;) this._popRange()
            }
            _popRange() {
                this._ranges.pop()
            }
        }

        function Zl(t, e) {
            return !e.has(t) && (e.add(t), t.root.document.model.schema.isBlock(t) && !!t.parent)
        }

        function Jl(t, e, n) {
            return Zl(t, e) && Ql(t, n)
        }

        function Yl(t, e) {
            const n = t.parent.root.document.model.schema,
                o = t.parent.getAncestors({
                    parentFirst: !0,
                    includeSelf: !0
                });
            let i = !1;
            const r = o.find((t => !i && (i = n.isLimit(t), !i && Zl(t, e))));
            return o.forEach((t => e.add(t))), r
        }

        function Ql(t, e) {
            const n = function(t) {
                const e = t.root.document.model.schema;
                let n = t.parent;
                for (; n;) {
                    if (e.isBlock(n)) return n;
                    n = n.parent
                }
            }(t);
            if (!n) return !0;
            return !e.containsRange(Pl._createOn(n), !0)
        }

        function Xl(t, e) {
            return !!t && (!(!e.isCollapsed && !t.isEmpty) || !e.start.isTouching(El._createAt(t, t.maxOffset)) && Ql(t, e))
        }

        function tc(t, e) {
            return !!t && (!(!e.isCollapsed && !t.isEmpty) || !e.end.isTouching(El._createAt(t, 0)) && Ql(t, e))
        }
        Kl.prototype.is = function(t) {
            return "selection" === t || "model:selection" === t
        };
        class ec extends(S(Pl)) {
            constructor(t, e) {
                super(t, e), nc.call(this)
            }
            detach() {
                this.stopListening()
            }
            toRange() {
                return new Pl(this.start, this.end)
            }
            static fromRange(t) {
                return new ec(t.start, t.end)
            }
        }

        function nc() {
            this.listenTo(this.root.document.model, "applyOperation", ((t, e) => {
                const n = e[0];
                n.isDocumentOperation && oc.call(this, n)
            }), {
                priority: "low"
            })
        }

        function oc(t) {
            const e = this.getTransformedByOperation(t),
                n = Pl._createFromRanges(e),
                o = !n.isEqual(this),
                i = function(t, e) {
                    switch (e.type) {
                        case "insert":
                            return t.containsPosition(e.position);
                        case "move":
                        case "remove":
                        case "reinsert":
                        case "merge":
                            return t.containsPosition(e.sourcePosition) || t.start.isEqual(e.sourcePosition) || t.containsPosition(e.targetPosition);
                        case "split":
                            return t.containsPosition(e.splitPosition) || t.containsPosition(e.insertionPosition)
                    }
                    return !1
                }(this, t);
            let r = null;
            if (o) {
                "$graveyard" == n.root.rootName && (r = "remove" == t.type ? t.sourcePosition : t.deletionPosition);
                const e = this.toRange();
                this.start = n.start, this.end = n.end, this.fire("change:range", e, {
                    deletionPosition: r
                })
            } else i && this.fire("change:content", this.toRange(), {
                deletionPosition: r
            })
        }
        ec.prototype.is = function(t) {
            return "liveRange" === t || "model:liveRange" === t || "range" == t || "model:range" === t
        };
        const ic = "selection:";
        class rc extends(S(kl)) {
            constructor(t) {
                super(), this._selection = new sc(t), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this)
            }
            get isCollapsed() {
                return this._selection.isCollapsed
            }
            get anchor() {
                return this._selection.anchor
            }
            get focus() {
                return this._selection.focus
            }
            get rangeCount() {
                return this._selection.rangeCount
            }
            get hasOwnRange() {
                return this._selection.hasOwnRange
            }
            get isBackward() {
                return this._selection.isBackward
            }
            get isGravityOverridden() {
                return this._selection.isGravityOverridden
            }
            get markers() {
                return this._selection.markers
            }
            get _ranges() {
                return this._selection._ranges
            }
            getRanges() {
                return this._selection.getRanges()
            }
            getFirstPosition() {
                return this._selection.getFirstPosition()
            }
            getLastPosition() {
                return this._selection.getLastPosition()
            }
            getFirstRange() {
                return this._selection.getFirstRange()
            }
            getLastRange() {
                return this._selection.getLastRange()
            }
            getSelectedBlocks() {
                return this._selection.getSelectedBlocks()
            }
            getSelectedElement() {
                return this._selection.getSelectedElement()
            }
            containsEntireContent(t) {
                return this._selection.containsEntireContent(t)
            }
            destroy() {
                this._selection.destroy()
            }
            getAttributeKeys() {
                return this._selection.getAttributeKeys()
            }
            getAttributes() {
                return this._selection.getAttributes()
            }
            getAttribute(t) {
                return this._selection.getAttribute(t)
            }
            hasAttribute(t) {
                return this._selection.hasAttribute(t)
            }
            refresh() {
                this._selection.updateMarkers(), this._selection._updateAttributes(!1)
            }
            observeMarkers(t) {
                this._selection.observeMarkers(t)
            }
            _setFocus(t, e) {
                this._selection.setFocus(t, e)
            }
            _setTo(...t) {
                this._selection.setTo(...t)
            }
            _setAttribute(t, e) {
                this._selection.setAttribute(t, e)
            }
            _removeAttribute(t) {
                this._selection.removeAttribute(t)
            }
            _getStoredAttributes() {
                return this._selection.getStoredAttributes()
            }
            _overrideGravity() {
                return this._selection.overrideGravity()
            }
            _restoreGravity(t) {
                this._selection.restoreGravity(t)
            }
            static _getStoreAttributeKey(t) {
                return ic + t
            }
            static _isStoreAttributeKey(t) {
                return t.startsWith(ic)
            }
        }
        rc.prototype.is = function(t) {
            return "selection" === t || "model:selection" == t || "documentSelection" == t || "model:documentSelection" == t
        };
        class sc extends Kl {
            constructor(t) {
                super(), this.markers = new xi({
                    idProperty: "name"
                }), this._attributePriority = new Map, this._selectionRestorePosition = null, this._hasChangedRange = !1, this._overriddenGravityRegister = new Set, this._observedMarkers = new Set, this._model = t.model, this._document = t, this.listenTo(this._model, "applyOperation", ((t, e) => {
                    const n = e[0];
                    n.isDocumentOperation && "marker" != n.type && "rename" != n.type && "noop" != n.type && (0 == this._ranges.length && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = !1, this.fire("change:range", {
                        directChange: !1
                    })))
                }), {
                    priority: "lowest"
                }), this.on("change:range", (() => {
                    this._validateSelectionRanges(this.getRanges())
                })), this.listenTo(this._model.markers, "update", ((t, e, n, o) => {
                    this._updateMarker(e, o)
                })), this.listenTo(this._document, "change", ((t, e) => {
                    ! function(t, e) {
                        const n = t.document.differ;
                        for (const o of n.getChanges()) {
                            if ("insert" != o.type) continue;
                            const n = o.position.parent;
                            o.length === n.maxOffset && t.enqueueChange(e, (t => {
                                const e = Array.from(n.getAttributeKeys()).filter((t => t.startsWith(ic)));
                                for (const o of e) t.removeAttribute(o, n)
                            }))
                        }
                    }(this._model, e)
                }))
            }
            get isCollapsed() {
                return 0 === this._ranges.length ? this._document._getDefaultRange().isCollapsed : super.isCollapsed
            }
            get anchor() {
                return super.anchor || this._document._getDefaultRange().start
            }
            get focus() {
                return super.focus || this._document._getDefaultRange().end
            }
            get rangeCount() {
                return this._ranges.length ? this._ranges.length : 1
            }
            get hasOwnRange() {
                return this._ranges.length > 0
            }
            get isGravityOverridden() {
                return !!this._overriddenGravityRegister.size
            }
            destroy() {
                for (let t = 0; t < this._ranges.length; t++) this._ranges[t].detach();
                this.stopListening()
            }* getRanges() {
                this._ranges.length ? yield* super.getRanges(): yield this._document._getDefaultRange()
            }
            getFirstRange() {
                return super.getFirstRange() || this._document._getDefaultRange()
            }
            getLastRange() {
                return super.getLastRange() || this._document._getDefaultRange()
            }
            setTo(...t) {
                super.setTo(...t), this._updateAttributes(!0), this.updateMarkers()
            }
            setFocus(t, e) {
                super.setFocus(t, e), this._updateAttributes(!0), this.updateMarkers()
            }
            setAttribute(t, e) {
                if (this._setAttribute(t, e)) {
                    const e = [t];
                    this.fire("change:attribute", {
                        attributeKeys: e,
                        directChange: !0
                    })
                }
            }
            removeAttribute(t) {
                if (this._removeAttribute(t)) {
                    const e = [t];
                    this.fire("change:attribute", {
                        attributeKeys: e,
                        directChange: !0
                    })
                }
            }
            overrideGravity() {
                const t = g();
                return this._overriddenGravityRegister.add(t), 1 === this._overriddenGravityRegister.size && this._updateAttributes(!0), t
            }
            restoreGravity(t) {
                if (!this._overriddenGravityRegister.has(t)) throw new b("document-selection-gravity-wrong-restore", this, {
                    uid: t
                });
                this._overriddenGravityRegister.delete(t), this.isGravityOverridden || this._updateAttributes(!0)
            }
            observeMarkers(t) {
                this._observedMarkers.add(t), this.updateMarkers()
            }
            _replaceAllRanges(t) {
                this._validateSelectionRanges(t), super._replaceAllRanges(t)
            }
            _popRange() {
                this._ranges.pop().detach()
            }
            _pushRange(t) {
                const e = this._prepareRange(t);
                e && this._ranges.push(e)
            }
            _validateSelectionRanges(t) {
                for (const e of t)
                    if (!this._document._validateSelectionRange(e)) throw new b("document-selection-wrong-position", this, {
                        range: e
                    })
            }
            _prepareRange(t) {
                if (this._checkRange(t), t.root == this._document.graveyard) return;
                const e = ec.fromRange(t);
                return e.on("change:range", ((t, n, o) => {
                    if (this._hasChangedRange = !0, e.root == this._document.graveyard) {
                        this._selectionRestorePosition = o.deletionPosition;
                        const t = this._ranges.indexOf(e);
                        this._ranges.splice(t, 1), e.detach()
                    }
                })), e
            }
            updateMarkers() {
                if (!this._observedMarkers.size) return;
                const t = [];
                let e = !1;
                for (const e of this._model.markers) {
                    const n = e.name.split(":", 1)[0];
                    if (!this._observedMarkers.has(n)) continue;
                    const o = e.getRange();
                    for (const n of this.getRanges()) o.containsRange(n, !n.isCollapsed) && t.push(e)
                }
                const n = Array.from(this.markers);
                for (const n of t) this.markers.has(n) || (this.markers.add(n), e = !0);
                for (const n of Array.from(this.markers)) t.includes(n) || (this.markers.remove(n), e = !0);
                e && this.fire("change:marker", {
                    oldMarkers: n,
                    directChange: !1
                })
            }
            _updateMarker(t, e) {
                const n = t.name.split(":", 1)[0];
                if (!this._observedMarkers.has(n)) return;
                let o = !1;
                const i = Array.from(this.markers),
                    r = this.markers.has(t);
                if (e) {
                    let n = !1;
                    for (const t of this.getRanges())
                        if (e.containsRange(t, !t.isCollapsed)) {
                            n = !0;
                            break
                        } n && !r ? (this.markers.add(t), o = !0) : !n && r && (this.markers.remove(t), o = !0)
                } else r && (this.markers.remove(t), o = !0);
                o && this.fire("change:marker", {
                    oldMarkers: i,
                    directChange: !1
                })
            }
            _updateAttributes(t) {
                const e = Ti(this._getSurroundingAttributes()),
                    n = Ti(this.getAttributes());
                if (t) this._attributePriority = new Map, this._attrs = new Map;
                else
                    for (const [t, e] of this._attributePriority) "low" == e && (this._attrs.delete(t), this._attributePriority.delete(t));
                this._setAttributesTo(e);
                const o = [];
                for (const [t, e] of this.getAttributes()) n.has(t) && n.get(t) === e || o.push(t);
                for (const [t] of n) this.hasAttribute(t) || o.push(t);
                o.length > 0 && this.fire("change:attribute", {
                    attributeKeys: o,
                    directChange: !1
                })
            }
            _setAttribute(t, e, n = !0) {
                const o = n ? "normal" : "low";
                if ("low" == o && "normal" == this._attributePriority.get(t)) return !1;
                return super.getAttribute(t) !== e && (this._attrs.set(t, e), this._attributePriority.set(t, o), !0)
            }
            _removeAttribute(t, e = !0) {
                const n = e ? "normal" : "low";
                return ("low" != n || "normal" != this._attributePriority.get(t)) && (this._attributePriority.set(t, n), !!super.hasAttribute(t) && (this._attrs.delete(t), !0))
            }
            _setAttributesTo(t) {
                const e = new Set;
                for (const [e, n] of this.getAttributes()) t.get(e) !== n && this._removeAttribute(e, !1);
                for (const [n, o] of t) {
                    this._setAttribute(n, o, !1) && e.add(n)
                }
                return e
            }* getStoredAttributes() {
                const t = this.getFirstPosition().parent;
                if (this.isCollapsed && t.isEmpty)
                    for (const e of t.getAttributeKeys())
                        if (e.startsWith(ic)) {
                            const n = e.substr(ic.length);
                            yield [n, t.getAttribute(e)]
                        }
            }
            _getSurroundingAttributes() {
                const t = this.getFirstPosition(),
                    e = this._model.schema;
                let n = null;
                if (this.isCollapsed) {
                    const o = t.textNode ? t.textNode : t.nodeBefore,
                        i = t.textNode ? t.textNode : t.nodeAfter;
                    if (this.isGravityOverridden || (n = ac(o, e)), n || (n = ac(i, e)), !this.isGravityOverridden && !n) {
                        let t = o;
                        for (; t && !n;) t = t.previousSibling, n = ac(t, e)
                    }
                    if (!n) {
                        let t = i;
                        for (; t && !n;) t = t.nextSibling, n = ac(t, e)
                    }
                    n || (n = this.getStoredAttributes())
                } else {
                    const t = this.getFirstRange();
                    for (const o of t) {
                        if (o.item.is("element") && e.isObject(o.item)) break;
                        if ("text" == o.type) {
                            n = o.item.getAttributes();
                            break
                        }
                    }
                }
                return n
            }
            _fixGraveyardSelection(t) {
                const e = this._model.schema.getNearestSelectionRange(t);
                e && this._pushRange(e)
            }
        }

        function ac(t, e) {
            if (!t) return null;
            if (t instanceof _l || t instanceof Cl) return t.getAttributes();
            if (!e.isInline(t)) return null;
            if (!e.isObject(t)) return [];
            const n = [];
            for (const [o, i] of t.getAttributes()) e.checkAttribute("$text", o) && n.push([o, i]);
            return n
        }
        class lc {
            constructor(t) {
                this._dispatchers = t
            }
            add(t) {
                for (const e of this._dispatchers) t(e);
                return this
            }
        }
        class cc extends lc {
            elementToElement(t) {
                return this.add(function(t) {
                    const e = uc(t.model),
                        n = gc(t.view, "container");
                    e.attributes.length && (e.children = !0);
                    return o => {
                        o.on(`insert:${e.name}`, function(t, e = Cc) {
                            return (n, o, i) => {
                                if (!e(o.item, i.consumable, {
                                        preflight: !0
                                    })) return;
                                const r = t(o.item, i, o);
                                if (!r) return;
                                e(o.item, i.consumable);
                                const s = i.mapper.toViewPosition(o.range.start);
                                i.mapper.bindElements(o.item, r), i.writer.insert(s, r), i.convertAttributes(o.item), wc(r, o.item.getChildren(), i, {
                                    reconversion: o.reconversion
                                })
                            }
                        }(n, kc(e)), {
                            priority: t.converterPriority || "normal"
                        }), (e.children || e.attributes.length) && o.on("reduceChanges", bc(e), {
                            priority: "low"
                        })
                    }
                }(t))
            }
            elementToStructure(t) {
                return this.add(function(t) {
                    const e = uc(t.model),
                        n = gc(t.view, "container");
                    return e.children = !0, o => {
                        if (o._conversionApi.schema.checkChild(e.name, "$text")) throw new b("conversion-element-to-structure-disallowed-text", o, {
                            elementName: e.name
                        });
                        var i, r;
                        o.on(`insert:${e.name}`, (i = n, r = kc(e), (t, e, n) => {
                            if (!r(e.item, n.consumable, {
                                    preflight: !0
                                })) return;
                            const o = new Map;
                            n.writer._registerSlotFactory(function(t, e, n) {
                                return (o, i) => {
                                    const r = o.createContainerElement("$slot");
                                    let s = null;
                                    if ("children" === i) s = Array.from(t.getChildren());
                                    else {
                                        if ("function" != typeof i) throw new b("conversion-slot-mode-unknown", n.dispatcher, {
                                            modeOrFilter: i
                                        });
                                        s = Array.from(t.getChildren()).filter((t => i(t)))
                                    }
                                    return e.set(r, s), r
                                }
                            }(e.item, o, n));
                            const s = i(e.item, n, e);
                            if (n.writer._clearSlotFactory(), !s) return;
                            ! function(t, e, n) {
                                const o = Array.from(e.values()).flat(),
                                    i = new Set(o);
                                if (i.size != o.length) throw new b("conversion-slot-filter-overlap", n.dispatcher, {
                                    element: t
                                });
                                if (i.size != t.childCount) throw new b("conversion-slot-filter-incomplete", n.dispatcher, {
                                    element: t
                                })
                            }(e.item, o, n), r(e.item, n.consumable);
                            const a = n.mapper.toViewPosition(e.range.start);
                            n.mapper.bindElements(e.item, s), n.writer.insert(a, s), n.convertAttributes(e.item),
                                function(t, e, n, o) {
                                    n.mapper.on("modelToViewPosition", s, {
                                        priority: "highest"
                                    });
                                    let i = null,
                                        r = null;
                                    for ([i, r] of e) wc(t, r, n, o), n.writer.move(n.writer.createRangeIn(i), n.writer.createPositionBefore(i)), n.writer.remove(i);

                                    function s(t, e) {
                                        const n = e.modelPosition.nodeAfter,
                                            o = r.indexOf(n);
                                        o < 0 || (e.viewPosition = e.mapper.findPositionIn(i, o))
                                    }
                                    n.mapper.off("modelToViewPosition", s)
                                }(s, o, n, {
                                    reconversion: e.reconversion
                                })
                        }), {
                            priority: t.converterPriority || "normal"
                        }), o.on("reduceChanges", bc(e), {
                            priority: "low"
                        })
                    }
                }(t))
            }
            attributeToElement(t) {
                return this.add(function(t) {
                    t = fl(t);
                    let e = t.model;
                    "string" == typeof e && (e = {
                        key: e
                    });
                    let n = `attribute:${e.key}`;
                    e.name && (n += ":" + e.name);
                    if (e.values)
                        for (const n of e.values) t.view[n] = gc(t.view[n], "attribute");
                    else t.view = gc(t.view, "attribute");
                    const o = mc(t);
                    return e => {
                        e.on(n, function(t) {
                            return (e, n, o) => {
                                if (!o.consumable.test(n.item, e.name)) return;
                                const i = t(n.attributeOldValue, o, n),
                                    r = t(n.attributeNewValue, o, n);
                                if (!i && !r) return;
                                o.consumable.consume(n.item, e.name);
                                const s = o.writer,
                                    a = s.document.selection;
                                if (n.item instanceof Kl || n.item instanceof rc) s.wrap(a.getFirstRange(), r);
                                else {
                                    let t = o.mapper.toViewRange(n.range);
                                    null !== n.attributeOldValue && i && (t = s.unwrap(t, i)), null !== n.attributeNewValue && r && s.wrap(t, r)
                                }
                            }
                        }(o), {
                            priority: t.converterPriority || "normal"
                        })
                    }
                }(t))
            }
            attributeToAttribute(t) {
                return this.add(function(t) {
                    t = fl(t);
                    let e = t.model;
                    "string" == typeof e && (e = {
                        key: e
                    });
                    let n = `attribute:${e.key}`;
                    e.name && (n += ":" + e.name);
                    if (e.values)
                        for (const n of e.values) t.view[n] = pc(t.view[n]);
                    else t.view = pc(t.view);
                    const o = mc(t);
                    return e => {
                        var i;
                        e.on(n, (i = o, (t, e, n) => {
                            if (!n.consumable.test(e.item, t.name)) return;
                            const o = i(e.attributeOldValue, n, e),
                                r = i(e.attributeNewValue, n, e);
                            if (!o && !r) return;
                            n.consumable.consume(e.item, t.name);
                            const s = n.mapper.toViewElement(e.item),
                                a = n.writer;
                            if (!s) throw new b("conversion-attribute-to-attribute-on-text", n.dispatcher, e);
                            if (null !== e.attributeOldValue && o)
                                if ("class" == o.key) {
                                    const t = Ai(o.value);
                                    for (const e of t) a.removeClass(e, s)
                                } else if ("style" == o.key) {
                                const t = Object.keys(o.value);
                                for (const e of t) a.removeStyle(e, s)
                            } else a.removeAttribute(o.key, s);
                            if (null !== e.attributeNewValue && r)
                                if ("class" == r.key) {
                                    const t = Ai(r.value);
                                    for (const e of t) a.addClass(e, s)
                                } else if ("style" == r.key) {
                                const t = Object.keys(r.value);
                                for (const e of t) a.setStyle(e, r.value[e], s)
                            } else a.setAttribute(r.key, r.value, s)
                        }), {
                            priority: t.converterPriority || "normal"
                        })
                    }
                }(t))
            }
            markerToElement(t) {
                return this.add(function(t) {
                    const e = gc(t.view, "ui");
                    return n => {
                        var o;
                        n.on(`addMarker:${t.model}`, (o = e, (t, e, n) => {
                            e.isOpening = !0;
                            const i = o(e, n);
                            e.isOpening = !1;
                            const r = o(e, n);
                            if (!i || !r) return;
                            const s = e.markerRange;
                            if (s.isCollapsed && !n.consumable.consume(s, t.name)) return;
                            for (const e of s)
                                if (!n.consumable.consume(e.item, t.name)) return;
                            const a = n.mapper,
                                l = n.writer;
                            l.insert(a.toViewPosition(s.start), i), n.mapper.bindElementToMarker(i, e.markerName), s.isCollapsed || (l.insert(a.toViewPosition(s.end), r), n.mapper.bindElementToMarker(r, e.markerName)), t.stop()
                        }), {
                            priority: t.converterPriority || "normal"
                        }), n.on(`removeMarker:${t.model}`, ((t, e, n) => {
                            const o = n.mapper.markerNameToElements(e.markerName);
                            if (o) {
                                for (const t of o) n.mapper.unbindElementFromMarkerName(t, e.markerName), n.writer.clear(n.writer.createRangeOn(t), t);
                                n.writer.clearClonedElementsGroup(e.markerName), t.stop()
                            }
                        }), {
                            priority: t.converterPriority || "normal"
                        })
                    }
                }(t))
            }
            markerToHighlight(t) {
                return this.add(function(t) {
                    return e => {
                        var n;
                        e.on(`addMarker:${t.model}`, (n = t.view, (t, e, o) => {
                            if (!e.item) return;
                            if (!(e.item instanceof Kl || e.item instanceof rc || e.item.is("$textProxy"))) return;
                            const i = fc(n, e, o);
                            if (!i) return;
                            if (!o.consumable.consume(e.item, t.name)) return;
                            const r = o.writer,
                                s = dc(r, i),
                                a = r.document.selection;
                            if (e.item instanceof Kl || e.item instanceof rc) r.wrap(a.getFirstRange(), s);
                            else {
                                const t = o.mapper.toViewRange(e.range),
                                    n = r.wrap(t, s);
                                for (const t of n.getItems())
                                    if (t.is("attributeElement") && t.isSimilar(s)) {
                                        o.mapper.bindElementToMarker(t, e.markerName);
                                        break
                                    }
                            }
                        }), {
                            priority: t.converterPriority || "normal"
                        }), e.on(`addMarker:${t.model}`, function(t) {
                            return (e, n, o) => {
                                if (!n.item) return;
                                if (!(n.item instanceof vl)) return;
                                const i = fc(t, n, o);
                                if (!i) return;
                                if (!o.consumable.test(n.item, e.name)) return;
                                const r = o.mapper.toViewElement(n.item);
                                if (r && r.getCustomProperty("addHighlight")) {
                                    o.consumable.consume(n.item, e.name);
                                    for (const t of Pl._createIn(n.item)) o.consumable.consume(t.item, e.name);
                                    r.getCustomProperty("addHighlight")(r, i, o.writer), o.mapper.bindElementToMarker(r, n.markerName)
                                }
                            }
                        }(t.view), {
                            priority: t.converterPriority || "normal"
                        }), e.on(`removeMarker:${t.model}`, function(t) {
                            return (e, n, o) => {
                                if (n.markerRange.isCollapsed) return;
                                const i = fc(t, n, o);
                                if (!i) return;
                                const r = dc(o.writer, i),
                                    s = o.mapper.markerNameToElements(n.markerName);
                                if (s) {
                                    for (const t of s)
                                        if (o.mapper.unbindElementFromMarkerName(t, n.markerName), t.is("attributeElement")) o.writer.unwrap(o.writer.createRangeOn(t), r);
                                        else {
                                            t.getCustomProperty("removeHighlight")(t, i.id, o.writer)
                                        } o.writer.clearClonedElementsGroup(n.markerName), e.stop()
                                }
                            }
                        }(t.view), {
                            priority: t.converterPriority || "normal"
                        })
                    }
                }(t))
            }
            markerToData(t) {
                return this.add(function(t) {
                    t = fl(t);
                    const e = t.model;
                    let n = t.view;
                    n || (n = n => ({
                        group: e,
                        name: n.substr(t.model.length + 1)
                    }));
                    return o => {
                        var i;
                        o.on(`addMarker:${e}`, (i = n, (t, e, n) => {
                            const o = i(e.markerName, n);
                            if (!o) return;
                            const r = e.markerRange;
                            n.consumable.consume(r, t.name) && (hc(r, !1, n, e, o), hc(r, !0, n, e, o), t.stop())
                        }), {
                            priority: t.converterPriority || "normal"
                        }), o.on(`removeMarker:${e}`, function(t) {
                            return (e, n, o) => {
                                const i = t(n.markerName, o);
                                if (!i) return;
                                const r = o.mapper.markerNameToElements(n.markerName);
                                if (r) {
                                    for (const t of r) o.mapper.unbindElementFromMarkerName(t, n.markerName), t.is("containerElement") ? (s(`data-${i.group}-start-before`, t), s(`data-${i.group}-start-after`, t), s(`data-${i.group}-end-before`, t), s(`data-${i.group}-end-after`, t)) : o.writer.clear(o.writer.createRangeOn(t), t);
                                    o.writer.clearClonedElementsGroup(n.markerName), e.stop()
                                }

                                function s(t, e) {
                                    if (e.hasAttribute(t)) {
                                        const n = new Set(e.getAttribute(t).split(","));
                                        n.delete(i.name), 0 == n.size ? o.writer.removeAttribute(t, e) : o.writer.setAttribute(t, Array.from(n).join(","), e)
                                    }
                                }
                            }
                        }(n), {
                            priority: t.converterPriority || "normal"
                        })
                    }
                }(t))
            }
        }

        function dc(t, e) {
            const n = t.createAttributeElement("span", e.attributes);
            return e.classes && n._addClass(e.classes), "number" == typeof e.priority && (n._priority = e.priority), n._id = e.id, n
        }

        function hc(t, e, n, o, i) {
            const r = e ? t.start : t.end,
                s = r.nodeAfter && r.nodeAfter.is("element") ? r.nodeAfter : null,
                a = r.nodeBefore && r.nodeBefore.is("element") ? r.nodeBefore : null;
            if (s || a) {
                let t, r;
                e && s || !e && !a ? (t = s, r = !0) : (t = a, r = !1);
                const l = n.mapper.toViewElement(t);
                if (l) return void
                function(t, e, n, o, i, r) {
                    const s = `data-${r.group}-${e?"start":"end"}-${n?"before":"after"}`,
                        a = t.hasAttribute(s) ? t.getAttribute(s).split(",") : [];
                    a.unshift(r.name), o.writer.setAttribute(s, a.join(","), t), o.mapper.bindElementToMarker(t, i.markerName)
                }(l, e, r, n, o, i)
            }! function(t, e, n, o, i) {
                const r = `${i.group}-${e?"start":"end"}`,
                    s = i.name ? {
                        name: i.name
                    } : null,
                    a = n.writer.createUIElement(r, s);
                n.writer.insert(t, a), n.mapper.bindElementToMarker(a, o.markerName)
            }(n.mapper.toViewPosition(r), e, n, o, i)
        }

        function uc(t) {
            return "string" == typeof t && (t = {
                name: t
            }), t.attributes ? Array.isArray(t.attributes) || (t.attributes = [t.attributes]) : t.attributes = [], t.children = !!t.children, t
        }

        function gc(t, e) {
            return "function" == typeof t ? t : (n, o) => function(t, e, n) {
                "string" == typeof t && (t = {
                    name: t
                });
                let o;
                const i = e.writer,
                    r = Object.assign({}, t.attributes);
                if ("container" == n) o = i.createContainerElement(t.name, r);
                else if ("attribute" == n) {
                    const e = {
                        priority: t.priority || Es.DEFAULT_PRIORITY
                    };
                    o = i.createAttributeElement(t.name, r, e)
                } else o = i.createUIElement(t.name, r);
                if (t.styles) {
                    const e = Object.keys(t.styles);
                    for (const n of e) i.setStyle(n, t.styles[n], o)
                }
                if (t.classes) {
                    const e = t.classes;
                    if ("string" == typeof e) i.addClass(e, o);
                    else
                        for (const t of e) i.addClass(t, o)
                }
                return o
            }(t, o, e)
        }

        function mc(t) {
            return t.model.values ? (e, n, o) => {
                const i = t.view[e];
                return i ? i(e, n, o) : null
            } : t.view
        }

        function pc(t) {
            return "string" == typeof t ? e => ({
                key: t,
                value: e
            }) : "object" == typeof t ? t.value ? () => t : e => ({
                key: t.key,
                value: e
            }) : t
        }

        function fc(t, e, n) {
            const o = "function" == typeof t ? t(e, n) : t;
            return o ? (o.priority || (o.priority = 10), o.id || (o.id = e.markerName), o) : null
        }

        function bc(t) {
            const e = function(t) {
                return (e, n) => {
                    if (!e.is("element", t.name)) return !1;
                    if ("attribute" == n.type) {
                        if (t.attributes.includes(n.attributeKey)) return !0
                    } else if (t.children) return !0;
                    return !1
                }
            }(t);
            return (t, n) => {
                const o = [];
                n.reconvertedElements || (n.reconvertedElements = new Set);
                for (const t of n.changes) {
                    const i = "attribute" == t.type ? t.range.start.nodeAfter : t.position.parent;
                    if (i && e(i, t)) {
                        if (!n.reconvertedElements.has(i)) {
                            n.reconvertedElements.add(i);
                            const t = El._createBefore(i);
                            let e = o.length;
                            for (let n = o.length - 1; n >= 0; n--) {
                                const i = o[n],
                                    r = ("attribute" == i.type ? i.range.start : i.position).compareWith(t);
                                if ("before" == r || "remove" == i.type && "same" == r) break;
                                e = n
                            }
                            o.splice(e, 0, {
                                type: "remove",
                                name: i.name,
                                position: t,
                                length: 1
                            }, {
                                type: "reinsert",
                                name: i.name,
                                position: t,
                                length: 1
                            })
                        }
                    } else o.push(t)
                }
                n.changes = o
            }
        }

        function kc(t) {
            return (e, n, o = {}) => {
                const i = ["insert"];
                for (const n of t.attributes) e.hasAttribute(n) && i.push(`attribute:${n}`);
                return !!i.every((t => n.test(e, t))) && (o.preflight || i.forEach((t => n.consume(e, t))), !0)
            }
        }

        function wc(t, e, n, o) {
            for (const i of e) Ac(t.root, i, n, o) || n.convertItem(i)
        }

        function Ac(t, e, n, o) {
            const {
                writer: i,
                mapper: r
            } = n;
            if (!o.reconversion) return !1;
            const s = r.toViewElement(e);
            return !(!s || s.root == t) && (!!n.canReuseView(s) && (i.move(i.createRangeOn(s), r.toViewPosition(El._createBefore(e))), !0))
        }

        function Cc(t, e, {
            preflight: n
        } = {}) {
            return n ? e.test(t, "insert") : e.consume(t, "insert")
        }

        function _c(t) {
            const {
                schema: e,
                document: n
            } = t.model;
            for (const o of n.getRootNames()) {
                const i = n.getRoot(o);
                if (i.isEmpty && !e.checkChild(i, "$text") && e.checkChild(i, "paragraph")) return t.insertElement("paragraph", i), !0
            }
            return !1
        }

        function vc(t, e, n) {
            const o = n.createContext(t);
            return !!n.checkChild(o, "paragraph") && !!n.checkChild(o.push("paragraph"), e)
        }

        function yc(t, e) {
            const n = e.createElement("paragraph");
            return e.insert(n, t), e.createPositionAt(n, 0)
        }
        var xc = Object.defineProperty,
            Ec = Object.defineProperties,
            Dc = Object.getOwnPropertyDescriptors,
            Sc = Object.getOwnPropertySymbols,
            Tc = Object.prototype.hasOwnProperty,
            Bc = Object.prototype.propertyIsEnumerable,
            Ic = (t, e, n) => e in t ? xc(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n;
        class Pc extends lc {
            elementToElement(t) {
                return this.add(Rc(t))
            }
            elementToAttribute(t) {
                return this.add(function(t) {
                    t = fl(t), Oc(t);
                    const e = Fc(t, !1),
                        n = zc(t.view),
                        o = n ? `element:${n}` : "element";
                    return n => {
                        n.on(o, e, {
                            priority: t.converterPriority || "low"
                        })
                    }
                }(t))
            }
            attributeToAttribute(t) {
                return this.add(function(t) {
                    t = fl(t);
                    let e = null;
                    ("string" == typeof t.view || t.view.key) && (e = function(t) {
                        "string" == typeof t.view && (t.view = {
                            key: t.view
                        });
                        const e = t.view.key;
                        let n;
                        if ("class" == e || "style" == e) {
                            n = {
                                ["class" == e ? "classes" : "styles"]: t.view.value
                            }
                        } else {
                            n = {
                                attributes: {
                                    [e]: void 0 === t.view.value ? /[\s\S]*/ : t.view.value
                                }
                            }
                        }
                        t.view.name && (n.name = t.view.name);
                        return t.view = n, e
                    }(t));
                    Oc(t, e);
                    const n = Fc(t, !0);
                    return e => {
                        e.on("element", n, {
                            priority: t.converterPriority || "low"
                        })
                    }
                }(t))
            }
            elementToMarker(t) {
                return this.add(function(t) {
                    const e = function(t) {
                        return (e, n) => {
                            const o = "string" == typeof t ? t : t(e, n);
                            return n.writer.createElement("$marker", {
                                "data-name": o
                            })
                        }
                    }(t.model);
                    return Rc((n = ((t, e) => {
                        for (var n in e || (e = {})) Tc.call(e, n) && Ic(t, n, e[n]);
                        if (Sc)
                            for (var n of Sc(e)) Bc.call(e, n) && Ic(t, n, e[n]);
                        return t
                    })({}, t), o = {
                        model: e
                    }, Ec(n, Dc(o))));
                    var n, o
                }(t))
            }
            dataToMarker(t) {
                return this.add(function(t) {
                    t = fl(t), t.model || (t.model = e => e ? t.view + ":" + e : t.view);
                    const e = {
                            view: t.view,
                            model: t.model
                        },
                        n = Vc(Mc(e, "start")),
                        o = Vc(Mc(e, "end"));
                    return i => {
                        i.on(`element:${t.view}-start`, n, {
                            priority: t.converterPriority || "normal"
                        }), i.on(`element:${t.view}-end`, o, {
                            priority: t.converterPriority || "normal"
                        });
                        const r = m.low,
                            s = m.highest,
                            a = m.get(t.converterPriority) / s;
                        i.on("element", function(t) {
                            return (e, n, o) => {
                                const i = `data-${t.view}`;

                                function r(e, i) {
                                    for (const r of i) {
                                        const i = t.model(r, o),
                                            s = o.writer.createElement("$marker", {
                                                "data-name": i
                                            });
                                        o.writer.insert(s, e), n.modelCursor.isEqual(e) ? n.modelCursor = n.modelCursor.getShiftedBy(1) : n.modelCursor = n.modelCursor._getTransformedByInsertion(e, 1), n.modelRange = n.modelRange._getTransformedByInsertion(e, 1)[0]
                                    }
                                }(o.consumable.test(n.viewItem, {
                                    attributes: i + "-end-after"
                                }) || o.consumable.test(n.viewItem, {
                                    attributes: i + "-start-after"
                                }) || o.consumable.test(n.viewItem, {
                                    attributes: i + "-end-before"
                                }) || o.consumable.test(n.viewItem, {
                                    attributes: i + "-start-before"
                                })) && (n.modelRange || Object.assign(n, o.convertChildren(n.viewItem, n.modelCursor)), o.consumable.consume(n.viewItem, {
                                    attributes: i + "-end-after"
                                }) && r(n.modelRange.end, n.viewItem.getAttribute(i + "-end-after").split(",")), o.consumable.consume(n.viewItem, {
                                    attributes: i + "-start-after"
                                }) && r(n.modelRange.end, n.viewItem.getAttribute(i + "-start-after").split(",")), o.consumable.consume(n.viewItem, {
                                    attributes: i + "-end-before"
                                }) && r(n.modelRange.start, n.viewItem.getAttribute(i + "-end-before").split(",")), o.consumable.consume(n.viewItem, {
                                    attributes: i + "-start-before"
                                }) && r(n.modelRange.start, n.viewItem.getAttribute(i + "-start-before").split(",")))
                            }
                        }(e), {
                            priority: r + a
                        })
                    }
                }(t))
            }
        }

        function Rc(t) {
            const e = Vc(t = fl(t)),
                n = zc(t.view),
                o = n ? `element:${n}` : "element";
            return n => {
                n.on(o, e, {
                    priority: t.converterPriority || "normal"
                })
            }
        }

        function zc(t) {
            return "string" == typeof t ? t : "object" == typeof t && "string" == typeof t.name ? t.name : null
        }

        function Vc(t) {
            const e = new rr(t.view);
            return (n, o, i) => {
                const r = e.match(o.viewItem);
                if (!r) return;
                const s = r.match;
                if (s.name = !0, !i.consumable.test(o.viewItem, s)) return;
                const a = function(t, e, n) {
                    return t instanceof Function ? t(e, n) : n.writer.createElement(t)
                }(t.model, o.viewItem, i);
                a && i.safeInsert(a, o.modelCursor) && (i.consumable.consume(o.viewItem, s), i.convertChildren(o.viewItem, a), i.updateConversionResult(a, o))
            }
        }

        function Oc(t, e = null) {
            const n = null === e || (t => t.getAttribute(e)),
                o = "object" != typeof t.model ? t.model : t.model.key,
                i = "object" != typeof t.model || void 0 === t.model.value ? n : t.model.value;
            t.model = {
                key: o,
                value: i
            }
        }

        function Fc(t, e) {
            const n = new rr(t.view);
            return (o, i, r) => {
                if (!i.modelRange && e) return;
                const s = n.match(i.viewItem);
                if (!s) return;
                if (! function(t, e) {
                        const n = "function" == typeof t ? t(e) : t;
                        if ("object" == typeof n && !zc(n)) return !1;
                        return !n.classes && !n.attributes && !n.styles
                    }(t.view, i.viewItem) ? delete s.match.name : s.match.name = !0, !r.consumable.test(i.viewItem, s.match)) return;
                const a = t.model.key,
                    l = "function" == typeof t.model.value ? t.model.value(i.viewItem, r) : t.model.value;
                if (null === l) return;
                i.modelRange || Object.assign(i, r.convertChildren(i.viewItem, i.modelCursor));
                const c = function(t, e, n, o) {
                    let i = !1;
                    for (const r of Array.from(t.getItems({
                            shallow: n
                        }))) o.schema.checkAttribute(r, e.key) && (i = !0, r.hasAttribute(e.key) || o.writer.setAttribute(e.key, e.value, r));
                    return i
                }(i.modelRange, {
                    key: a,
                    value: l
                }, e, r);
                c && (r.consumable.test(i.viewItem, {
                    name: !0
                }) && (s.match.name = !0), r.consumable.consume(i.viewItem, s.match))
            }
        }

        function Mc(t, e) {
            return {
                view: `${t.view}-${e}`,
                model: (e, n) => {
                    const o = e.getAttribute("name"),
                        i = t.model(o, n);
                    return n.writer.createElement("$marker", {
                        "data-name": i
                    })
                }
            }
        }

        function Nc(t) {
            t.document.registerPostFixer((e => function(t, e) {
                const n = e.document.selection,
                    o = e.schema,
                    i = [];
                let r = !1;
                for (const t of n.getRanges()) {
                    const e = Lc(t, o);
                    e && !e.isEqual(t) ? (i.push(e), r = !0) : i.push(t)
                }
                r && t.setSelection(function(t) {
                    const e = [...t],
                        n = new Set;
                    let o = 1;
                    for (; o < e.length;) {
                        const t = e[o],
                            i = e.slice(0, o);
                        for (const [r, s] of i.entries())
                            if (!n.has(r))
                                if (t.isEqual(s)) n.add(r);
                                else if (t.isIntersecting(s)) {
                            n.add(r), n.add(o);
                            const i = t.getJoined(s);
                            e.push(i)
                        }
                        o++
                    }
                    return e.filter(((t, e) => !n.has(e)))
                }(i), {
                    backward: n.isBackward
                });
                return !1
            }(e, t)))
        }

        function Lc(t, e) {
            return t.isCollapsed ? function(t, e) {
                const n = t.start,
                    o = e.getNearestSelectionRange(n);
                if (!o) {
                    const t = n.getAncestors().reverse().find((t => e.isObject(t)));
                    return t ? Pl._createOn(t) : null
                }
                if (!o.isCollapsed) return o;
                const i = o.start;
                if (n.isEqual(i)) return null;
                return new Pl(i)
            }(t, e) : function(t, e) {
                const {
                    start: n,
                    end: o
                } = t, i = e.checkChild(n, "$text"), r = e.checkChild(o, "$text"), s = e.getLimitElement(n), a = e.getLimitElement(o);
                if (s === a) {
                    if (i && r) return null;
                    if (function(t, e, n) {
                            const o = t.nodeAfter && !n.isLimit(t.nodeAfter) || n.checkChild(t, "$text"),
                                i = e.nodeBefore && !n.isLimit(e.nodeBefore) || n.checkChild(e, "$text");
                            return o || i
                        }(n, o, e)) {
                        const t = n.nodeAfter && e.isSelectable(n.nodeAfter) ? null : e.getNearestSelectionRange(n, "forward"),
                            i = o.nodeBefore && e.isSelectable(o.nodeBefore) ? null : e.getNearestSelectionRange(o, "backward"),
                            r = t ? t.start : n,
                            s = i ? i.end : o;
                        return new Pl(r, s)
                    }
                }
                const l = s && !s.is("rootElement"),
                    c = a && !a.is("rootElement");
                if (l || c) {
                    const t = n.nodeAfter && o.nodeBefore && n.nodeAfter.parent === o.nodeBefore.parent,
                        i = l && (!t || !jc(n.nodeAfter, e)),
                        r = c && (!t || !jc(o.nodeBefore, e));
                    let d = n,
                        h = o;
                    return i && (d = El._createBefore(Hc(s, e))), r && (h = El._createAfter(Hc(a, e))), new Pl(d, h)
                }
                return null
            }(t, e)
        }

        function Hc(t, e) {
            let n = t,
                o = n;
            for (; e.isLimit(o) && o.parent;) n = o, o = o.parent;
            return n
        }

        function jc(t, e) {
            return t && e.isSelectable(t)
        }
        class qc extends(q()) {
            constructor(t, e) {
                super(), this.model = t, this.view = new bl(e), this.mapper = new Rl, this.downcastDispatcher = new Ul({
                    mapper: this.mapper,
                    schema: t.schema
                });
                const n = this.model.document,
                    o = n.selection,
                    r = this.model.markers;
                var s, a, l;
                this.listenTo(this.model, "_beforeChanges", (() => {
                    this.view._disableRendering(!0)
                }), {
                    priority: "highest"
                }), this.listenTo(this.model, "_afterChanges", (() => {
                    this.view._disableRendering(!1)
                }), {
                    priority: "lowest"
                }), this.listenTo(n, "change", (() => {
                    this.view.change((t => {
                        this.downcastDispatcher.convertChanges(n.differ, r, t), this.downcastDispatcher.convertSelection(o, r, t)
                    }))
                }), {
                    priority: "low"
                }), this.listenTo(this.view.document, "selectionChange", function(t, e) {
                    return (n, o) => {
                        const i = o.newSelection,
                            r = [];
                        for (const t of i.getRanges()) r.push(e.toModelRange(t));
                        const s = t.createSelection(r, {
                            backward: i.isBackward
                        });
                        s.isEqual(t.document.selection) || t.change((t => {
                            t.setSelection(s)
                        }))
                    }
                }(this.model, this.mapper)), this.listenTo(this.view.document, "beforeinput", (s = this.mapper, a = this.model.schema, l = this.view, (t, e) => {
                    if (!l.document.isComposing || i.isAndroid)
                        for (let t = 0; t < e.targetRanges.length; t++) {
                            const n = e.targetRanges[t],
                                o = s.toModelRange(n),
                                i = Lc(o, a);
                            i && !i.isEqual(o) && (e.targetRanges[t] = s.toViewRange(i))
                        }
                }), {
                    priority: "high"
                }), this.downcastDispatcher.on("insert:$text", ((t, e, n) => {
                    if (!n.consumable.consume(e.item, t.name)) return;
                    const o = n.writer,
                        i = n.mapper.toViewPosition(e.range.start),
                        r = o.createText(e.item.data);
                    o.insert(i, r)
                }), {
                    priority: "lowest"
                }), this.downcastDispatcher.on("insert", ((t, e, n) => {
                    n.convertAttributes(e.item), e.reconversion || !e.item.is("element") || e.item.isEmpty || n.convertChildren(e.item)
                }), {
                    priority: "lowest"
                }), this.downcastDispatcher.on("remove", ((t, e, n) => {
                    const o = n.mapper.toViewPosition(e.position),
                        i = e.position.getShiftedBy(e.length),
                        r = n.mapper.toViewPosition(i, {
                            isPhantom: !0
                        }),
                        s = n.writer.createRange(o, r),
                        a = n.writer.remove(s.getTrimmed());
                    for (const t of n.writer.createRangeIn(a).getItems()) n.mapper.unbindViewElement(t, {
                        defer: !0
                    })
                }), {
                    priority: "low"
                }), this.downcastDispatcher.on("selection", ((t, e, n) => {
                    const o = n.writer,
                        i = o.document.selection;
                    for (const t of i.getRanges()) t.isCollapsed && t.end.parent.isAttached() && n.writer.mergeAttributes(t.start);
                    o.setSelection(null)
                }), {
                    priority: "high"
                }), this.downcastDispatcher.on("selection", ((t, e, n) => {
                    const o = e.selection;
                    if (o.isCollapsed) return;
                    if (!n.consumable.consume(o, "selection")) return;
                    const i = [];
                    for (const t of o.getRanges()) i.push(n.mapper.toViewRange(t));
                    n.writer.setSelection(i, {
                        backward: o.isBackward
                    })
                }), {
                    priority: "low"
                }), this.downcastDispatcher.on("selection", ((t, e, n) => {
                    const o = e.selection;
                    if (!o.isCollapsed) return;
                    if (!n.consumable.consume(o, "selection")) return;
                    const i = n.writer,
                        r = o.getFirstPosition(),
                        s = n.mapper.toViewPosition(r),
                        a = i.breakAttributes(s);
                    i.setSelection(a)
                }), {
                    priority: "low"
                }), this.view.document.roots.bindTo(this.model.document.roots).using((t => {
                    if ("$graveyard" == t.rootName) return null;
                    const e = new hs(this.view.document, t.name);
                    return e.rootName = t.rootName, this.mapper.bindElements(t, e), e
                }))
            }
            destroy() {
                this.view.destroy(), this.stopListening()
            }
            reconvertMarker(t) {
                const e = "string" == typeof t ? t : t.name,
                    n = this.model.markers.get(e);
                if (!n) throw new b("editingcontroller-reconvertmarker-marker-not-exist", this, {
                    markerName: e
                });
                this.model.change((() => {
                    this.model.markers._refresh(n)
                }))
            }
            reconvertItem(t) {
                this.model.change((() => {
                    this.model.document.differ._refreshItem(t)
                }))
            }
        }
        class Wc {
            constructor() {
                this._consumables = new Map
            }
            add(t, e) {
                let n;
                t.is("$text") || t.is("documentFragment") ? this._consumables.set(t, !0) : (this._consumables.has(t) ? n = this._consumables.get(t) : (n = new $c(t), this._consumables.set(t, n)), n.add(e))
            }
            test(t, e) {
                const n = this._consumables.get(t);
                return void 0 === n ? null : t.is("$text") || t.is("documentFragment") ? n : n.test(e)
            }
            consume(t, e) {
                return !!this.test(t, e) && (t.is("$text") || t.is("documentFragment") ? this._consumables.set(t, !1) : this._consumables.get(t).consume(e), !0)
            }
            revert(t, e) {
                const n = this._consumables.get(t);
                void 0 !== n && (t.is("$text") || t.is("documentFragment") ? this._consumables.set(t, !0) : n.revert(e))
            }
            static consumablesFromElement(t) {
                const e = {
                        element: t,
                        name: !0,
                        attributes: [],
                        classes: [],
                        styles: []
                    },
                    n = t.getAttributeKeys();
                for (const t of n) "style" != t && "class" != t && e.attributes.push(t);
                const o = t.getClassNames();
                for (const t of o) e.classes.push(t);
                const i = t.getStyleNames();
                for (const t of i) e.styles.push(t);
                return e
            }
            static createFrom(t, e) {
                if (e || (e = new Wc), t.is("$text")) return e.add(t), e;
                t.is("element") && e.add(t, Wc.consumablesFromElement(t)), t.is("documentFragment") && e.add(t);
                for (const n of t.getChildren()) e = Wc.createFrom(n, e);
                return e
            }
        }
        const Uc = ["attributes", "classes", "styles"];
        class $c {
            constructor(t) {
                this.element = t, this._canConsumeName = null, this._consumables = {
                    attributes: new Map,
                    styles: new Map,
                    classes: new Map
                }
            }
            add(t) {
                t.name && (this._canConsumeName = !0);
                for (const e of Uc) e in t && this._add(e, t[e])
            }
            test(t) {
                if (t.name && !this._canConsumeName) return this._canConsumeName;
                for (const e of Uc)
                    if (e in t) {
                        const n = this._test(e, t[e]);
                        if (!0 !== n) return n
                    } return !0
            }
            consume(t) {
                t.name && (this._canConsumeName = !1);
                for (const e of Uc) e in t && this._consume(e, t[e])
            }
            revert(t) {
                t.name && (this._canConsumeName = !0);
                for (const e of Uc) e in t && this._revert(e, t[e])
            }
            _add(t, e) {
                const n = ut(e) ? e : [e],
                    o = this._consumables[t];
                for (const e of n) {
                    if ("attributes" === t && ("class" === e || "style" === e)) throw new b("viewconsumable-invalid-attribute", this);
                    if (o.set(e, !0), "styles" === t)
                        for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) o.set(t, !0)
                }
            }
            _test(t, e) {
                const n = ut(e) ? e : [e],
                    o = this._consumables[t];
                for (const e of n)
                    if ("attributes" !== t || "class" !== e && "style" !== e) {
                        const t = o.get(e);
                        if (void 0 === t) return null;
                        if (!t) return !1
                    } else {
                        const t = "class" == e ? "classes" : "styles",
                            n = this._test(t, [...this._consumables[t].keys()]);
                        if (!0 !== n) return n
                    } return !0
            }
            _consume(t, e) {
                const n = ut(e) ? e : [e],
                    o = this._consumables[t];
                for (const e of n)
                    if ("attributes" !== t || "class" !== e && "style" !== e) {
                        if (o.set(e, !1), "styles" == t)
                            for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) o.set(t, !1)
                    } else {
                        const t = "class" == e ? "classes" : "styles";
                        this._consume(t, [...this._consumables[t].keys()])
                    }
            }
            _revert(t, e) {
                const n = ut(e) ? e : [e],
                    o = this._consumables[t];
                for (const e of n)
                    if ("attributes" !== t || "class" !== e && "style" !== e) {
                        !1 === o.get(e) && o.set(e, !0)
                    } else {
                        const t = "class" == e ? "classes" : "styles";
                        this._revert(t, [...this._consumables[t].keys()])
                    }
            }
        }
        class Gc extends(q()) {
            constructor() {
                super(), this._sourceDefinitions = {}, this._attributeProperties = {}, this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", ((t, e) => {
                    e[0] = new Kc(e[0])
                }), {
                    priority: "highest"
                }), this.on("checkChild", ((t, e) => {
                    e[0] = new Kc(e[0]), e[1] = this.getDefinition(e[1])
                }), {
                    priority: "highest"
                })
            }
            register(t, e) {
                if (this._sourceDefinitions[t]) throw new b("schema-cannot-register-item-twice", this, {
                    itemName: t
                });
                this._sourceDefinitions[t] = [Object.assign({}, e)], this._clearCache()
            }
            extend(t, e) {
                if (!this._sourceDefinitions[t]) throw new b("schema-cannot-extend-missing-item", this, {
                    itemName: t
                });
                this._sourceDefinitions[t].push(Object.assign({}, e)), this._clearCache()
            }
            getDefinitions() {
                return this._compiledDefinitions || this._compile(), this._compiledDefinitions
            }
            getDefinition(t) {
                let e;
                return e = "string" == typeof t ? t : "is" in t && (t.is("$text") || t.is("$textProxy")) ? "$text" : t.name, this.getDefinitions()[e]
            }
            isRegistered(t) {
                return !!this.getDefinition(t)
            }
            isBlock(t) {
                const e = this.getDefinition(t);
                return !(!e || !e.isBlock)
            }
            isLimit(t) {
                const e = this.getDefinition(t);
                return !!e && !(!e.isLimit && !e.isObject)
            }
            isObject(t) {
                const e = this.getDefinition(t);
                return !!e && !!(e.isObject || e.isLimit && e.isSelectable && e.isContent)
            }
            isInline(t) {
                const e = this.getDefinition(t);
                return !(!e || !e.isInline)
            }
            isSelectable(t) {
                const e = this.getDefinition(t);
                return !!e && !(!e.isSelectable && !e.isObject)
            }
            isContent(t) {
                const e = this.getDefinition(t);
                return !!e && !(!e.isContent && !e.isObject)
            }
            checkChild(t, e) {
                return !!e && this._checkContextMatch(e, t)
            }
            checkAttribute(t, e) {
                const n = this.getDefinition(t.last);
                return !!n && n.allowAttributes.includes(e)
            }
            checkMerge(t, e) {
                if (t instanceof El) {
                    const e = t.nodeBefore,
                        n = t.nodeAfter;
                    if (!(e instanceof vl)) throw new b("schema-check-merge-no-element-before", this);
                    if (!(n instanceof vl)) throw new b("schema-check-merge-no-element-after", this);
                    return this.checkMerge(e, n)
                }
                for (const n of e.getChildren())
                    if (!this.checkChild(t, n)) return !1;
                return !0
            }
            addChildCheck(t) {
                this.on("checkChild", ((e, [n, o]) => {
                    if (!o) return;
                    const i = t(n, o);
                    "boolean" == typeof i && (e.stop(), e.return = i)
                }), {
                    priority: "high"
                })
            }
            addAttributeCheck(t) {
                this.on("checkAttribute", ((e, [n, o]) => {
                    const i = t(n, o);
                    "boolean" == typeof i && (e.stop(), e.return = i)
                }), {
                    priority: "high"
                })
            }
            setAttributeProperties(t, e) {
                this._attributeProperties[t] = Object.assign(this.getAttributeProperties(t), e)
            }
            getAttributeProperties(t) {
                return this._attributeProperties[t] || {}
            }
            getLimitElement(t) {
                let e;
                if (t instanceof El) e = t.parent;
                else {
                    e = (t instanceof Pl ? [t] : Array.from(t.getRanges())).reduce(((t, e) => {
                        const n = e.getCommonAncestor();
                        return t ? t.getCommonAncestor(n, {
                            includeSelf: !0
                        }) : n
                    }), null)
                }
                for (; !this.isLimit(e) && e.parent;) e = e.parent;
                return e
            }
            checkAttributeInSelection(t, e) {
                if (t.isCollapsed) {
                    const n = [...t.getFirstPosition().getAncestors(), new Cl("", t.getAttributes())];
                    return this.checkAttribute(n, e)
                } {
                    const n = t.getRanges();
                    for (const t of n)
                        for (const n of t)
                            if (this.checkAttribute(n.item, e)) return !0
                }
                return !1
            }* getValidRanges(t, e) {
                t = function*(t) {
                    for (const e of t) yield* e.getMinimalFlatRanges()
                }(t);
                for (const n of t) yield* this._getValidRangesForRange(n, e)
            }
            getNearestSelectionRange(t, e = "both") {
                if (this.checkChild(t, "$text")) return new Pl(t);
                let n, o;
                const i = t.getAncestors().reverse().find((t => this.isLimit(t))) || t.root;
                "both" != e && "backward" != e || (n = new yl({
                    boundaries: Pl._createIn(i),
                    startPosition: t,
                    direction: "backward"
                })), "both" != e && "forward" != e || (o = new yl({
                    boundaries: Pl._createIn(i),
                    startPosition: t
                }));
                for (const t of function*(t, e) {
                        let n = !1;
                        for (; !n;) {
                            if (n = !0, t) {
                                const e = t.next();
                                e.done || (n = !1, yield {
                                    walker: t,
                                    value: e.value
                                })
                            }
                            if (e) {
                                const t = e.next();
                                t.done || (n = !1, yield {
                                    walker: e,
                                    value: t.value
                                })
                            }
                        }
                    }(n, o)) {
                    const e = t.walker == n ? "elementEnd" : "elementStart",
                        o = t.value;
                    if (o.type == e && this.isObject(o.item)) return Pl._createOn(o.item);
                    if (this.checkChild(o.nextPosition, "$text")) return new Pl(o.nextPosition)
                }
                return null
            }
            findAllowedParent(t, e) {
                let n = t.parent;
                for (; n;) {
                    if (this.checkChild(n, e)) return n;
                    if (this.isLimit(n)) return null;
                    n = n.parent
                }
                return null
            }
            setAllowedAttributes(t, e, n) {
                const o = n.model;
                for (const [i, r] of Object.entries(e)) o.schema.checkAttribute(t, i) && n.setAttribute(i, r, t)
            }
            removeDisallowedAttributes(t, e) {
                for (const n of t)
                    if (n.is("$text")) ad(this, n, e);
                    else {
                        const t = Pl._createIn(n).getPositions();
                        for (const n of t) {
                            ad(this, n.nodeBefore || n.parent, e)
                        }
                    }
            }
            getAttributesWithProperty(t, e, n) {
                const o = {};
                for (const [i, r] of t.getAttributes()) {
                    const t = this.getAttributeProperties(i);
                    void 0 !== t[e] && (void 0 !== n && n !== t[e] || (o[i] = r))
                }
                return o
            }
            createContext(t) {
                return new Kc(t)
            }
            _clearCache() {
                this._compiledDefinitions = null
            }
            _compile() {
                const t = {},
                    e = this._sourceDefinitions,
                    n = Object.keys(e);
                for (const o of n) t[o] = Zc(e[o], o);
                for (const e of n) Jc(t, e);
                for (const e of n) Yc(t, e);
                for (const e of n) Qc(t, e);
                for (const e of n) Xc(t, e), td(t, e);
                for (const e of n) ed(t, e), nd(t, e), od(t, e);
                this._compiledDefinitions = t
            }
            _checkContextMatch(t, e, n = e.length - 1) {
                const o = e.getItem(n);
                if (t.allowIn.includes(o.name)) {
                    if (0 == n) return !0;
                    {
                        const t = this.getDefinition(o);
                        return this._checkContextMatch(t, e, n - 1)
                    }
                }
                return !1
            }* _getValidRangesForRange(t, e) {
                let n = t.start,
                    o = t.start;
                for (const i of t.getItems({
                        shallow: !0
                    })) i.is("element") && (yield* this._getValidRangesForRange(Pl._createIn(i), e)), this.checkAttribute(i, e) || (n.isEqual(o) || (yield new Pl(n, o)), n = El._createAfter(i)), o = El._createAfter(i);
                n.isEqual(o) || (yield new Pl(n, o))
            }
        }
        class Kc {
            constructor(t) {
                if (t instanceof Kc) return t;
                let e;
                e = "string" == typeof t ? [t] : Array.isArray(t) ? t : t.getAncestors({
                    includeSelf: !0
                }), this._items = e.map(sd)
            }
            get length() {
                return this._items.length
            }
            get last() {
                return this._items[this._items.length - 1]
            } [Symbol.iterator]() {
                return this._items[Symbol.iterator]()
            }
            push(t) {
                const e = new Kc([t]);
                return e._items = [...this._items, ...e._items], e
            }
            getItem(t) {
                return this._items[t]
            }* getNames() {
                yield* this._items.map((t => t.name))
            }
            endsWith(t) {
                return Array.from(this.getNames()).join(" ").endsWith(t)
            }
            startsWith(t) {
                return Array.from(this.getNames()).join(" ").startsWith(t)
            }
        }

        function Zc(t, e) {
            const n = {
                name: e,
                allowIn: [],
                allowContentOf: [],
                allowWhere: [],
                allowAttributes: [],
                allowAttributesOf: [],
                allowChildren: [],
                inheritTypesFrom: []
            };
            return function(t, e) {
                    for (const n of t) {
                        const t = Object.keys(n).filter((t => t.startsWith("is")));
                        for (const o of t) e[o] = !!n[o]
                    }
                }(t, n), id(t, n, "allowIn"), id(t, n, "allowContentOf"), id(t, n, "allowWhere"), id(t, n, "allowAttributes"), id(t, n, "allowAttributesOf"), id(t, n, "allowChildren"), id(t, n, "inheritTypesFrom"),
                function(t, e) {
                    for (const n of t) {
                        const t = n.inheritAllFrom;
                        t && (e.allowContentOf.push(t), e.allowWhere.push(t), e.allowAttributesOf.push(t), e.inheritTypesFrom.push(t))
                    }
                }(t, n), n
        }

        function Jc(t, e) {
            const n = t[e];
            for (const o of n.allowChildren) {
                const n = t[o];
                n && n.allowIn.push(e)
            }
            n.allowChildren.length = 0
        }

        function Yc(t, e) {
            for (const n of t[e].allowContentOf)
                if (t[n]) {
                    rd(t, n).forEach((t => {
                        t.allowIn.push(e)
                    }))
                } delete t[e].allowContentOf
        }

        function Qc(t, e) {
            for (const n of t[e].allowWhere) {
                const o = t[n];
                if (o) {
                    const n = o.allowIn;
                    t[e].allowIn.push(...n)
                }
            }
            delete t[e].allowWhere
        }

        function Xc(t, e) {
            for (const n of t[e].allowAttributesOf) {
                const o = t[n];
                if (o) {
                    const n = o.allowAttributes;
                    t[e].allowAttributes.push(...n)
                }
            }
            delete t[e].allowAttributesOf
        }

        function td(t, e) {
            const n = t[e];
            for (const e of n.inheritTypesFrom) {
                const o = t[e];
                if (o) {
                    const t = Object.keys(o).filter((t => t.startsWith("is")));
                    for (const e of t) e in n || (n[e] = o[e])
                }
            }
            delete n.inheritTypesFrom
        }

        function ed(t, e) {
            const n = t[e],
                o = n.allowIn.filter((e => t[e]));
            n.allowIn = Array.from(new Set(o))
        }

        function nd(t, e) {
            const n = t[e];
            for (const o of n.allowIn) {
                t[o].allowChildren.push(e)
            }
        }

        function od(t, e) {
            const n = t[e];
            n.allowAttributes = Array.from(new Set(n.allowAttributes))
        }

        function id(t, e, n) {
            for (const o of t) {
                const t = o[n];
                "string" == typeof t ? e[n].push(t) : Array.isArray(t) && e[n].push(...t)
            }
        }

        function rd(t, e) {
            const n = t[e];
            return (o = t, Object.keys(o).map((t => o[t]))).filter((t => t.allowIn.includes(n.name)));
            var o
        }

        function sd(t) {
            return "string" == typeof t || t.is("documentFragment") ? {
                name: "string" == typeof t ? t : "$documentFragment",
                * getAttributeKeys() {},
                getAttribute() {}
            } : {
                name: t.is("element") ? t.name : "$text",
                * getAttributeKeys() {
                    yield* t.getAttributeKeys()
                },
                getAttribute: e => t.getAttribute(e)
            }
        }

        function ad(t, e, n) {
            for (const o of e.getAttributeKeys()) t.checkAttribute(e, o) || n.removeAttribute(o, e)
        }
        var ld = Object.defineProperty,
            cd = Object.defineProperties,
            dd = Object.getOwnPropertyDescriptors,
            hd = Object.getOwnPropertySymbols,
            ud = Object.prototype.hasOwnProperty,
            gd = Object.prototype.propertyIsEnumerable,
            md = (t, e, n) => e in t ? ld(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n;
        class pd extends(S()) {
            constructor(t) {
                var e;
                super(), this._splitParts = new Map, this._cursorParents = new Map, this._modelCursor = null, this._emptyElementsToKeep = new Set, this.conversionApi = (e = ((t, e) => {
                    for (var n in e || (e = {})) ud.call(e, n) && md(t, n, e[n]);
                    if (hd)
                        for (var n of hd(e)) gd.call(e, n) && md(t, n, e[n]);
                    return t
                })({}, t), cd(e, dd({
                    consumable: null,
                    writer: null,
                    store: null,
                    convertItem: (t, e) => this._convertItem(t, e),
                    convertChildren: (t, e) => this._convertChildren(t, e),
                    safeInsert: (t, e) => this._safeInsert(t, e),
                    updateConversionResult: (t, e) => this._updateConversionResult(t, e),
                    splitToAllowedParent: (t, e) => this._splitToAllowedParent(t, e),
                    getSplitParts: t => this._getSplitParts(t),
                    keepEmptyElement: t => this._keepEmptyElement(t)
                })))
            }
            convert(t, e, n = ["$root"]) {
                this.fire("viewCleanup", t), this._modelCursor = function(t, e) {
                    let n;
                    for (const o of new Kc(t)) {
                        const t = {};
                        for (const e of o.getAttributeKeys()) t[e] = o.getAttribute(e);
                        const i = e.createElement(o.name, t);
                        n && e.insert(i, n), n = El._createAt(i, 0)
                    }
                    return n
                }(n, e), this.conversionApi.writer = e, this.conversionApi.consumable = Wc.createFrom(t), this.conversionApi.store = {};
                const {
                    modelRange: o
                } = this._convertItem(t, this._modelCursor), i = e.createDocumentFragment();
                if (o) {
                    this._removeEmptyElements();
                    for (const t of Array.from(this._modelCursor.parent.getChildren())) e.append(t, i);
                    i.markers = function(t, e) {
                        const n = new Set,
                            o = new Map,
                            i = Pl._createIn(t).getItems();
                        for (const t of i) t.is("element", "$marker") && n.add(t);
                        for (const t of n) {
                            const n = t.getAttribute("data-name"),
                                i = e.createPositionBefore(t);
                            o.has(n) ? o.get(n).end = i.clone() : o.set(n, new Pl(i.clone())), e.remove(t)
                        }
                        return o
                    }(i, e)
                }
                return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this._emptyElementsToKeep.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, i
            }
            _convertItem(t, e) {
                const n = {
                    viewItem: t,
                    modelCursor: e,
                    modelRange: null
                };
                if (t.is("element") ? this.fire(`element:${t.name}`, n, this.conversionApi) : t.is("$text") ? this.fire("text", n, this.conversionApi) : this.fire("documentFragment", n, this.conversionApi), n.modelRange && !(n.modelRange instanceof Pl)) throw new b("view-conversion-dispatcher-incorrect-result", this);
                return {
                    modelRange: n.modelRange,
                    modelCursor: n.modelCursor
                }
            }
            _convertChildren(t, e) {
                let n = e.is("position") ? e : El._createAt(e, 0);
                const o = new Pl(n);
                for (const e of Array.from(t.getChildren())) {
                    const t = this._convertItem(e, n);
                    t.modelRange instanceof Pl && (o.end = t.modelRange.end, n = t.modelCursor)
                }
                return {
                    modelRange: o,
                    modelCursor: n
                }
            }
            _safeInsert(t, e) {
                const n = this._splitToAllowedParent(t, e);
                return !!n && (this.conversionApi.writer.insert(t, n.position), !0)
            }
            _updateConversionResult(t, e) {
                const n = this._getSplitParts(t),
                    o = this.conversionApi.writer;
                e.modelRange || (e.modelRange = o.createRange(o.createPositionBefore(t), o.createPositionAfter(n[n.length - 1])));
                const i = this._cursorParents.get(t);
                e.modelCursor = i ? o.createPositionAt(i, 0) : e.modelRange.end
            }
            _splitToAllowedParent(t, e) {
                const {
                    schema: n,
                    writer: o
                } = this.conversionApi;
                let i = n.findAllowedParent(e, t);
                if (i) {
                    if (i === e.parent) return {
                        position: e
                    };
                    this._modelCursor.parent.getAncestors().includes(i) && (i = null)
                }
                if (!i) return vc(e, t, n) ? {
                    position: yc(e, o)
                } : null;
                const r = this.conversionApi.writer.split(e, i),
                    s = [];
                for (const t of r.range.getWalker())
                    if ("elementEnd" == t.type) s.push(t.item);
                    else {
                        const e = s.pop(),
                            n = t.item;
                        this._registerSplitPair(e, n)
                    } const a = r.range.end.parent;
                return this._cursorParents.set(t, a), {
                    position: r.position,
                    cursorParent: a
                }
            }
            _registerSplitPair(t, e) {
                this._splitParts.has(t) || this._splitParts.set(t, [t]);
                const n = this._splitParts.get(t);
                this._splitParts.set(e, n), n.push(e)
            }
            _getSplitParts(t) {
                let e;
                return e = this._splitParts.has(t) ? this._splitParts.get(t) : [t], e
            }
            _keepEmptyElement(t) {
                this._emptyElementsToKeep.add(t)
            }
            _removeEmptyElements() {
                let t = !1;
                for (const e of this._splitParts.keys()) e.isEmpty && !this._emptyElementsToKeep.has(e) && (this.conversionApi.writer.remove(e), this._splitParts.delete(e), t = !0);
                t && this._removeEmptyElements()
            }
        }
        class fd {
            getHtml(t) {
                const e = document.implementation.createHTMLDocument("").createElement("div");
                return e.appendChild(t), e.innerHTML
            }
        }
        class bd {
            constructor(t) {
                this.skipComments = !0, this.domParser = new DOMParser, this.domConverter = new fa(t, {
                    renderingMode: "data"
                }), this.htmlWriter = new fd
            }
            toData(t) {
                const e = this.domConverter.viewToDom(t);
                return this.htmlWriter.getHtml(e)
            }
            toView(t) {
                const e = this._toDom(t);
                return this.domConverter.domToView(e, {
                    skipComments: this.skipComments
                })
            }
            registerRawContentMatcher(t) {
                this.domConverter.registerRawContentMatcher(t)
            }
            useFillerType(t) {
                this.domConverter.blockFillerMode = "marked" == t ? "markedNbsp" : "nbsp"
            }
            _toDom(t) {
                t.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) || (t = `<body>${t}</body>`);
                const e = this.domParser.parseFromString(t, "text/html"),
                    n = e.createDocumentFragment(),
                    o = e.body.childNodes;
                for (; o.length > 0;) n.appendChild(o[0]);
                return n
            }
        }
        class kd extends(S()) {
            constructor(t, e) {
                super(), this.model = t, this.mapper = new Rl, this.downcastDispatcher = new Ul({
                    mapper: this.mapper,
                    schema: t.schema
                }), this.downcastDispatcher.on("insert:$text", ((t, e, n) => {
                    if (!n.consumable.consume(e.item, t.name)) return;
                    const o = n.writer,
                        i = n.mapper.toViewPosition(e.range.start),
                        r = o.createText(e.item.data);
                    o.insert(i, r)
                }), {
                    priority: "lowest"
                }), this.downcastDispatcher.on("insert", ((t, e, n) => {
                    n.convertAttributes(e.item), e.reconversion || !e.item.is("element") || e.item.isEmpty || n.convertChildren(e.item)
                }), {
                    priority: "lowest"
                }), this.upcastDispatcher = new pd({
                    schema: t.schema
                }), this.viewDocument = new xs(e), this.stylesProcessor = e, this.htmlProcessor = new bd(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new Fs(this.viewDocument), this.upcastDispatcher.on("text", ((t, e, {
                    schema: n,
                    consumable: o,
                    writer: i
                }) => {
                    let r = e.modelCursor;
                    if (!o.test(e.viewItem)) return;
                    if (!n.checkChild(r, "$text")) {
                        if (!vc(r, "$text", n)) return;
                        if (0 == e.viewItem.data.trim().length) return;
                        const t = r.nodeBefore;
                        r = yc(r, i), t && t.is("element", "$marker") && (i.move(i.createRangeOn(t), r), r = i.createPositionAfter(t))
                    }
                    o.consume(e.viewItem);
                    const s = i.createText(e.viewItem.data);
                    i.insert(s, r), e.modelRange = i.createRange(r, r.getShiftedBy(s.offsetSize)), e.modelCursor = e.modelRange.end
                }), {
                    priority: "lowest"
                }), this.upcastDispatcher.on("element", ((t, e, n) => {
                    if (!e.modelRange && n.consumable.consume(e.viewItem, {
                            name: !0
                        })) {
                        const {
                            modelRange: t,
                            modelCursor: o
                        } = n.convertChildren(e.viewItem, e.modelCursor);
                        e.modelRange = t, e.modelCursor = o
                    }
                }), {
                    priority: "lowest"
                }), this.upcastDispatcher.on("documentFragment", ((t, e, n) => {
                    if (!e.modelRange && n.consumable.consume(e.viewItem, {
                            name: !0
                        })) {
                        const {
                            modelRange: t,
                            modelCursor: o
                        } = n.convertChildren(e.viewItem, e.modelCursor);
                        e.modelRange = t, e.modelCursor = o
                    }
                }), {
                    priority: "lowest"
                }), q().prototype.decorate.call(this, "init"), q().prototype.decorate.call(this, "set"), q().prototype.decorate.call(this, "get"), q().prototype.decorate.call(this, "toView"), q().prototype.decorate.call(this, "toModel"), this.on("init", (() => {
                    this.fire("ready")
                }), {
                    priority: "lowest"
                }), this.on("ready", (() => {
                    this.model.enqueueChange({
                        isUndoable: !1
                    }, _c)
                }), {
                    priority: "lowest"
                })
            }
            get(t = {}) {
                const {
                    rootName: e = "main",
                    trim: n = "empty"
                } = t;
                if (!this._checkIfRootsExists([e])) throw new b("datacontroller-get-non-existent-root", this);
                const o = this.model.document.getRoot(e);
                return o.isAttached() || k("datacontroller-get-detached-root", this), "empty" !== n || this.model.hasContent(o, {
                    ignoreWhitespaces: !0
                }) ? this.stringify(o, t) : ""
            }
            stringify(t, e = {}) {
                const n = this.toView(t, e);
                return this.processor.toData(n)
            }
            toView(t, e = {}) {
                const n = this.viewDocument,
                    o = this._viewWriter;
                this.mapper.clearBindings();
                const i = Pl._createIn(t),
                    r = new Os(n);
                this.mapper.bindElements(t, r);
                const s = t.is("documentFragment") ? t.markers : function(t) {
                    const e = [],
                        n = t.root.document;
                    if (!n) return new Map;
                    const o = Pl._createIn(t);
                    for (const t of n.model.markers) {
                        const n = t.getRange(),
                            i = n.isCollapsed,
                            r = n.start.isEqual(o.start) || n.end.isEqual(o.end);
                        if (i && r) e.push([t.name, n]);
                        else {
                            const i = o.getIntersection(n);
                            i && e.push([t.name, i])
                        }
                    }
                    return e.sort((([t, e], [n, o]) => {
                        if ("after" !== e.end.compareWith(o.start)) return 1;
                        if ("before" !== e.start.compareWith(o.end)) return -1;
                        switch (e.start.compareWith(o.start)) {
                            case "before":
                                return 1;
                            case "after":
                                return -1;
                            default:
                                switch (e.end.compareWith(o.end)) {
                                    case "before":
                                        return 1;
                                    case "after":
                                        return -1;
                                    default:
                                        return n.localeCompare(t)
                                }
                        }
                    })), new Map(e)
                }(t);
                return this.downcastDispatcher.convert(i, s, o, e), r
            }
            init(t) {
                if (this.model.document.version) throw new b("datacontroller-init-document-not-empty", this);
                let e = {};
                if ("string" == typeof t ? e.main = t : e = t, !this._checkIfRootsExists(Object.keys(e))) throw new b("datacontroller-init-non-existent-root", this);
                return this.model.enqueueChange({
                    isUndoable: !1
                }, (t => {
                    for (const n of Object.keys(e)) {
                        const o = this.model.document.getRoot(n);
                        t.insert(this.parse(e[n], o), o, 0)
                    }
                })), Promise.resolve()
            }
            set(t, e = {}) {
                let n = {};
                if ("string" == typeof t ? n.main = t : n = t, !this._checkIfRootsExists(Object.keys(n))) throw new b("datacontroller-set-non-existent-root", this);
                this.model.enqueueChange(e.batchType || {}, (t => {
                    t.setSelection(null), t.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
                    for (const e of Object.keys(n)) {
                        const o = this.model.document.getRoot(e);
                        t.remove(t.createRangeIn(o)), t.insert(this.parse(n[e], o), o, 0)
                    }
                }))
            }
            parse(t, e = "$root") {
                const n = this.processor.toView(t);
                return this.toModel(n, e)
            }
            toModel(t, e = "$root") {
                return this.model.change((n => this.upcastDispatcher.convert(t, n, e)))
            }
            addStyleProcessorRules(t) {
                t(this.stylesProcessor)
            }
            registerRawContentMatcher(t) {
                this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(t), this.htmlProcessor.registerRawContentMatcher(t)
            }
            destroy() {
                this.stopListening()
            }
            _checkIfRootsExists(t) {
                for (const e of t)
                    if (!this.model.document.getRoot(e)) return !1;
                return !0
            }
        }
        class wd {
            constructor(t, e) {
                this._helpers = new Map, this._downcast = Ai(t), this._createConversionHelpers({
                    name: "downcast",
                    dispatchers: this._downcast,
                    isDowncast: !0
                }), this._upcast = Ai(e), this._createConversionHelpers({
                    name: "upcast",
                    dispatchers: this._upcast,
                    isDowncast: !1
                })
            }
            addAlias(t, e) {
                const n = this._downcast.includes(e);
                if (!this._upcast.includes(e) && !n) throw new b("conversion-add-alias-dispatcher-not-registered", this);
                this._createConversionHelpers({
                    name: t,
                    dispatchers: [e],
                    isDowncast: n
                })
            }
            for (t) {
                if (!this._helpers.has(t)) throw new b("conversion-for-unknown-group", this);
                return this._helpers.get(t)
            }
            elementToElement(t) {
                this.for("downcast").elementToElement(t);
                for (const {
                        model: e,
                        view: n
                    }
                    of Ad(t)) this.for("upcast").elementToElement({
                    model: e,
                    view: n,
                    converterPriority: t.converterPriority
                })
            }
            attributeToElement(t) {
                this.for("downcast").attributeToElement(t);
                for (const {
                        model: e,
                        view: n
                    }
                    of Ad(t)) this.for("upcast").elementToAttribute({
                    view: n,
                    model: e,
                    converterPriority: t.converterPriority
                })
            }
            attributeToAttribute(t) {
                this.for("downcast").attributeToAttribute(t);
                for (const {
                        model: e,
                        view: n
                    }
                    of Ad(t)) this.for("upcast").attributeToAttribute({
                    view: n,
                    model: e
                })
            }
            _createConversionHelpers({
                name: t,
                dispatchers: e,
                isDowncast: n
            }) {
                if (this._helpers.has(t)) throw new b("conversion-group-exists", this);
                const o = n ? new cc(e) : new Pc(e);
                this._helpers.set(t, o)
            }
        }

        function* Ad(t) {
            if (t.model.values)
                for (const e of t.model.values) {
                    const n = {
                            key: t.model.key,
                            value: e
                        },
                        o = t.view[e],
                        i = t.upcastAlso ? t.upcastAlso[e] : void 0;
                    yield* Cd(n, o, i)
                } else yield* Cd(t.model, t.view, t.upcastAlso)
        }

        function* Cd(t, e, n) {
            if (yield {
                    model: t,
                    view: e
                }, n)
                for (const e of Ai(n)) yield {
                    model: t,
                    view: e
                }
        }
        class _d {
            constructor(t) {
                this.baseVersion = t, this.isDocumentOperation = null !== this.baseVersion, this.batch = null
            }
            _validate() {}
            toJSON() {
                const t = Object.assign({}, this);
                return t.__className = this.constructor.className, delete t.batch, delete t.isDocumentOperation, t
            }
            static get className() {
                return "Operation"
            }
            static fromJSON(t, e) {
                return new this(t.baseVersion)
            }
        }

        function vd(t, e) {
            const n = Ed(e),
                o = n.reduce(((t, e) => t + e.offsetSize), 0),
                i = t.parent;
            Sd(t);
            const r = t.index;
            return i._insertChild(r, n), Dd(i, r + n.length), Dd(i, r), new Pl(t, t.getShiftedBy(o))
        }

        function yd(t) {
            if (!t.isFlat) throw new b("operation-utils-remove-range-not-flat", this);
            const e = t.start.parent;
            Sd(t.start), Sd(t.end);
            const n = e._removeChildren(t.start.index, t.end.index - t.start.index);
            return Dd(e, t.start.index), n
        }

        function xd(t, e) {
            if (!t.isFlat) throw new b("operation-utils-move-range-not-flat", this);
            const n = yd(t);
            return vd(e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset), n)
        }

        function Ed(t) {
            const e = [];
            ! function t(n) {
                if ("string" == typeof n) e.push(new Cl(n));
                else if (n instanceof _l) e.push(new Cl(n.data, n.getAttributes()));
                else if (n instanceof wl) e.push(n);
                else if (Q(n))
                    for (const e of n) t(e)
            }(t);
            for (let t = 1; t < e.length; t++) {
                const n = e[t],
                    o = e[t - 1];
                n instanceof Cl && o instanceof Cl && Td(n, o) && (e.splice(t - 1, 2, new Cl(o.data + n.data, o.getAttributes())), t--)
            }
            return e
        }

        function Dd(t, e) {
            const n = t.getChild(e - 1),
                o = t.getChild(e);
            if (n && o && n.is("$text") && o.is("$text") && Td(n, o)) {
                const i = new Cl(n.data + o.data, n.getAttributes());
                t._removeChildren(e - 1, 2), t._insertChild(e - 1, i)
            }
        }

        function Sd(t) {
            const e = t.textNode,
                n = t.parent;
            if (e) {
                const o = t.offset - e.startOffset,
                    i = e.index;
                n._removeChildren(i, 1);
                const r = new Cl(e.data.substr(0, o), e.getAttributes()),
                    s = new Cl(e.data.substr(o), e.getAttributes());
                n._insertChild(i, [r, s])
            }
        }

        function Td(t, e) {
            const n = t.getAttributes(),
                o = e.getAttributes();
            for (const t of n) {
                if (t[1] !== e.getAttribute(t[0])) return !1;
                o.next()
            }
            return o.next().done
        }
        class Bd extends _d {
            constructor(t, e, n, o) {
                super(o), this.sourcePosition = t.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = e, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNone"
            }
            get type() {
                return "$graveyard" == this.targetPosition.root.rootName ? "remove" : "$graveyard" == this.sourcePosition.root.rootName ? "reinsert" : "move"
            }
            get affectedSelectable() {
                return [Pl._createFromPositionAndShift(this.sourcePosition, this.howMany), Pl._createFromPositionAndShift(this.targetPosition, 0)]
            }
            clone() {
                return new Bd(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion)
            }
            getMovedRangeStart() {
                return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany)
            }
            getReversed() {
                const t = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
                return new Bd(this.getMovedRangeStart(), this.howMany, t, this.baseVersion + 1)
            }
            _validate() {
                const t = this.sourcePosition.parent,
                    e = this.targetPosition.parent,
                    n = this.sourcePosition.offset,
                    o = this.targetPosition.offset;
                if (n + this.howMany > t.maxOffset) throw new b("move-operation-nodes-do-not-exist", this);
                if (t === e && n < o && o < n + this.howMany) throw new b("move-operation-range-into-itself", this);
                if (this.sourcePosition.root == this.targetPosition.root && "prefix" == Y(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath())) {
                    const t = this.sourcePosition.path.length - 1;
                    if (this.targetPosition.path[t] >= n && this.targetPosition.path[t] < n + this.howMany) throw new b("move-operation-node-into-itself", this)
                }
            }
            _execute() {
                xd(Pl._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition)
            }
            toJSON() {
                const t = super.toJSON();
                return t.sourcePosition = this.sourcePosition.toJSON(), t.targetPosition = this.targetPosition.toJSON(), t
            }
            static get className() {
                return "MoveOperation"
            }
            static fromJSON(t, e) {
                const n = El.fromJSON(t.sourcePosition, e),
                    o = El.fromJSON(t.targetPosition, e);
                return new this(n, t.howMany, o, t.baseVersion)
            }
        }
        class Id extends _d {
            constructor(t, e, n) {
                super(n), this.position = t.clone(), this.position.stickiness = "toNone", this.nodes = new Al(Ed(e)), this.shouldReceiveAttributes = !1
            }
            get type() {
                return "insert"
            }
            get howMany() {
                return this.nodes.maxOffset
            }
            get affectedSelectable() {
                return this.position.clone()
            }
            clone() {
                const t = new Al([...this.nodes].map((t => t._clone(!0)))),
                    e = new Id(this.position, t, this.baseVersion);
                return e.shouldReceiveAttributes = this.shouldReceiveAttributes, e
            }
            getReversed() {
                const t = this.position.root.document.graveyard,
                    e = new El(t, [0]);
                return new Bd(this.position, this.nodes.maxOffset, e, this.baseVersion + 1)
            }
            _validate() {
                const t = this.position.parent;
                if (!t || t.maxOffset < this.position.offset) throw new b("insert-operation-position-invalid", this)
            }
            _execute() {
                const t = this.nodes;
                this.nodes = new Al([...t].map((t => t._clone(!0)))), vd(this.position, t)
            }
            toJSON() {
                const t = super.toJSON();
                return t.position = this.position.toJSON(), t.nodes = this.nodes.toJSON(), t
            }
            static get className() {
                return "InsertOperation"
            }
            static fromJSON(t, e) {
                const n = [];
                for (const e of t.nodes) e.name ? n.push(vl.fromJSON(e)) : n.push(Cl.fromJSON(e));
                const o = new Id(El.fromJSON(t.position, e), n, t.baseVersion);
                return o.shouldReceiveAttributes = t.shouldReceiveAttributes, o
            }
        }
        class Pd extends _d {
            constructor(t, e, n, o, i) {
                super(i), this.splitPosition = t.clone(), this.splitPosition.stickiness = "toNext", this.howMany = e, this.insertionPosition = n, this.graveyardPosition = o ? o.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext")
            }
            get type() {
                return "split"
            }
            get moveTargetPosition() {
                const t = this.insertionPosition.path.slice();
                return t.push(0), new El(this.insertionPosition.root, t)
            }
            get movedRange() {
                const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
                return new Pl(this.splitPosition, t)
            }
            get affectedSelectable() {
                const t = [Pl._createFromPositionAndShift(this.splitPosition, 0), Pl._createFromPositionAndShift(this.insertionPosition, 0)];
                return this.graveyardPosition && t.push(Pl._createFromPositionAndShift(this.graveyardPosition, 0)), t
            }
            clone() {
                return new Pd(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion)
            }
            getReversed() {
                const t = this.splitPosition.root.document.graveyard,
                    e = new El(t, [0]);
                return new Rd(this.moveTargetPosition, this.howMany, this.splitPosition, e, this.baseVersion + 1)
            }
            _validate() {
                const t = this.splitPosition.parent,
                    e = this.splitPosition.offset;
                if (!t || t.maxOffset < e) throw new b("split-operation-position-invalid", this);
                if (!t.parent) throw new b("split-operation-split-in-root", this);
                if (this.howMany != t.maxOffset - this.splitPosition.offset) throw new b("split-operation-how-many-invalid", this);
                if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) throw new b("split-operation-graveyard-position-invalid", this)
            }
            _execute() {
                const t = this.splitPosition.parent;
                if (this.graveyardPosition) xd(Pl._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
                else {
                    const e = t._clone();
                    vd(this.insertionPosition, e)
                }
                xd(new Pl(El._createAt(t, this.splitPosition.offset), El._createAt(t, t.maxOffset)), this.moveTargetPosition)
            }
            toJSON() {
                const t = super.toJSON();
                return t.splitPosition = this.splitPosition.toJSON(), t.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (t.graveyardPosition = this.graveyardPosition.toJSON()), t
            }
            static get className() {
                return "SplitOperation"
            }
            static getInsertionPosition(t) {
                const e = t.path.slice(0, -1);
                return e[e.length - 1]++, new El(t.root, e, "toPrevious")
            }
            static fromJSON(t, e) {
                const n = El.fromJSON(t.splitPosition, e),
                    o = El.fromJSON(t.insertionPosition, e),
                    i = t.graveyardPosition ? El.fromJSON(t.graveyardPosition, e) : null;
                return new this(n, t.howMany, o, i, t.baseVersion)
            }
        }
        class Rd extends _d {
            constructor(t, e, n, o, i) {
                super(i), this.sourcePosition = t.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = e, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = o.clone()
            }
            get type() {
                return "merge"
            }
            get deletionPosition() {
                return new El(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1))
            }
            get movedRange() {
                const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
                return new Pl(this.sourcePosition, t)
            }
            get affectedSelectable() {
                const t = this.sourcePosition.parent;
                return [Pl._createOn(t), Pl._createFromPositionAndShift(this.targetPosition, 0), Pl._createFromPositionAndShift(this.graveyardPosition, 0)]
            }
            clone() {
                return new Rd(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion)
            }
            getReversed() {
                const t = this.targetPosition._getTransformedByMergeOperation(this),
                    e = this.sourcePosition.path.slice(0, -1),
                    n = new El(this.sourcePosition.root, e)._getTransformedByMergeOperation(this);
                return new Pd(t, this.howMany, n, this.graveyardPosition, this.baseVersion + 1)
            }
            _validate() {
                const t = this.sourcePosition.parent,
                    e = this.targetPosition.parent;
                if (!t.parent) throw new b("merge-operation-source-position-invalid", this);
                if (!e.parent) throw new b("merge-operation-target-position-invalid", this);
                if (this.howMany != t.maxOffset) throw new b("merge-operation-how-many-invalid", this)
            }
            _execute() {
                const t = this.sourcePosition.parent;
                xd(Pl._createIn(t), this.targetPosition), xd(Pl._createOn(t), this.graveyardPosition)
            }
            toJSON() {
                const t = super.toJSON();
                return t.sourcePosition = t.sourcePosition.toJSON(), t.targetPosition = t.targetPosition.toJSON(), t.graveyardPosition = t.graveyardPosition.toJSON(), t
            }
            static get className() {
                return "MergeOperation"
            }
            static fromJSON(t, e) {
                const n = El.fromJSON(t.sourcePosition, e),
                    o = El.fromJSON(t.targetPosition, e),
                    i = El.fromJSON(t.graveyardPosition, e);
                return new this(n, t.howMany, o, i, t.baseVersion)
            }
        }
        class zd extends _d {
            constructor(t, e, n, o, i, r) {
                super(r), this.name = t, this.oldRange = e ? e.clone() : null, this.newRange = n ? n.clone() : null, this.affectsData = i, this._markers = o
            }
            get type() {
                return "marker"
            }
            get affectedSelectable() {
                const t = [];
                return this.oldRange && t.push(this.oldRange.clone()), this.newRange && (this.oldRange ? t.push(...this.newRange.getDifference(this.oldRange)) : t.push(this.newRange.clone())), t
            }
            clone() {
                return new zd(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion)
            }
            getReversed() {
                return new zd(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1)
            }
            _execute() {
                this.newRange ? this._markers._set(this.name, this.newRange, !0, this.affectsData) : this._markers._remove(this.name)
            }
            toJSON() {
                const t = super.toJSON();
                return this.oldRange && (t.oldRange = this.oldRange.toJSON()), this.newRange && (t.newRange = this.newRange.toJSON()), delete t._markers, t
            }
            static get className() {
                return "MarkerOperation"
            }
            static fromJSON(t, e) {
                return new zd(t.name, t.oldRange ? Pl.fromJSON(t.oldRange, e) : null, t.newRange ? Pl.fromJSON(t.newRange, e) : null, e.model.markers, t.affectsData, t.baseVersion)
            }
        }
        const Vd = function(t, e) {
            return il(t, e)
        };
        class Od extends _d {
            constructor(t, e, n, o, i) {
                super(i), this.range = t.clone(), this.key = e, this.oldValue = void 0 === n ? null : n, this.newValue = void 0 === o ? null : o
            }
            get type() {
                return null === this.oldValue ? "addAttribute" : null === this.newValue ? "removeAttribute" : "changeAttribute"
            }
            get affectedSelectable() {
                return this.range.clone()
            }
            clone() {
                return new Od(this.range, this.key, this.oldValue, this.newValue, this.baseVersion)
            }
            getReversed() {
                return new Od(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
            }
            toJSON() {
                const t = super.toJSON();
                return t.range = this.range.toJSON(), t
            }
            _validate() {
                if (!this.range.isFlat) throw new b("attribute-operation-range-not-flat", this);
                for (const t of this.range.getItems({
                        shallow: !0
                    })) {
                    if (null !== this.oldValue && !Vd(t.getAttribute(this.key), this.oldValue)) throw new b("attribute-operation-wrong-old-value", this, {
                        item: t,
                        key: this.key,
                        value: this.oldValue
                    });
                    if (null === this.oldValue && null !== this.newValue && t.hasAttribute(this.key)) throw new b("attribute-operation-attribute-exists", this, {
                        node: t,
                        key: this.key
                    })
                }
            }
            _execute() {
                Vd(this.oldValue, this.newValue) || function(t, e, n) {
                    Sd(t.start), Sd(t.end);
                    for (const o of t.getItems({
                            shallow: !0
                        })) {
                        const t = o.is("$textProxy") ? o.textNode : o;
                        null !== n ? t._setAttribute(e, n) : t._removeAttribute(e), Dd(t.parent, t.index)
                    }
                    Dd(t.end.parent, t.end.index)
                }(this.range, this.key, this.newValue)
            }
            static get className() {
                return "AttributeOperation"
            }
            static fromJSON(t, e) {
                return new Od(Pl.fromJSON(t.range, e), t.key, t.oldValue, t.newValue, t.baseVersion)
            }
        }
        class Fd extends _d {
            get type() {
                return "noop"
            }
            get affectedSelectable() {
                return null
            }
            clone() {
                return new Fd(this.baseVersion)
            }
            getReversed() {
                return new Fd(this.baseVersion + 1)
            }
            _execute() {}
            static get className() {
                return "NoOperation"
            }
        }
        class Md extends _d {
            constructor(t, e, n, o) {
                super(o), this.position = t, this.position.stickiness = "toNext", this.oldName = e, this.newName = n
            }
            get type() {
                return "rename"
            }
            get affectedSelectable() {
                return this.position.nodeAfter
            }
            clone() {
                return new Md(this.position.clone(), this.oldName, this.newName, this.baseVersion)
            }
            getReversed() {
                return new Md(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1)
            }
            _validate() {
                const t = this.position.nodeAfter;
                if (!(t instanceof vl)) throw new b("rename-operation-wrong-position", this);
                if (t.name !== this.oldName) throw new b("rename-operation-wrong-name", this)
            }
            _execute() {
                this.position.nodeAfter.name = this.newName
            }
            toJSON() {
                const t = super.toJSON();
                return t.position = this.position.toJSON(), t
            }
            static get className() {
                return "RenameOperation"
            }
            static fromJSON(t, e) {
                return new Md(El.fromJSON(t.position, e), t.oldName, t.newName, t.baseVersion)
            }
        }
        class Nd extends _d {
            constructor(t, e, n, o, i) {
                super(i), this.root = t, this.key = e, this.oldValue = void 0 === n ? null : n, this.newValue = void 0 === o ? null : o
            }
            get type() {
                return null === this.oldValue ? "addRootAttribute" : null === this.newValue ? "removeRootAttribute" : "changeRootAttribute"
            }
            get affectedSelectable() {
                return this.root
            }
            clone() {
                return new Nd(this.root, this.key, this.oldValue, this.newValue, this.baseVersion)
            }
            getReversed() {
                return new Nd(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
            }
            _validate() {
                if (this.root != this.root.root || this.root.is("documentFragment")) throw new b("rootattribute-operation-not-a-root", this, {
                    root: this.root,
                    key: this.key
                });
                if (null !== this.oldValue && this.root.getAttribute(this.key) !== this.oldValue) throw new b("rootattribute-operation-wrong-old-value", this, {
                    root: this.root,
                    key: this.key
                });
                if (null === this.oldValue && null !== this.newValue && this.root.hasAttribute(this.key)) throw new b("rootattribute-operation-attribute-exists", this, {
                    root: this.root,
                    key: this.key
                })
            }
            _execute() {
                null !== this.newValue ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key)
            }
            toJSON() {
                const t = super.toJSON();
                return t.root = this.root.toJSON(), t
            }
            static get className() {
                return "RootAttributeOperation"
            }
            static fromJSON(t, e) {
                if (!e.getRoot(t.root)) throw new b("rootattribute-operation-fromjson-no-root", this, {
                    rootName: t.root
                });
                return new Nd(e.getRoot(t.root), t.key, t.oldValue, t.newValue, t.baseVersion)
            }
        }
        class Ld extends _d {
            constructor(t, e, n, o, i) {
                if (super(i), this.rootName = t, this.elementName = e, this.isAdd = n, this._document = o, !this._document.getRoot(this.rootName)) {
                    this._document.createRoot(this.elementName, this.rootName)._isAttached = !1
                }
            }
            get type() {
                return this.isAdd ? "addRoot" : "detachRoot"
            }
            get affectedSelectable() {
                return this._document.getRoot(this.rootName)
            }
            clone() {
                return new Ld(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion)
            }
            getReversed() {
                return new Ld(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1)
            }
            _validate() {
                const t = this._document.getRoot(this.rootName);
                if (t.isAttached() && this.isAdd) throw new b("root-operation-root-attached", this);
                if (!t.isAttached() && !this.isAdd) throw new b("root-operation-root-detached", this)
            }
            _execute() {
                this._document.getRoot(this.rootName)._isAttached = this.isAdd
            }
            toJSON() {
                const t = super.toJSON();
                return delete t._document, t
            }
            static get className() {
                return "RootOperation"
            }
            static fromJSON(t, e) {
                return new Ld(t.rootName, t.elementName, t.isAdd, e, t.baseVersion)
            }
        }
        const Hd = {};
        Hd[Od.className] = Od, Hd[Id.className] = Id, Hd[zd.className] = zd, Hd[Bd.className] = Bd, Hd[Fd.className] = Fd, Hd[_d.className] = _d, Hd[Md.className] = Md, Hd[Nd.className] = Nd, Hd[Ld.className] = Ld, Hd[Pd.className] = Pd, Hd[Rd.className] = Rd;
        class jd {
            static fromJSON(t, e) {
                return Hd[t.__className].fromJSON(t, e)
            }
        }
        const qd = new Map;

        function Wd(t, e, n) {
            let o = qd.get(t);
            o || (o = new Map, qd.set(t, o)), o.set(e, n)
        }

        function Ud(t) {
            return [t]
        }

        function $d(t, e, n = {}) {
            const o = function(t, e) {
                const n = qd.get(t);
                return n && n.has(e) ? n.get(e) : Ud
            }(t.constructor, e.constructor);
            try {
                return o(t = t.clone(), e, n)
            } catch (t) {
                throw t
            }
        }

        function Gd(t, e, n) {
            t = t.slice(), e = e.slice();
            const o = new Kd(n.document, n.useRelations, n.forceWeakRemove);
            o.setOriginalOperations(t), o.setOriginalOperations(e);
            const i = o.originalOperations;
            if (0 == t.length || 0 == e.length) return {
                operationsA: t,
                operationsB: e,
                originalOperations: i
            };
            const r = new WeakMap;
            for (const e of t) r.set(e, 0);
            const s = {
                nextBaseVersionA: t[t.length - 1].baseVersion + 1,
                nextBaseVersionB: e[e.length - 1].baseVersion + 1,
                originalOperationsACount: t.length,
                originalOperationsBCount: e.length
            };
            let a = 0;
            for (; a < t.length;) {
                const n = t[a],
                    i = r.get(n);
                if (i == e.length) {
                    a++;
                    continue
                }
                const s = e[i],
                    l = $d(n, s, o.getContext(n, s, !0)),
                    c = $d(s, n, o.getContext(s, n, !1));
                o.updateRelation(n, s), o.setOriginalOperations(l, n), o.setOriginalOperations(c, s);
                for (const t of l) r.set(t, i + c.length);
                t.splice(a, 1, ...l), e.splice(i, 1, ...c)
            }
            if (n.padWithNoOps) {
                const n = t.length - s.originalOperationsACount,
                    o = e.length - s.originalOperationsBCount;
                Jd(t, o - n), Jd(e, n - o)
            }
            return Zd(t, s.nextBaseVersionB), Zd(e, s.nextBaseVersionA), {
                operationsA: t,
                operationsB: e,
                originalOperations: i
            }
        }
        class Kd {
            constructor(t, e, n = !1) {
                this.originalOperations = new Map, this._history = t.history, this._useRelations = e, this._forceWeakRemove = !!n, this._relations = new Map
            }
            setOriginalOperations(t, e = null) {
                const n = e ? this.originalOperations.get(e) : null;
                for (const e of t) this.originalOperations.set(e, n || e)
            }
            updateRelation(t, e) {
                if (t instanceof Bd) e instanceof Rd ? t.targetPosition.isEqual(e.sourcePosition) || e.movedRange.containsPosition(t.targetPosition) ? this._setRelation(t, e, "insertAtSource") : t.targetPosition.isEqual(e.deletionPosition) ? this._setRelation(t, e, "insertBetween") : t.targetPosition.isAfter(e.sourcePosition) && this._setRelation(t, e, "moveTargetAfter") : e instanceof Bd && (t.targetPosition.isEqual(e.sourcePosition) || t.targetPosition.isBefore(e.sourcePosition) ? this._setRelation(t, e, "insertBefore") : this._setRelation(t, e, "insertAfter"));
                else if (t instanceof Pd) {
                    if (e instanceof Rd) t.splitPosition.isBefore(e.sourcePosition) && this._setRelation(t, e, "splitBefore");
                    else if (e instanceof Bd)
                        if (t.splitPosition.isEqual(e.sourcePosition) || t.splitPosition.isBefore(e.sourcePosition)) this._setRelation(t, e, "splitBefore");
                        else {
                            const n = Pl._createFromPositionAndShift(e.sourcePosition, e.howMany);
                            if (t.splitPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(t.splitPosition)) {
                                const o = n.end.offset - t.splitPosition.offset,
                                    i = t.splitPosition.offset - n.start.offset;
                                this._setRelation(t, e, {
                                    howMany: o,
                                    offset: i
                                })
                            }
                        }
                } else if (t instanceof Rd) e instanceof Rd ? (t.targetPosition.isEqual(e.sourcePosition) || this._setRelation(t, e, "mergeTargetNotMoved"), t.sourcePosition.isEqual(e.targetPosition) && this._setRelation(t, e, "mergeSourceNotMoved"), t.sourcePosition.isEqual(e.sourcePosition) && this._setRelation(t, e, "mergeSameElement")) : e instanceof Pd && t.sourcePosition.isEqual(e.splitPosition) && this._setRelation(t, e, "splitAtSource");
                else if (t instanceof zd) {
                    const n = t.newRange;
                    if (!n) return;
                    if (e instanceof Bd) {
                        const o = Pl._createFromPositionAndShift(e.sourcePosition, e.howMany),
                            i = o.containsPosition(n.start) || o.start.isEqual(n.start),
                            r = o.containsPosition(n.end) || o.end.isEqual(n.end);
                        !i && !r || o.containsRange(n) || this._setRelation(t, e, {
                            side: i ? "left" : "right",
                            path: i ? n.start.path.slice() : n.end.path.slice()
                        })
                    } else if (e instanceof Rd) {
                        const o = n.start.isEqual(e.targetPosition),
                            i = n.start.isEqual(e.deletionPosition),
                            r = n.end.isEqual(e.deletionPosition),
                            s = n.end.isEqual(e.sourcePosition);
                        (o || i || r || s) && this._setRelation(t, e, {
                            wasInLeftElement: o,
                            wasStartBeforeMergedElement: i,
                            wasEndBeforeMergedElement: r,
                            wasInRightElement: s
                        })
                    }
                }
            }
            getContext(t, e, n) {
                return {
                    aIsStrong: n,
                    aWasUndone: this._wasUndone(t),
                    bWasUndone: this._wasUndone(e),
                    abRelation: this._useRelations ? this._getRelation(t, e) : null,
                    baRelation: this._useRelations ? this._getRelation(e, t) : null,
                    forceWeakRemove: this._forceWeakRemove
                }
            }
            _wasUndone(t) {
                const e = this.originalOperations.get(t);
                return e.wasUndone || this._history.isUndoneOperation(e)
            }
            _getRelation(t, e) {
                const n = this.originalOperations.get(e),
                    o = this._history.getUndoneOperation(n);
                if (!o) return null;
                const i = this.originalOperations.get(t),
                    r = this._relations.get(i);
                return r && r.get(o) || null
            }
            _setRelation(t, e, n) {
                const o = this.originalOperations.get(t),
                    i = this.originalOperations.get(e);
                let r = this._relations.get(o);
                r || (r = new Map, this._relations.set(o, r)), r.set(i, n)
            }
        }

        function Zd(t, e) {
            for (const n of t) n.baseVersion = e++
        }

        function Jd(t, e) {
            for (let n = 0; n < e; n++) t.push(new Fd(0))
        }

        function Yd(t, e, n) {
            const o = t.nodes.getNode(0).getAttribute(e);
            if (o == n) return null;
            const i = new Pl(t.position, t.position.getShiftedBy(t.howMany));
            return new Od(i, e, o, n, 0)
        }

        function Qd(t, e) {
            return null === t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)
        }

        function Xd(t, e) {
            const n = [];
            for (let o = 0; o < t.length; o++) {
                const i = t[o],
                    r = new Bd(i.start, i.end.offset - i.start.offset, e, 0);
                n.push(r);
                for (let e = o + 1; e < t.length; e++) t[e] = t[e]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0];
                e = e._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)
            }
            return n
        }
        Wd(Od, Od, ((t, e, n) => {
            if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
                const o = t.range.getDifference(e.range).map((e => new Od(e, t.key, t.oldValue, t.newValue, 0))),
                    i = t.range.getIntersection(e.range);
                return i && n.aIsStrong && o.push(new Od(i, e.key, e.newValue, t.newValue, 0)), 0 == o.length ? [new Fd(0)] : o
            }
            return [t]
        })), Wd(Od, Id, ((t, e) => {
            if (t.range.start.hasSameParentAs(e.position) && t.range.containsPosition(e.position)) {
                const n = t.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes).map((e => new Od(e, t.key, t.oldValue, t.newValue, t.baseVersion)));
                if (e.shouldReceiveAttributes) {
                    const o = Yd(e, t.key, t.oldValue);
                    o && n.unshift(o)
                }
                return n
            }
            return t.range = t.range._getTransformedByInsertion(e.position, e.howMany, !1)[0], [t]
        })), Wd(Od, Rd, ((t, e) => {
            const n = [];
            t.range.start.hasSameParentAs(e.deletionPosition) && (t.range.containsPosition(e.deletionPosition) || t.range.start.isEqual(e.deletionPosition)) && n.push(Pl._createFromPositionAndShift(e.graveyardPosition, 1));
            const o = t.range._getTransformedByMergeOperation(e);
            return o.isCollapsed || n.push(o), n.map((e => new Od(e, t.key, t.oldValue, t.newValue, t.baseVersion)))
        })), Wd(Od, Bd, ((t, e) => {
            const n = function(t, e) {
                const n = Pl._createFromPositionAndShift(e.sourcePosition, e.howMany);
                let o = null,
                    i = [];
                n.containsRange(t, !0) ? o = t : t.start.hasSameParentAs(n.start) ? (i = t.getDifference(n), o = t.getIntersection(n)) : i = [t];
                const r = [];
                for (let t of i) {
                    t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
                    const n = e.getMovedRangeStart(),
                        o = t.start.hasSameParentAs(n),
                        i = t._getTransformedByInsertion(n, e.howMany, o);
                    r.push(...i)
                }
                o && r.push(o._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, !1)[0]);
                return r
            }(t.range, e);
            return n.map((e => new Od(e, t.key, t.oldValue, t.newValue, t.baseVersion)))
        })), Wd(Od, Pd, ((t, e) => {
            if (t.range.end.isEqual(e.insertionPosition)) return e.graveyardPosition || t.range.end.offset++, [t];
            if (t.range.start.hasSameParentAs(e.splitPosition) && t.range.containsPosition(e.splitPosition)) {
                const n = t.clone();
                return n.range = new Pl(e.moveTargetPosition.clone(), t.range.end._getCombined(e.splitPosition, e.moveTargetPosition)), t.range.end = e.splitPosition.clone(), t.range.end.stickiness = "toPrevious", [t, n]
            }
            return t.range = t.range._getTransformedBySplitOperation(e), [t]
        })), Wd(Id, Od, ((t, e) => {
            const n = [t];
            if (t.shouldReceiveAttributes && t.position.hasSameParentAs(e.range.start) && e.range.containsPosition(t.position)) {
                const o = Yd(t, e.key, e.newValue);
                o && n.push(o)
            }
            return n
        })), Wd(Id, Id, ((t, e, n) => (t.position.isEqual(e.position) && n.aIsStrong || (t.position = t.position._getTransformedByInsertOperation(e)), [t]))), Wd(Id, Bd, ((t, e) => (t.position = t.position._getTransformedByMoveOperation(e), [t]))), Wd(Id, Pd, ((t, e) => (t.position = t.position._getTransformedBySplitOperation(e), [t]))), Wd(Id, Rd, ((t, e) => (t.position = t.position._getTransformedByMergeOperation(e), [t]))), Wd(zd, Id, ((t, e) => (t.oldRange && (t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0]), t.newRange && (t.newRange = t.newRange._getTransformedByInsertOperation(e)[0]), [t]))), Wd(zd, zd, ((t, e, n) => {
            if (t.name == e.name) {
                if (!n.aIsStrong) return [new Fd(0)];
                t.oldRange = e.newRange ? e.newRange.clone() : null
            }
            return [t]
        })), Wd(zd, Rd, ((t, e) => (t.oldRange && (t.oldRange = t.oldRange._getTransformedByMergeOperation(e)), t.newRange && (t.newRange = t.newRange._getTransformedByMergeOperation(e)), [t]))), Wd(zd, Bd, ((t, e, n) => {
            if (t.oldRange && (t.oldRange = Pl._createFromRanges(t.oldRange._getTransformedByMoveOperation(e))), t.newRange) {
                if (n.abRelation) {
                    const o = Pl._createFromRanges(t.newRange._getTransformedByMoveOperation(e));
                    if ("left" == n.abRelation.side && e.targetPosition.isEqual(t.newRange.start)) return t.newRange.end = o.end, t.newRange.start.path = n.abRelation.path, [t];
                    if ("right" == n.abRelation.side && e.targetPosition.isEqual(t.newRange.end)) return t.newRange.start = o.start, t.newRange.end.path = n.abRelation.path, [t]
                }
                t.newRange = Pl._createFromRanges(t.newRange._getTransformedByMoveOperation(e))
            }
            return [t]
        })), Wd(zd, Pd, ((t, e, n) => {
            if (t.oldRange && (t.oldRange = t.oldRange._getTransformedBySplitOperation(e)), t.newRange) {
                if (n.abRelation) {
                    const o = t.newRange._getTransformedBySplitOperation(e);
                    return t.newRange.start.isEqual(e.splitPosition) && n.abRelation.wasStartBeforeMergedElement ? t.newRange.start = El._createAt(e.insertionPosition) : t.newRange.start.isEqual(e.splitPosition) && !n.abRelation.wasInLeftElement && (t.newRange.start = El._createAt(e.moveTargetPosition)), t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasInRightElement ? t.newRange.end = El._createAt(e.moveTargetPosition) : t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasEndBeforeMergedElement ? t.newRange.end = El._createAt(e.insertionPosition) : t.newRange.end = o.end, [t]
                }
                t.newRange = t.newRange._getTransformedBySplitOperation(e)
            }
            return [t]
        })), Wd(Rd, Id, ((t, e) => (t.sourcePosition.hasSameParentAs(e.position) && (t.howMany += e.howMany), t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e), t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e), [t]))), Wd(Rd, Rd, ((t, e, n) => {
            if (t.sourcePosition.isEqual(e.sourcePosition) && t.targetPosition.isEqual(e.targetPosition)) {
                if (n.bWasUndone) {
                    const n = e.graveyardPosition.path.slice();
                    return n.push(0), t.sourcePosition = new El(e.graveyardPosition.root, n), t.howMany = 0, [t]
                }
                return [new Fd(0)]
            }
            if (t.sourcePosition.isEqual(e.sourcePosition) && !t.targetPosition.isEqual(e.targetPosition) && !n.bWasUndone && "splitAtSource" != n.abRelation) {
                const o = "$graveyard" == t.targetPosition.root.rootName,
                    i = "$graveyard" == e.targetPosition.root.rootName;
                if (i && !o || !(o && !i) && n.aIsStrong) {
                    const n = e.targetPosition._getTransformedByMergeOperation(e),
                        o = t.targetPosition._getTransformedByMergeOperation(e);
                    return [new Bd(n, t.howMany, o, 0)]
                }
                return [new Fd(0)]
            }
            return t.sourcePosition.hasSameParentAs(e.targetPosition) && (t.howMany += e.howMany), t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e), t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e), t.graveyardPosition.isEqual(e.graveyardPosition) && n.aIsStrong || (t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)), [t]
        })), Wd(Rd, Bd, ((t, e, n) => {
            const o = Pl._createFromPositionAndShift(e.sourcePosition, e.howMany);
            return "remove" == e.type && !n.bWasUndone && !n.forceWeakRemove && t.deletionPosition.hasSameParentAs(e.sourcePosition) && o.containsPosition(t.sourcePosition) ? [new Fd(0)] : (t.sourcePosition.hasSameParentAs(e.targetPosition) && (t.howMany += e.howMany), t.sourcePosition.hasSameParentAs(e.sourcePosition) && (t.howMany -= e.howMany), t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e), t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e), t.graveyardPosition.isEqual(e.targetPosition) || (t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)), [t])
        })), Wd(Rd, Pd, ((t, e, n) => {
            if (e.graveyardPosition && (t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1), t.deletionPosition.isEqual(e.graveyardPosition) && (t.howMany = e.howMany)), t.targetPosition.isEqual(e.splitPosition)) {
                const o = 0 != e.howMany,
                    i = e.graveyardPosition && t.deletionPosition.isEqual(e.graveyardPosition);
                if (o || i || "mergeTargetNotMoved" == n.abRelation) return t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e), [t]
            }
            if (t.sourcePosition.isEqual(e.splitPosition)) {
                if ("mergeSourceNotMoved" == n.abRelation) return t.howMany = 0, t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e), [t];
                if ("mergeSameElement" == n.abRelation || t.sourcePosition.offset > 0) return t.sourcePosition = e.moveTargetPosition.clone(), t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e), [t]
            }
            return t.sourcePosition.hasSameParentAs(e.splitPosition) && (t.howMany = e.splitPosition.offset), t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e), t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e), [t]
        })), Wd(Bd, Id, ((t, e) => {
            const n = Pl._createFromPositionAndShift(t.sourcePosition, t.howMany)._getTransformedByInsertOperation(e, !1)[0];
            return t.sourcePosition = n.start, t.howMany = n.end.offset - n.start.offset, t.targetPosition.isEqual(e.position) || (t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e)), [t]
        })), Wd(Bd, Bd, ((t, e, n) => {
            const o = Pl._createFromPositionAndShift(t.sourcePosition, t.howMany),
                i = Pl._createFromPositionAndShift(e.sourcePosition, e.howMany);
            let r, s = n.aIsStrong,
                a = !n.aIsStrong;
            if ("insertBefore" == n.abRelation || "insertAfter" == n.baRelation ? a = !0 : "insertAfter" != n.abRelation && "insertBefore" != n.baRelation || (a = !1), r = t.targetPosition.isEqual(e.targetPosition) && a ? t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) : t.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), Qd(t, e) && Qd(e, t)) return [e.getReversed()];
            if (o.containsPosition(e.targetPosition) && o.containsRange(i, !0)) return o.start = o.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), o.end = o.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), Xd([o], r);
            if (i.containsPosition(t.targetPosition) && i.containsRange(o, !0)) return o.start = o.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), o.end = o.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), Xd([o], r);
            const l = Y(t.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
            if ("prefix" == l || "extension" == l) return o.start = o.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), o.end = o.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), Xd([o], r);
            "remove" != t.type || "remove" == e.type || n.aWasUndone || n.forceWeakRemove ? "remove" == t.type || "remove" != e.type || n.bWasUndone || n.forceWeakRemove || (s = !1) : s = !0;
            const c = [],
                d = o.getDifference(i);
            for (const t of d) {
                t.start = t.start._getTransformedByDeletion(e.sourcePosition, e.howMany), t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
                const n = "same" == Y(t.start.getParentPath(), e.getMovedRangeStart().getParentPath()),
                    o = t._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, n);
                c.push(...o)
            }
            const h = o.getIntersection(i);
            return null !== h && s && (h.start = h.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), h.end = h.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), 0 === c.length ? c.push(h) : 1 == c.length ? i.start.isBefore(o.start) || i.start.isEqual(o.start) ? c.unshift(h) : c.push(h) : c.splice(1, 0, h)), 0 === c.length ? [new Fd(t.baseVersion)] : Xd(c, r)
        })), Wd(Bd, Pd, ((t, e, n) => {
            let o = t.targetPosition.clone();
            t.targetPosition.isEqual(e.insertionPosition) && e.graveyardPosition && "moveTargetAfter" != n.abRelation || (o = t.targetPosition._getTransformedBySplitOperation(e));
            const i = Pl._createFromPositionAndShift(t.sourcePosition, t.howMany);
            if (i.end.isEqual(e.insertionPosition)) return e.graveyardPosition || t.howMany++, t.targetPosition = o, [t];
            if (i.start.hasSameParentAs(e.splitPosition) && i.containsPosition(e.splitPosition)) {
                let t = new Pl(e.splitPosition, i.end);
                t = t._getTransformedBySplitOperation(e);
                return Xd([new Pl(i.start, e.splitPosition), t], o)
            }
            t.targetPosition.isEqual(e.splitPosition) && "insertAtSource" == n.abRelation && (o = e.moveTargetPosition), t.targetPosition.isEqual(e.insertionPosition) && "insertBetween" == n.abRelation && (o = t.targetPosition);
            const r = [i._getTransformedBySplitOperation(e)];
            if (e.graveyardPosition) {
                const o = i.start.isEqual(e.graveyardPosition) || i.containsPosition(e.graveyardPosition);
                t.howMany > 1 && o && !n.aWasUndone && r.push(Pl._createFromPositionAndShift(e.insertionPosition, 1))
            }
            return Xd(r, o)
        })), Wd(Bd, Rd, ((t, e, n) => {
            const o = Pl._createFromPositionAndShift(t.sourcePosition, t.howMany);
            if (e.deletionPosition.hasSameParentAs(t.sourcePosition) && o.containsPosition(e.sourcePosition))
                if ("remove" != t.type || n.forceWeakRemove) {
                    if (1 == t.howMany) return n.bWasUndone ? (t.sourcePosition = e.graveyardPosition.clone(), t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e), [t]) : [new Fd(0)]
                } else if (!n.aWasUndone) {
                const n = [];
                let o = e.graveyardPosition.clone(),
                    i = e.targetPosition._getTransformedByMergeOperation(e);
                t.howMany > 1 && (n.push(new Bd(t.sourcePosition, t.howMany - 1, t.targetPosition, 0)), o = o._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1), i = i._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1));
                const r = e.deletionPosition._getCombined(t.sourcePosition, t.targetPosition),
                    s = new Bd(o, 1, r, 0),
                    a = s.getMovedRangeStart().path.slice();
                a.push(0);
                const l = new El(s.targetPosition.root, a);
                i = i._getTransformedByMove(o, r, 1);
                const c = new Bd(i, e.howMany, l, 0);
                return n.push(s), n.push(c), n
            }
            const i = Pl._createFromPositionAndShift(t.sourcePosition, t.howMany)._getTransformedByMergeOperation(e);
            return t.sourcePosition = i.start, t.howMany = i.end.offset - i.start.offset, t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e), [t]
        })), Wd(Md, Id, ((t, e) => (t.position = t.position._getTransformedByInsertOperation(e), [t]))), Wd(Md, Rd, ((t, e) => t.position.isEqual(e.deletionPosition) ? (t.position = e.graveyardPosition.clone(), t.position.stickiness = "toNext", [t]) : (t.position = t.position._getTransformedByMergeOperation(e), [t]))), Wd(Md, Bd, ((t, e) => (t.position = t.position._getTransformedByMoveOperation(e), [t]))), Wd(Md, Md, ((t, e, n) => {
            if (t.position.isEqual(e.position)) {
                if (!n.aIsStrong) return [new Fd(0)];
                t.oldName = e.newName
            }
            return [t]
        })), Wd(Md, Pd, ((t, e) => {
            if ("same" == Y(t.position.path, e.splitPosition.getParentPath()) && !e.graveyardPosition) {
                const e = new Md(t.position.getShiftedBy(1), t.oldName, t.newName, 0);
                return [t, e]
            }
            return t.position = t.position._getTransformedBySplitOperation(e), [t]
        })), Wd(Nd, Nd, ((t, e, n) => {
            if (t.root === e.root && t.key === e.key) {
                if (!n.aIsStrong || t.newValue === e.newValue) return [new Fd(0)];
                t.oldValue = e.newValue
            }
            return [t]
        })), Wd(Ld, Ld, ((t, e, n) => t.rootName !== e.rootName || t.isAdd !== e.isAdd || n.bWasUndone ? [t] : [new Fd(0)])), Wd(Pd, Id, ((t, e) => (t.splitPosition.hasSameParentAs(e.position) && t.splitPosition.offset < e.position.offset && (t.howMany += e.howMany), t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e), t.insertionPosition = t.insertionPosition._getTransformedByInsertOperation(e), [t]))), Wd(Pd, Rd, ((t, e, n) => {
            if (!t.graveyardPosition && !n.bWasUndone && t.splitPosition.hasSameParentAs(e.sourcePosition)) {
                const n = e.graveyardPosition.path.slice();
                n.push(0);
                const o = new El(e.graveyardPosition.root, n),
                    i = Pd.getInsertionPosition(new El(e.graveyardPosition.root, n)),
                    r = new Pd(o, 0, i, null, 0);
                return t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e), t.insertionPosition = Pd.getInsertionPosition(t.splitPosition), t.graveyardPosition = r.insertionPosition.clone(), t.graveyardPosition.stickiness = "toNext", [r, t]
            }
            return t.splitPosition.hasSameParentAs(e.deletionPosition) && !t.splitPosition.isAfter(e.deletionPosition) && t.howMany--, t.splitPosition.hasSameParentAs(e.targetPosition) && (t.howMany += e.howMany), t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e), t.insertionPosition = Pd.getInsertionPosition(t.splitPosition), t.graveyardPosition && (t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)), [t]
        })), Wd(Pd, Bd, ((t, e, n) => {
            const o = Pl._createFromPositionAndShift(e.sourcePosition, e.howMany);
            if (t.graveyardPosition) {
                const i = o.start.isEqual(t.graveyardPosition) || o.containsPosition(t.graveyardPosition);
                if (!n.bWasUndone && i) {
                    const n = t.splitPosition._getTransformedByMoveOperation(e),
                        o = t.graveyardPosition._getTransformedByMoveOperation(e),
                        i = o.path.slice();
                    i.push(0);
                    const r = new El(o.root, i);
                    return [new Bd(n, t.howMany, r, 0)]
                }
                t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)
            }
            const i = t.splitPosition.isEqual(e.targetPosition);
            if (i && ("insertAtSource" == n.baRelation || "splitBefore" == n.abRelation)) return t.howMany += e.howMany, t.splitPosition = t.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany), t.insertionPosition = Pd.getInsertionPosition(t.splitPosition), [t];
            if (i && n.abRelation && n.abRelation.howMany) {
                const {
                    howMany: e,
                    offset: o
                } = n.abRelation;
                return t.howMany += e, t.splitPosition = t.splitPosition.getShiftedBy(o), [t]
            }
            if (t.splitPosition.hasSameParentAs(e.sourcePosition) && o.containsPosition(t.splitPosition)) {
                const n = e.howMany - (t.splitPosition.offset - e.sourcePosition.offset);
                return t.howMany -= n, t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset && (t.howMany += e.howMany), t.splitPosition = e.sourcePosition.clone(), t.insertionPosition = Pd.getInsertionPosition(t.splitPosition), [t]
            }
            return e.sourcePosition.isEqual(e.targetPosition) || (t.splitPosition.hasSameParentAs(e.sourcePosition) && t.splitPosition.offset <= e.sourcePosition.offset && (t.howMany -= e.howMany), t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset && (t.howMany += e.howMany)), t.splitPosition.stickiness = "toNone", t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e), t.splitPosition.stickiness = "toNext", t.graveyardPosition ? t.insertionPosition = t.insertionPosition._getTransformedByMoveOperation(e) : t.insertionPosition = Pd.getInsertionPosition(t.splitPosition), [t]
        })), Wd(Pd, Pd, ((t, e, n) => {
            if (t.splitPosition.isEqual(e.splitPosition)) {
                if (!t.graveyardPosition && !e.graveyardPosition) return [new Fd(0)];
                if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) return [new Fd(0)];
                if ("splitBefore" == n.abRelation) return t.howMany = 0, t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e), [t]
            }
            if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) {
                const o = "$graveyard" == t.splitPosition.root.rootName,
                    i = "$graveyard" == e.splitPosition.root.rootName;
                if (i && !o || !(o && !i) && n.aIsStrong) {
                    const n = [];
                    return e.howMany && n.push(new Bd(e.moveTargetPosition, e.howMany, e.splitPosition, 0)), t.howMany && n.push(new Bd(t.splitPosition, t.howMany, t.moveTargetPosition, 0)), n
                }
                return [new Fd(0)]
            }
            if (t.graveyardPosition && (t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e)), t.splitPosition.isEqual(e.insertionPosition) && "splitBefore" == n.abRelation) return t.howMany++, [t];
            if (e.splitPosition.isEqual(t.insertionPosition) && "splitBefore" == n.baRelation) {
                const n = e.insertionPosition.path.slice();
                n.push(0);
                const o = new El(e.insertionPosition.root, n);
                return [t, new Bd(t.insertionPosition, 1, o, 0)]
            }
            return t.splitPosition.hasSameParentAs(e.splitPosition) && t.splitPosition.offset < e.splitPosition.offset && (t.howMany -= e.howMany), t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e), t.insertionPosition = Pd.getInsertionPosition(t.splitPosition), [t]
        }));
        class th extends(S(El)) {
            constructor(t, e, n = "toNone") {
                if (super(t, e, n), !this.root.is("rootElement")) throw new b("model-liveposition-root-not-rootelement", t);
                eh.call(this)
            }
            detach() {
                this.stopListening()
            }
            toPosition() {
                return new El(this.root, this.path.slice(), this.stickiness)
            }
            static fromPosition(t, e) {
                return new this(t.root, t.path.slice(), e || t.stickiness)
            }
        }

        function eh() {
            this.listenTo(this.root.document.model, "applyOperation", ((t, e) => {
                const n = e[0];
                n.isDocumentOperation && nh.call(this, n)
            }), {
                priority: "low"
            })
        }

        function nh(t) {
            const e = this.getTransformedByOperation(t);
            if (!this.isEqual(e)) {
                const t = this.toPosition();
                this.path = e.path, this.root = e.root, this.fire("change", t)
            }
        }
        th.prototype.is = function(t) {
            return "livePosition" === t || "model:livePosition" === t || "position" == t || "model:position" === t
        };
        class oh {
            constructor(t = {}) {
                "string" == typeof t && (t = "transparent" === t ? {
                    isUndoable: !1
                } : {}, k("batch-constructor-deprecated-string-type"));
                const {
                    isUndoable: e = !0,
                    isLocal: n = !0,
                    isUndo: o = !1,
                    isTyping: i = !1
                } = t;
                this.operations = [], this.isUndoable = e, this.isLocal = n, this.isUndo = o, this.isTyping = i
            }
            get type() {
                return k("batch-type-deprecated"), "default"
            }
            get baseVersion() {
                for (const t of this.operations)
                    if (null !== t.baseVersion) return t.baseVersion;
                return null
            }
            addOperation(t) {
                return t.batch = this, this.operations.push(t), t
            }
        }
        var ih = Object.defineProperty,
            rh = Object.getOwnPropertySymbols,
            sh = Object.prototype.hasOwnProperty,
            ah = Object.prototype.propertyIsEnumerable,
            lh = (t, e, n) => e in t ? ih(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n;
        class ch {
            constructor(t) {
                this._changesInElement = new Map, this._elementSnapshots = new Map, this._changedMarkers = new Map, this._changedRoots = new Map, this._changeCount = 0, this._cachedChanges = null, this._cachedChangesWithGraveyard = null, this._refreshedItems = new Set, this._markerCollection = t
            }
            get isEmpty() {
                return 0 == this._changesInElement.size && 0 == this._changedMarkers.size && 0 == this._changedRoots.size
            }
            bufferOperation(t) {
                const e = t;
                switch (e.type) {
                    case "insert":
                        if (this._isInInsertedElement(e.position.parent)) return;
                        this._markInsert(e.position.parent, e.position.offset, e.nodes.maxOffset);
                        break;
                    case "addAttribute":
                    case "removeAttribute":
                    case "changeAttribute":
                        for (const t of e.range.getItems({
                                shallow: !0
                            })) this._isInInsertedElement(t.parent) || this._markAttribute(t);
                        break;
                    case "remove":
                    case "move":
                    case "reinsert": {
                        if (e.sourcePosition.isEqual(e.targetPosition) || e.sourcePosition.getShiftedBy(e.howMany).isEqual(e.targetPosition)) return;
                        const t = this._isInInsertedElement(e.sourcePosition.parent),
                            n = this._isInInsertedElement(e.targetPosition.parent);
                        t || this._markRemove(e.sourcePosition.parent, e.sourcePosition.offset, e.howMany), n || this._markInsert(e.targetPosition.parent, e.getMovedRangeStart().offset, e.howMany);
                        break
                    }
                    case "rename": {
                        if (this._isInInsertedElement(e.position.parent)) return;
                        this._markRemove(e.position.parent, e.position.offset, 1), this._markInsert(e.position.parent, e.position.offset, 1);
                        const t = Pl._createFromPositionAndShift(e.position, 1);
                        for (const e of this._markerCollection.getMarkersIntersectingRange(t)) {
                            const t = e.getData();
                            this.bufferMarkerChange(e.name, t, t)
                        }
                        break
                    }
                    case "split": {
                        const t = e.splitPosition.parent;
                        this._isInInsertedElement(t) || this._markRemove(t, e.splitPosition.offset, e.howMany), this._isInInsertedElement(e.insertionPosition.parent) || this._markInsert(e.insertionPosition.parent, e.insertionPosition.offset, 1), e.graveyardPosition && this._markRemove(e.graveyardPosition.parent, e.graveyardPosition.offset, 1);
                        break
                    }
                    case "merge": {
                        const t = e.sourcePosition.parent;
                        this._isInInsertedElement(t.parent) || this._markRemove(t.parent, t.startOffset, 1);
                        const n = e.graveyardPosition.parent;
                        this._markInsert(n, e.graveyardPosition.offset, 1);
                        const o = e.targetPosition.parent;
                        this._isInInsertedElement(o) || this._markInsert(o, e.targetPosition.offset, t.maxOffset);
                        break
                    }
                    case "detachRoot":
                    case "addRoot":
                        this._bufferRootStateChange(e.rootName, e.isAdd);
                        break;
                    case "addRootAttribute":
                    case "removeRootAttribute":
                    case "changeRootAttribute": {
                        const t = e.root.rootName;
                        this._bufferRootAttributeChange(t, e.key, e.oldValue, e.newValue);
                        break
                    }
                }
                this._cachedChanges = null
            }
            bufferMarkerChange(t, e, n) {
                const o = this._changedMarkers.get(t);
                o ? (o.newMarkerData = n, null == o.oldMarkerData.range && null == n.range && this._changedMarkers.delete(t)) : this._changedMarkers.set(t, {
                    newMarkerData: n,
                    oldMarkerData: e
                })
            }
            getMarkersToRemove() {
                const t = [];
                for (const [e, n] of this._changedMarkers) null != n.oldMarkerData.range && t.push({
                    name: e,
                    range: n.oldMarkerData.range
                });
                return t
            }
            getMarkersToAdd() {
                const t = [];
                for (const [e, n] of this._changedMarkers) null != n.newMarkerData.range && t.push({
                    name: e,
                    range: n.newMarkerData.range
                });
                return t
            }
            getChangedMarkers() {
                return Array.from(this._changedMarkers).map((([t, e]) => ({
                    name: t,
                    data: {
                        oldRange: e.oldMarkerData.range,
                        newRange: e.newMarkerData.range
                    }
                })))
            }
            hasDataChanges() {
                if (this._changesInElement.size > 0) return !0;
                if (this._changedRoots.size > 0) return !0;
                for (const {
                        newMarkerData: t,
                        oldMarkerData: e
                    }
                    of this._changedMarkers.values()) {
                    if (t.affectsData !== e.affectsData) return !0;
                    if (t.affectsData) {
                        const n = t.range && !e.range,
                            o = !t.range && e.range,
                            i = t.range && e.range && !t.range.isEqual(e.range);
                        if (n || o || i) return !0
                    }
                }
                return !1
            }
            getChanges(t = {}) {
                if (this._cachedChanges) return t.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
                let e = [];
                for (const t of this._changesInElement.keys()) {
                    const n = this._changesInElement.get(t).sort(((t, e) => t.offset === e.offset ? t.type != e.type ? "remove" == t.type ? -1 : 1 : 0 : t.offset < e.offset ? -1 : 1)),
                        o = this._elementSnapshots.get(t),
                        i = dh(t.getChildren()),
                        r = hh(o.length, n);
                    let s = 0,
                        a = 0;
                    for (const n of r)
                        if ("i" === n) e.push(this._getInsertDiff(t, s, i[s])), s++;
                        else if ("r" === n) e.push(this._getRemoveDiff(t, s, o[a])), a++;
                    else if ("a" === n) {
                        const n = i[s].attributes,
                            r = o[a].attributes;
                        let l;
                        if ("$text" == i[s].name) l = new Pl(El._createAt(t, s), El._createAt(t, s + 1));
                        else {
                            const e = t.offsetToIndex(s);
                            l = new Pl(El._createAt(t, s), El._createAt(t.getChild(e), 0))
                        }
                        e.push(...this._getAttributesDiff(l, r, n)), s++, a++
                    } else s++, a++
                }
                e.sort(((t, e) => t.position.root != e.position.root ? t.position.root.rootName < e.position.root.rootName ? -1 : 1 : t.position.isEqual(e.position) ? t.changeCount - e.changeCount : t.position.isBefore(e.position) ? -1 : 1));
                for (let t = 1, n = 0; t < e.length; t++) {
                    const o = e[n],
                        i = e[t],
                        r = "remove" == o.type && "remove" == i.type && "$text" == o.name && "$text" == i.name && o.position.isEqual(i.position),
                        s = "insert" == o.type && "insert" == i.type && "$text" == o.name && "$text" == i.name && o.position.parent == i.position.parent && o.position.offset + o.length == i.position.offset,
                        a = "attribute" == o.type && "attribute" == i.type && o.position.parent == i.position.parent && o.range.isFlat && i.range.isFlat && o.position.offset + o.length == i.position.offset && o.attributeKey == i.attributeKey && o.attributeOldValue == i.attributeOldValue && o.attributeNewValue == i.attributeNewValue;
                    r || s || a ? (o.length++, a && (o.range.end = o.range.end.getShiftedBy(1)), e[t] = null) : n = t
                }
                e = e.filter((t => t));
                for (const t of e) delete t.changeCount, "attribute" == t.type && (delete t.position, delete t.length);
                return this._changeCount = 0, this._cachedChangesWithGraveyard = e, this._cachedChanges = e.filter(uh), t.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice()
            }
            getChangedRoots() {
                return Array.from(this._changedRoots.values()).map((t => {
                    const e = ((t, e) => {
                        for (var n in e || (e = {})) sh.call(e, n) && lh(t, n, e[n]);
                        if (rh)
                            for (var n of rh(e)) ah.call(e, n) && lh(t, n, e[n]);
                        return t
                    })({}, t);
                    return void 0 !== e.state && delete e.attributes, e
                }))
            }
            getRefreshedItems() {
                return new Set(this._refreshedItems)
            }
            reset() {
                this._changesInElement.clear(), this._elementSnapshots.clear(), this._changedMarkers.clear(), this._changedRoots.clear(), this._refreshedItems = new Set, this._cachedChanges = null
            }
            _bufferRootStateChange(t, e) {
                if (!this._changedRoots.has(t)) return void this._changedRoots.set(t, {
                    name: t,
                    state: e ? "attached" : "detached"
                });
                const n = this._changedRoots.get(t);
                void 0 !== n.state ? (delete n.state, void 0 === n.attributes && this._changedRoots.delete(t)) : n.state = e ? "attached" : "detached"
            }
            _bufferRootAttributeChange(t, e, n, o) {
                const i = this._changedRoots.get(t) || {
                        name: t
                    },
                    r = i.attributes || {};
                if (r[e]) {
                    const t = r[e];
                    o === t.oldValue ? delete r[e] : t.newValue = o
                } else r[e] = {
                    oldValue: n,
                    newValue: o
                };
                0 === Object.entries(r).length ? (delete i.attributes, void 0 === i.state && this._changedRoots.delete(t)) : (i.attributes = r, this._changedRoots.set(t, i))
            }
            _refreshItem(t) {
                if (this._isInInsertedElement(t.parent)) return;
                this._markRemove(t.parent, t.startOffset, t.offsetSize), this._markInsert(t.parent, t.startOffset, t.offsetSize), this._refreshedItems.add(t);
                const e = Pl._createOn(t);
                for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
                    const e = t.getData();
                    this.bufferMarkerChange(t.name, e, e)
                }
                this._cachedChanges = null
            }
            _markInsert(t, e, n) {
                const o = {
                    type: "insert",
                    offset: e,
                    howMany: n,
                    count: this._changeCount++
                };
                this._markChange(t, o)
            }
            _markRemove(t, e, n) {
                const o = {
                    type: "remove",
                    offset: e,
                    howMany: n,
                    count: this._changeCount++
                };
                this._markChange(t, o), this._removeAllNestedChanges(t, e, n)
            }
            _markAttribute(t) {
                const e = {
                    type: "attribute",
                    offset: t.startOffset,
                    howMany: t.offsetSize,
                    count: this._changeCount++
                };
                this._markChange(t.parent, e)
            }
            _markChange(t, e) {
                this._makeSnapshot(t);
                const n = this._getChangesForElement(t);
                this._handleChange(e, n), n.push(e);
                for (let t = 0; t < n.length; t++) n[t].howMany < 1 && (n.splice(t, 1), t--)
            }
            _getChangesForElement(t) {
                let e;
                return this._changesInElement.has(t) ? e = this._changesInElement.get(t) : (e = [], this._changesInElement.set(t, e)), e
            }
            _makeSnapshot(t) {
                this._elementSnapshots.has(t) || this._elementSnapshots.set(t, dh(t.getChildren()))
            }
            _handleChange(t, e) {
                t.nodesToHandle = t.howMany;
                for (const n of e) {
                    const o = t.offset + t.howMany,
                        i = n.offset + n.howMany;
                    if ("insert" == t.type && ("insert" == n.type && (t.offset <= n.offset ? n.offset += t.howMany : t.offset < i && (n.howMany += t.nodesToHandle, t.nodesToHandle = 0)), "remove" == n.type && t.offset < n.offset && (n.offset += t.howMany), "attribute" == n.type))
                        if (t.offset <= n.offset) n.offset += t.howMany;
                        else if (t.offset < i) {
                        const i = n.howMany;
                        n.howMany = t.offset - n.offset, e.unshift({
                            type: "attribute",
                            offset: o,
                            howMany: i - n.howMany,
                            count: this._changeCount++
                        })
                    }
                    if ("remove" == t.type) {
                        if ("insert" == n.type)
                            if (o <= n.offset) n.offset -= t.howMany;
                            else if (o <= i)
                            if (t.offset < n.offset) {
                                const e = o - n.offset;
                                n.offset = t.offset, n.howMany -= e, t.nodesToHandle -= e
                            } else n.howMany -= t.nodesToHandle, t.nodesToHandle = 0;
                        else if (t.offset <= n.offset) t.nodesToHandle -= n.howMany, n.howMany = 0;
                        else if (t.offset < i) {
                            const e = i - t.offset;
                            n.howMany -= e, t.nodesToHandle -= e
                        }
                        if ("remove" == n.type && (o <= n.offset ? n.offset -= t.howMany : t.offset < n.offset && (t.nodesToHandle += n.howMany, n.howMany = 0)), "attribute" == n.type)
                            if (o <= n.offset) n.offset -= t.howMany;
                            else if (t.offset < n.offset) {
                            const e = o - n.offset;
                            n.offset = t.offset, n.howMany -= e
                        } else if (t.offset < i)
                            if (o <= i) {
                                const o = n.howMany;
                                n.howMany = t.offset - n.offset;
                                const i = o - n.howMany - t.nodesToHandle;
                                e.unshift({
                                    type: "attribute",
                                    offset: t.offset,
                                    howMany: i,
                                    count: this._changeCount++
                                })
                            } else n.howMany -= i - t.offset
                    }
                    if ("attribute" == t.type) {
                        if ("insert" == n.type)
                            if (t.offset < n.offset && o > n.offset) {
                                if (o > i) {
                                    const t = {
                                        type: "attribute",
                                        offset: i,
                                        howMany: o - i,
                                        count: this._changeCount++
                                    };
                                    this._handleChange(t, e), e.push(t)
                                }
                                t.nodesToHandle = n.offset - t.offset, t.howMany = t.nodesToHandle
                            } else t.offset >= n.offset && t.offset < i && (o > i ? (t.nodesToHandle = o - i, t.offset = i) : t.nodesToHandle = 0);
                        if ("remove" == n.type && t.offset < n.offset && o > n.offset) {
                            const i = {
                                type: "attribute",
                                offset: n.offset,
                                howMany: o - n.offset,
                                count: this._changeCount++
                            };
                            this._handleChange(i, e), e.push(i), t.nodesToHandle = n.offset - t.offset, t.howMany = t.nodesToHandle
                        }
                        "attribute" == n.type && (t.offset >= n.offset && o <= i ? (t.nodesToHandle = 0, t.howMany = 0, t.offset = 0) : t.offset <= n.offset && o >= i && (n.howMany = 0))
                    }
                }
                t.howMany = t.nodesToHandle, delete t.nodesToHandle
            }
            _getInsertDiff(t, e, n) {
                return {
                    type: "insert",
                    position: El._createAt(t, e),
                    name: n.name,
                    attributes: new Map(n.attributes),
                    length: 1,
                    changeCount: this._changeCount++
                }
            }
            _getRemoveDiff(t, e, n) {
                return {
                    type: "remove",
                    position: El._createAt(t, e),
                    name: n.name,
                    attributes: new Map(n.attributes),
                    length: 1,
                    changeCount: this._changeCount++
                }
            }
            _getAttributesDiff(t, e, n) {
                const o = [];
                n = new Map(n);
                for (const [i, r] of e) {
                    const e = n.has(i) ? n.get(i) : null;
                    e !== r && o.push({
                        type: "attribute",
                        position: t.start,
                        range: t.clone(),
                        length: 1,
                        attributeKey: i,
                        attributeOldValue: r,
                        attributeNewValue: e,
                        changeCount: this._changeCount++
                    }), n.delete(i)
                }
                for (const [e, i] of n) o.push({
                    type: "attribute",
                    position: t.start,
                    range: t.clone(),
                    length: 1,
                    attributeKey: e,
                    attributeOldValue: null,
                    attributeNewValue: i,
                    changeCount: this._changeCount++
                });
                return o
            }
            _isInInsertedElement(t) {
                const e = t.parent;
                if (!e) return !1;
                const n = this._changesInElement.get(e),
                    o = t.startOffset;
                if (n)
                    for (const t of n)
                        if ("insert" == t.type && o >= t.offset && o < t.offset + t.howMany) return !0;
                return this._isInInsertedElement(e)
            }
            _removeAllNestedChanges(t, e, n) {
                const o = new Pl(El._createAt(t, e), El._createAt(t, e + n));
                for (const t of o.getItems({
                        shallow: !0
                    })) t.is("element") && (this._elementSnapshots.delete(t), this._changesInElement.delete(t), this._removeAllNestedChanges(t, 0, t.maxOffset))
            }
        }

        function dh(t) {
            const e = [];
            for (const n of t)
                if (n.is("$text"))
                    for (let t = 0; t < n.data.length; t++) e.push({
                        name: "$text",
                        attributes: new Map(n.getAttributes())
                    });
                else e.push({
                    name: n.name,
                    attributes: new Map(n.getAttributes())
                });
            return e
        }

        function hh(t, e) {
            const n = [];
            let o = 0,
                i = 0;
            for (const t of e) {
                if (t.offset > o) {
                    for (let e = 0; e < t.offset - o; e++) n.push("e");
                    i += t.offset - o
                }
                if ("insert" == t.type) {
                    for (let e = 0; e < t.howMany; e++) n.push("i");
                    o = t.offset + t.howMany
                } else if ("remove" == t.type) {
                    for (let e = 0; e < t.howMany; e++) n.push("r");
                    o = t.offset, i += t.howMany
                } else n.push(..."a".repeat(t.howMany).split("")), o = t.offset + t.howMany, i += t.howMany
            }
            if (i < t)
                for (let e = 0; e < t - i - o; e++) n.push("e");
            return n
        }

        function uh(t) {
            const e = "position" in t && "$graveyard" == t.position.root.rootName,
                n = "range" in t && "$graveyard" == t.range.root.rootName;
            return !e && !n
        }
        class gh {
            constructor() {
                this._operations = [], this._undoPairs = new Map, this._undoneOperations = new Set, this._baseVersionToOperationIndex = new Map, this._version = 0, this._gaps = new Map
            }
            get version() {
                return this._version
            }
            set version(t) {
                this._operations.length && t > this._version + 1 && this._gaps.set(this._version, t), this._version = t
            }
            get lastOperation() {
                return this._operations[this._operations.length - 1]
            }
            addOperation(t) {
                if (t.baseVersion !== this.version) throw new b("model-document-history-addoperation-incorrect-version", this, {
                    operation: t,
                    historyVersion: this.version
                });
                this._operations.push(t), this._version++, this._baseVersionToOperationIndex.set(t.baseVersion, this._operations.length - 1)
            }
            getOperations(t, e = this.version) {
                if (!this._operations.length) return [];
                const n = this._operations[0];
                void 0 === t && (t = n.baseVersion);
                let o = e - 1;
                for (const [e, n] of this._gaps) t > e && t < n && (t = n), o > e && o < n && (o = e - 1);
                if (o < n.baseVersion || t > this.lastOperation.baseVersion) return [];
                let i = this._baseVersionToOperationIndex.get(t);
                void 0 === i && (i = 0);
                let r = this._baseVersionToOperationIndex.get(o);
                return void 0 === r && (r = this._operations.length - 1), this._operations.slice(i, r + 1)
            }
            getOperation(t) {
                const e = this._baseVersionToOperationIndex.get(t);
                if (void 0 !== e) return this._operations[e]
            }
            setOperationAsUndone(t, e) {
                this._undoPairs.set(e, t), this._undoneOperations.add(t)
            }
            isUndoingOperation(t) {
                return this._undoPairs.has(t)
            }
            isUndoneOperation(t) {
                return this._undoneOperations.has(t)
            }
            getUndoneOperation(t) {
                return this._undoPairs.get(t)
            }
            reset() {
                this._version = 0, this._undoPairs = new Map, this._operations = [], this._undoneOperations = new Set, this._gaps = new Map, this._baseVersionToOperationIndex = new Map
            }
        }
        class mh extends vl {
            constructor(t, e, n = "main") {
                super(e), this._isAttached = !0, this._document = t, this.rootName = n
            }
            get document() {
                return this._document
            }
            isAttached() {
                return this._isAttached
            }
            toJSON() {
                return this.rootName
            }
        }
        mh.prototype.is = function(t, e) {
            return e ? e === this.name && ("rootElement" === t || "model:rootElement" === t || "element" === t || "model:element" === t) : "rootElement" === t || "model:rootElement" === t || "element" === t || "model:element" === t || "node" === t || "model:node" === t
        };
        var ph = Object.defineProperty,
            fh = Object.defineProperties,
            bh = Object.getOwnPropertyDescriptors,
            kh = Object.getOwnPropertySymbols,
            wh = Object.prototype.hasOwnProperty,
            Ah = Object.prototype.propertyIsEnumerable,
            Ch = (t, e, n) => e in t ? ph(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n,
            _h = (t, e) => {
                for (var n in e || (e = {})) wh.call(e, n) && Ch(t, n, e[n]);
                if (kh)
                    for (var n of kh(e)) Ah.call(e, n) && Ch(t, n, e[n]);
                return t
            },
            vh = (t, e) => fh(t, bh(e));
        const yh = "$graveyard";
        class xh extends(S()) {
            constructor(t) {
                super(), this.model = t, this.history = new gh, this.selection = new rc(this), this.roots = new xi({
                    idProperty: "rootName"
                }), this.differ = new ch(t.markers), this.isReadOnly = !1, this._postFixers = new Set, this._hasSelectionChangedFromTheLastChangeBlock = !1, this.createRoot("$root", yh), this.listenTo(t, "applyOperation", ((t, e) => {
                    const n = e[0];
                    n.isDocumentOperation && this.differ.bufferOperation(n)
                }), {
                    priority: "high"
                }), this.listenTo(t, "applyOperation", ((t, e) => {
                    const n = e[0];
                    n.isDocumentOperation && this.history.addOperation(n)
                }), {
                    priority: "low"
                }), this.listenTo(this.selection, "change", (() => {
                    this._hasSelectionChangedFromTheLastChangeBlock = !0
                })), this.listenTo(t.markers, "update", ((t, e, n, o, i) => {
                    const r = vh(_h({}, e.getData()), {
                        range: o
                    });
                    this.differ.bufferMarkerChange(e.name, i, r), null === n && e.on("change", ((t, n) => {
                        const o = e.getData();
                        this.differ.bufferMarkerChange(e.name, vh(_h({}, o), {
                            range: n
                        }), o)
                    }))
                })), this.registerPostFixer((t => {
                    let e = !1;
                    for (const n of this.roots) n.isAttached() || n.isEmpty || (t.remove(t.createRangeIn(n)), e = !0);
                    for (const n of this.model.markers) n.getRange().root.isAttached() || (t.removeMarker(n), e = !0);
                    return e
                }))
            }
            get version() {
                return this.history.version
            }
            set version(t) {
                this.history.version = t
            }
            get graveyard() {
                return this.getRoot(yh)
            }
            createRoot(t = "$root", e = "main") {
                if (this.roots.get(e)) throw new b("model-document-createroot-name-exists", this, {
                    name: e
                });
                const n = new mh(this, t, e);
                return this.roots.add(n), n
            }
            destroy() {
                this.selection.destroy(), this.stopListening()
            }
            getRoot(t = "main") {
                return this.roots.get(t)
            }
            getRootNames(t = !1) {
                return Array.from(this.roots).filter((e => e.rootName != yh && (t || e.isAttached()))).map((t => t.rootName))
            }
            registerPostFixer(t) {
                this._postFixers.add(t)
            }
            toJSON() {
                const t = er(this);
                return t.selection = "[engine.model.DocumentSelection]", t.model = "[engine.model.Model]", t
            }
            _handleChangeBlock(t) {
                this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(t), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", t.batch) : this.fire("change", t.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = !1
            }
            _hasDocumentChangedFromTheLastChangeBlock() {
                return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock
            }
            _getDefaultRoot() {
                for (const t of this.roots)
                    if (t !== this.graveyard) return t;
                return this.graveyard
            }
            _getDefaultRange() {
                const t = this._getDefaultRoot(),
                    e = this.model,
                    n = e.schema,
                    o = e.createPositionFromPath(t, [0]);
                return n.getNearestSelectionRange(o) || e.createRange(o)
            }
            _validateSelectionRange(t) {
                return Eh(t.start) && Eh(t.end)
            }
            _callPostFixers(t) {
                let e = !1;
                do {
                    for (const n of this._postFixers)
                        if (this.selection.refresh(), e = n(t), e) break
                } while (e)
            }
        }

        function Eh(t) {
            const e = t.textNode;
            if (e) {
                const n = e.data,
                    o = t.offset - e.startOffset;
                return !Ii(n, o) && !Pi(n, o)
            }
            return !0
        }
        var Dh = Object.defineProperty,
            Sh = Object.defineProperties,
            Th = Object.getOwnPropertyDescriptors,
            Bh = Object.getOwnPropertySymbols,
            Ih = Object.prototype.hasOwnProperty,
            Ph = Object.prototype.propertyIsEnumerable,
            Rh = (t, e, n) => e in t ? Dh(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n;
        class zh extends(S()) {
            constructor() {
                super(...arguments), this._markers = new Map
            } [Symbol.iterator]() {
                return this._markers.values()
            }
            has(t) {
                const e = t instanceof Vh ? t.name : t;
                return this._markers.has(e)
            }
            get(t) {
                return this._markers.get(t) || null
            }
            _set(t, e, n = !1, o = !1) {
                const i = t instanceof Vh ? t.name : t;
                if (i.includes(",")) throw new b("markercollection-incorrect-marker-name", this);
                const r = this._markers.get(i);
                if (r) {
                    const t = r.getData(),
                        s = r.getRange();
                    let a = !1;
                    return s.isEqual(e) || (r._attachLiveRange(ec.fromRange(e)), a = !0), n != r.managedUsingOperations && (r._managedUsingOperations = n, a = !0), "boolean" == typeof o && o != r.affectsData && (r._affectsData = o, a = !0), a && this.fire(`update:${i}`, r, s, e, t), r
                }
                const s = ec.fromRange(e),
                    a = new Vh(i, s, n, o);
                var l;
                return this._markers.set(i, a), this.fire(`update:${i}`, a, null, e, (l = ((t, e) => {
                    for (var n in e || (e = {})) Ih.call(e, n) && Rh(t, n, e[n]);
                    if (Bh)
                        for (var n of Bh(e)) Ph.call(e, n) && Rh(t, n, e[n]);
                    return t
                })({}, a.getData()), Sh(l, Th({
                    range: null
                })))), a
            }
            _remove(t) {
                const e = t instanceof Vh ? t.name : t,
                    n = this._markers.get(e);
                return !!n && (this._markers.delete(e), this.fire(`update:${e}`, n, n.getRange(), null, n.getData()), this._destroyMarker(n), !0)
            }
            _refresh(t) {
                const e = t instanceof Vh ? t.name : t,
                    n = this._markers.get(e);
                if (!n) throw new b("markercollection-refresh-marker-not-exists", this);
                const o = n.getRange();
                this.fire(`update:${e}`, n, o, o, n.getData())
            }* getMarkersAtPosition(t) {
                for (const e of this) e.getRange().containsPosition(t) && (yield e)
            }* getMarkersIntersectingRange(t) {
                for (const e of this) null !== e.getRange().getIntersection(t) && (yield e)
            }
            destroy() {
                for (const t of this._markers.values()) this._destroyMarker(t);
                this._markers = null, this.stopListening()
            }* getMarkersGroup(t) {
                for (const e of this._markers.values()) e.name.startsWith(t + ":") && (yield e)
            }
            _destroyMarker(t) {
                t.stopListening(), t._detachLiveRange()
            }
        }
        class Vh extends(S(kl)) {
            constructor(t, e, n, o) {
                super(), this.name = t, this._liveRange = this._attachLiveRange(e), this._managedUsingOperations = n, this._affectsData = o
            }
            get managedUsingOperations() {
                if (!this._liveRange) throw new b("marker-destroyed", this);
                return this._managedUsingOperations
            }
            get affectsData() {
                if (!this._liveRange) throw new b("marker-destroyed", this);
                return this._affectsData
            }
            getData() {
                return {
                    range: this.getRange(),
                    affectsData: this.affectsData,
                    managedUsingOperations: this.managedUsingOperations
                }
            }
            getStart() {
                if (!this._liveRange) throw new b("marker-destroyed", this);
                return this._liveRange.start.clone()
            }
            getEnd() {
                if (!this._liveRange) throw new b("marker-destroyed", this);
                return this._liveRange.end.clone()
            }
            getRange() {
                if (!this._liveRange) throw new b("marker-destroyed", this);
                return this._liveRange.toRange()
            }
            _attachLiveRange(t) {
                return this._liveRange && this._detachLiveRange(), t.delegate("change:range").to(this), t.delegate("change:content").to(this), this._liveRange = t, t
            }
            _detachLiveRange() {
                this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null
            }
        }
        Vh.prototype.is = function(t) {
            return "marker" === t || "model:marker" === t
        };
        class Oh extends _d {
            constructor(t, e) {
                super(null), this.sourcePosition = t.clone(), this.howMany = e
            }
            get type() {
                return "detach"
            }
            get affectedSelectable() {
                return null
            }
            toJSON() {
                const t = super.toJSON();
                return t.sourcePosition = this.sourcePosition.toJSON(), t
            }
            _validate() {
                if (this.sourcePosition.root.document) throw new b("detach-operation-on-document-node", this)
            }
            _execute() {
                yd(Pl._createFromPositionAndShift(this.sourcePosition, this.howMany))
            }
            static get className() {
                return "DetachOperation"
            }
        }
        class Fh extends kl {
            constructor(t) {
                super(), this.markers = new Map, this._children = new Al, t && this._insertChild(0, t)
            } [Symbol.iterator]() {
                return this.getChildren()
            }
            get childCount() {
                return this._children.length
            }
            get maxOffset() {
                return this._children.maxOffset
            }
            get isEmpty() {
                return 0 === this.childCount
            }
            get nextSibling() {
                return null
            }
            get previousSibling() {
                return null
            }
            get root() {
                return this
            }
            get parent() {
                return null
            }
            get document() {
                return null
            }
            isAttached() {
                return !1
            }
            getAncestors() {
                return []
            }
            getChild(t) {
                return this._children.getNode(t)
            }
            getChildren() {
                return this._children[Symbol.iterator]()
            }
            getChildIndex(t) {
                return this._children.getNodeIndex(t)
            }
            getChildStartOffset(t) {
                return this._children.getNodeStartOffset(t)
            }
            getPath() {
                return []
            }
            getNodeByPath(t) {
                let e = this;
                for (const n of t) e = e.getChild(e.offsetToIndex(n));
                return e
            }
            offsetToIndex(t) {
                return this._children.offsetToIndex(t)
            }
            toJSON() {
                const t = [];
                for (const e of this._children) t.push(e.toJSON());
                return t
            }
            static fromJSON(t) {
                const e = [];
                for (const n of t) n.name ? e.push(vl.fromJSON(n)) : e.push(Cl.fromJSON(n));
                return new Fh(e)
            }
            _appendChild(t) {
                this._insertChild(this.childCount, t)
            }
            _insertChild(t, e) {
                const n = function(t) {
                    if ("string" == typeof t) return [new Cl(t)];
                    Q(t) || (t = [t]);
                    return Array.from(t).map((t => "string" == typeof t ? new Cl(t) : t instanceof _l ? new Cl(t.data, t.getAttributes()) : t))
                }(e);
                for (const t of n) null !== t.parent && t._remove(), t.parent = this;
                this._children._insertNodes(t, n)
            }
            _removeChildren(t, e = 1) {
                const n = this._children._removeNodes(t, e);
                for (const t of n) t.parent = null;
                return n
            }
        }
        Fh.prototype.is = function(t) {
            return "documentFragment" === t || "model:documentFragment" === t
        };
        class Mh {
            constructor(t, e) {
                this.model = t, this.batch = e
            }
            createText(t, e) {
                return new Cl(t, e)
            }
            createElement(t, e) {
                return new vl(t, e)
            }
            createDocumentFragment() {
                return new Fh
            }
            cloneElement(t, e = !0) {
                return t._clone(e)
            }
            insert(t, e, n = 0) {
                if (this._assertWriterUsedCorrectly(), t instanceof Cl && "" == t.data) return;
                const o = El._createAt(e, n);
                if (t.parent) {
                    if (qh(t.root, o.root)) return void this.move(Pl._createOn(t), o);
                    if (t.root.document) throw new b("model-writer-insert-forbidden-move", this);
                    this.remove(t)
                }
                const i = o.root.document ? o.root.document.version : null,
                    r = new Id(o, t, i);
                if (t instanceof Cl && (r.shouldReceiveAttributes = !0), this.batch.addOperation(r), this.model.applyOperation(r), t instanceof Fh)
                    for (const [e, n] of t.markers) {
                        const t = El._createAt(n.root, 0),
                            i = {
                                range: new Pl(n.start._getCombined(t, o), n.end._getCombined(t, o)),
                                usingOperation: !0,
                                affectsData: !0
                            };
                        this.model.markers.has(e) ? this.updateMarker(e, i) : this.addMarker(e, i)
                    }
            }
            insertText(t, e, n, o) {
                e instanceof Fh || e instanceof vl || e instanceof El ? this.insert(this.createText(t), e, n) : this.insert(this.createText(t, e), n, o)
            }
            insertElement(t, e, n, o) {
                e instanceof Fh || e instanceof vl || e instanceof El ? this.insert(this.createElement(t), e, n) : this.insert(this.createElement(t, e), n, o)
            }
            append(t, e) {
                this.insert(t, e, "end")
            }
            appendText(t, e, n) {
                e instanceof Fh || e instanceof vl ? this.insert(this.createText(t), e, "end") : this.insert(this.createText(t, e), n, "end")
            }
            appendElement(t, e, n) {
                e instanceof Fh || e instanceof vl ? this.insert(this.createElement(t), e, "end") : this.insert(this.createElement(t, e), n, "end")
            }
            setAttribute(t, e, n) {
                if (this._assertWriterUsedCorrectly(), n instanceof Pl) {
                    const o = n.getMinimalFlatRanges();
                    for (const n of o) Nh(this, t, e, n)
                } else Lh(this, t, e, n)
            }
            setAttributes(t, e) {
                for (const [n, o] of Ti(t)) this.setAttribute(n, o, e)
            }
            removeAttribute(t, e) {
                if (this._assertWriterUsedCorrectly(), e instanceof Pl) {
                    const n = e.getMinimalFlatRanges();
                    for (const e of n) Nh(this, t, null, e)
                } else Lh(this, t, null, e)
            }
            clearAttributes(t) {
                this._assertWriterUsedCorrectly();
                const e = t => {
                    for (const e of t.getAttributeKeys()) this.removeAttribute(e, t)
                };
                if (t instanceof Pl)
                    for (const n of t.getItems()) e(n);
                else e(t)
            }
            move(t, e, n) {
                if (this._assertWriterUsedCorrectly(), !(t instanceof Pl)) throw new b("writer-move-invalid-range", this);
                if (!t.isFlat) throw new b("writer-move-range-not-flat", this);
                const o = El._createAt(e, n);
                if (o.isEqual(t.start)) return;
                if (this._addOperationForAffectedMarkers("move", t), !qh(t.root, o.root)) throw new b("writer-move-different-document", this);
                const i = t.root.document ? t.root.document.version : null,
                    r = new Bd(t.start, t.end.offset - t.start.offset, o, i);
                this.batch.addOperation(r), this.model.applyOperation(r)
            }
            remove(t) {
                this._assertWriterUsedCorrectly();
                const e = (t instanceof Pl ? t : Pl._createOn(t)).getMinimalFlatRanges().reverse();
                for (const t of e) this._addOperationForAffectedMarkers("move", t), jh(t.start, t.end.offset - t.start.offset, this.batch, this.model)
            }
            merge(t) {
                this._assertWriterUsedCorrectly();
                const e = t.nodeBefore,
                    n = t.nodeAfter;
                if (this._addOperationForAffectedMarkers("merge", t), !(e instanceof vl)) throw new b("writer-merge-no-element-before", this);
                if (!(n instanceof vl)) throw new b("writer-merge-no-element-after", this);
                t.root.document ? this._merge(t) : this._mergeDetached(t)
            }
            createPositionFromPath(t, e, n) {
                return this.model.createPositionFromPath(t, e, n)
            }
            createPositionAt(t, e) {
                return this.model.createPositionAt(t, e)
            }
            createPositionAfter(t) {
                return this.model.createPositionAfter(t)
            }
            createPositionBefore(t) {
                return this.model.createPositionBefore(t)
            }
            createRange(t, e) {
                return this.model.createRange(t, e)
            }
            createRangeIn(t) {
                return this.model.createRangeIn(t)
            }
            createRangeOn(t) {
                return this.model.createRangeOn(t)
            }
            createSelection(...t) {
                return this.model.createSelection(...t)
            }
            _mergeDetached(t) {
                const e = t.nodeBefore,
                    n = t.nodeAfter;
                this.move(Pl._createIn(n), El._createAt(e, "end")), this.remove(n)
            }
            _merge(t) {
                const e = El._createAt(t.nodeBefore, "end"),
                    n = El._createAt(t.nodeAfter, 0),
                    o = t.root.document.graveyard,
                    i = new El(o, [0]),
                    r = t.root.document.version,
                    s = new Rd(n, t.nodeAfter.maxOffset, e, i, r);
                this.batch.addOperation(s), this.model.applyOperation(s)
            }
            rename(t, e) {
                if (this._assertWriterUsedCorrectly(), !(t instanceof vl)) throw new b("writer-rename-not-element-instance", this);
                const n = t.root.document ? t.root.document.version : null,
                    o = new Md(El._createBefore(t), t.name, e, n);
                this.batch.addOperation(o), this.model.applyOperation(o)
            }
            split(t, e) {
                this._assertWriterUsedCorrectly();
                let n, o, i = t.parent;
                if (!i.parent) throw new b("writer-split-element-no-parent", this);
                if (e || (e = i.parent), !t.parent.getAncestors({
                        includeSelf: !0
                    }).includes(e)) throw new b("writer-split-invalid-limit-element", this);
                do {
                    const e = i.root.document ? i.root.document.version : null,
                        r = i.maxOffset - t.offset,
                        s = Pd.getInsertionPosition(t),
                        a = new Pd(t, r, s, null, e);
                    this.batch.addOperation(a), this.model.applyOperation(a), n || o || (n = i, o = t.parent.nextSibling), i = (t = this.createPositionAfter(t.parent)).parent
                } while (i !== e);
                return {
                    position: t,
                    range: new Pl(El._createAt(n, "end"), El._createAt(o, 0))
                }
            }
            wrap(t, e) {
                if (this._assertWriterUsedCorrectly(), !t.isFlat) throw new b("writer-wrap-range-not-flat", this);
                const n = e instanceof vl ? e : new vl(e);
                if (n.childCount > 0) throw new b("writer-wrap-element-not-empty", this);
                if (null !== n.parent) throw new b("writer-wrap-element-attached", this);
                this.insert(n, t.start);
                const o = new Pl(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
                this.move(o, El._createAt(n, 0))
            }
            unwrap(t) {
                if (this._assertWriterUsedCorrectly(), null === t.parent) throw new b("writer-unwrap-element-no-parent", this);
                this.move(Pl._createIn(t), this.createPositionAfter(t)), this.remove(t)
            }
            addMarker(t, e) {
                if (this._assertWriterUsedCorrectly(), !e || "boolean" != typeof e.usingOperation) throw new b("writer-addmarker-no-usingoperation", this);
                const n = e.usingOperation,
                    o = e.range,
                    i = void 0 !== e.affectsData && e.affectsData;
                if (this.model.markers.has(t)) throw new b("writer-addmarker-marker-exists", this);
                if (!o) throw new b("writer-addmarker-no-range", this);
                return n ? (Hh(this, t, null, o, i), this.model.markers.get(t)) : this.model.markers._set(t, o, n, i)
            }
            updateMarker(t, e) {
                this._assertWriterUsedCorrectly();
                const n = "string" == typeof t ? t : t.name,
                    o = this.model.markers.get(n);
                if (!o) throw new b("writer-updatemarker-marker-not-exists", this);
                if (!e) return k("writer-updatemarker-reconvert-using-editingcontroller", {
                    markerName: n
                }), void this.model.markers._refresh(o);
                const i = "boolean" == typeof e.usingOperation,
                    r = "boolean" == typeof e.affectsData,
                    s = r ? e.affectsData : o.affectsData;
                if (!i && !e.range && !r) throw new b("writer-updatemarker-wrong-options", this);
                const a = o.getRange(),
                    l = e.range ? e.range : a;
                i && e.usingOperation !== o.managedUsingOperations ? e.usingOperation ? Hh(this, n, null, l, s) : (Hh(this, n, a, null, s), this.model.markers._set(n, l, void 0, s)) : o.managedUsingOperations ? Hh(this, n, a, l, s) : this.model.markers._set(n, l, void 0, s)
            }
            removeMarker(t) {
                this._assertWriterUsedCorrectly();
                const e = "string" == typeof t ? t : t.name;
                if (!this.model.markers.has(e)) throw new b("writer-removemarker-no-marker", this);
                const n = this.model.markers.get(e);
                if (!n.managedUsingOperations) return void this.model.markers._remove(e);
                Hh(this, e, n.getRange(), null, n.affectsData)
            }
            addRoot(t, e = "$root") {
                this._assertWriterUsedCorrectly();
                const n = this.model.document.getRoot(t);
                if (n && n.isAttached()) throw new b("writer-addroot-root-exists", this);
                const o = this.model.document,
                    i = new Ld(t, e, !0, o, o.version);
                return this.batch.addOperation(i), this.model.applyOperation(i), this.model.document.getRoot(t)
            }
            detachRoot(t) {
                this._assertWriterUsedCorrectly();
                const e = "string" == typeof t ? this.model.document.getRoot(t) : t;
                if (!e || !e.isAttached()) throw new b("writer-detachroot-no-root", this);
                for (const t of this.model.markers) t.getRange().root === e && this.removeMarker(t);
                for (const t of e.getAttributeKeys()) this.removeAttribute(t, e);
                this.remove(this.createRangeIn(e));
                const n = this.model.document,
                    o = new Ld(e.rootName, e.name, !1, n, n.version);
                this.batch.addOperation(o), this.model.applyOperation(o)
            }
            setSelection(...t) {
                this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(...t)
            }
            setSelectionFocus(t, e) {
                this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(t, e)
            }
            setSelectionAttribute(t, e) {
                if (this._assertWriterUsedCorrectly(), "string" == typeof t) this._setSelectionAttribute(t, e);
                else
                    for (const [e, n] of Ti(t)) this._setSelectionAttribute(e, n)
            }
            removeSelectionAttribute(t) {
                if (this._assertWriterUsedCorrectly(), "string" == typeof t) this._removeSelectionAttribute(t);
                else
                    for (const e of t) this._removeSelectionAttribute(e)
            }
            overrideSelectionGravity() {
                return this.model.document.selection._overrideGravity()
            }
            restoreSelectionGravity(t) {
                this.model.document.selection._restoreGravity(t)
            }
            _setSelectionAttribute(t, e) {
                const n = this.model.document.selection;
                if (n.isCollapsed && n.anchor.parent.isEmpty) {
                    const o = rc._getStoreAttributeKey(t);
                    this.setAttribute(o, e, n.anchor.parent)
                }
                n._setAttribute(t, e)
            }
            _removeSelectionAttribute(t) {
                const e = this.model.document.selection;
                if (e.isCollapsed && e.anchor.parent.isEmpty) {
                    const n = rc._getStoreAttributeKey(t);
                    this.removeAttribute(n, e.anchor.parent)
                }
                e._removeAttribute(t)
            }
            _assertWriterUsedCorrectly() {
                if (this.model._currentWriter !== this) throw new b("writer-incorrect-use", this)
            }
            _addOperationForAffectedMarkers(t, e) {
                for (const n of this.model.markers) {
                    if (!n.managedUsingOperations) continue;
                    const o = n.getRange();
                    let i = !1;
                    if ("move" === t) {
                        const t = e;
                        i = t.containsPosition(o.start) || t.start.isEqual(o.start) || t.containsPosition(o.end) || t.end.isEqual(o.end)
                    } else {
                        const t = e,
                            n = t.nodeBefore,
                            r = t.nodeAfter,
                            s = o.start.parent == n && o.start.isAtEnd,
                            a = o.end.parent == r && 0 == o.end.offset,
                            l = o.end.nodeAfter == r,
                            c = o.start.nodeAfter == r;
                        i = s || a || l || c
                    }
                    i && this.updateMarker(n.name, {
                        range: o
                    })
                }
            }
        }

        function Nh(t, e, n, o) {
            const i = t.model,
                r = i.document;
            let s, a, l, c = o.start;
            for (const t of o.getWalker({
                    shallow: !0
                })) l = t.item.getAttribute(e), s && a != l && (a != n && d(), c = s), s = t.nextPosition, a = l;

            function d() {
                const o = new Pl(c, s),
                    l = o.root.document ? r.version : null,
                    d = new Od(o, e, a, n, l);
                t.batch.addOperation(d), i.applyOperation(d)
            }
            s instanceof El && s != c && a != n && d()
        }

        function Lh(t, e, n, o) {
            const i = t.model,
                r = i.document,
                s = o.getAttribute(e);
            let a, l;
            if (s != n) {
                if (o.root === o) {
                    const t = o.document ? r.version : null;
                    l = new Nd(o, e, s, n, t)
                } else {
                    a = new Pl(El._createBefore(o), t.createPositionAfter(o));
                    const i = a.root.document ? r.version : null;
                    l = new Od(a, e, s, n, i)
                }
                t.batch.addOperation(l), i.applyOperation(l)
            }
        }

        function Hh(t, e, n, o, i) {
            const r = t.model,
                s = r.document,
                a = new zd(e, n, o, r.markers, !!i, s.version);
            t.batch.addOperation(a), r.applyOperation(a)
        }

        function jh(t, e, n, o) {
            let i;
            if (t.root.document) {
                const n = o.document,
                    r = new El(n.graveyard, [0]);
                i = new Bd(t, e, r, n.version)
            } else i = new Oh(t, e);
            n.addOperation(i), o.applyOperation(i)
        }

        function qh(t, e) {
            return t === e || t instanceof mh && e instanceof mh
        }

        function Wh(t, e, n = {}) {
            if (e.isCollapsed) return;
            const o = e.getFirstRange();
            if ("$graveyard" == o.root.rootName) return;
            const i = t.schema;
            t.change((t => {
                if (!n.doNotResetEntireContent && function(t, e) {
                        const n = t.getLimitElement(e);
                        if (!e.containsEntireContent(n)) return !1;
                        const o = e.getFirstRange();
                        if (o.start.parent == o.end.parent) return !1;
                        return t.checkChild(n, "paragraph")
                    }(i, e)) return void
                function(t, e) {
                    const n = t.model.schema.getLimitElement(e);
                    t.remove(t.createRangeIn(n)), Kh(t, t.createPositionAt(n, 0), e)
                }(t, e);
                const r = {};
                if (!n.doNotAutoparagraph) {
                    const t = e.getSelectedElement();
                    t && Object.assign(r, i.getAttributesWithProperty(t, "copyOnReplace", !0))
                }
                const [s, a] = function(t) {
                    const e = t.root.document.model,
                        n = t.start;
                    let o = t.end;
                    if (e.hasContent(t, {
                            ignoreMarkers: !0
                        })) {
                        const n = function(t) {
                            const e = t.parent,
                                n = e.root.document.model.schema,
                                o = e.getAncestors({
                                    parentFirst: !0,
                                    includeSelf: !0
                                });
                            for (const t of o) {
                                if (n.isLimit(t)) return null;
                                if (n.isBlock(t)) return t
                            }
                        }(o);
                        if (n && o.isTouching(e.createPositionAt(n, 0))) {
                            const n = e.createSelection(t);
                            e.modifySelection(n, {
                                direction: "backward"
                            });
                            const i = n.getLastPosition(),
                                r = e.createRange(i, o);
                            e.hasContent(r, {
                                ignoreMarkers: !0
                            }) || (o = i)
                        }
                    }
                    return [th.fromPosition(n, "toPrevious"), th.fromPosition(o, "toNext")]
                }(o);
                s.isTouching(a) || t.remove(t.createRange(s, a)), n.leaveUnmerged || (! function(t, e, n) {
                    const o = t.model;
                    if (!Gh(t.model.schema, e, n)) return;
                    const [i, r] = function(t, e) {
                        const n = t.getAncestors(),
                            o = e.getAncestors();
                        let i = 0;
                        for (; n[i] && n[i] == o[i];) i++;
                        return [n[i], o[i]]
                    }(e, n);
                    if (!i || !r) return;
                    !o.hasContent(i, {
                        ignoreMarkers: !0
                    }) && o.hasContent(r, {
                        ignoreMarkers: !0
                    }) ? $h(t, e, n, i.parent) : Uh(t, e, n, i.parent)
                }(t, s, a), i.removeDisallowedAttributes(s.parent.getChildren(), t)), Zh(t, e, s), !n.doNotAutoparagraph && function(t, e) {
                    const n = t.checkChild(e, "$text"),
                        o = t.checkChild(e, "paragraph");
                    return !n && o
                }(i, s) && Kh(t, s, e, r), s.detach(), a.detach()
            }))
        }

        function Uh(t, e, n, o) {
            const i = e.parent,
                r = n.parent;
            if (i != o && r != o) {
                for (e = t.createPositionAfter(i), (n = t.createPositionBefore(r)).isEqual(e) || t.insert(r, e), t.merge(e); n.parent.isEmpty;) {
                    const e = n.parent;
                    n = t.createPositionBefore(e), t.remove(e)
                }
                Gh(t.model.schema, e, n) && Uh(t, e, n, o)
            }
        }

        function $h(t, e, n, o) {
            const i = e.parent,
                r = n.parent;
            if (i != o && r != o) {
                for (e = t.createPositionAfter(i), (n = t.createPositionBefore(r)).isEqual(e) || t.insert(i, n); e.parent.isEmpty;) {
                    const n = e.parent;
                    e = t.createPositionBefore(n), t.remove(n)
                }
                n = t.createPositionBefore(r),
                    function(t, e) {
                        const n = e.nodeBefore,
                            o = e.nodeAfter;
                        n.name != o.name && t.rename(n, o.name);
                        t.clearAttributes(n), t.setAttributes(Object.fromEntries(o.getAttributes()), n), t.merge(e)
                    }(t, n), Gh(t.model.schema, e, n) && $h(t, e, n, o)
            }
        }

        function Gh(t, e, n) {
            const o = e.parent,
                i = n.parent;
            return o != i && (!t.isLimit(o) && !t.isLimit(i) && function(t, e, n) {
                const o = new Pl(t, e);
                for (const t of o.getWalker())
                    if (n.isLimit(t.item)) return !1;
                return !0
            }(e, n, t))
        }

        function Kh(t, e, n, o = {}) {
            const i = t.createElement("paragraph");
            t.model.schema.setAllowedAttributes(i, o, t), t.insert(i, e), Zh(t, n, t.createPositionAt(i, 0))
        }

        function Zh(t, e, n) {
            e instanceof rc ? t.setSelection(n) : e.setTo(n)
        }

        function Jh(t, e) {
            const n = [];
            Array.from(t.getItems({
                direction: "backward"
            })).map((t => e.createRangeOn(t))).filter((e => (e.start.isAfter(t.start) || e.start.isEqual(t.start)) && (e.end.isBefore(t.end) || e.end.isEqual(t.end)))).forEach((t => {
                n.push(t.start.parent), e.remove(t)
            })), n.forEach((t => {
                let n = t;
                for (; n.parent && n.isEmpty;) {
                    const t = e.createRangeOn(n);
                    n = n.parent, e.remove(t)
                }
            }))
        }
        class Yh {
            constructor(t, e, n) {
                this._firstNode = null, this._lastNode = null, this._lastAutoParagraph = null, this._filterAttributesOf = [], this._affectedStart = null, this._affectedEnd = null, this._nodeToSelect = null, this.model = t, this.writer = e, this.position = n, this.canMergeWith = new Set([this.position.parent]), this.schema = t.schema, this._documentFragment = e.createDocumentFragment(), this._documentFragmentPosition = e.createPositionAt(this._documentFragment, 0)
            }
            handleNodes(t) {
                for (const e of Array.from(t)) this._handleNode(e);
                this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = []
            }
            _updateLastNodeFromAutoParagraph(t) {
                const e = this.writer.createPositionAfter(this._lastNode),
                    n = this.writer.createPositionAfter(t);
                if (n.isAfter(e)) {
                    if (this._lastNode = t, this.position.parent != t || !this.position.isAtEnd) throw new b("insertcontent-invalid-insertion-position", this);
                    this.position = n, this._setAffectedBoundaries(this.position)
                }
            }
            getSelectionRange() {
                return this._nodeToSelect ? Pl._createOn(this._nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position)
            }
            getAffectedRange() {
                return this._affectedStart ? new Pl(this._affectedStart, this._affectedEnd) : null
            }
            destroy() {
                this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach()
            }
            _handleNode(t) {
                if (this.schema.isObject(t)) return void this._handleObject(t);
                let e = this._checkAndAutoParagraphToAllowedPosition(t);
                e || (e = this._checkAndSplitToAllowedPosition(t), e) ? (this._appendToFragment(t), this._firstNode || (this._firstNode = t), this._lastNode = t) : this._handleDisallowedNode(t)
            }
            _insertPartialFragment() {
                if (this._documentFragment.isEmpty) return;
                const t = th.fromPosition(this.position, "toNext");
                this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = t.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = t.toPosition(), t.detach()
            }
            _handleObject(t) {
                this._checkAndSplitToAllowedPosition(t) ? this._appendToFragment(t) : this._tryAutoparagraphing(t)
            }
            _handleDisallowedNode(t) {
                t.is("element") ? this.handleNodes(t.getChildren()) : this._tryAutoparagraphing(t)
            }
            _appendToFragment(t) {
                if (!this.schema.checkChild(this.position, t)) throw new b("insertcontent-wrong-position", this, {
                    node: t,
                    position: this.position
                });
                this.writer.insert(t, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(t.offsetSize), this.schema.isObject(t) && !this.schema.checkChild(this.position, "$text") ? this._nodeToSelect = t : this._nodeToSelect = null, this._filterAttributesOf.push(t)
            }
            _setAffectedBoundaries(t) {
                this._affectedStart || (this._affectedStart = th.fromPosition(t, "toPrevious")), this._affectedEnd && !this._affectedEnd.isBefore(t) || (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = th.fromPosition(t, "toNext"))
            }
            _mergeOnLeft() {
                const t = this._firstNode;
                if (!(t instanceof vl)) return;
                if (!this._canMergeLeft(t)) return;
                const e = th._createBefore(t);
                e.stickiness = "toNext";
                const n = th.fromPosition(this.position, "toNext");
                this._affectedStart.isEqual(e) && (this._affectedStart.detach(), this._affectedStart = th._createAt(e.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = e.nodeBefore, this._lastNode = e.nodeBefore), this.writer.merge(e), e.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = th._createAt(e.nodeBefore, "end", "toNext")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), e.detach()
            }
            _mergeOnRight() {
                const t = this._lastNode;
                if (!(t instanceof vl)) return;
                if (!this._canMergeRight(t)) return;
                const e = th._createAfter(t);
                if (e.stickiness = "toNext", !this.position.isEqual(e)) throw new b("insertcontent-invalid-insertion-position", this);
                this.position = El._createAt(e.nodeBefore, "end");
                const n = th.fromPosition(this.position, "toPrevious");
                this._affectedEnd.isEqual(e) && (this._affectedEnd.detach(), this._affectedEnd = th._createAt(e.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = e.nodeBefore, this._lastNode = e.nodeBefore), this.writer.merge(e), e.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = th._createAt(e.nodeBefore, 0, "toPrevious")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), e.detach()
            }
            _canMergeLeft(t) {
                const e = t.previousSibling;
                return e instanceof vl && this.canMergeWith.has(e) && this.model.schema.checkMerge(e, t)
            }
            _canMergeRight(t) {
                const e = t.nextSibling;
                return e instanceof vl && this.canMergeWith.has(e) && this.model.schema.checkMerge(t, e)
            }
            _tryAutoparagraphing(t) {
                const e = this.writer.createElement("paragraph");
                this._getAllowedIn(this.position.parent, e) && this.schema.checkChild(e, t) && (e._appendChild(t), this._handleNode(e))
            }
            _checkAndAutoParagraphToAllowedPosition(t) {
                if (this.schema.checkChild(this.position.parent, t)) return !0;
                if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", t)) return !1;
                this._insertPartialFragment();
                const e = this.writer.createElement("paragraph");
                return this.writer.insert(e, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = e, this.position = this.writer.createPositionAt(e, 0), !0
            }
            _checkAndSplitToAllowedPosition(t) {
                const e = this._getAllowedIn(this.position.parent, t);
                if (!e) return !1;
                for (e != this.position.parent && this._insertPartialFragment(); e != this.position.parent;)
                    if (this.position.isAtStart) {
                        const t = this.position.parent;
                        this.position = this.writer.createPositionBefore(t), t.isEmpty && t.parent === e && this.writer.remove(t)
                    } else if (this.position.isAtEnd) this.position = this.writer.createPositionAfter(this.position.parent);
                else {
                    const t = this.writer.createPositionAfter(this.position.parent);
                    this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = t, this.canMergeWith.add(this.position.nodeAfter)
                }
                return !0
            }
            _getAllowedIn(t, e) {
                return this.schema.checkChild(t, e) ? t : this.schema.isLimit(t) ? null : this._getAllowedIn(t.parent, e)
            }
        }

        function Qh(t, e, n = "auto") {
            const o = t.getSelectedElement();
            if (o && e.schema.isObject(o) && !e.schema.isInline(o)) return "before" == n || "after" == n ? e.createRange(e.createPositionAt(o, n)) : e.createRangeOn(o);
            const i = Ei(t.getSelectedBlocks());
            if (!i) return e.createRange(t.focus);
            if (i.isEmpty) return e.createRange(e.createPositionAt(i, 0));
            const r = e.createPositionAfter(i);
            return t.focus.isTouching(r) ? e.createRange(r) : e.createRange(e.createPositionBefore(i))
        }

        function Xh(t, e, n, o = {}) {
            if (!t.schema.isObject(e)) throw new b("insertobject-element-not-an-object", t, {
                object: e
            });
            const i = n || t.document.selection;
            let r = i;
            o.findOptimalPosition && t.schema.isBlock(e) && (r = t.createSelection(Qh(i, t, o.findOptimalPosition)));
            const s = Ei(i.getSelectedBlocks()),
                a = {};
            return s && Object.assign(a, t.schema.getAttributesWithProperty(s, "copyOnReplace", !0)), t.change((n => {
                r.isCollapsed || t.deleteContent(r, {
                    doNotAutoparagraph: !0
                });
                let i = e;
                const s = r.anchor.parent;
                !t.schema.checkChild(s, e) && t.schema.checkChild(s, "paragraph") && t.schema.checkChild("paragraph", e) && (i = n.createElement("paragraph"), n.insert(e, i)), t.schema.setAllowedAttributes(i, a, n);
                const l = t.insertContent(i, r);
                return l.isCollapsed || o.setSelection && function(t, e, n, o) {
                    const i = t.model;
                    if ("on" == n) return void t.setSelection(e, "on");
                    if ("after" != n) throw new b("insertobject-invalid-place-parameter-value", i);
                    let r = e.nextSibling;
                    if (i.schema.isInline(e)) return void t.setSelection(e, "after");
                    const s = r && i.schema.checkChild(r, "$text");
                    !s && i.schema.checkChild(e.parent, "paragraph") && (r = t.createElement("paragraph"), i.schema.setAllowedAttributes(r, o, t), i.insertContent(r, t.createPositionAfter(e)));
                    r && t.setSelection(r, 0)
                }(n, e, o.setSelection, a), l
            }))
        }
        const tu = ' ,.?!:;"-()';

        function eu(t, e) {
            const {
                isForward: n,
                walker: o,
                unit: i,
                schema: r,
                treatEmojiAsSingleUnit: s
            } = t, {
                type: a,
                item: l,
                nextPosition: c
            } = e;
            if ("text" == a) return "word" === t.unit ? function(t, e) {
                let n = t.position.textNode;
                n || (n = e ? t.position.nodeAfter : t.position.nodeBefore);
                for (; n && n.is("$text");) {
                    const o = t.position.offset - n.startOffset;
                    if (iu(n, o, e)) n = e ? t.position.nodeAfter : t.position.nodeBefore;
                    else {
                        if (ou(n.data, o, e)) break;
                        t.next()
                    }
                }
                return t.position
            }(o, n) : function(t, e, n) {
                const o = t.position.textNode;
                if (o) {
                    const i = o.data;
                    let r = t.position.offset - o.startOffset;
                    for (; Ii(i, r) || "character" == e && Pi(i, r) || n && zi(i, r);) t.next(), r = t.position.offset - o.startOffset
                }
                return t.position
            }(o, i, s);
            if (a == (n ? "elementStart" : "elementEnd")) {
                if (r.isSelectable(l)) return El._createAt(l, n ? "after" : "before");
                if (r.checkChild(c, "$text")) return c
            } else {
                if (r.isLimit(l)) return void o.skip((() => !0));
                if (r.checkChild(c, "$text")) return c
            }
        }

        function nu(t, e) {
            const n = t.root,
                o = El._createAt(n, e ? "end" : 0);
            return e ? new Pl(t, o) : new Pl(o, t)
        }

        function ou(t, e, n) {
            const o = e + (n ? 0 : -1);
            return tu.includes(t.charAt(o))
        }

        function iu(t, e, n) {
            return e === (n ? t.offsetSize : 0)
        }
        class ru extends(q()) {
            constructor() {
                super(), this.markers = new zh, this.document = new xh(this), this.schema = new Gc, this._pendingChanges = [], this._currentWriter = null, ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((t => this.decorate(t))), this.on("applyOperation", ((t, e) => {
                    e[0]._validate()
                }), {
                    priority: "highest"
                }), this.schema.register("$root", {
                    isLimit: !0
                }), this.schema.register("$container", {
                    allowIn: ["$root", "$container"]
                }), this.schema.register("$block", {
                    allowIn: ["$root", "$container"],
                    isBlock: !0
                }), this.schema.register("$blockObject", {
                    allowWhere: "$block",
                    isBlock: !0,
                    isObject: !0
                }), this.schema.register("$inlineObject", {
                    allowWhere: "$text",
                    allowAttributesOf: "$text",
                    isInline: !0,
                    isObject: !0
                }), this.schema.register("$text", {
                    allowIn: "$block",
                    isInline: !0,
                    isContent: !0
                }), this.schema.register("$clipboardHolder", {
                    allowContentOf: "$root",
                    allowChildren: "$text",
                    isLimit: !0
                }), this.schema.register("$documentFragment", {
                    allowContentOf: "$root",
                    allowChildren: "$text",
                    isLimit: !0
                }), this.schema.register("$marker"), this.schema.addChildCheck(((t, e) => {
                    if ("$marker" === e.name) return !0
                })), Nc(this), this.document.registerPostFixer(_c), this.on("insertContent", ((t, [e, n]) => {
                    t.return = function(t, e, n) {
                        return t.change((o => {
                            const i = n || t.document.selection;
                            i.isCollapsed || t.deleteContent(i, {
                                doNotAutoparagraph: !0
                            });
                            const r = new Yh(t, o, i.anchor),
                                s = [];
                            let a;
                            if (e.is("documentFragment")) {
                                if (e.markers.size) {
                                    const t = [];
                                    for (const [n, o] of e.markers) {
                                        const {
                                            start: e,
                                            end: i
                                        } = o, r = e.isEqual(i);
                                        t.push({
                                            position: e,
                                            name: n,
                                            isCollapsed: r
                                        }, {
                                            position: i,
                                            name: n,
                                            isCollapsed: r
                                        })
                                    }
                                    t.sort((({
                                        position: t
                                    }, {
                                        position: e
                                    }) => t.isBefore(e) ? 1 : -1));
                                    for (const {
                                            position: n,
                                            name: i,
                                            isCollapsed: r
                                        }
                                        of t) {
                                        let t = null,
                                            a = null;
                                        const l = n.parent === e && n.isAtStart,
                                            c = n.parent === e && n.isAtEnd;
                                        l || c ? r && (a = l ? "start" : "end") : (t = o.createElement("$marker"), o.insert(t, n)), s.push({
                                            name: i,
                                            element: t,
                                            collapsed: a
                                        })
                                    }
                                }
                                a = e.getChildren()
                            } else a = [e];
                            r.handleNodes(a);
                            let l = r.getSelectionRange();
                            if (e.is("documentFragment") && s.length) {
                                const t = l ? ec.fromRange(l) : null,
                                    e = {};
                                for (let t = s.length - 1; t >= 0; t--) {
                                    const {
                                        name: n,
                                        element: i,
                                        collapsed: a
                                    } = s[t], l = !e[n];
                                    if (l && (e[n] = []), i) {
                                        const t = o.createPositionAt(i, "before");
                                        e[n].push(t), o.remove(i)
                                    } else {
                                        const t = r.getAffectedRange();
                                        if (!t) {
                                            a && e[n].push(r.position);
                                            continue
                                        }
                                        a ? e[n].push(t[a]) : e[n].push(l ? t.start : t.end)
                                    }
                                }
                                for (const [t, [n, i]] of Object.entries(e)) n && i && n.root === i.root && o.addMarker(t, {
                                    usingOperation: !0,
                                    affectsData: !0,
                                    range: new Pl(n, i)
                                });
                                t && (l = t.toRange(), t.detach())
                            }
                            l && (i instanceof rc ? o.setSelection(l) : i.setTo(l));
                            const c = r.getAffectedRange() || t.createRange(i.anchor);
                            return r.destroy(), c
                        }))
                    }(this, e, n)
                })), this.on("insertObject", ((t, [e, n, o]) => {
                    t.return = Xh(this, e, n, o)
                })), this.on("canEditAt", (t => {
                    const e = !this.document.isReadOnly;
                    t.return = e, e || t.stop()
                }))
            }
            change(t) {
                try {
                    return 0 === this._pendingChanges.length ? (this._pendingChanges.push({
                        batch: new oh,
                        callback: t
                    }), this._runPendingChanges()[0]) : t(this._currentWriter)
                } catch (t) {
                    b.rethrowUnexpectedError(t, this)
                }
            }
            enqueueChange(t, e) {
                try {
                    t ? "function" == typeof t ? (e = t, t = new oh) : t instanceof oh || (t = new oh(t)) : t = new oh, this._pendingChanges.push({
                        batch: t,
                        callback: e
                    }), 1 == this._pendingChanges.length && this._runPendingChanges()
                } catch (t) {
                    b.rethrowUnexpectedError(t, this)
                }
            }
            applyOperation(t) {
                t._execute()
            }
            insertContent(t, e, n, ...o) {
                const i = su(e, n);
                return this.fire("insertContent", [t, i, n, ...o])
            }
            insertObject(t, e, n, o, ...i) {
                const r = su(e, n);
                return this.fire("insertObject", [t, r, o, o, ...i])
            }
            deleteContent(t, e) {
                Wh(this, t, e)
            }
            modifySelection(t, e) {
                ! function(t, e, n = {}) {
                    const o = t.schema,
                        i = "backward" != n.direction,
                        r = n.unit ? n.unit : "character",
                        s = !!n.treatEmojiAsSingleUnit,
                        a = e.focus,
                        l = new yl({
                            boundaries: nu(a, i),
                            singleCharacters: !0,
                            direction: i ? "forward" : "backward"
                        }),
                        c = {
                            walker: l,
                            schema: o,
                            isForward: i,
                            unit: r,
                            treatEmojiAsSingleUnit: s
                        };
                    let d;
                    for (; d = l.next();) {
                        if (d.done) return;
                        const n = eu(c, d.value);
                        if (n) return void(e instanceof rc ? t.change((t => {
                            t.setSelectionFocus(n)
                        })) : e.setFocus(n))
                    }
                }(this, t, e)
            }
            getSelectedContent(t) {
                return function(t, e) {
                    return t.change((t => {
                        const n = t.createDocumentFragment(),
                            o = e.getFirstRange();
                        if (!o || o.isCollapsed) return n;
                        const i = o.start.root,
                            r = o.start.getCommonPath(o.end),
                            s = i.getNodeByPath(r);
                        let a;
                        a = o.start.parent == o.end.parent ? o : t.createRange(t.createPositionAt(s, o.start.path[r.length]), t.createPositionAt(s, o.end.path[r.length] + 1));
                        const l = a.end.offset - a.start.offset;
                        for (const e of a.getItems({
                                shallow: !0
                            })) e.is("$textProxy") ? t.appendText(e.data, e.getAttributes(), n) : t.append(t.cloneElement(e, !0), n);
                        if (a != o) {
                            const e = o._getTransformedByMove(a.start, t.createPositionAt(n, 0), l)[0],
                                i = t.createRange(t.createPositionAt(n, 0), e.start);
                            Jh(t.createRange(e.end, t.createPositionAt(n, "end")), t), Jh(i, t)
                        }
                        return n
                    }))
                }(this, t)
            }
            hasContent(t, e = {}) {
                const n = t instanceof Pl ? t : Pl._createIn(t);
                if (n.isCollapsed) return !1;
                const {
                    ignoreWhitespaces: o = !1,
                    ignoreMarkers: i = !1
                } = e;
                if (!i)
                    for (const t of this.markers.getMarkersIntersectingRange(n))
                        if (t.affectsData) return !0;
                for (const t of n.getItems())
                    if (this.schema.isContent(t)) {
                        if (!t.is("$textProxy")) return !0;
                        if (!o) return !0;
                        if (-1 !== t.data.search(/\S/)) return !0
                    } return !1
            }
            canEditAt(t) {
                const e = su(t);
                return this.fire("canEditAt", [e])
            }
            createPositionFromPath(t, e, n) {
                return new El(t, e, n)
            }
            createPositionAt(t, e) {
                return El._createAt(t, e)
            }
            createPositionAfter(t) {
                return El._createAfter(t)
            }
            createPositionBefore(t) {
                return El._createBefore(t)
            }
            createRange(t, e) {
                return new Pl(t, e)
            }
            createRangeIn(t) {
                return Pl._createIn(t)
            }
            createRangeOn(t) {
                return Pl._createOn(t)
            }
            createSelection(...t) {
                return new Kl(...t)
            }
            createBatch(t) {
                return new oh(t)
            }
            createOperationFromJSON(t) {
                return jd.fromJSON(t, this.document)
            }
            destroy() {
                this.document.destroy(), this.stopListening()
            }
            _runPendingChanges() {
                const t = [];
                this.fire("_beforeChanges");
                try {
                    for (; this._pendingChanges.length;) {
                        const e = this._pendingChanges[0].batch;
                        this._currentWriter = new Mh(this, e);
                        const n = this._pendingChanges[0].callback(this._currentWriter);
                        t.push(n), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null
                    }
                } finally {
                    this._pendingChanges.length = 0, this._currentWriter = null, this.fire("_afterChanges")
                }
                return t
            }
        }

        function su(t, e) {
            if (t) return t instanceof Kl || t instanceof rc ? t : t instanceof wl ? e || 0 === e ? new Kl(t, e) : t.is("rootElement") ? new Kl(t, "in") : new Kl(t, "on") : new Kl(t)
        }
        class au extends va {
            constructor() {
                super(...arguments), this.domEventType = "click"
            }
            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }
        class lu extends va {
            constructor() {
                super(...arguments), this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"]
            }
            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }
        class cu {
            constructor(t) {
                this.document = t
            }
            createDocumentFragment(t) {
                return new Os(this.document, t)
            }
            createElement(t, e, n) {
                return new rs(this.document, t, e, n)
            }
            createText(t) {
                return new or(this.document, t)
            }
            clone(t, e = !1) {
                return t._clone(e)
            }
            appendChild(t, e) {
                return e._appendChild(t)
            }
            insertChild(t, e, n) {
                return n._insertChild(t, e)
            }
            removeChildren(t, e, n) {
                return n._removeChildren(t, e)
            }
            remove(t) {
                const e = t.parent;
                return e ? this.removeChildren(e.getChildIndex(t), 1, e) : []
            }
            replace(t, e) {
                const n = t.parent;
                if (n) {
                    const o = n.getChildIndex(t);
                    return this.removeChildren(o, 1, n), this.insertChild(o, e, n), !0
                }
                return !1
            }
            unwrapElement(t) {
                const e = t.parent;
                if (e) {
                    const n = e.getChildIndex(t);
                    this.remove(t), this.insertChild(n, t.getChildren(), e)
                }
            }
            rename(t, e) {
                const n = new rs(this.document, t, e.getAttributes(), e.getChildren());
                return this.replace(e, n) ? n : null
            }
            setAttribute(t, e, n) {
                n._setAttribute(t, e)
            }
            removeAttribute(t, e) {
                e._removeAttribute(t)
            }
            addClass(t, e) {
                e._addClass(t)
            }
            removeClass(t, e) {
                e._removeClass(t)
            }
            setStyle(t, e, n) {
                vt(t) && void 0 === n ? e._setStyle(t) : n._setStyle(t, e)
            }
            removeStyle(t, e) {
                e._removeStyle(t)
            }
            setCustomProperty(t, e, n) {
                n._setCustomProperty(t, e)
            }
            removeCustomProperty(t, e) {
                return e._removeCustomProperty(t)
            }
            createPositionAt(t, e) {
                return gs._createAt(t, e)
            }
            createPositionAfter(t) {
                return gs._createAfter(t)
            }
            createPositionBefore(t) {
                return gs._createBefore(t)
            }
            createRange(t, e) {
                return new ms(t, e)
            }
            createRangeOn(t) {
                return ms._createOn(t)
            }
            createRangeIn(t) {
                return ms._createIn(t)
            }
            createSelection(...t) {
                return new fs(...t)
            }
        }
        const du = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i,
            hu = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i,
            uu = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i,
            gu = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i,
            mu = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i,
            pu = /\w+\((?:[^()]|\([^()]*\))*\)|\S+/gi,
            fu = new Set(["black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange", "aliceblue", "antiquewhite", "aquamarine", "azure", "beige", "bisque", "blanchedalmond", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "gainsboro", "ghostwhite", "gold", "goldenrod", "greenyellow", "grey", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "limegreen", "linen", "magenta", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "oldlace", "olivedrab", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "thistle", "tomato", "turquoise", "violet", "wheat", "whitesmoke", "yellowgreen", "activeborder", "activecaption", "appworkspace", "background", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "captiontext", "graytext", "highlight", "highlighttext", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infobackground", "infotext", "menu", "menutext", "scrollbar", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "window", "windowframe", "windowtext", "rebeccapurple", "currentcolor", "transparent"]);

        function bu(t) {
            return t.startsWith("#") ? du.test(t) : t.startsWith("rgb") ? hu.test(t) || uu.test(t) : t.startsWith("hsl") ? gu.test(t) || mu.test(t) : fu.has(t.toLowerCase())
        }
        const ku = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"];

        function wu(t) {
            return ku.includes(t)
        }
        const Au = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;

        function Cu(t) {
            return Au.test(t)
        }
        const _u = /^[+-]?[0-9]*([.][0-9]+)?%$/;

        function vu(t) {
            return _u.test(t)
        }
        const yu = ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"];

        function xu(t) {
            return yu.includes(t)
        }
        const Eu = ["center", "top", "bottom", "left", "right"];

        function Du(t) {
            return Eu.includes(t)
        }
        const Su = ["fixed", "scroll", "local"];

        function Tu(t) {
            return Su.includes(t)
        }
        const Bu = /^url\(/;

        function Iu(t) {
            return Bu.test(t)
        }

        function Pu(t = "") {
            if ("" === t) return {
                top: void 0,
                right: void 0,
                bottom: void 0,
                left: void 0
            };
            const e = Ou(t),
                n = e[0],
                o = e[2] || n,
                i = e[1] || n;
            return {
                top: n,
                bottom: o,
                right: i,
                left: e[3] || i
            }
        }

        function Ru(t) {
            return e => {
                const {
                    top: n,
                    right: o,
                    bottom: i,
                    left: r
                } = e, s = [];
                return [n, o, r, i].every((t => !!t)) ? s.push([t, zu(e)]) : (n && s.push([t + "-top", n]), o && s.push([t + "-right", o]), i && s.push([t + "-bottom", i]), r && s.push([t + "-left", r])), s
            }
        }

        function zu({
            top: t,
            right: e,
            bottom: n,
            left: o
        }) {
            const i = [];
            return o !== e ? i.push(t, e, n, o) : n !== t ? i.push(t, e, n) : e !== t ? i.push(t, e) : i.push(t), i.join(" ")
        }

        function Vu(t) {
            return e => ({
                path: t,
                value: Pu(e)
            })
        }

        function Ou(t) {
            const e = t.matchAll(pu);
            return Array.from(e).map((t => t[0]))
        }

        function Fu(t) {
            t.setNormalizer("background", (t => {
                const e = {},
                    n = Ou(t);
                for (const t of n) xu(t) ? (e.repeat = e.repeat || [], e.repeat.push(t)) : Du(t) ? (e.position = e.position || [], e.position.push(t)) : Tu(t) ? e.attachment = t : bu(t) ? e.color = t : Iu(t) && (e.image = t);
                return {
                    path: "background",
                    value: e
                }
            })), t.setNormalizer("background-color", (t => ({
                path: "background.color",
                value: t
            }))), t.setReducer("background", (t => {
                const e = [];
                return e.push(["background-color", t.color]), e
            })), t.setStyleRelation("background", ["background-color"])
        }

        function Mu(t) {
            t.setNormalizer("border", (t => {
                const {
                    color: e,
                    style: n,
                    width: o
                } = Uu(t);
                return {
                    path: "border",
                    value: {
                        color: Pu(e),
                        style: Pu(n),
                        width: Pu(o)
                    }
                }
            })), t.setNormalizer("border-top", Nu("top")), t.setNormalizer("border-right", Nu("right")), t.setNormalizer("border-bottom", Nu("bottom")), t.setNormalizer("border-left", Nu("left")), t.setNormalizer("border-color", Lu("color")), t.setNormalizer("border-width", Lu("width")), t.setNormalizer("border-style", Lu("style")), t.setNormalizer("border-top-color", ju("color", "top")), t.setNormalizer("border-top-style", ju("style", "top")), t.setNormalizer("border-top-width", ju("width", "top")), t.setNormalizer("border-right-color", ju("color", "right")), t.setNormalizer("border-right-style", ju("style", "right")), t.setNormalizer("border-right-width", ju("width", "right")), t.setNormalizer("border-bottom-color", ju("color", "bottom")), t.setNormalizer("border-bottom-style", ju("style", "bottom")), t.setNormalizer("border-bottom-width", ju("width", "bottom")), t.setNormalizer("border-left-color", ju("color", "left")), t.setNormalizer("border-left-style", ju("style", "left")), t.setNormalizer("border-left-width", ju("width", "left")), t.setExtractor("border-top", qu("top")), t.setExtractor("border-right", qu("right")), t.setExtractor("border-bottom", qu("bottom")), t.setExtractor("border-left", qu("left")), t.setExtractor("border-top-color", "border.color.top"), t.setExtractor("border-right-color", "border.color.right"), t.setExtractor("border-bottom-color", "border.color.bottom"), t.setExtractor("border-left-color", "border.color.left"), t.setExtractor("border-top-width", "border.width.top"), t.setExtractor("border-right-width", "border.width.right"), t.setExtractor("border-bottom-width", "border.width.bottom"), t.setExtractor("border-left-width", "border.width.left"), t.setExtractor("border-top-style", "border.style.top"), t.setExtractor("border-right-style", "border.style.right"), t.setExtractor("border-bottom-style", "border.style.bottom"), t.setExtractor("border-left-style", "border.style.left"), t.setReducer("border-color", Ru("border-color")), t.setReducer("border-style", Ru("border-style")), t.setReducer("border-width", Ru("border-width")), t.setReducer("border-top", $u("top")), t.setReducer("border-right", $u("right")), t.setReducer("border-bottom", $u("bottom")), t.setReducer("border-left", $u("left")), t.setReducer("border", function() {
                return e => {
                    const n = Wu(e, "top"),
                        o = Wu(e, "right"),
                        i = Wu(e, "bottom"),
                        r = Wu(e, "left"),
                        s = [n, o, i, r],
                        a = {
                            width: t(s, "width"),
                            style: t(s, "style"),
                            color: t(s, "color")
                        },
                        l = Gu(a, "all");
                    if (l.length) return l;
                    return [...Object.entries(a).reduce(((t, [e, n]) => (n && (t.push([`border-${e}`, n]), s.forEach((t => delete t[e]))), t)), []), ...Gu(n, "top"), ...Gu(o, "right"), ...Gu(i, "bottom"), ...Gu(r, "left")]
                };

                function t(t, e) {
                    return t.map((t => t[e])).reduce(((t, e) => t == e ? t : null))
                }
            }()), t.setStyleRelation("border", ["border-color", "border-style", "border-width", "border-top", "border-right", "border-bottom", "border-left", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "border-top-style", "border-right-style", "border-bottom-style", "border-left-style", "border-top-width", "border-right-width", "border-bottom-width", "border-left-width"]), t.setStyleRelation("border-color", ["border-top-color", "border-right-color", "border-bottom-color", "border-left-color"]), t.setStyleRelation("border-style", ["border-top-style", "border-right-style", "border-bottom-style", "border-left-style"]), t.setStyleRelation("border-width", ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"]), t.setStyleRelation("border-top", ["border-top-color", "border-top-style", "border-top-width"]), t.setStyleRelation("border-right", ["border-right-color", "border-right-style", "border-right-width"]), t.setStyleRelation("border-bottom", ["border-bottom-color", "border-bottom-style", "border-bottom-width"]), t.setStyleRelation("border-left", ["border-left-color", "border-left-style", "border-left-width"])
        }

        function Nu(t) {
            return e => {
                const {
                    color: n,
                    style: o,
                    width: i
                } = Uu(e), r = {};
                return void 0 !== n && (r.color = {
                    [t]: n
                }), void 0 !== o && (r.style = {
                    [t]: o
                }), void 0 !== i && (r.width = {
                    [t]: i
                }), {
                    path: "border",
                    value: r
                }
            }
        }

        function Lu(t) {
            return e => ({
                path: "border",
                value: Hu(e, t)
            })
        }

        function Hu(t, e) {
            return {
                [e]: Pu(t)
            }
        }

        function ju(t, e) {
            return n => ({
                path: "border",
                value: {
                    [t]: {
                        [e]: n
                    }
                }
            })
        }

        function qu(t) {
            return (e, n) => {
                if (n.border) return Wu(n.border, t)
            }
        }

        function Wu(t, e) {
            const n = {};
            return t.width && t.width[e] && (n.width = t.width[e]), t.style && t.style[e] && (n.style = t.style[e]), t.color && t.color[e] && (n.color = t.color[e]), n
        }

        function Uu(t) {
            const e = {},
                n = Ou(t);
            for (const t of n) Cu(t) || /thin|medium|thick/.test(t) ? e.width = t : wu(t) ? e.style = t : e.color = t;
            return e
        }

        function $u(t) {
            return e => Gu(e, t)
        }

        function Gu(t, e) {
            const n = [];
            if (t && t.width && n.push("width"), t && t.style && n.push("style"), t && t.color && n.push("color"), 3 == n.length) {
                const o = n.map((e => t[e])).join(" ");
                return ["all" == e ? ["border", o] : [`border-${e}`, o]]
            }
            return "all" == e ? [] : n.map((n => [`border-${e}-${n}`, t[n]]))
        }

        function Ku(t) {
            t.setNormalizer("margin", Vu("margin")), t.setNormalizer("margin-top", (t => ({
                path: "margin.top",
                value: t
            }))), t.setNormalizer("margin-right", (t => ({
                path: "margin.right",
                value: t
            }))), t.setNormalizer("margin-bottom", (t => ({
                path: "margin.bottom",
                value: t
            }))), t.setNormalizer("margin-left", (t => ({
                path: "margin.left",
                value: t
            }))), t.setReducer("margin", Ru("margin")), t.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"])
        }

        function Zu(t) {
            t.setNormalizer("padding", Vu("padding")), t.setNormalizer("padding-top", (t => ({
                path: "padding.top",
                value: t
            }))), t.setNormalizer("padding-right", (t => ({
                path: "padding.right",
                value: t
            }))), t.setNormalizer("padding-bottom", (t => ({
                path: "padding.bottom",
                value: t
            }))), t.setNormalizer("padding-left", (t => ({
                path: "padding.left",
                value: t
            }))), t.setReducer("padding", Ru("padding")), t.setStyleRelation("padding", ["padding-top", "padding-right", "padding-bottom", "padding-left"])
        }
        class Ju {
            constructor() {
                this._commands = new Map
            }
            add(t, e) {
                this._commands.set(t, e)
            }
            get(t) {
                return this._commands.get(t)
            }
            execute(t, ...e) {
                const n = this.get(t);
                if (!n) throw new b("commandcollection-command-not-found", this, {
                    commandName: t
                });
                return n.execute(...e)
            }* names() {
                yield* this._commands.keys()
            }* commands() {
                yield* this._commands.values()
            } [Symbol.iterator]() {
                return this._commands[Symbol.iterator]()
            }
            destroy() {
                for (const t of this.commands()) t.destroy()
            }
        }
        class Yu extends(q()) {
            constructor(t = {}) {
                super();
                const e = this.constructor,
                    n = t.language || e.defaultConfig && e.defaultConfig.language;
                this._context = t.context || new Hi({
                    language: n
                }), this._context._addEditor(this, !t.context);
                const o = Array.from(e.builtinPlugins || []);
                this.config = new _o(t, e.defaultConfig), this.config.define("plugins", o), this.config.define(this._context._getEditorConfig()), this.plugins = new Li(this, o, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this._readOnlyLocks = new Set, this.commands = new Ju, this.set("state", "initializing"), this.once("ready", (() => this.state = "ready"), {
                    priority: "high"
                }), this.once("destroy", (() => this.state = "destroyed"), {
                    priority: "high"
                }), this.model = new ru, this.on("change:isReadOnly", (() => {
                    this.model.document.isReadOnly = this.isReadOnly
                }));
                const i = new ns;
                this.data = new kd(this.model, i), this.editing = new qc(this.model, i), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new wd([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new qi(this), this.keystrokes.listenTo(this.editing.view.document)
            }
            get isReadOnly() {
                return this._readOnlyLocks.size > 0
            }
            set isReadOnly(t) {
                throw new b("editor-isreadonly-has-no-setter")
            }
            enableReadOnlyMode(t) {
                if ("string" != typeof t && "symbol" != typeof t) throw new b("editor-read-only-lock-id-invalid", null, {
                    lockId: t
                });
                this._readOnlyLocks.has(t) || (this._readOnlyLocks.add(t), 1 === this._readOnlyLocks.size && this.fire("change:isReadOnly", "isReadOnly", !0, !1))
            }
            disableReadOnlyMode(t) {
                if ("string" != typeof t && "symbol" != typeof t) throw new b("editor-read-only-lock-id-invalid", null, {
                    lockId: t
                });
                this._readOnlyLocks.has(t) && (this._readOnlyLocks.delete(t), 0 === this._readOnlyLocks.size && this.fire("change:isReadOnly", "isReadOnly", !1, !0))
            }
            initPlugins() {
                const t = this.config,
                    e = t.get("plugins"),
                    n = t.get("removePlugins") || [],
                    o = t.get("extraPlugins") || [],
                    i = t.get("substitutePlugins") || [];
                return this.plugins.init(e.concat(o), n, i)
            }
            destroy() {
                let t = Promise.resolve();
                return "initializing" == this.state && (t = new Promise((t => this.once("ready", t)))), t.then((() => {
                    this.fire("destroy"), this.stopListening(), this.commands.destroy()
                })).then((() => this.plugins.destroy())).then((() => {
                    this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy()
                })).then((() => this._context._removeEditor(this)))
            }
            execute(t, ...e) {
                try {
                    return this.commands.execute(t, ...e)
                } catch (t) {
                    b.rethrowUnexpectedError(t, this)
                }
            }
            focus() {
                this.editing.view.focus()
            }
            static create(...t) {
                throw new Error("This is an abstract method.")
            }
        }

        function Qu(t) {
            return class extends t {
                setData(t) {
                    this.data.set(t)
                }
                getData(t) {
                    return this.data.get(t)
                }
            }
        } {
            const t = Qu(Object);
            Qu.setData = t.prototype.setData, Qu.getData = t.prototype.getData
        }

        function Xu(t) {
            return class extends t {
                updateSourceElement(t = this.data.get()) {
                    if (!this.sourceElement) throw new b("editor-missing-sourceelement", this);
                    const e = this.config.get("updateSourceElementOnDestroy"),
                        n = this.sourceElement instanceof HTMLTextAreaElement;
                    Uo(this.sourceElement, e || n ? t : "")
                }
            }
        }
        Xu.updateSourceElement = Xu(Object).prototype.updateSourceElement;
        class tg extends ji {
            static get pluginName() {
                return "PendingActions"
            }
            init() {
                this.set("hasAny", !1), this._actions = new xi({
                    idProperty: "_id"
                }), this._actions.delegate("add", "remove").to(this)
            }
            add(t) {
                if ("string" != typeof t) throw new b("pendingactions-add-invalid-message", this);
                const e = new(q());
                return e.set("message", t), this._actions.add(e), this.hasAny = !0, e
            }
            remove(t) {
                this._actions.remove(t), this.hasAny = !!this._actions.length
            }
            get first() {
                return this._actions.get(0)
            } [Symbol.iterator]() {
                return this._actions[Symbol.iterator]()
            }
        }
        const eg = {
            bold: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>',
            cancel: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>',
            caption: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>',
            check: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>',
            cog: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>',
            eraser: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>',
            image: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>',
            lowVision: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>',
            importExport: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>',
            paragraph: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>',
            plus: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>',
            text: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>',
            alignBottom: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>',
            alignMiddle: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>',
            alignTop: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>',
            alignLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
            alignCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>',
            alignRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>',
            alignJustify: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
            objectLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
            objectCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>',
            objectRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
            objectFullWidth: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>',
            objectInline: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
            objectBlockLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
            objectBlockRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
            objectSizeFull: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>',
            objectSizeLarge: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>',
            objectSizeSmall: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>',
            objectSizeMedium: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>',
            pencil: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>',
            pilcrow: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>',
            quote: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>',
            threeVerticalDots: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>'
        };

        function ng({
            emitter: t,
            activator: e,
            callback: n,
            contextElements: o
        }) {
            t.listenTo(document, "mousedown", ((t, i) => {
                if (!e()) return;
                const r = "function" == typeof i.composedPath ? i.composedPath() : [],
                    s = "function" == typeof o ? o() : o;
                for (const t of s)
                    if (t.contains(i.target) || r.includes(t)) return;
                n()
            }))
        }

        function og(t) {
            return class extends t {
                disableCssTransitions() {
                    this._isCssTransitionsDisabled = !0
                }
                enableCssTransitions() {
                    this._isCssTransitionsDisabled = !1
                }
                constructor(...t) {
                    super(...t), this.set("_isCssTransitionsDisabled", !1), this.initializeCssTransitionDisablerMixin()
                }
                initializeCssTransitionDisablerMixin() {
                    this.extendTemplate({
                        attributes: {
                            class: [this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")]
                        }
                    })
                }
            }
        }

        function ig({
            view: t
        }) {
            t.listenTo(t.element, "submit", ((e, n) => {
                n.preventDefault(), t.fire("submit")
            }), {
                useCapture: !0
            })
        }

        function rg({
            keystrokeHandler: t,
            focusTracker: e,
            gridItems: n,
            numberOfColumns: o,
            uiLanguageDirection: i
        }) {
            const r = "number" == typeof o ? () => o : o;

            function s(t) {
                return o => {
                    const i = n.find((t => t.element === e.focusedElement)),
                        r = n.getIndex(i),
                        s = t(r, n);
                    n.get(s).focus(), o.stopPropagation(), o.preventDefault()
                }
            }

            function a(t, e) {
                return t === e - 1 ? 0 : t + 1
            }

            function l(t, e) {
                return 0 === t ? e - 1 : t - 1
            }
            t.set("arrowright", s(((t, e) => "rtl" === i ? l(t, e.length) : a(t, e.length)))), t.set("arrowleft", s(((t, e) => "rtl" === i ? a(t, e.length) : l(t, e.length)))), t.set("arrowup", s(((t, e) => {
                let n = t - r();
                return n < 0 && (n = t + r() * Math.floor(e.length / r()), n > e.length - 1 && (n -= r())), n
            }))), t.set("arrowdown", s(((t, e) => {
                let n = t + r();
                return n > e.length - 1 && (n = t % r()), n
            })))
        }
        class sg extends xi {
            constructor(t = []) {
                super(t, {
                    idProperty: "viewUid"
                }), this.on("add", ((t, e, n) => {
                    this._renderViewIntoCollectionParent(e, n)
                })), this.on("remove", ((t, e) => {
                    e.element && this._parentElement && e.element.remove()
                })), this._parentElement = null
            }
            destroy() {
                this.map((t => t.destroy()))
            }
            setParent(t) {
                this._parentElement = t;
                for (const t of this) this._renderViewIntoCollectionParent(t)
            }
            delegate(...t) {
                if (!t.length || !t.every((t => "string" == typeof t))) throw new b("ui-viewcollection-delegate-wrong-events", this);
                return {
                    to: e => {
                        for (const n of this)
                            for (const o of t) n.delegate(o).to(e);
                        this.on("add", ((n, o) => {
                            for (const n of t) o.delegate(n).to(e)
                        })), this.on("remove", ((n, o) => {
                            for (const n of t) o.stopDelegating(n, e)
                        }))
                    }
                }
            }
            _renderViewIntoCollectionParent(t, e) {
                t.isRendered || t.render(), t.element && this._parentElement && this._parentElement.insertBefore(t.element, this._parentElement.children[e])
            }
            remove(t) {
                return super.remove(t)
            }
        }
        var ag = n(4793),
            lg = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(ag.Z, lg);
        ag.Z.locals;
        class cg extends(So(q())) {
            constructor(t) {
                super(), this.element = null, this.isRendered = !1, this.locale = t, this.t = t && t.t, this._viewCollections = new xi, this._unboundChildren = this.createCollection(), this._viewCollections.on("add", ((e, n) => {
                    n.locale = t, n.t = t && t.t
                })), this.decorate("render")
            }
            get bindTemplate() {
                return this._bindTemplate ? this._bindTemplate : this._bindTemplate = dg.bind(this, this)
            }
            createCollection(t) {
                const e = new sg(t);
                return this._viewCollections.add(e), e
            }
            registerChild(t) {
                Q(t) || (t = [t]);
                for (const e of t) this._unboundChildren.add(e)
            }
            deregisterChild(t) {
                Q(t) || (t = [t]);
                for (const e of t) this._unboundChildren.remove(e)
            }
            setTemplate(t) {
                this.template = new dg(t)
            }
            extendTemplate(t) {
                dg.extend(this.template, t)
            }
            render() {
                if (this.isRendered) throw new b("ui-view-render-already-rendered", this);
                this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = !0
            }
            destroy() {
                this.stopListening(), this._viewCollections.map((t => t.destroy())), this.template && this.template._revertData && this.template.revert(this.element)
            }
        }
        class dg extends(S()) {
            constructor(t) {
                super(), Object.assign(this, Ag(wg(t))), this._isRendered = !1, this._revertData = null
            }
            render() {
                const t = this._renderNode({
                    intoFragment: !0
                });
                return this._isRendered = !0, t
            }
            apply(t) {
                return this._revertData = {
                    children: [],
                    bindings: [],
                    attributes: {}
                }, this._renderNode({
                    node: t,
                    intoFragment: !1,
                    isApplying: !0,
                    revertData: this._revertData
                }), t
            }
            revert(t) {
                if (!this._revertData) throw new b("ui-template-revert-not-applied", [this, t]);
                this._revertTemplateFromNode(t, this._revertData)
            }* getViews() {
                yield* function* t(e) {
                    if (e.children)
                        for (const n of e.children) Eg(n) ? yield n: Dg(n) && (yield* t(n))
                }(this)
            }
            static bind(t, e) {
                return {
                    to: (n, o) => new ug({
                        eventNameOrFunction: n,
                        attribute: n,
                        observable: t,
                        emitter: e,
                        callback: o
                    }),
                    if: (n, o, i) => new gg({
                        observable: t,
                        emitter: e,
                        attribute: n,
                        valueIfTrue: o,
                        callback: i
                    })
                }
            }
            static extend(t, e) {
                if (t._isRendered) throw new b("template-extend-render", [this, t]);
                yg(t, Ag(wg(e)))
            }
            _renderNode(t) {
                let e;
                if (e = t.node ? this.tag && this.text : this.tag ? this.text : !this.text, e) throw new b("ui-template-wrong-syntax", this);
                return this.text ? this._renderText(t) : this._renderElement(t)
            }
            _renderElement(t) {
                let e = t.node;
                return e || (e = t.node = document.createElementNS(this.ns || "http://www.w3.org/1999/xhtml", this.tag)), this._renderAttributes(t), this._renderElementChildren(t), this._setUpListeners(t), e
            }
            _renderText(t) {
                let e = t.node;
                return e ? t.revertData.text = e.textContent : e = t.node = document.createTextNode(""), mg(this.text) ? this._bindToObservable({
                    schema: this.text,
                    updater: fg(e),
                    data: t
                }) : e.textContent = this.text.join(""), e
            }
            _renderAttributes(t) {
                if (!this.attributes) return;
                const e = t.node,
                    n = t.revertData;
                for (const o in this.attributes) {
                    const i = e.getAttribute(o),
                        r = this.attributes[o];
                    n && (n.attributes[o] = i);
                    const s = Tg(r) ? r[0].ns : null;
                    if (mg(r)) {
                        const a = Tg(r) ? r[0].value : r;
                        n && Bg(o) && a.unshift(i), this._bindToObservable({
                            schema: a,
                            updater: bg(e, o, s),
                            data: t
                        })
                    } else if ("style" == o && "string" != typeof r[0]) this._renderStyleAttribute(r[0], t);
                    else {
                        n && i && Bg(o) && r.unshift(i);
                        const t = r.map((t => t && t.value || t)).reduce(((t, e) => t.concat(e)), []).reduce(_g, "");
                        xg(t) || e.setAttributeNS(s, o, t)
                    }
                }
            }
            _renderStyleAttribute(t, e) {
                const n = e.node;
                for (const o in t) {
                    const i = t[o];
                    mg(i) ? this._bindToObservable({
                        schema: [i],
                        updater: kg(n, o),
                        data: e
                    }) : n.style[o] = i
                }
            }
            _renderElementChildren(t) {
                const e = t.node,
                    n = t.intoFragment ? document.createDocumentFragment() : e,
                    o = t.isApplying;
                let i = 0;
                for (const r of this.children)
                    if (Sg(r)) {
                        if (!o) {
                            r.setParent(e);
                            for (const t of r) n.appendChild(t.element)
                        }
                    } else if (Eg(r)) o || (r.isRendered || r.render(), n.appendChild(r.element));
                else if (xo(r)) n.appendChild(r);
                else if (o) {
                    const e = {
                        children: [],
                        bindings: [],
                        attributes: {}
                    };
                    t.revertData.children.push(e), r._renderNode({
                        intoFragment: !1,
                        node: n.childNodes[i++],
                        isApplying: !0,
                        revertData: e
                    })
                } else n.appendChild(r.render());
                t.intoFragment && e.appendChild(n)
            }
            _setUpListeners(t) {
                if (this.eventListeners)
                    for (const e in this.eventListeners) {
                        const n = this.eventListeners[e].map((n => {
                            const [o, i] = e.split("@");
                            return n.activateDomEventListener(o, i, t)
                        }));
                        t.revertData && t.revertData.bindings.push(n)
                    }
            }
            _bindToObservable({
                schema: t,
                updater: e,
                data: n
            }) {
                const o = n.revertData;
                pg(t, e, n);
                const i = t.filter((t => !xg(t))).filter((t => t.observable)).map((o => o.activateAttributeListener(t, e, n)));
                o && o.bindings.push(i)
            }
            _revertTemplateFromNode(t, e) {
                for (const t of e.bindings)
                    for (const e of t) e();
                if (e.text) return void(t.textContent = e.text);
                const n = t;
                for (const t in e.attributes) {
                    const o = e.attributes[t];
                    null === o ? n.removeAttribute(t) : n.setAttribute(t, o)
                }
                for (let t = 0; t < e.children.length; ++t) this._revertTemplateFromNode(n.childNodes[t], e.children[t])
            }
        }
        class hg {
            constructor(t) {
                this.attribute = t.attribute, this.observable = t.observable, this.emitter = t.emitter, this.callback = t.callback
            }
            getValue(t) {
                const e = this.observable[this.attribute];
                return this.callback ? this.callback(e, t) : e
            }
            activateAttributeListener(t, e, n) {
                const o = () => pg(t, e, n);
                return this.emitter.listenTo(this.observable, `change:${this.attribute}`, o), () => {
                    this.emitter.stopListening(this.observable, `change:${this.attribute}`, o)
                }
            }
        }
        class ug extends hg {
            constructor(t) {
                super(t), this.eventNameOrFunction = t.eventNameOrFunction
            }
            activateDomEventListener(t, e, n) {
                const o = (t, n) => {
                    e && !n.target.matches(e) || ("function" == typeof this.eventNameOrFunction ? this.eventNameOrFunction(n) : this.observable.fire(this.eventNameOrFunction, n))
                };
                return this.emitter.listenTo(n.node, t, o), () => {
                    this.emitter.stopListening(n.node, t, o)
                }
            }
        }
        class gg extends hg {
            constructor(t) {
                super(t), this.valueIfTrue = t.valueIfTrue
            }
            getValue(t) {
                return !xg(super.getValue(t)) && (this.valueIfTrue || !0)
            }
        }

        function mg(t) {
            return !!t && (t.value && (t = t.value), Array.isArray(t) ? t.some(mg) : t instanceof hg)
        }

        function pg(t, e, {
            node: n
        }) {
            const o = function(t, e) {
                return t.map((t => t instanceof hg ? t.getValue(e) : t))
            }(t, n);
            let i;
            i = 1 == t.length && t[0] instanceof gg ? o[0] : o.reduce(_g, ""), xg(i) ? e.remove() : e.set(i)
        }

        function fg(t) {
            return {
                set(e) {
                    t.textContent = e
                },
                remove() {
                    t.textContent = ""
                }
            }
        }

        function bg(t, e, n) {
            return {
                set(o) {
                    t.setAttributeNS(n, e, o)
                },
                remove() {
                    t.removeAttributeNS(n, e)
                }
            }
        }

        function kg(t, e) {
            return {
                set(n) {
                    t.style[e] = n
                },
                remove() {
                    t.style[e] = null
                }
            }
        }

        function wg(t) {
            return Ao(t, (t => {
                if (t && (t instanceof hg || Dg(t) || Eg(t) || Sg(t))) return t
            }))
        }

        function Ag(t) {
            if ("string" == typeof t ? t = function(t) {
                    return {
                        text: [t]
                    }
                }(t) : t.text && function(t) {
                    t.text = Ai(t.text)
                }(t), t.on && (t.eventListeners = function(t) {
                    for (const e in t) Cg(t, e);
                    return t
                }(t.on), delete t.on), !t.text) {
                t.attributes && function(t) {
                    for (const e in t) t[e].value && (t[e].value = Ai(t[e].value)), Cg(t, e)
                }(t.attributes);
                const e = [];
                if (t.children)
                    if (Sg(t.children)) e.push(t.children);
                    else
                        for (const n of t.children) Dg(n) || Eg(n) || xo(n) ? e.push(n) : e.push(new dg(n));
                t.children = e
            }
            return t
        }

        function Cg(t, e) {
            t[e] = Ai(t[e])
        }

        function _g(t, e) {
            return xg(e) ? t : xg(t) ? e : `${t} ${e}`
        }

        function vg(t, e) {
            for (const n in e) t[n] ? t[n].push(...e[n]) : t[n] = e[n]
        }

        function yg(t, e) {
            if (e.attributes && (t.attributes || (t.attributes = {}), vg(t.attributes, e.attributes)), e.eventListeners && (t.eventListeners || (t.eventListeners = {}), vg(t.eventListeners, e.eventListeners)), e.text && t.text.push(...e.text), e.children && e.children.length) {
                if (t.children.length != e.children.length) throw new b("ui-template-extend-children-mismatch", t);
                let n = 0;
                for (const o of e.children) yg(t.children[n++], o)
            }
        }

        function xg(t) {
            return !t && 0 !== t
        }

        function Eg(t) {
            return t instanceof cg
        }

        function Dg(t) {
            return t instanceof dg
        }

        function Sg(t) {
            return t instanceof sg
        }

        function Tg(t) {
            return O(t[0]) && t[0].ns
        }

        function Bg(t) {
            return "class" == t || "style" == t
        }
        class Ig extends sg {
            constructor(t, e = []) {
                super(e), this.locale = t
            }
            get bodyCollectionContainer() {
                return this._bodyCollectionContainer
            }
            attachToDom() {
                this._bodyCollectionContainer = new dg({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
                        dir: this.locale.uiLanguageDirection
                    },
                    children: this
                }).render();
                let t = document.querySelector(".ck-body-wrapper");
                t || (t = pt(document, "div", {
                    class: "ck-body-wrapper"
                }), document.body.appendChild(t)), t.appendChild(this._bodyCollectionContainer)
            }
            detachFromDom() {
                super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
                const t = document.querySelector(".ck-body-wrapper");
                t && 0 == t.childElementCount && t.remove()
            }
        }
        var Pg = n(6574),
            Rg = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Pg.Z, Rg);
        Pg.Z.locals;
        const zg = class extends cg {
            constructor() {
                super();
                const t = this.bindTemplate;
                this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.set("isColorInherited", !0), this.setTemplate({
                    tag: "svg",
                    ns: "http://www.w3.org/2000/svg",
                    attributes: {
                        class: ["ck", "ck-icon", "ck-reset_all-excluded", t.if("isColorInherited", "ck-icon_inherit-color")],
                        viewBox: t.to("viewBox")
                    }
                })
            }
            render() {
                super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", (() => {
                    this._updateXMLContent(), this._colorFillPaths()
                })), this.on("change:fillColor", (() => {
                    this._colorFillPaths()
                }))
            }
            _updateXMLContent() {
                if (this.content) {
                    const t = (new DOMParser).parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg"),
                        e = t.getAttribute("viewBox");
                    e && (this.viewBox = e);
                    for (const {
                            name: e,
                            value: n
                        }
                        of Array.from(t.attributes)) zg.presentationalAttributeNames.includes(e) && this.element.setAttribute(e, n);
                    for (; this.element.firstChild;) this.element.removeChild(this.element.firstChild);
                    for (; t.childNodes.length > 0;) this.element.appendChild(t.childNodes[0])
                }
            }
            _colorFillPaths() {
                this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach((t => {
                    t.style.fill = this.fillColor
                }))
            }
        };
        let Vg = zg;
        Vg.presentationalAttributeNames = ["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-rendering", "cursor", "direction", "display", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform", "unicode-bidi", "vector-effect", "visibility", "white-space", "word-spacing", "writing-mode"];
        var Og = n(4906),
            Fg = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Og.Z, Fg);
        Og.Z.locals;
        class Mg extends cg {
            constructor(t) {
                super(t), this._focusDelayed = null;
                const e = this.bindTemplate,
                    n = g();
                this.set("ariaChecked", void 0), this.set("ariaLabel", void 0), this.set("ariaLabelledBy", `ck-editor__aria-label_${n}`), this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isVisible", !0), this.set("isToggleable", !1), this.set("keystroke", void 0), this.set("label", void 0), this.set("role", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.set("withKeystroke", !1), this.children = this.createCollection(), this.labelView = this._createLabelView(), this.iconView = new Vg, this.iconView.extendTemplate({
                    attributes: {
                        class: "ck-button__icon"
                    }
                }), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
                const o = {
                    tag: "button",
                    attributes: {
                        class: ["ck", "ck-button", e.to("class"), e.if("isEnabled", "ck-disabled", (t => !t)), e.if("isVisible", "ck-hidden", (t => !t)), e.to("isOn", (t => t ? "ck-on" : "ck-off")), e.if("withText", "ck-button_with-text"), e.if("withKeystroke", "ck-button_with-keystroke")],
                        role: e.to("role"),
                        type: e.to("type", (t => t || "button")),
                        tabindex: e.to("tabindex"),
                        "aria-label": e.to("ariaLabel"),
                        "aria-labelledby": e.to("ariaLabelledBy"),
                        "aria-disabled": e.if("isEnabled", !0, (t => !t)),
                        "aria-checked": e.to("isOn"),
                        "aria-pressed": e.to("isOn", (t => !!this.isToggleable && String(!!t))),
                        "data-cke-tooltip-text": e.to("_tooltipString"),
                        "data-cke-tooltip-position": e.to("tooltipPosition")
                    },
                    children: this.children,
                    on: {
                        click: e.to((t => {
                            this.isEnabled ? this.fire("execute") : t.preventDefault()
                        }))
                    }
                };
                i.isSafari && (this._focusDelayed || (this._focusDelayed = Bi((() => this.focus()), 0)), o.on.mousedown = e.to((() => {
                    this._focusDelayed()
                })), o.on.mouseup = e.to((() => {
                    this._focusDelayed.cancel()
                }))), this.setTemplate(o)
            }
            render() {
                super.render(), this.icon && (this.iconView.bind("content").to(this, "icon"), this.children.add(this.iconView)), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView)
            }
            focus() {
                this.element.focus()
            }
            destroy() {
                this._focusDelayed && this._focusDelayed.cancel(), super.destroy()
            }
            _createLabelView() {
                const t = new cg,
                    e = this.bindTemplate;
                return t.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-button__label"],
                        style: e.to("labelStyle"),
                        id: this.ariaLabelledBy
                    },
                    children: [{
                        text: e.to("label")
                    }]
                }), t
            }
            _createKeystrokeView() {
                const t = new cg;
                return t.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-button__keystroke"]
                    },
                    children: [{
                        text: this.bindTemplate.to("keystroke", (t => ki(t)))
                    }]
                }), t
            }
            _getTooltipString(t, e, n) {
                return t ? "string" == typeof t ? t : (n && (n = ki(n)), t instanceof Function ? t(e, n) : `${e}${n?` (${n})`:""}`) : ""
            }
        }
        var Ng = n(5332),
            Lg = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Ng.Z, Lg);
        Ng.Z.locals;
        class Hg extends Mg {
            constructor(t) {
                super(t), this.isToggleable = !0, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({
                    attributes: {
                        class: "ck-switchbutton"
                    }
                })
            }
            render() {
                super.render(), this.children.add(this.toggleSwitchView)
            }
            _createToggleView() {
                const t = new cg;
                return t.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-button__toggle"]
                    },
                    children: [{
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-button__toggle__inner"]
                        }
                    }]
                }), t
            }
        }

        function jg(t, e) {
            const n = t.t,
                o = {
                    Black: n("Black"),
                    "Dim grey": n("Dim grey"),
                    Grey: n("Grey"),
                    "Light grey": n("Light grey"),
                    White: n("White"),
                    Red: n("Red"),
                    Orange: n("Orange"),
                    Yellow: n("Yellow"),
                    "Light green": n("Light green"),
                    Green: n("Green"),
                    Aquamarine: n("Aquamarine"),
                    Turquoise: n("Turquoise"),
                    "Light blue": n("Light blue"),
                    Blue: n("Blue"),
                    Purple: n("Purple")
                };
            return e.map((t => {
                const e = o[t.label];
                return e && e != t.label && (t.label = e), t
            }))
        }

        function qg(t) {
            return t.map(Wg).filter((t => !!t))
        }

        function Wg(t) {
            return "string" == typeof t ? {
                model: t,
                label: t,
                hasBorder: !1,
                view: {
                    name: "span",
                    styles: {
                        color: t
                    }
                }
            } : {
                model: t.color,
                label: t.label || t.color,
                hasBorder: void 0 !== t.hasBorder && t.hasBorder,
                view: {
                    name: "span",
                    styles: {
                        color: `${t.color}`
                    }
                }
            }
        }
        class Ug extends Mg {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("color", void 0), this.set("hasBorder", !1), this.icon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>', this.extendTemplate({
                    attributes: {
                        style: {
                            backgroundColor: e.to("color")
                        },
                        class: ["ck", "ck-color-grid__tile", e.if("hasBorder", "ck-color-table__color-tile_bordered")]
                    }
                })
            }
            render() {
                super.render(), this.iconView.fillColor = "hsl(0, 0%, 100%)"
            }
        }
        var $g = n(6781),
            Gg = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()($g.Z, Gg);
        $g.Z.locals;
        class Kg extends cg {
            constructor(t, e) {
                super(t);
                const n = e && e.colorDefinitions ? e.colorDefinitions : [];
                this.columns = e && e.columns ? e.columns : 5;
                const o = {
                    gridTemplateColumns: `repeat( ${this.columns}, 1fr)`
                };
                this.set("selectedColor", void 0), this.items = this.createCollection(), this.focusTracker = new Di, this.keystrokes = new Si, this.items.on("add", ((t, e) => {
                    e.isOn = e.color === this.selectedColor
                })), n.forEach((t => {
                    const e = new Ug;
                    e.set({
                        color: t.color,
                        label: t.label,
                        tooltip: !0,
                        hasBorder: t.options.hasBorder
                    }), e.on("execute", (() => {
                        this.fire("execute", {
                            value: t.color,
                            hasBorder: t.options.hasBorder,
                            label: t.label
                        })
                    })), this.items.add(e)
                })), this.setTemplate({
                    tag: "div",
                    children: this.items,
                    attributes: {
                        class: ["ck", "ck-color-grid"],
                        style: o
                    }
                }), this.on("change:selectedColor", ((t, e, n) => {
                    for (const t of this.items) t.isOn = t.color === n
                }))
            }
            focus() {
                this.items.length && this.items.first.focus()
            }
            focusLast() {
                this.items.length && this.items.last.focus()
            }
            render() {
                super.render();
                for (const t of this.items) this.focusTracker.add(t.element);
                this.items.on("add", ((t, e) => {
                    this.focusTracker.add(e.element)
                })), this.items.on("remove", ((t, e) => {
                    this.focusTracker.remove(e.element)
                })), this.keystrokes.listenTo(this.element), rg({
                    keystrokeHandler: this.keystrokes,
                    focusTracker: this.focusTracker,
                    gridItems: this.items,
                    numberOfColumns: this.columns,
                    uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
                })
            }
            destroy() {
                super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
            }
        }
        var Zg = n(1103);
        const Jg = function(t) {
            var e, n, o = [],
                i = 1;
            if ("string" == typeof t)
                if (Zg[t]) o = Zg[t].slice(), n = "rgb";
                else if ("transparent" === t) i = 0, n = "rgb", o = [0, 0, 0];
            else if (/^#[A-Fa-f0-9]+$/.test(t)) {
                var r = t.slice(1);
                i = 1, (l = r.length) <= 4 ? (o = [parseInt(r[0] + r[0], 16), parseInt(r[1] + r[1], 16), parseInt(r[2] + r[2], 16)], 4 === l && (i = parseInt(r[3] + r[3], 16) / 255)) : (o = [parseInt(r[0] + r[1], 16), parseInt(r[2] + r[3], 16), parseInt(r[4] + r[5], 16)], 8 === l && (i = parseInt(r[6] + r[7], 16) / 255)), o[0] || (o[0] = 0), o[1] || (o[1] = 0), o[2] || (o[2] = 0), n = "rgb"
            } else if (e = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(t)) {
                var s = e[1],
                    a = "rgb" === s;
                n = r = s.replace(/a$/, "");
                var l = "cmyk" === r ? 4 : "gray" === r ? 1 : 3;
                o = e[2].trim().split(/\s*[,\/]\s*|\s+/).map((function(t, e) {
                    if (/%$/.test(t)) return e === l ? parseFloat(t) / 100 : "rgb" === r ? 255 * parseFloat(t) / 100 : parseFloat(t);
                    if ("h" === r[e]) {
                        if (/deg$/.test(t)) return parseFloat(t);
                        if (void 0 !== Yg[t]) return Yg[t]
                    }
                    return parseFloat(t)
                })), s === r && o.push(1), i = a || void 0 === o[l] ? 1 : o[l], o = o.slice(0, l)
            } else t.length > 10 && /[0-9](?:\s|\/)/.test(t) && (o = t.match(/([0-9]+)/g).map((function(t) {
                return parseFloat(t)
            })), n = t.match(/([a-z])/gi).join("").toLowerCase());
            else isNaN(t) ? Array.isArray(t) || t.length ? (o = [t[0], t[1], t[2]], n = "rgb", i = 4 === t.length ? t[3] : 1) : t instanceof Object && (null != t.r || null != t.red || null != t.R ? (n = "rgb", o = [t.r || t.red || t.R || 0, t.g || t.green || t.G || 0, t.b || t.blue || t.B || 0]) : (n = "hsl", o = [t.h || t.hue || t.H || 0, t.s || t.saturation || t.S || 0, t.l || t.lightness || t.L || t.b || t.brightness]), i = t.a || t.alpha || t.opacity || 1, null != t.opacity && (i /= 100)) : (n = "rgb", o = [t >>> 16, (65280 & t) >>> 8, 255 & t]);
            return {
                space: n,
                values: o,
                alpha: i
            }
        };
        var Yg = {
            red: 0,
            orange: 60,
            yellow: 120,
            green: 180,
            blue: 240,
            purple: 300
        };
        var Qg = n(841);

        function Xg(t, e) {
            if (!t) return "";
            const n = tm(t);
            if (!n) return "";
            if (n.space === e) return t;
            if (o = n, !Object.keys(Qg).includes(o.space)) return "";
            var o;
            const i = Qg[n.space][e];
            if (!i) return "";
            return function(t, e) {
                switch (e) {
                    case "hex":
                        return `#${t}`;
                    case "rgb":
                        return `rgb( ${t[0]}, ${t[1]}, ${t[2]} )`;
                    case "hsl":
                        return `hsl( ${t[0]}, ${t[1]}%, ${t[2]}% )`;
                    case "hwb":
                        return `hwb( ${t[0]}, ${t[1]}, ${t[2]} )`;
                    case "lab":
                        return `lab( ${t[0]}% ${t[1]} ${t[2]} )`;
                    case "lch":
                        return `lch( ${t[0]}% ${t[1]} ${t[2]} )`;
                    default:
                        return ""
                }
            }(i("hex" === n.space ? n.hexValue : n.values), e)
        }

        function tm(t) {
            if (t.startsWith("#")) {
                const e = Jg(t);
                return {
                    space: "hex",
                    values: e.values,
                    hexValue: t,
                    alpha: e.alpha
                }
            }
            const e = Jg(t);
            return e.space ? e : null
        }
        var em = n(3662),
            nm = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(em.Z, nm);
        em.Z.locals;
        class om extends cg {
            constructor(t) {
                super(t), this.set("text", void 0), this.set("for", void 0), this.id = `ck-editor__label_${g()}`;
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "label",
                    attributes: {
                        class: ["ck", "ck-label"],
                        id: this.id,
                        for: e.to("for")
                    },
                    children: [{
                        text: e.to("text")
                    }]
                })
            }
        }
        var im = n(2577),
            rm = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(im.Z, rm);
        im.Z.locals;
        class sm extends cg {
            constructor(t, e) {
                super(t);
                const n = `ck-labeled-field-view-${g()}`,
                    o = `ck-labeled-field-view-status-${g()}`;
                this.fieldView = e(this, n, o), this.set("label", void 0), this.set("isEnabled", !0), this.set("isEmpty", !0), this.set("isFocused", !1), this.set("errorText", null), this.set("infoText", null), this.set("class", void 0), this.set("placeholder", void 0), this.labelView = this._createLabelView(n), this.statusView = this._createStatusView(o), this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]), this.bind("_statusText").to(this, "errorText", this, "infoText", ((t, e) => t || e));
                const i = this.bindTemplate;
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-labeled-field-view", i.to("class"), i.if("isEnabled", "ck-disabled", (t => !t)), i.if("isEmpty", "ck-labeled-field-view_empty"), i.if("isFocused", "ck-labeled-field-view_focused"), i.if("placeholder", "ck-labeled-field-view_placeholder"), i.if("errorText", "ck-error")]
                    },
                    children: [{
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-labeled-field-view__input-wrapper"]
                        },
                        children: this.fieldWrapperChildren
                    }, this.statusView]
                })
            }
            _createLabelView(t) {
                const e = new om(this.locale);
                return e.for = t, e.bind("text").to(this, "label"), e
            }
            _createStatusView(t) {
                const e = new cg(this.locale),
                    n = this.bindTemplate;
                return e.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-labeled-field-view__status", n.if("errorText", "ck-labeled-field-view__status_error"), n.if("_statusText", "ck-hidden", (t => !t))],
                        id: t,
                        role: n.if("errorText", "alert")
                    },
                    children: [{
                        text: n.to("_statusText")
                    }]
                }), e
            }
            focus() {
                this.fieldView.focus()
            }
        }
        var am = n(4879),
            lm = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(am.Z, lm);
        am.Z.locals;
        class cm extends cg {
            constructor(t) {
                super(t), this.set("value", void 0), this.set("id", void 0), this.set("placeholder", void 0), this.set("isReadOnly", !1), this.set("hasError", !1), this.set("ariaDescribedById", void 0), this.focusTracker = new Di, this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", !0), this.set("inputMode", "text");
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "input",
                    attributes: {
                        class: ["ck", "ck-input", e.if("isFocused", "ck-input_focused"), e.if("isEmpty", "ck-input-text_empty"), e.if("hasError", "ck-error")],
                        id: e.to("id"),
                        placeholder: e.to("placeholder"),
                        readonly: e.to("isReadOnly"),
                        inputmode: e.to("inputMode"),
                        "aria-invalid": e.if("hasError", !0),
                        "aria-describedby": e.to("ariaDescribedById")
                    },
                    on: {
                        input: e.to(((...t) => {
                            this.fire("input", ...t), this._updateIsEmpty()
                        })),
                        change: e.to(this._updateIsEmpty.bind(this))
                    }
                })
            }
            render() {
                super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", ((t, e, n) => {
                    this._setDomElementValue(n), this._updateIsEmpty()
                }))
            }
            destroy() {
                super.destroy(), this.focusTracker.destroy()
            }
            select() {
                this.element.select()
            }
            focus() {
                this.element.focus()
            }
            _updateIsEmpty() {
                this.isEmpty = !this.element.value
            }
            _setDomElementValue(t) {
                this.element.value = t || 0 === t ? t : ""
            }
        }
        class dm extends cm {
            constructor(t) {
                super(t), this.extendTemplate({
                    attributes: {
                        type: "text",
                        class: ["ck-input-text"]
                    }
                })
            }
        }
        class hm extends cm {
            constructor(t, {
                min: e,
                max: n,
                step: o
            } = {}) {
                super(t);
                const i = this.bindTemplate;
                this.set("min", e), this.set("max", n), this.set("step", o), this.extendTemplate({
                    attributes: {
                        type: "number",
                        class: ["ck-input-number"],
                        min: i.to("min"),
                        max: i.to("max"),
                        step: i.to("step")
                    }
                })
            }
        }
        class um extends cg {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-reset", "ck-dropdown__panel", e.to("position", (t => `ck-dropdown__panel_${t}`)), e.if("isVisible", "ck-dropdown__panel-visible")]
                    },
                    children: this.children,
                    on: {
                        selectstart: e.to((t => {
                            "input" !== t.target.tagName.toLocaleLowerCase() && t.preventDefault()
                        }))
                    }
                })
            }
            focus() {
                if (this.children.length) {
                    const t = this.children.first;
                    "function" == typeof t.focus ? t.focus() : k("ui-dropdown-panel-focus-child-missing-focus", {
                        childView: this.children.first,
                        dropdownPanel: this
                    })
                }
            }
            focusLast() {
                if (this.children.length) {
                    const t = this.children.last;
                    "function" == typeof t.focusLast ? t.focusLast() : t.focus()
                }
            }
        }
        var gm = n(5485),
            mm = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(gm.Z, mm);
        gm.Z.locals;
        const pm = class extends cg {
            constructor(t, e, n) {
                super(t);
                const o = this.bindTemplate;
                this.buttonView = e, this.panelView = n, this.set("isOpen", !1), this.set("isEnabled", !0), this.set("class", void 0), this.set("id", void 0), this.set("panelPosition", "auto"), this.keystrokes = new Si, this.focusTracker = new Di, this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-dropdown", o.to("class"), o.if("isEnabled", "ck-disabled", (t => !t))],
                        id: o.to("id"),
                        "aria-describedby": o.to("ariaDescribedById")
                    },
                    children: [e, n]
                }), e.extendTemplate({
                    attributes: {
                        class: ["ck-dropdown__button"],
                        "data-cke-tooltip-disabled": o.to("isOpen")
                    }
                })
            }
            render() {
                super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.listenTo(this.buttonView, "open", (() => {
                    this.isOpen = !this.isOpen
                })), this.panelView.bind("isVisible").to(this, "isOpen"), this.on("change:isOpen", ((t, e, n) => {
                    n && ("auto" === this.panelPosition ? this.panelView.position = pm._getOptimalPosition({
                        element: this.panelView.element,
                        target: this.buttonView.element,
                        fitInViewport: !0,
                        positions: this._panelPositions
                    }).name : this.panelView.position = this.panelPosition)
                })), this.keystrokes.listenTo(this.element);
                const t = (t, e) => {
                    this.isOpen && (this.isOpen = !1, e())
                };
                this.keystrokes.set("arrowdown", ((t, e) => {
                    this.buttonView.isEnabled && !this.isOpen && (this.isOpen = !0, e())
                })), this.keystrokes.set("arrowright", ((t, e) => {
                    this.isOpen && e()
                })), this.keystrokes.set("arrowleft", t), this.keystrokes.set("esc", t)
            }
            focus() {
                this.buttonView.focus()
            }
            get _panelPositions() {
                const {
                    south: t,
                    north: e,
                    southEast: n,
                    southWest: o,
                    northEast: i,
                    northWest: r,
                    southMiddleEast: s,
                    southMiddleWest: a,
                    northMiddleEast: l,
                    northMiddleWest: c
                } = pm.defaultPanelPositions;
                return "rtl" !== this.locale.uiLanguageDirection ? [n, o, s, a, t, i, r, l, c, e] : [o, n, a, s, t, r, i, c, l, e]
            }
        };
        let fm = pm;
        fm.defaultPanelPositions = {
            south: (t, e) => ({
                top: t.bottom,
                left: t.left - (e.width - t.width) / 2,
                name: "s"
            }),
            southEast: t => ({
                top: t.bottom,
                left: t.left,
                name: "se"
            }),
            southWest: (t, e) => ({
                top: t.bottom,
                left: t.left - e.width + t.width,
                name: "sw"
            }),
            southMiddleEast: (t, e) => ({
                top: t.bottom,
                left: t.left - (e.width - t.width) / 4,
                name: "sme"
            }),
            southMiddleWest: (t, e) => ({
                top: t.bottom,
                left: t.left - 3 * (e.width - t.width) / 4,
                name: "smw"
            }),
            north: (t, e) => ({
                top: t.top - e.height,
                left: t.left - (e.width - t.width) / 2,
                name: "n"
            }),
            northEast: (t, e) => ({
                top: t.top - e.height,
                left: t.left,
                name: "ne"
            }),
            northWest: (t, e) => ({
                top: t.top - e.height,
                left: t.left - e.width + t.width,
                name: "nw"
            }),
            northMiddleEast: (t, e) => ({
                top: t.top - e.height,
                left: t.left - (e.width - t.width) / 4,
                name: "nme"
            }),
            northMiddleWest: (t, e) => ({
                top: t.top - e.height,
                left: t.left - 3 * (e.width - t.width) / 4,
                name: "nmw"
            })
        }, fm._getOptimalPosition = Qo;
        const bm = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
        class km extends Mg {
            constructor(t) {
                super(t), this.arrowView = this._createArrowView(), this.extendTemplate({
                    attributes: {
                        "aria-haspopup": !0,
                        "aria-expanded": this.bindTemplate.to("isOn", (t => String(t)))
                    }
                }), this.delegate("execute").to(this, "open")
            }
            render() {
                super.render(), this.children.add(this.arrowView)
            }
            _createArrowView() {
                const t = new Vg;
                return t.content = bm, t.extendTemplate({
                    attributes: {
                        class: "ck-dropdown__arrow"
                    }
                }), t
            }
        }
        class wm {
            constructor(t) {
                if (this.focusables = t.focusables, this.focusTracker = t.focusTracker, this.keystrokeHandler = t.keystrokeHandler, this.actions = t.actions, t.actions && t.keystrokeHandler)
                    for (const e in t.actions) {
                        let n = t.actions[e];
                        "string" == typeof n && (n = [n]);
                        for (const o of n) t.keystrokeHandler.set(o, ((t, n) => {
                            this[e](), n()
                        }))
                    }
            }
            get first() {
                return this.focusables.find(Am) || null
            }
            get last() {
                return this.focusables.filter(Am).slice(-1)[0] || null
            }
            get next() {
                return this._getFocusableItem(1)
            }
            get previous() {
                return this._getFocusableItem(-1)
            }
            get current() {
                let t = null;
                return null === this.focusTracker.focusedElement ? null : (this.focusables.find(((e, n) => {
                    const o = e.element === this.focusTracker.focusedElement;
                    return o && (t = n), o
                })), t)
            }
            focusFirst() {
                this._focus(this.first)
            }
            focusLast() {
                this._focus(this.last)
            }
            focusNext() {
                this._focus(this.next)
            }
            focusPrevious() {
                this._focus(this.previous)
            }
            _focus(t) {
                t && t.focus()
            }
            _getFocusableItem(t) {
                const e = this.current,
                    n = this.focusables.length;
                if (!n) return null;
                if (null === e) return this[1 === t ? "first" : "last"];
                let o = (e + n + t) % n;
                do {
                    const e = this.focusables.get(o);
                    if (Am(e)) return e;
                    o = (o + n + t) % n
                } while (o !== e);
                return null
            }
        }

        function Am(t) {
            return !(!t.focus || !Jo(t.element))
        }
        class Cm extends cg {
            constructor(t) {
                super(t), this.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-toolbar__separator"]
                    }
                })
            }
        }
        class _m extends cg {
            constructor(t) {
                super(t), this.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-toolbar__line-break"]
                    }
                })
            }
        }

        function vm(t) {
            return Array.isArray(t) ? {
                items: t,
                removeItems: []
            } : t ? Object.assign({
                items: [],
                removeItems: []
            }, t) : {
                items: [],
                removeItems: []
            }
        }
        var ym = n(5542),
            xm = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(ym.Z, xm);
        ym.Z.locals;
        const {
            threeVerticalDots: Em
        } = eg, Dm = {
            alignLeft: eg.alignLeft,
            bold: eg.bold,
            importExport: eg.importExport,
            paragraph: eg.paragraph,
            plus: eg.plus,
            text: eg.text,
            threeVerticalDots: eg.threeVerticalDots
        };
        class Sm extends cg {
            constructor(t, e) {
                super(t);
                const n = this.bindTemplate,
                    o = this.t;
                this.options = e || {}, this.set("ariaLabel", o("Editor toolbar")), this.set("maxWidth", "auto"), this.items = this.createCollection(), this.focusTracker = new Di, this.keystrokes = new Si, this.set("class", void 0), this.set("isCompact", !1), this.itemsView = new Tm(t), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
                const i = "rtl" === t.uiLanguageDirection;
                this._focusCycler = new wm({
                    focusables: this.focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: [i ? "arrowright" : "arrowleft", "arrowup"],
                        focusNext: [i ? "arrowleft" : "arrowright", "arrowdown"]
                    }
                });
                const r = ["ck", "ck-toolbar", n.to("class"), n.if("isCompact", "ck-toolbar_compact")];
                var s;
                this.options.shouldGroupWhenFull && this.options.isFloating && r.push("ck-toolbar_floating"), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: r,
                        role: "toolbar",
                        "aria-label": n.to("ariaLabel"),
                        style: {
                            maxWidth: n.to("maxWidth")
                        },
                        tabindex: -1
                    },
                    children: this.children,
                    on: {
                        mousedown: (s = this, s.bindTemplate.to((t => {
                            t.target === s.element && t.preventDefault()
                        })))
                    }
                }), this._behavior = this.options.shouldGroupWhenFull ? new Im(this) : new Bm(this)
            }
            render() {
                super.render(), this.focusTracker.add(this.element);
                for (const t of this.items) this.focusTracker.add(t.element);
                this.items.on("add", ((t, e) => {
                    this.focusTracker.add(e.element)
                })), this.items.on("remove", ((t, e) => {
                    this.focusTracker.remove(e.element)
                })), this.keystrokes.listenTo(this.element), this._behavior.render(this)
            }
            destroy() {
                return this._behavior.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), super.destroy()
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            focusLast() {
                this._focusCycler.focusLast()
            }
            fillFromConfig(t, e, n) {
                this.items.addMany(this._buildItemsFromConfig(t, e, n))
            }
            _buildItemsFromConfig(t, e, n) {
                const o = vm(t),
                    i = n || o.removeItems;
                return this._cleanItemsConfiguration(o.items, e, i).map((t => O(t) ? this._createNestedToolbarDropdown(t, e, i) : "|" === t ? new Cm : "-" === t ? new _m : e.create(t))).filter((t => !!t))
            }
            _cleanItemsConfiguration(t, e, n) {
                const o = t.filter(((t, o, i) => "|" === t || -1 === n.indexOf(t) && ("-" === t ? !this.options.shouldGroupWhenFull || (k("toolbarview-line-break-ignored-when-grouping-items", i), !1) : !(!O(t) && !e.has(t)) || (k("toolbarview-item-unavailable", {
                    item: t
                }), !1))));
                return this._cleanSeparatorsAndLineBreaks(o)
            }
            _cleanSeparatorsAndLineBreaks(t) {
                const e = t => "-" !== t && "|" !== t,
                    n = t.length,
                    o = t.findIndex(e);
                if (-1 === o) return [];
                const i = n - t.slice().reverse().findIndex(e);
                return t.slice(o, i).filter(((t, n, o) => {
                    if (e(t)) return !0;
                    return !(n > 0 && o[n - 1] === t)
                }))
            }
            _createNestedToolbarDropdown(t, e, n) {
                let {
                    label: o,
                    icon: i,
                    items: r,
                    tooltip: s = !0,
                    withText: a = !1
                } = t;
                if (r = this._cleanItemsConfiguration(r, e, n), !r.length) return null;
                const l = Wm(this.locale);
                return o || k("toolbarview-nested-toolbar-dropdown-missing-label", t), l.class = "ck-toolbar__nested-toolbar-dropdown", l.buttonView.set({
                    label: o,
                    tooltip: s,
                    withText: !!a
                }), !1 !== i ? l.buttonView.icon = Dm[i] || i || Em : l.buttonView.withText = !0, Um(l, (() => l.toolbarView._buildItemsFromConfig(r, e, n))), l
            }
        }
        class Tm extends cg {
            constructor(t) {
                super(t), this.children = this.createCollection(), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-toolbar__items"]
                    },
                    children: this.children
                })
            }
        }
        class Bm {
            constructor(t) {
                const e = t.bindTemplate;
                t.set("isVertical", !1), t.itemsView.children.bindTo(t.items).using((t => t)), t.focusables.bindTo(t.items).using((t => t)), t.extendTemplate({
                    attributes: {
                        class: [e.if("isVertical", "ck-toolbar_vertical")]
                    }
                })
            }
            render() {}
            destroy() {}
        }
        class Im {
            constructor(t) {
                this.resizeObserver = null, this.cachedPadding = null, this.shouldUpdateGroupingOnNextResize = !1, this.view = t, this.viewChildren = t.children, this.viewFocusables = t.focusables, this.viewItemsView = t.itemsView, this.viewFocusTracker = t.focusTracker, this.viewLocale = t.locale, this.ungroupedItems = t.createCollection(), this.groupedItems = t.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), t.itemsView.children.bindTo(this.ungroupedItems).using((t => t)), this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this)), t.children.on("change", this._updateFocusCycleableItems.bind(this)), t.items.on("change", ((t, e) => {
                    const n = e.index,
                        o = Array.from(e.added);
                    for (const t of e.removed) n >= this.ungroupedItems.length ? this.groupedItems.remove(t) : this.ungroupedItems.remove(t);
                    for (let t = n; t < n + o.length; t++) {
                        const e = o[t - n];
                        t > this.ungroupedItems.length ? this.groupedItems.add(e, t - this.ungroupedItems.length) : this.ungroupedItems.add(e, t)
                    }
                    this._updateGrouping()
                })), t.extendTemplate({
                    attributes: {
                        class: ["ck-toolbar_grouping"]
                    }
                })
            }
            render(t) {
                this.viewElement = t.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(t)
            }
            destroy() {
                this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy()
            }
            _updateGrouping() {
                if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) return;
                if (!Jo(this.viewElement)) return void(this.shouldUpdateGroupingOnNextResize = !0);
                const t = this.groupedItems.length;
                let e;
                for (; this._areItemsOverflowing;) this._groupLastItem(), e = !0;
                if (!e && this.groupedItems.length) {
                    for (; this.groupedItems.length && !this._areItemsOverflowing;) this._ungroupFirstItem();
                    this._areItemsOverflowing && this._groupLastItem()
                }
                this.groupedItems.length !== t && this.view.fire("groupedItemsUpdate")
            }
            get _areItemsOverflowing() {
                if (!this.ungroupedItems.length) return !1;
                const t = this.viewElement,
                    e = this.viewLocale.uiLanguageDirection,
                    n = new Mo(t.lastChild),
                    o = new Mo(t);
                if (!this.cachedPadding) {
                    const n = Po.window.getComputedStyle(t),
                        o = "ltr" === e ? "paddingRight" : "paddingLeft";
                    this.cachedPadding = Number.parseInt(n[o])
                }
                return "ltr" === e ? n.right > o.right - this.cachedPadding : n.left < o.left + this.cachedPadding
            }
            _enableGroupingOnResize() {
                let t;
                this.resizeObserver = new Wo(this.viewElement, (e => {
                    t && t === e.contentRect.width && !this.shouldUpdateGroupingOnNextResize || (this.shouldUpdateGroupingOnNextResize = !1, this._updateGrouping(), t = e.contentRect.width)
                })), this._updateGrouping()
            }
            _enableGroupingOnMaxWidthChange(t) {
                t.on("change:maxWidth", (() => {
                    this._updateGrouping()
                }))
            }
            _groupLastItem() {
                this.groupedItems.length || (this.viewChildren.add(new Cm), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0)
            }
            _ungroupFirstItem() {
                this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element))
            }
            _createGroupedItemsDropdown() {
                const t = this.viewLocale,
                    e = t.t,
                    n = Wm(t);
                return n.class = "ck-toolbar__grouped-dropdown", n.panelPosition = "ltr" === t.uiLanguageDirection ? "sw" : "se", Um(n, this.groupedItems), n.buttonView.set({
                    label: e("Show more items"),
                    tooltip: !0,
                    tooltipPosition: "rtl" === t.uiLanguageDirection ? "se" : "sw",
                    icon: Em
                }), n
            }
            _updateFocusCycleableItems() {
                this.viewFocusables.clear(), this.ungroupedItems.map((t => {
                    this.viewFocusables.add(t)
                })), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown)
            }
        }
        var Pm = n(1046),
            Rm = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Pm.Z, Rm);
        Pm.Z.locals;
        class zm extends cg {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.items = this.createCollection(), this.focusTracker = new Di, this.keystrokes = new Si, this._focusCycler = new wm({
                    focusables: this.items,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "arrowup",
                        focusNext: "arrowdown"
                    }
                }), this.set("ariaLabel", void 0), this.set("role", void 0), this.setTemplate({
                    tag: "ul",
                    attributes: {
                        class: ["ck", "ck-reset", "ck-list"],
                        role: e.to("role"),
                        "aria-label": e.to("ariaLabel")
                    },
                    children: this.items
                })
            }
            render() {
                super.render();
                for (const t of this.items) this.focusTracker.add(t.element);
                this.items.on("add", ((t, e) => {
                    this.focusTracker.add(e.element)
                })), this.items.on("remove", ((t, e) => {
                    this.focusTracker.remove(e.element)
                })), this.keystrokes.listenTo(this.element)
            }
            destroy() {
                super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            focusLast() {
                this._focusCycler.focusLast()
            }
        }
        class Vm extends cg {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("isVisible", !0), this.children = this.createCollection(), this.setTemplate({
                    tag: "li",
                    attributes: {
                        class: ["ck", "ck-list__item", e.if("isVisible", "ck-hidden", (t => !t))],
                        role: "presentation"
                    },
                    children: this.children
                })
            }
            focus() {
                this.children.first.focus()
            }
        }
        class Om extends cg {
            constructor(t) {
                super(t), this.setTemplate({
                    tag: "li",
                    attributes: {
                        class: ["ck", "ck-list__separator"]
                    }
                })
            }
        }
        var Fm = n(7686),
            Mm = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Fm.Z, Mm);
        Fm.Z.locals;
        class Nm extends cg {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isToggleable", !1), this.set("isVisible", !0), this.set("keystroke", void 0), this.set("withKeystroke", !1), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.children = this.createCollection(), this.actionView = this._createActionView(), this.arrowView = this._createArrowView(), this.keystrokes = new Si, this.focusTracker = new Di, this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-splitbutton", e.to("class"), e.if("isVisible", "ck-hidden", (t => !t)), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")]
                    },
                    children: this.children
                })
            }
            render() {
                super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", ((t, e) => {
                    this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), e())
                })), this.keystrokes.set("arrowleft", ((t, e) => {
                    this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), e())
                }))
            }
            destroy() {
                super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
            }
            focus() {
                this.actionView.focus()
            }
            _createActionView() {
                const t = new Mg;
                return t.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), t.extendTemplate({
                    attributes: {
                        class: "ck-splitbutton__action"
                    }
                }), t.delegate("execute").to(this), t
            }
            _createArrowView() {
                const t = new Mg,
                    e = t.bindTemplate;
                return t.icon = bm, t.extendTemplate({
                    attributes: {
                        class: ["ck-splitbutton__arrow"],
                        "data-cke-tooltip-disabled": e.to("isOn"),
                        "aria-haspopup": !0,
                        "aria-expanded": e.to("isOn", (t => String(t)))
                    }
                }), t.bind("isEnabled").to(this), t.bind("label").to(this), t.bind("tooltip").to(this), t.delegate("execute").to(this, "open"), t
            }
        }
        var Lm = n(7339),
            Hm = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Lm.Z, Hm);
        Lm.Z.locals;
        var jm = n(3949),
            qm = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(jm.Z, qm);
        jm.Z.locals;

        function Wm(t, e = km) {
            const n = new e(t),
                o = new um(t),
                i = new fm(t, n, o);
            return n.bind("isEnabled").to(i), n instanceof Nm ? n.arrowView.bind("isOn").to(i, "isOpen") : n.bind("isOn").to(i, "isOpen"),
                function(t) {
                    (function(t) {
                        t.on("render", (() => {
                            ng({
                                emitter: t,
                                activator: () => t.isOpen,
                                callback: () => {
                                    t.isOpen = !1
                                },
                                contextElements: [t.element]
                            })
                        }))
                    })(t),
                    function(t) {
                        t.on("execute", (e => {
                            e.source instanceof Hg || (t.isOpen = !1)
                        }))
                    }(t),
                    function(t) {
                        t.focusTracker.on("change:isFocused", ((e, n, o) => {
                            t.isOpen && !o && (t.isOpen = !1)
                        }))
                    }(t),
                    function(t) {
                        t.keystrokes.set("arrowdown", ((e, n) => {
                            t.isOpen && (t.panelView.focus(), n())
                        })), t.keystrokes.set("arrowup", ((e, n) => {
                            t.isOpen && (t.panelView.focusLast(), n())
                        }))
                    }(t),
                    function(t) {
                        t.on("change:isOpen", ((e, n, o) => {
                            if (o) return;
                            const i = t.panelView.element;
                            i && i.contains(Po.document.activeElement) && t.buttonView.focus()
                        }))
                    }(t),
                    function(t) {
                        t.on("change:isOpen", ((e, n, o) => {
                            o && t.panelView.focus()
                        }), {
                            priority: "low"
                        })
                    }(t)
                }(i), i
        }

        function Um(t, e, n = {}) {
            t.extendTemplate({
                attributes: {
                    class: ["ck-toolbar-dropdown"]
                }
            }), t.isOpen ? $m(t, e, n) : t.once("change:isOpen", (() => $m(t, e, n)), {
                priority: "highest"
            }), n.enableActiveItemFocusOnDropdownOpen && Zm(t, (() => t.toolbarView.items.find((t => t.isOn))))
        }

        function $m(t, e, n) {
            const o = t.locale,
                i = o.t,
                r = t.toolbarView = new Sm(o),
                s = "function" == typeof e ? e() : e;
            r.ariaLabel = n.ariaLabel || i("Dropdown toolbar"), n.maxWidth && (r.maxWidth = n.maxWidth), n.class && (r.class = n.class), n.isCompact && (r.isCompact = n.isCompact), n.isVertical && (r.isVertical = !0), s instanceof sg ? r.items.bindTo(s).using((t => t)) : r.items.addMany(s), t.panelView.children.add(r), r.items.delegate("execute").to(t)
        }

        function Gm(t, e, n = {}) {
            t.isOpen ? Km(t, e, n) : t.once("change:isOpen", (() => Km(t, e, n)), {
                priority: "highest"
            }), Zm(t, (() => t.listView.items.find((t => t instanceof Vm && t.children.first.isOn))))
        }

        function Km(t, e, n) {
            const o = t.locale,
                i = t.listView = new zm(o),
                r = "function" == typeof e ? e() : e;
            i.ariaLabel = n.ariaLabel, i.role = n.role, i.items.bindTo(r).using((t => {
                if ("separator" === t.type) return new Om(o);
                if ("button" === t.type || "switchbutton" === t.type) {
                    const e = new Vm(o);
                    let n;
                    return n = "button" === t.type ? new Mg(o) : new Hg(o), n.bind(...Object.keys(t.model)).to(t.model), n.delegate("execute").to(e), e.children.add(n), e
                }
                return null
            })), t.panelView.children.add(i), i.items.delegate("execute").to(t)
        }

        function Zm(t, e) {
            t.on("change:isOpen", (() => {
                if (!t.isOpen) return;
                const n = e();
                n && ("function" == typeof n.focus ? n.focus() : k("ui-dropdown-focus-child-on-open-child-missing-focus", {
                    view: n
                }))
            }), {
                priority: m.low - 10
            })
        }

        function Jm(t, e, n) {
            const o = new dm(t.locale);
            return o.set({
                id: e,
                ariaDescribedById: n
            }), o.bind("isReadOnly").to(t, "isEnabled", (t => !t)), o.bind("hasError").to(t, "errorText", (t => !!t)), o.on("input", (() => {
                t.errorText = null
            })), t.bind("isEmpty", "isFocused", "placeholder").to(o), o
        }

        function Ym(t, e, n) {
            const o = new hm(t.locale);
            return o.set({
                id: e,
                ariaDescribedById: n,
                inputMode: "numeric"
            }), o.bind("isReadOnly").to(t, "isEnabled", (t => !t)), o.bind("hasError").to(t, "errorText", (t => !!t)), o.on("input", (() => {
                t.errorText = null
            })), t.bind("isEmpty", "isFocused", "placeholder").to(o), o
        }

        function Qm(t, e, n) {
            const o = Wm(t.locale);
            return o.set({
                id: e,
                ariaDescribedById: n
            }), o.bind("isEnabled").to(t), o
        }
        const Xm = (t, e = 0, n = 1) => t > n ? n : t < e ? e : t,
            tp = (t, e = 0, n = Math.pow(10, e)) => Math.round(n * t) / n,
            ep = (Math.PI, t => ("#" === t[0] && (t = t.substring(1)), t.length < 6 ? {
                r: parseInt(t[0] + t[0], 16),
                g: parseInt(t[1] + t[1], 16),
                b: parseInt(t[2] + t[2], 16),
                a: 4 === t.length ? tp(parseInt(t[3] + t[3], 16) / 255, 2) : 1
            } : {
                r: parseInt(t.substring(0, 2), 16),
                g: parseInt(t.substring(2, 4), 16),
                b: parseInt(t.substring(4, 6), 16),
                a: 8 === t.length ? tp(parseInt(t.substring(6, 8), 16) / 255, 2) : 1
            })),
            np = ({
                h: t,
                s: e,
                v: n,
                a: o
            }) => {
                const i = (200 - e) * n / 100;
                return {
                    h: tp(t),
                    s: tp(i > 0 && i < 200 ? e * n / 100 / (i <= 100 ? i : 200 - i) * 100 : 0),
                    l: tp(i / 2),
                    a: tp(o, 2)
                }
            },
            op = t => {
                const {
                    h: e,
                    s: n,
                    l: o
                } = np(t);
                return `hsl(${e}, ${n}%, ${o}%)`
            },
            ip = ({
                h: t,
                s: e,
                v: n,
                a: o
            }) => {
                t = t / 360 * 6, e /= 100, n /= 100;
                const i = Math.floor(t),
                    r = n * (1 - e),
                    s = n * (1 - (t - i) * e),
                    a = n * (1 - (1 - t + i) * e),
                    l = i % 6;
                return {
                    r: tp(255 * [n, s, r, r, a, n][l]),
                    g: tp(255 * [a, n, n, s, r, r][l]),
                    b: tp(255 * [r, r, a, n, n, s][l]),
                    a: tp(o, 2)
                }
            },
            rp = t => {
                const e = t.toString(16);
                return e.length < 2 ? "0" + e : e
            },
            sp = ({
                r: t,
                g: e,
                b: n,
                a: o
            }) => {
                const i = o < 1 ? rp(tp(255 * o)) : "";
                return "#" + rp(t) + rp(e) + rp(n) + i
            },
            ap = ({
                r: t,
                g: e,
                b: n,
                a: o
            }) => {
                const i = Math.max(t, e, n),
                    r = i - Math.min(t, e, n),
                    s = r ? i === t ? (e - n) / r : i === e ? 2 + (n - t) / r : 4 + (t - e) / r : 0;
                return {
                    h: tp(60 * (s < 0 ? s + 6 : s)),
                    s: tp(i ? r / i * 100 : 0),
                    v: tp(i / 255 * 100),
                    a: o
                }
            },
            lp = (t, e) => {
                if (t === e) return !0;
                for (const n in t)
                    if (t[n] !== e[n]) return !1;
                return !0
            },
            cp = {},
            dp = t => {
                let e = cp[t];
                return e || (e = document.createElement("template"), e.innerHTML = t, cp[t] = e), e
            },
            hp = (t, e, n) => {
                t.dispatchEvent(new CustomEvent(e, {
                    bubbles: !0,
                    detail: n
                }))
            };
        let up = !1;
        const gp = t => "touches" in t,
            mp = (t, e) => {
                const n = gp(e) ? e.touches[0] : e,
                    o = t.el.getBoundingClientRect();
                hp(t.el, "move", t.getMove({
                    x: Xm((n.pageX - (o.left + window.pageXOffset)) / o.width),
                    y: Xm((n.pageY - (o.top + window.pageYOffset)) / o.height)
                }))
            };
        class pp {
            constructor(t, e, n, o) {
                const i = dp(`<div role="slider" tabindex="0" part="${e}" ${n}><div part="${e}-pointer"></div></div>`);
                t.appendChild(i.content.cloneNode(!0));
                const r = t.querySelector(`[part=${e}]`);
                r.addEventListener("mousedown", this), r.addEventListener("touchstart", this), r.addEventListener("keydown", this), this.el = r, this.xy = o, this.nodes = [r.firstChild, r]
            }
            set dragging(t) {
                const e = t ? document.addEventListener : document.removeEventListener;
                e(up ? "touchmove" : "mousemove", this), e(up ? "touchend" : "mouseup", this)
            }
            handleEvent(t) {
                switch (t.type) {
                    case "mousedown":
                    case "touchstart":
                        if (t.preventDefault(), !(t => !(up && !gp(t) || (up || (up = gp(t)), 0)))(t) || !up && 0 != t.button) return;
                        this.el.focus(), mp(this, t), this.dragging = !0;
                        break;
                    case "mousemove":
                    case "touchmove":
                        t.preventDefault(), mp(this, t);
                        break;
                    case "mouseup":
                    case "touchend":
                        this.dragging = !1;
                        break;
                    case "keydown":
                        ((t, e) => {
                            const n = e.keyCode;
                            n > 40 || t.xy && n < 37 || n < 33 || (e.preventDefault(), hp(t.el, "move", t.getMove({
                                x: 39 === n ? .01 : 37 === n ? -.01 : 34 === n ? .05 : 33 === n ? -.05 : 35 === n ? 1 : 36 === n ? -1 : 0,
                                y: 40 === n ? .01 : 38 === n ? -.01 : 0
                            }, !0)))
                        })(this, t)
                }
            }
            style(t) {
                t.forEach(((t, e) => {
                    for (const n in t) this.nodes[e].style.setProperty(n, t[n])
                }))
            }
        }
        class fp extends pp {
            constructor(t) {
                super(t, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', !1)
            }
            update({
                h: t
            }) {
                this.h = t, this.style([{
                    left: t / 360 * 100 + "%",
                    color: op({
                        h: t,
                        s: 100,
                        v: 100,
                        a: 1
                    })
                }]), this.el.setAttribute("aria-valuenow", `${tp(t)}`)
            }
            getMove(t, e) {
                return {
                    h: e ? Xm(this.h + 360 * t.x, 0, 360) : 360 * t.x
                }
            }
        }
        class bp extends pp {
            constructor(t) {
                super(t, "saturation", 'aria-label="Color"', !0)
            }
            update(t) {
                this.hsva = t, this.style([{
                    top: 100 - t.v + "%",
                    left: `${t.s}%`,
                    color: op(t)
                }, {
                    "background-color": op({
                        h: t.h,
                        s: 100,
                        v: 100,
                        a: 1
                    })
                }]), this.el.setAttribute("aria-valuetext", `Saturation ${tp(t.s)}%, Brightness ${tp(t.v)}%`)
            }
            getMove(t, e) {
                return {
                    s: e ? Xm(this.hsva.s + 100 * t.x, 0, 100) : 100 * t.x,
                    v: e ? Xm(this.hsva.v - 100 * t.y, 0, 100) : Math.round(100 - 100 * t.y)
                }
            }
        }
        const kp = Symbol("same"),
            wp = Symbol("color"),
            Ap = Symbol("hsva"),
            Cp = Symbol("update"),
            _p = Symbol("parts"),
            vp = Symbol("css"),
            yp = Symbol("sliders");
        class xp extends HTMLElement {
            static get observedAttributes() {
                return ["color"]
            }
            get[vp]() {
                return [':host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}', "[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}", "[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}"]
            }
            get[yp]() {
                return [bp, fp]
            }
            get color() {
                return this[wp]
            }
            set color(t) {
                if (!this[kp](t)) {
                    const e = this.colorModel.toHsva(t);
                    this[Cp](e), this[wp] = t
                }
            }
            constructor() {
                super();
                const t = dp(`<style>${this[vp].join("")}</style>`),
                    e = this.attachShadow({
                        mode: "open"
                    });
                e.appendChild(t.content.cloneNode(!0)), e.addEventListener("move", this), this[_p] = this[yp].map((t => new t(e)))
            }
            connectedCallback() {
                if (this.hasOwnProperty("color")) {
                    const t = this.color;
                    delete this.color, this.color = t
                } else this.color || (this.color = this.colorModel.defaultColor)
            }
            attributeChangedCallback(t, e, n) {
                const o = this.colorModel.fromAttr(n);
                this[kp](o) || (this.color = o)
            }
            handleEvent(t) {
                const e = this[Ap],
                    n = {
                        ...e,
                        ...t.detail
                    };
                let o;
                this[Cp](n), lp(n, e) || this[kp](o = this.colorModel.fromHsva(n)) || (this[wp] = o, hp(this, "color-changed", {
                    value: o
                }))
            } [kp](t) {
                return this.color && this.colorModel.equal(t, this.color)
            } [Cp](t) {
                this[Ap] = t, this[_p].forEach((e => e.update(t)))
            }
        }
        const Ep = {
            defaultColor: "#000",
            toHsva: t => ap(ep(t)),
            fromHsva: ({
                h: t,
                s: e,
                v: n
            }) => sp(ip({
                h: t,
                s: e,
                v: n,
                a: 1
            })),
            equal: (t, e) => t.toLowerCase() === e.toLowerCase() || lp(ep(t), ep(e)),
            fromAttr: t => t
        };
        class Dp extends xp {
            get colorModel() {
                return Ep
            }
        }
        customElements.define("hex-color-picker", class extends Dp {});
        var Sp = n(3398),
            Tp = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Sp.Z, Tp);
        Sp.Z.locals;
        class Bp extends cg {
            constructor(t, e) {
                super(t), this.set("color", ""), this.set("_hexColor", ""), this._format = e.format || "hsl", this.hexInputRow = this._createInputRow();
                const n = this.createCollection();
                n.add(this.hexInputRow), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-color-picker"],
                        tabindex: -1
                    },
                    children: n
                }), this._debounceColorPickerEvent = Fa((t => {
                    this.set("color", t)
                }), 150, {
                    leading: !0
                }), this.on("set:color", ((t, e, n) => {
                    t.return = Xg(n, this._format)
                })), this.on("change:color", (() => {
                    this._hexColor = Ip(this.color)
                })), this.on("change:_hexColor", (() => {
                    document.activeElement !== this.picker && this.picker.setAttribute("color", this._hexColor), Ip(this.color) != Ip(this._hexColor) && (this.color = this._hexColor)
                }))
            }
            render() {
                if (super.render(), this.picker = Po.document.createElement("hex-color-picker"), this.picker.setAttribute("class", "hex-color-picker"), this.picker.setAttribute("tabindex", "-1"), this._createSlidersView(), this.element) {
                    this.element.insertBefore(this.picker, this.hexInputRow.element);
                    const t = document.createElement("style");
                    t.textContent = '[role="slider"]:focus [part$="pointer"] {border: 1px solid #fff;outline: 1px solid var(--ck-color-focus-border);box-shadow: 0 0 0 2px #fff;}', this.picker.shadowRoot.appendChild(t)
                }
                this.picker.addEventListener("color-changed", (t => {
                    const e = t.detail.value;
                    this._debounceColorPickerEvent(e)
                }))
            }
            focus() {
                if (i.isGecko || i.isiOS || i.isSafari) {
                    this.hexInputRow.children.get(1).focus()
                }
                this.slidersView.first.focus()
            }
            _createSlidersView() {
                const t = [...this.picker.shadowRoot.children].filter((t => "slider" === t.getAttribute("role"))).map((t => new Pp(t)));
                this.slidersView = this.createCollection(), t.forEach((t => {
                    this.slidersView.add(t)
                }))
            }
            _createInputRow() {
                const t = new Rp,
                    e = this._createColorInput();
                return new zp(this.locale, [t, e])
            }
            _createColorInput() {
                const t = new sm(this.locale, Jm),
                    {
                        t: e
                    } = this.locale;
                return t.set({
                    label: e("HEX"),
                    class: "color-picker-hex-input"
                }), t.fieldView.bind("value").to(this, "_hexColor", (e => t.isFocused ? t.fieldView.value : e.startsWith("#") ? e.substring(1) : e)), t.fieldView.on("input", (() => {
                    const e = t.fieldView.element.value;
                    if (e) {
                        const t = e.trim(),
                            n = t.startsWith("#") ? t.substring(1) : t;
                        [3, 4, 6, 8].includes(n.length) && /(([0-9a-fA-F]{2}){3,4}|([0-9a-fA-F]){3,4})/.test(n) && this._debounceColorPickerEvent("#" + n)
                    }
                })), t
            }
        }

        function Ip(t) {
            let e = function(t) {
                if (!t) return "";
                const e = tm(t);
                return e ? "hex" === e.space ? e.hexValue : Xg(t, "hex") : "#000"
            }(t);
            return e || (e = "#000"), 4 === e.length && (e = "#" + [e[1], e[1], e[2], e[2], e[3], e[3]].join("")), e.toLowerCase()
        }
        class Pp extends cg {
            constructor(t) {
                super(), this.element = t
            }
            focus() {
                this.element.focus()
            }
        }
        class Rp extends cg {
            constructor(t) {
                super(t), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-color-picker__hash-view"]
                    },
                    children: "#"
                })
            }
        }
        class zp extends cg {
            constructor(t, e) {
                super(t), this.children = this.createCollection(e), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-color-picker__row"]
                    },
                    children: this.children
                })
            }
        }
        class Vp {
            constructor(t) {
                this._components = new Map, this.editor = t
            }* names() {
                for (const t of this._components.values()) yield t.originalName
            }
            add(t, e) {
                this._components.set(Op(t), {
                    callback: e,
                    originalName: t
                })
            }
            create(t) {
                if (!this.has(t)) throw new b("componentfactory-item-missing", this, {
                    name: t
                });
                return this._components.get(Op(t)).callback(this.editor.locale)
            }
            has(t) {
                return this._components.has(Op(t))
            }
        }

        function Op(t) {
            return String(t).toLowerCase()
        }
        var Fp = n(8793),
            Mp = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Fp.Z, Mp);
        Fp.Z.locals;
        var Np = Object.defineProperty,
            Lp = Object.getOwnPropertySymbols,
            Hp = Object.prototype.hasOwnProperty,
            jp = Object.prototype.propertyIsEnumerable,
            qp = (t, e, n) => e in t ? Np(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n,
            Wp = (t, e) => {
                for (var n in e || (e = {})) Hp.call(e, n) && qp(t, n, e[n]);
                if (Lp)
                    for (var n of Lp(e)) jp.call(e, n) && qp(t, n, e[n]);
                return t
            };
        const Up = $o("px"),
            $p = Po.document.body,
            Gp = class extends cg {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", !1), this.set("withArrow", !0), this.set("class", void 0), this._pinWhenIsVisibleCallback = null, this.content = this.createCollection(), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-balloon-panel", e.to("position", (t => `ck-balloon-panel_${t}`)), e.if("isVisible", "ck-balloon-panel_visible"), e.if("withArrow", "ck-balloon-panel_with-arrow"), e.to("class")],
                            style: {
                                top: e.to("top", Up),
                                left: e.to("left", Up)
                            }
                        },
                        children: this.content
                    })
                }
                show() {
                    this.isVisible = !0
                }
                hide() {
                    this.isVisible = !1
                }
                attachTo(t) {
                    this.show();
                    const e = Gp.defaultPositions,
                        n = Object.assign({}, {
                            element: this.element,
                            positions: [e.southArrowNorth, e.southArrowNorthMiddleWest, e.southArrowNorthMiddleEast, e.southArrowNorthWest, e.southArrowNorthEast, e.northArrowSouth, e.northArrowSouthMiddleWest, e.northArrowSouthMiddleEast, e.northArrowSouthWest, e.northArrowSouthEast, e.viewportStickyNorth],
                            limiter: $p,
                            fitInViewport: !0
                        }, t),
                        o = Gp._getOptimalPosition(n),
                        i = parseInt(o.left),
                        r = parseInt(o.top),
                        s = o.name,
                        a = o.config || {},
                        {
                            withArrow: l = !0
                        } = a;
                    this.top = r, this.left = i, this.position = s, this.withArrow = l
                }
                pin(t) {
                    this.unpin(), this._pinWhenIsVisibleCallback = () => {
                        this.isVisible ? this._startPinning(t) : this._stopPinning()
                    }, this._startPinning(t), this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback)
                }
                unpin() {
                    this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide())
                }
                _startPinning(t) {
                    this.attachTo(t);
                    const e = Zp(t.target),
                        n = t.limiter ? Zp(t.limiter) : $p;
                    this.listenTo(Po.document, "scroll", ((o, i) => {
                        const r = i.target,
                            s = e && r.contains(e),
                            a = n && r.contains(n);
                        !s && !a && e && n || this.attachTo(t)
                    }), {
                        useCapture: !0
                    }), this.listenTo(Po.window, "resize", (() => {
                        this.attachTo(t)
                    }))
                }
                _stopPinning() {
                    this.stopListening(Po.document, "scroll"), this.stopListening(Po.window, "resize")
                }
            };
        let Kp = Gp;

        function Zp(t) {
            return Co(t) ? t : Vo(t) ? t.commonAncestorContainer : "function" == typeof t ? Zp(t()) : null
        }

        function Jp(t = {}) {
            const {
                sideOffset: e = Kp.arrowSideOffset,
                heightOffset: n = Kp.arrowHeightOffset,
                stickyVerticalOffset: o = Kp.stickyVerticalOffset,
                config: i
            } = t;
            return {
                northWestArrowSouthWest: (t, n) => Wp({
                    top: r(t, n),
                    left: t.left - e,
                    name: "arrow_sw"
                }, i && {
                    config: i
                }),
                northWestArrowSouthMiddleWest: (t, n) => Wp({
                    top: r(t, n),
                    left: t.left - .25 * n.width - e,
                    name: "arrow_smw"
                }, i && {
                    config: i
                }),
                northWestArrowSouth: (t, e) => Wp({
                    top: r(t, e),
                    left: t.left - e.width / 2,
                    name: "arrow_s"
                }, i && {
                    config: i
                }),
                northWestArrowSouthMiddleEast: (t, n) => Wp({
                    top: r(t, n),
                    left: t.left - .75 * n.width + e,
                    name: "arrow_sme"
                }, i && {
                    config: i
                }),
                northWestArrowSouthEast: (t, n) => Wp({
                    top: r(t, n),
                    left: t.left - n.width + e,
                    name: "arrow_se"
                }, i && {
                    config: i
                }),
                northArrowSouthWest: (t, n) => Wp({
                    top: r(t, n),
                    left: t.left + t.width / 2 - e,
                    name: "arrow_sw"
                }, i && {
                    config: i
                }),
                northArrowSouthMiddleWest: (t, n) => Wp({
                    top: r(t, n),
                    left: t.left + t.width / 2 - .25 * n.width - e,
                    name: "arrow_smw"
                }, i && {
                    config: i
                }),
                northArrowSouth: (t, e) => Wp({
                    top: r(t, e),
                    left: t.left + t.width / 2 - e.width / 2,
                    name: "arrow_s"
                }, i && {
                    config: i
                }),
                northArrowSouthMiddleEast: (t, n) => Wp({
                    top: r(t, n),
                    left: t.left + t.width / 2 - .75 * n.width + e,
                    name: "arrow_sme"
                }, i && {
                    config: i
                }),
                northArrowSouthEast: (t, n) => Wp({
                    top: r(t, n),
                    left: t.left + t.width / 2 - n.width + e,
                    name: "arrow_se"
                }, i && {
                    config: i
                }),
                northEastArrowSouthWest: (t, n) => Wp({
                    top: r(t, n),
                    left: t.right - e,
                    name: "arrow_sw"
                }, i && {
                    config: i
                }),
                northEastArrowSouthMiddleWest: (t, n) => Wp({
                    top: r(t, n),
                    left: t.right - .25 * n.width - e,
                    name: "arrow_smw"
                }, i && {
                    config: i
                }),
                northEastArrowSouth: (t, e) => Wp({
                    top: r(t, e),
                    left: t.right - e.width / 2,
                    name: "arrow_s"
                }, i && {
                    config: i
                }),
                northEastArrowSouthMiddleEast: (t, n) => Wp({
                    top: r(t, n),
                    left: t.right - .75 * n.width + e,
                    name: "arrow_sme"
                }, i && {
                    config: i
                }),
                northEastArrowSouthEast: (t, n) => Wp({
                    top: r(t, n),
                    left: t.right - n.width + e,
                    name: "arrow_se"
                }, i && {
                    config: i
                }),
                southWestArrowNorthWest: t => Wp({
                    top: s(t),
                    left: t.left - e,
                    name: "arrow_nw"
                }, i && {
                    config: i
                }),
                southWestArrowNorthMiddleWest: (t, n) => Wp({
                    top: s(t),
                    left: t.left - .25 * n.width - e,
                    name: "arrow_nmw"
                }, i && {
                    config: i
                }),
                southWestArrowNorth: (t, e) => Wp({
                    top: s(t),
                    left: t.left - e.width / 2,
                    name: "arrow_n"
                }, i && {
                    config: i
                }),
                southWestArrowNorthMiddleEast: (t, n) => Wp({
                    top: s(t),
                    left: t.left - .75 * n.width + e,
                    name: "arrow_nme"
                }, i && {
                    config: i
                }),
                southWestArrowNorthEast: (t, n) => Wp({
                    top: s(t),
                    left: t.left - n.width + e,
                    name: "arrow_ne"
                }, i && {
                    config: i
                }),
                southArrowNorthWest: t => Wp({
                    top: s(t),
                    left: t.left + t.width / 2 - e,
                    name: "arrow_nw"
                }, i && {
                    config: i
                }),
                southArrowNorthMiddleWest: (t, n) => Wp({
                    top: s(t),
                    left: t.left + t.width / 2 - .25 * n.width - e,
                    name: "arrow_nmw"
                }, i && {
                    config: i
                }),
                southArrowNorth: (t, e) => Wp({
                    top: s(t),
                    left: t.left + t.width / 2 - e.width / 2,
                    name: "arrow_n"
                }, i && {
                    config: i
                }),
                southArrowNorthMiddleEast: (t, n) => Wp({
                    top: s(t),
                    left: t.left + t.width / 2 - .75 * n.width + e,
                    name: "arrow_nme"
                }, i && {
                    config: i
                }),
                southArrowNorthEast: (t, n) => Wp({
                    top: s(t),
                    left: t.left + t.width / 2 - n.width + e,
                    name: "arrow_ne"
                }, i && {
                    config: i
                }),
                southEastArrowNorthWest: t => Wp({
                    top: s(t),
                    left: t.right - e,
                    name: "arrow_nw"
                }, i && {
                    config: i
                }),
                southEastArrowNorthMiddleWest: (t, n) => Wp({
                    top: s(t),
                    left: t.right - .25 * n.width - e,
                    name: "arrow_nmw"
                }, i && {
                    config: i
                }),
                southEastArrowNorth: (t, e) => Wp({
                    top: s(t),
                    left: t.right - e.width / 2,
                    name: "arrow_n"
                }, i && {
                    config: i
                }),
                southEastArrowNorthMiddleEast: (t, n) => Wp({
                    top: s(t),
                    left: t.right - .75 * n.width + e,
                    name: "arrow_nme"
                }, i && {
                    config: i
                }),
                southEastArrowNorthEast: (t, n) => Wp({
                    top: s(t),
                    left: t.right - n.width + e,
                    name: "arrow_ne"
                }, i && {
                    config: i
                }),
                westArrowEast: (t, e) => Wp({
                    top: t.top + t.height / 2 - e.height / 2,
                    left: t.left - e.width - n,
                    name: "arrow_e"
                }, i && {
                    config: i
                }),
                eastArrowWest: (t, e) => Wp({
                    top: t.top + t.height / 2 - e.height / 2,
                    left: t.right + n,
                    name: "arrow_w"
                }, i && {
                    config: i
                }),
                viewportStickyNorth: (t, e, n) => t.getIntersection(n) ? {
                    top: n.top + o,
                    left: t.left + t.width / 2 - e.width / 2,
                    name: "arrowless",
                    config: Wp({
                        withArrow: !1
                    }, i)
                } : null
            };

            function r(t, e) {
                return t.top - e.height - n
            }

            function s(t) {
                return t.bottom + n
            }
        }
        Kp.arrowSideOffset = 25, Kp.arrowHeightOffset = 10, Kp.stickyVerticalOffset = 20, Kp._getOptimalPosition = Qo, Kp.defaultPositions = Jp();
        var Yp = n(3332),
            Qp = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Yp.Z, Qp);
        Yp.Z.locals;
        const Xp = "ck-tooltip",
            tf = class extends(So()) {
                constructor(t) {
                    if (super(), this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver = null, tf._editors.add(t), tf._instance) return tf._instance;
                    tf._instance = this, this.tooltipTextView = new cg(t.locale), this.tooltipTextView.set("text", ""), this.tooltipTextView.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-tooltip__text"]
                        },
                        children: [{
                            text: this.tooltipTextView.bindTemplate.to("text")
                        }]
                    }), this.balloonPanelView = new Kp(t.locale), this.balloonPanelView.class = Xp, this.balloonPanelView.content.add(this.tooltipTextView), this._pinTooltipDebounced = Fa(this._pinTooltip, 600), this.listenTo(Po.document, "mouseenter", this._onEnterOrFocus.bind(this), {
                        useCapture: !0
                    }), this.listenTo(Po.document, "mouseleave", this._onLeaveOrBlur.bind(this), {
                        useCapture: !0
                    }), this.listenTo(Po.document, "focus", this._onEnterOrFocus.bind(this), {
                        useCapture: !0
                    }), this.listenTo(Po.document, "blur", this._onLeaveOrBlur.bind(this), {
                        useCapture: !0
                    }), this.listenTo(Po.document, "scroll", this._onScroll.bind(this), {
                        useCapture: !0
                    }), this._watchdogExcluded = !0
                }
                destroy(t) {
                    const e = t.ui.view && t.ui.view.body;
                    tf._editors.delete(t), this.stopListening(t.ui), e && e.has(this.balloonPanelView) && e.remove(this.balloonPanelView), tf._editors.size || (this._unpinTooltip(), this.balloonPanelView.destroy(), this.stopListening(), tf._instance = null)
                }
                static getPositioningFunctions(t) {
                    const e = tf.defaultBalloonPositions;
                    return {
                        s: [e.southArrowNorth, e.southArrowNorthEast, e.southArrowNorthWest],
                        n: [e.northArrowSouth],
                        e: [e.eastArrowWest],
                        w: [e.westArrowEast],
                        sw: [e.southArrowNorthEast],
                        se: [e.southArrowNorthWest]
                    } [t]
                }
                _onEnterOrFocus(t, {
                    target: e
                }) {
                    const n = nf(e);
                    var o;
                    n && (n !== this._currentElementWithTooltip && (this._unpinTooltip(), this._pinTooltipDebounced(n, {
                        text: (o = n).dataset.ckeTooltipText,
                        position: o.dataset.ckeTooltipPosition || "s",
                        cssClass: o.dataset.ckeTooltipClass || ""
                    })))
                }
                _onLeaveOrBlur(t, {
                    target: e,
                    relatedTarget: n
                }) {
                    if ("mouseleave" === t.name) {
                        if (!Co(e)) return;
                        if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) return;
                        const t = nf(e),
                            o = nf(n);
                        t && t !== o && this._unpinTooltip()
                    } else {
                        if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) return;
                        this._unpinTooltip()
                    }
                }
                _onScroll(t, {
                    target: e
                }) {
                    this._currentElementWithTooltip && (e.contains(this.balloonPanelView.element) && e.contains(this._currentElementWithTooltip) || this._unpinTooltip())
                }
                _pinTooltip(t, {
                    text: e,
                    position: n,
                    cssClass: o
                }) {
                    const i = Ei(tf._editors.values()).ui.view.body;
                    i.has(this.balloonPanelView) || i.add(this.balloonPanelView), this.tooltipTextView.text = e, this.balloonPanelView.pin({
                        target: t,
                        positions: tf.getPositioningFunctions(n)
                    }), this._resizeObserver = new Wo(t, (() => {
                        Jo(t) || this._unpinTooltip()
                    })), this.balloonPanelView.class = [Xp, o].filter((t => t)).join(" ");
                    for (const t of tf._editors) this.listenTo(t.ui, "update", this._updateTooltipPosition.bind(this), {
                        priority: "low"
                    });
                    this._currentElementWithTooltip = t, this._currentTooltipPosition = n
                }
                _unpinTooltip() {
                    this._pinTooltipDebounced.cancel(), this.balloonPanelView.unpin();
                    for (const t of tf._editors) this.stopListening(t.ui, "update");
                    this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver && this._resizeObserver.destroy()
                }
                _updateTooltipPosition() {
                    Jo(this._currentElementWithTooltip) ? this.balloonPanelView.pin({
                        target: this._currentElementWithTooltip,
                        positions: tf.getPositioningFunctions(this._currentTooltipPosition)
                    }) : this._unpinTooltip()
                }
            };
        let ef = tf;

        function nf(t) {
            return Co(t) ? t.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") : null
        }
        ef.defaultBalloonPositions = Jp({
            heightOffset: 5,
            sideOffset: 13
        }), ef._editors = new Set, ef._instance = null;
        const of = function(t, e, n) {
            var o = !0,
                i = !0;
            if ("function" != typeof t) throw new TypeError("Expected a function");
            return O(n) && (o = "leading" in n ? !!n.leading : o, i = "trailing" in n ? !!n.trailing : i), Fa(t, e, {
                leading: o,
                maxWait: e,
                trailing: i
            })
        };
        var rf = Object.defineProperty,
            sf = Object.getOwnPropertySymbols,
            af = Object.prototype.hasOwnProperty,
            lf = Object.prototype.propertyIsEnumerable,
            cf = (t, e, n) => e in t ? rf(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n,
            df = (t, e) => {
                for (var n in e || (e = {})) af.call(e, n) && cf(t, n, e[n]);
                if (sf)
                    for (var n of sf(e)) lf.call(e, n) && cf(t, n, e[n]);
                return t
            };
        const hf = 50,
            uf = 350,
            gf = "Powered by",
            mf = {
                top: -99999,
                left: -99999,
                name: "invalid",
                config: {
                    withArrow: !1
                }
            };
        class pf extends(So()) {
            constructor(t) {
                super(), this.editor = t, this._balloonView = null, this._lastFocusedEditableElement = null, this._showBalloonThrottled = of(this._showBalloon.bind(this), 50, {
                    leading: !0
                }), t.on("ready", this._handleEditorReady.bind(this))
            }
            destroy() {
                const t = this._balloonView;
                t && (t.unpin(), this._balloonView = null), this._showBalloonThrottled.cancel(), this.stopListening()
            }
            _handleEditorReady() {
                const t = this.editor;
                (!!t.config.get("ui.poweredBy.forceVisible") || "VALID" !== function(t) {
                    function e(t) {
                        return t.length >= 40 && t.length <= 255 ? "VALID" : "INVALID"
                    }
                    if (!t) return "INVALID";
                    let n = "";
                    try {
                        n = atob(t)
                    } catch (t) {
                        return "INVALID"
                    }
                    const o = n.split("-"),
                        i = o[0],
                        r = o[1];
                    if (!r) return e(t);
                    try {
                        atob(r)
                    } catch (n) {
                        try {
                            if (atob(i), !atob(i).length) return e(t)
                        } catch (n) {
                            return e(t)
                        }
                    }
                    if (i.length < 40 || i.length > 255) return "INVALID";
                    let s = "";
                    try {
                        atob(i), s = atob(r)
                    } catch (t) {
                        return "INVALID"
                    }
                    if (8 !== s.length) return "INVALID";
                    const a = Number(s.substring(0, 4)),
                        l = Number(s.substring(4, 6)) - 1,
                        c = Number(s.substring(6, 8)),
                        d = new Date(a, l, c);
                    return d < _ || isNaN(Number(d)) ? "INVALID" : "VALID"
                }(t.config.get("licenseKey"))) && t.ui.view && (t.ui.focusTracker.on("change:isFocused", ((t, e, n) => {
                    this._updateLastFocusedEditableElement(), n ? this._showBalloon() : this._hideBalloon()
                })), t.ui.focusTracker.on("change:focusedElement", ((t, e, n) => {
                    this._updateLastFocusedEditableElement(), n && this._showBalloon()
                })), t.ui.on("update", (() => {
                    this._showBalloonThrottled()
                })))
            }
            _createBalloonView() {
                const t = this.editor,
                    e = this._balloonView = new Kp,
                    n = kf(t),
                    o = new ff(t.locale, n.label);
                e.content.add(o), e.set({
                    class: "ck-powered-by-balloon"
                }), t.ui.view.body.add(e), t.ui.focusTracker.add(e.element), this._balloonView = e
            }
            _showBalloon() {
                if (!this._lastFocusedEditableElement) return;
                const t = function(t, e) {
                    const n = kf(t),
                        o = "right" === n.side ? function(t, e) {
                            return bf(t, e, ((t, n) => t.left + t.width - n.width - e.horizontalOffset))
                        }(e, n) : function(t, e) {
                            return bf(t, e, (t => t.left + e.horizontalOffset))
                        }(e, n);
                    return {
                        target: e,
                        positions: [o]
                    }
                }(this.editor, this._lastFocusedEditableElement);
                t && (this._balloonView || this._createBalloonView(), this._balloonView.pin(t))
            }
            _hideBalloon() {
                this._balloonView && this._balloonView.unpin()
            }
            _updateLastFocusedEditableElement() {
                const t = this.editor,
                    e = t.ui.focusTracker.isFocused,
                    n = t.ui.focusTracker.focusedElement;
                if (!e || !n) return void(this._lastFocusedEditableElement = null);
                const o = Array.from(t.ui.getEditableElementsNames()).map((e => t.ui.getEditableElement(e)));
                o.includes(n) ? this._lastFocusedEditableElement = n : this._lastFocusedEditableElement = o[0]
            }
        }
        class ff extends cg {
            constructor(t, e) {
                super(t);
                const n = new Vg,
                    o = this.bindTemplate;
                n.set({
                    content: '<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>\n',
                    isColorInherited: !1
                }), n.extendTemplate({
                    attributes: {
                        style: {
                            width: "53px",
                            height: "10px"
                        }
                    }
                }), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-powered-by"],
                        "aria-hidden": !0
                    },
                    children: [{
                        tag: "a",
                        attributes: {
                            href: "https://ckeditor.com/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
                            target: "_blank",
                            tabindex: "-1"
                        },
                        children: [...e ? [{
                            tag: "span",
                            attributes: {
                                class: ["ck", "ck-powered-by__label"]
                            },
                            children: [e]
                        }] : [], n],
                        on: {
                            dragstart: o.to((t => t.preventDefault()))
                        }
                    }]
                })
            }
        }

        function bf(t, e, n) {
            return (o, i) => {
                const r = o.getVisible();
                if (!r) return mf;
                if (o.width < uf || o.height < hf) return mf;
                let s;
                s = "inside" === e.position ? o.bottom - i.height : o.bottom - i.height / 2, s -= e.verticalOffset;
                const a = n(o, i);
                if ("inside" === e.position) {
                    const t = i.clone().moveTo(a, s);
                    if (t.getIntersectionArea(r) < t.getArea()) return mf
                } else {
                    const e = function(t) {
                        let e = t.parentElement;
                        if (!e) return null;
                        for (;
                            "BODY" != e.tagName;) {
                            const t = e.style.overflowY || Po.window.getComputedStyle(e).overflowY;
                            if ("auto" === t || "scroll" === t) break;
                            if (e = e.parentElement, !e) return null
                        }
                        return e
                    }(t);
                    if (e) {
                        const t = new Mo(e);
                        if (r.bottom + i.height / 2 > t.bottom) return mf
                    }
                }
                return {
                    top: s,
                    left: a,
                    name: `position_${e.position}-side_${e.side}`,
                    config: {
                        withArrow: !1
                    }
                }
            }
        }

        function kf(t) {
            const e = t.config.get("ui.poweredBy"),
                n = e && e.position || "border";
            return df({
                position: n,
                label: gf,
                verticalOffset: "inside" === n ? 5 : 0,
                horizontalOffset: 5,
                side: "ltr" === t.locale.contentLanguageDirection ? "right" : "left"
            }, e)
        }
        var wf = Object.defineProperty,
            Af = Object.getOwnPropertySymbols,
            Cf = Object.prototype.hasOwnProperty,
            _f = Object.prototype.propertyIsEnumerable,
            vf = (t, e, n) => e in t ? wf(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n;
        class yf extends(q()) {
            constructor(t) {
                super(), this.isReady = !1, this._editableElementsMap = new Map, this._focusableToolbarDefinitions = [];
                const e = t.editing.view;
                this.editor = t, this.componentFactory = new Vp(t), this.focusTracker = new Di, this.tooltipManager = new ef(t), this.poweredBy = new pf(t), this.set("viewportOffset", this._readViewportOffsetFromConfig()), this.once("ready", (() => {
                    this.isReady = !0
                })), this.listenTo(e.document, "layoutChanged", this.update.bind(this)), this.listenTo(e, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this)), this._initFocusTracking()
            }
            get element() {
                return null
            }
            update() {
                this.fire("update")
            }
            destroy() {
                this.stopListening(), this.focusTracker.destroy(), this.tooltipManager.destroy(this.editor), this.poweredBy.destroy();
                for (const t of this._editableElementsMap.values()) t.ckeditorInstance = null, this.editor.keystrokes.stopListening(t);
                this._editableElementsMap = new Map, this._focusableToolbarDefinitions = []
            }
            setEditableElement(t, e) {
                this._editableElementsMap.set(t, e), e.ckeditorInstance || (e.ckeditorInstance = this.editor), this.focusTracker.add(e);
                const n = () => {
                    this.editor.editing.view.getDomRoot(t) || this.editor.keystrokes.listenTo(e)
                };
                this.isReady ? n() : this.once("ready", n)
            }
            removeEditableElement(t) {
                const e = this._editableElementsMap.get(t);
                e && (this._editableElementsMap.delete(t), this.editor.keystrokes.stopListening(e), this.focusTracker.remove(e), e.ckeditorInstance = null)
            }
            getEditableElement(t = "main") {
                return this._editableElementsMap.get(t)
            }
            getEditableElementsNames() {
                return this._editableElementsMap.keys()
            }
            addToolbar(t, e = {}) {
                t.isRendered ? (this.focusTracker.add(t.element), this.editor.keystrokes.listenTo(t.element)) : t.once("render", (() => {
                    this.focusTracker.add(t.element), this.editor.keystrokes.listenTo(t.element)
                })), this._focusableToolbarDefinitions.push({
                    toolbarView: t,
                    options: e
                })
            }
            get _editableElements() {
                return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", {
                    editorUI: this
                }), this._editableElementsMap
            }
            _readViewportOffsetFromConfig() {
                const t = this.editor,
                    e = t.config.get("ui.viewportOffset");
                if (e) return e;
                const n = t.config.get("toolbar.viewportTopOffset");
                return n ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), {
                    top: n
                }) : {
                    top: 0
                }
            }
            _initFocusTracking() {
                const t = this.editor,
                    e = t.editing.view;
                let n, o;
                t.keystrokes.set("Alt+F10", ((t, i) => {
                    const r = this.focusTracker.focusedElement;
                    Array.from(this._editableElementsMap.values()).includes(r) && !Array.from(e.domRoots.values()).includes(r) && (n = r);
                    const s = this._getCurrentFocusedToolbarDefinition();
                    s && o || (o = this._getFocusableCandidateToolbarDefinitions());
                    for (let t = 0; t < o.length; t++) {
                        const t = o.shift();
                        if (o.push(t), t !== s && this._focusFocusableCandidateToolbar(t)) {
                            s && s.options.afterBlur && s.options.afterBlur();
                            break
                        }
                    }
                    i()
                })), t.keystrokes.set("Esc", ((e, o) => {
                    const i = this._getCurrentFocusedToolbarDefinition();
                    i && (n ? (n.focus(), n = null) : t.editing.view.focus(), i.options.afterBlur && i.options.afterBlur(), o())
                }))
            }
            _getFocusableCandidateToolbarDefinitions() {
                const t = [];
                for (const e of this._focusableToolbarDefinitions) {
                    const {
                        toolbarView: n,
                        options: o
                    } = e;
                    (Jo(n.element) || o.beforeFocus) && t.push(e)
                }
                return t.sort(((t, e) => xf(t) - xf(e))), t
            }
            _getCurrentFocusedToolbarDefinition() {
                for (const t of this._focusableToolbarDefinitions)
                    if (t.toolbarView.element && t.toolbarView.element.contains(this.focusTracker.focusedElement)) return t;
                return null
            }
            _focusFocusableCandidateToolbar(t) {
                const {
                    toolbarView: e,
                    options: {
                        beforeFocus: n
                    }
                } = t;
                return n && n(), !!Jo(e.element) && (e.focus(), !0)
            }
            _handleScrollToTheSelection(t, e) {
                const n = ((t, e) => {
                    for (var n in e || (e = {})) Cf.call(e, n) && vf(t, n, e[n]);
                    if (Af)
                        for (var n of Af(e)) _f.call(e, n) && vf(t, n, e[n]);
                    return t
                })({
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0
                }, this.viewportOffset);
                e.viewportOffset.top += n.top, e.viewportOffset.bottom += n.bottom, e.viewportOffset.left += n.left, e.viewportOffset.right += n.right
            }
        }

        function xf(t) {
            const {
                toolbarView: e,
                options: n
            } = t;
            let o = 10;
            return Jo(e.element) && o--, n.isContextual && o--, o
        }
        var Ef = n(9688),
            Df = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Ef.Z, Df);
        Ef.Z.locals;
        class Sf extends cg {
            constructor(t) {
                super(t), this.body = new Ig(t)
            }
            render() {
                super.render(), this.body.attachToDom()
            }
            destroy() {
                return this.body.detachFromDom(), super.destroy()
            }
        }
        class Tf extends cg {
            constructor(t, e, n) {
                super(t), this.name = null, this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"],
                        lang: t.contentLanguage,
                        dir: t.contentLanguageDirection
                    }
                }), this.set("isFocused", !1), this._editableElement = n, this._hasExternalElement = !!this._editableElement, this._editingView = e
            }
            render() {
                super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", (() => this._updateIsFocusedClasses())), this._updateIsFocusedClasses()
            }
            destroy() {
                this._hasExternalElement && this.template.revert(this._editableElement), super.destroy()
            }
            get hasExternalElement() {
                return this._hasExternalElement
            }
            _updateIsFocusedClasses() {
                const t = this._editingView;

                function e(e) {
                    t.change((n => {
                        const o = t.document.getRoot(e.name);
                        n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", o), n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", o)
                    }))
                }
                t.isRenderingInProgress ? function n(o) {
                    t.once("change:isRenderingInProgress", ((t, i, r) => {
                        r ? n(o) : e(o)
                    }))
                }(this) : e(this)
            }
        }
        class Bf extends Tf {
            constructor(t, e, n, o = {}) {
                super(t, e, n);
                const i = t.t;
                this.extendTemplate({
                    attributes: {
                        role: "textbox",
                        class: "ck-editor__editable_inline"
                    }
                }), this._generateLabel = o.label || (() => i("Editor editing area: %0", this.name))
            }
            render() {
                super.render();
                const t = this._editingView;
                t.change((e => {
                    const n = t.document.getRoot(this.name);
                    e.setAttribute("aria-label", this._generateLabel(this), n)
                }))
            }
        }
        var If = n(8847),
            Pf = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(If.Z, Pf);
        If.Z.locals;
        class Rf extends cg {
            constructor(t, e = {}) {
                super(t);
                const n = this.bindTemplate;
                this.set("label", e.label || ""), this.set("class", e.class || null), this.children = this.createCollection(), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-form__header", n.to("class")]
                    },
                    children: this.children
                });
                const o = new cg(t);
                o.setTemplate({
                    tag: "h2",
                    attributes: {
                        class: ["ck", "ck-form__header__label"]
                    },
                    children: [{
                        text: n.to("label")
                    }]
                }), this.children.add(o)
            }
        }
        class zf extends ji {
            static get pluginName() {
                return "Notification"
            }
            init() {
                this.on("show:warning", ((t, e) => {
                    window.alert(e.message)
                }), {
                    priority: "lowest"
                })
            }
            showSuccess(t, e = {}) {
                this._showNotification({
                    message: t,
                    type: "success",
                    namespace: e.namespace,
                    title: e.title
                })
            }
            showInfo(t, e = {}) {
                this._showNotification({
                    message: t,
                    type: "info",
                    namespace: e.namespace,
                    title: e.title
                })
            }
            showWarning(t, e = {}) {
                this._showNotification({
                    message: t,
                    type: "warning",
                    namespace: e.namespace,
                    title: e.title
                })
            }
            _showNotification(t) {
                const e = t.namespace ? `show:${t.type}:${t.namespace}` : `show:${t.type}`;
                this.fire(e, {
                    message: t.message,
                    type: t.type,
                    title: t.title || ""
                })
            }
        }
        class Vf extends(q()) {
            constructor(t, e) {
                super(), e && Ca(this, e), t && this.set(t)
            }
        }
        const Of = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
        var Ff = n(4650),
            Mf = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Ff.Z, Mf);
        Ff.Z.locals;
        var Nf = n(7676),
            Lf = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Nf.Z, Lf);
        Nf.Z.locals;
        const Hf = $o("px");
        class jf extends Vi {
            constructor(t) {
                super(t), this._viewToStack = new Map, this._idToStack = new Map, this._view = null, this._rotatorView = null, this._fakePanelsView = null, this.positionLimiter = () => {
                    const t = this.editor.editing.view,
                        e = t.document.selection.editableElement;
                    return e ? t.domConverter.mapViewToDom(e.root) : null
                }, this.set("visibleView", null), this.set("_numberOfStacks", 0), this.set("_singleViewMode", !1)
            }
            static get pluginName() {
                return "ContextualBalloon"
            }
            destroy() {
                super.destroy(), this._view && this._view.destroy(), this._rotatorView && this._rotatorView.destroy(), this._fakePanelsView && this._fakePanelsView.destroy()
            }
            get view() {
                return this._view || this._createPanelView(), this._view
            }
            hasView(t) {
                return Array.from(this._viewToStack.keys()).includes(t)
            }
            add(t) {
                if (this._view || this._createPanelView(), this.hasView(t.view)) throw new b("contextualballoon-add-view-exist", [this, t]);
                const e = t.stackId || "main";
                if (!this._idToStack.has(e)) return this._idToStack.set(e, new Map([
                    [t.view, t]
                ])), this._viewToStack.set(t.view, this._idToStack.get(e)), this._numberOfStacks = this._idToStack.size, void(this._visibleStack && !t.singleViewMode || this.showStack(e));
                const n = this._idToStack.get(e);
                t.singleViewMode && this.showStack(e), n.set(t.view, t), this._viewToStack.set(t.view, n), n === this._visibleStack && this._showView(t)
            }
            remove(t) {
                if (!this.hasView(t)) throw new b("contextualballoon-remove-view-not-exist", [this, t]);
                const e = this._viewToStack.get(t);
                this._singleViewMode && this.visibleView === t && (this._singleViewMode = !1), this.visibleView === t && (1 === e.size ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(e.values())[e.size - 2])), 1 === e.size ? (this._idToStack.delete(this._getStackId(e)), this._numberOfStacks = this._idToStack.size) : e.delete(t), this._viewToStack.delete(t)
            }
            updatePosition(t) {
                t && (this._visibleStack.get(this.visibleView).position = t), this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition()
            }
            showStack(t) {
                this.visibleStack = t;
                const e = this._idToStack.get(t);
                if (!e) throw new b("contextualballoon-showstack-stack-not-exist", this);
                this._visibleStack !== e && this._showView(Array.from(e.values()).pop())
            }
            _createPanelView() {
                this._view = new Kp(this.editor.locale), this.editor.ui.view.body.add(this._view), this.editor.ui.focusTracker.add(this._view.element), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView()
            }
            get _visibleStack() {
                return this._viewToStack.get(this.visibleView)
            }
            _getStackId(t) {
                return Array.from(this._idToStack.entries()).find((e => e[1] === t))[0]
            }
            _showNextStack() {
                const t = Array.from(this._idToStack.values());
                let e = t.indexOf(this._visibleStack) + 1;
                t[e] || (e = 0), this.showStack(this._getStackId(t[e]))
            }
            _showPrevStack() {
                const t = Array.from(this._idToStack.values());
                let e = t.indexOf(this._visibleStack) - 1;
                t[e] || (e = t.length - 1), this.showStack(this._getStackId(t[e]))
            }
            _createRotatorView() {
                const t = new qf(this.editor.locale),
                    e = this.editor.locale.t;
                return this.view.content.add(t), t.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", ((t, e) => !e && t > 1)), t.on("change:isNavigationVisible", (() => this.updatePosition()), {
                    priority: "low"
                }), t.bind("counter").to(this, "visibleView", this, "_numberOfStacks", ((t, n) => {
                    if (n < 2) return "";
                    const o = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
                    return e("%0 of %1", [o, n])
                })), t.buttonNextView.on("execute", (() => {
                    t.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack()
                })), t.buttonPrevView.on("execute", (() => {
                    t.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack()
                })), t
            }
            _createFakePanelsView() {
                const t = new Wf(this.editor.locale, this.view);
                return t.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", ((t, e) => !e && t >= 2 ? Math.min(t - 1, 2) : 0)), t.listenTo(this.view, "change:top", (() => t.updatePosition())), t.listenTo(this.view, "change:left", (() => t.updatePosition())), this.editor.ui.view.body.add(t), t
            }
            _showView({
                view: t,
                balloonClassName: e = "",
                withArrow: n = !0,
                singleViewMode: o = !1
            }) {
                this.view.class = e, this.view.withArrow = n, this._rotatorView.showView(t), this.visibleView = t, this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition(), o && (this._singleViewMode = !0)
            }
            _getBalloonPosition() {
                let t = Array.from(this._visibleStack.values()).pop().position;
                return t && (t.limiter || (t = Object.assign({}, t, {
                    limiter: this.positionLimiter
                })), t = Object.assign({}, t, {
                    viewportOffsetConfig: this.editor.ui.viewportOffset
                })), t
            }
        }
        class qf extends cg {
            constructor(t) {
                super(t);
                const e = t.t,
                    n = this.bindTemplate;
                this.set("isNavigationVisible", !0), this.focusTracker = new Di, this.buttonPrevView = this._createButtonView(e("Previous"), Of), this.buttonNextView = this._createButtonView(e("Next"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'), this.content = this.createCollection(), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-balloon-rotator"],
                        "z-index": "-1"
                    },
                    children: [{
                        tag: "div",
                        attributes: {
                            class: ["ck-balloon-rotator__navigation", n.to("isNavigationVisible", (t => t ? "" : "ck-hidden"))]
                        },
                        children: [this.buttonPrevView, {
                            tag: "span",
                            attributes: {
                                class: ["ck-balloon-rotator__counter"]
                            },
                            children: [{
                                text: n.to("counter")
                            }]
                        }, this.buttonNextView]
                    }, {
                        tag: "div",
                        attributes: {
                            class: "ck-balloon-rotator__content"
                        },
                        children: this.content
                    }]
                })
            }
            render() {
                super.render(), this.focusTracker.add(this.element)
            }
            destroy() {
                super.destroy(), this.focusTracker.destroy()
            }
            showView(t) {
                this.hideView(), this.content.add(t)
            }
            hideView() {
                this.content.clear()
            }
            _createButtonView(t, e) {
                const n = new Mg(this.locale);
                return n.set({
                    label: t,
                    icon: e,
                    tooltip: !0
                }), n
            }
        }
        class Wf extends cg {
            constructor(t, e) {
                super(t);
                const n = this.bindTemplate;
                this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = e, this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck-fake-panel", n.to("numberOfPanels", (t => t ? "" : "ck-hidden"))],
                        style: {
                            top: n.to("top", Hf),
                            left: n.to("left", Hf),
                            width: n.to("width", Hf),
                            height: n.to("height", Hf)
                        }
                    },
                    children: this.content
                }), this.on("change:numberOfPanels", ((t, e, n, o) => {
                    n > o ? this._addPanels(n - o) : this._removePanels(o - n), this.updatePosition()
                }))
            }
            _addPanels(t) {
                for (; t--;) {
                    const t = new cg;
                    t.setTemplate({
                        tag: "div"
                    }), this.content.add(t), this.registerChild(t)
                }
            }
            _removePanels(t) {
                for (; t--;) {
                    const t = this.content.last;
                    this.content.remove(t), this.deregisterChild(t), t.destroy()
                }
            }
            updatePosition() {
                if (this.numberOfPanels) {
                    const {
                        top: t,
                        left: e
                    } = this._balloonPanelView, {
                        width: n,
                        height: o
                    } = new Mo(this._balloonPanelView.element);
                    Object.assign(this, {
                        top: t,
                        left: e,
                        width: n,
                        height: o
                    })
                }
            }
        }
        var Uf = n(5868),
            $f = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Uf.Z, $f);
        Uf.Z.locals, $o("px");
        const Gf = $o("px");
        class Kf extends Vi {
            constructor(t) {
                super(t), this._resizeObserver = null, this._balloonConfig = vm(t.config.get("balloonToolbar")), this.toolbarView = this._createToolbarView(), this.focusTracker = new Di, t.ui.once("ready", (() => {
                    this.focusTracker.add(t.ui.getEditableElement()), this.focusTracker.add(this.toolbarView.element)
                })), t.ui.addToolbar(this.toolbarView, {
                    beforeFocus: () => this.show(!0),
                    afterBlur: () => this.hide(),
                    isContextual: !0
                }), this._balloon = t.plugins.get(jf), this._fireSelectionChangeDebounced = Fa((() => this.fire("_selectionChangeDebounced")), 200), this.decorate("show")
            }
            static get pluginName() {
                return "BalloonToolbar"
            }
            static get requires() {
                return [jf]
            }
            init() {
                const t = this.editor,
                    e = t.model.document.selection;
                this.listenTo(this.focusTracker, "change:isFocused", ((t, e, n) => {
                    const o = this._balloon.visibleView === this.toolbarView;
                    !n && o ? this.hide() : n && this.show()
                })), this.listenTo(e, "change:range", ((t, n) => {
                    (n.directChange || e.isCollapsed) && this.hide(), this._fireSelectionChangeDebounced()
                })), this.listenTo(this, "_selectionChangeDebounced", (() => {
                    this.editor.editing.view.document.isFocused && this.show()
                })), this._balloonConfig.shouldNotGroupWhenFull || this.listenTo(t, "ready", (() => {
                    const e = t.ui.view.editable.element;
                    this._resizeObserver = new Wo(e, (t => {
                        this.toolbarView.maxWidth = Gf(.9 * t.contentRect.width)
                    }))
                })), this.listenTo(this.toolbarView, "groupedItemsUpdate", (() => {
                    this._updatePosition()
                }))
            }
            afterInit() {
                const t = this.editor.ui.componentFactory;
                this.toolbarView.fillFromConfig(this._balloonConfig, t)
            }
            _createToolbarView() {
                const t = this.editor.locale.t,
                    e = !this._balloonConfig.shouldNotGroupWhenFull,
                    n = new Sm(this.editor.locale, {
                        shouldGroupWhenFull: e,
                        isFloating: !0
                    });
                return n.ariaLabel = t("Editor contextual toolbar"), n.render(), n
            }
            show(t = !1) {
                const e = this.editor,
                    n = e.model.document.selection,
                    o = e.model.schema;
                this._balloon.hasView(this.toolbarView) || n.isCollapsed && !t || function(t, e) {
                    if (1 === t.rangeCount) return !1;
                    return [...t.getRanges()].every((t => {
                        const n = t.getContainedElement();
                        return n && e.isSelectable(n)
                    }))
                }(n, o) || Array.from(this.toolbarView.items).every((t => void 0 !== t.isEnabled && !t.isEnabled)) || (this.listenTo(this.editor.ui, "update", (() => {
                    this._updatePosition()
                })), this._balloon.add({
                    view: this.toolbarView,
                    position: this._getBalloonPositionData(),
                    balloonClassName: "ck-toolbar-container"
                }))
            }
            hide() {
                this._balloon.hasView(this.toolbarView) && (this.stopListening(this.editor.ui, "update"), this._balloon.remove(this.toolbarView))
            }
            _getBalloonPositionData() {
                const t = this.editor.editing.view,
                    e = t.document,
                    n = e.selection,
                    o = e.selection.isBackward;
                return {
                    target: () => {
                        const e = o ? n.getFirstRange() : n.getLastRange(),
                            i = Mo.getDomRangeRects(t.domConverter.viewRangeToDom(e));
                        return o ? i[0] : (i.length > 1 && 0 === i[i.length - 1].width && i.pop(), i[i.length - 1])
                    },
                    positions: this._getBalloonPositions(o)
                }
            }
            _updatePosition() {
                this._balloon.updatePosition(this._getBalloonPositionData())
            }
            destroy() {
                super.destroy(), this.stopListening(), this._fireSelectionChangeDebounced.cancel(), this.toolbarView.destroy(), this.focusTracker.destroy(), this._resizeObserver && this._resizeObserver.destroy()
            }
            _getBalloonPositions(t) {
                const e = i.isSafari && i.isiOS ? Jp({
                    heightOffset: Math.max(Kp.arrowHeightOffset, Math.round(20 / Po.window.visualViewport.scale))
                }) : Kp.defaultPositions;
                return t ? [e.northWestArrowSouth, e.northWestArrowSouthWest, e.northWestArrowSouthEast, e.northWestArrowSouthMiddleEast, e.northWestArrowSouthMiddleWest, e.southWestArrowNorth, e.southWestArrowNorthWest, e.southWestArrowNorthEast, e.southWestArrowNorthMiddleWest, e.southWestArrowNorthMiddleEast] : [e.southEastArrowNorth, e.southEastArrowNorthEast, e.southEastArrowNorthWest, e.southEastArrowNorthMiddleEast, e.southEastArrowNorthMiddleWest, e.northEastArrowSouth, e.northEastArrowSouthEast, e.northEastArrowSouthWest, e.northEastArrowSouthMiddleEast, e.northEastArrowSouthMiddleWest]
            }
        }
        var Zf = n(9695),
            Jf = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Zf.Z, Jf);
        Zf.Z.locals;
        const Yf = $o("px");
        class Qf extends Mg {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.isVisible = !1, this.isToggleable = !0, this.set("top", 0), this.set("left", 0), this.extendTemplate({
                    attributes: {
                        class: "ck-block-toolbar-button",
                        style: {
                            top: e.to("top", (t => Yf(t))),
                            left: e.to("left", (t => Yf(t)))
                        }
                    }
                })
            }
        }
        const Xf = $o("px"),
            {
                pilcrow: tb
            } = eg;
        const eb = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.209 18.717A8.5 8.5 0 1 1 18.686 9.6h-.008l.002.12a3 3 0 0 1-2.866 2.997h-.268l-.046-.002v.002h-4.791a2 2 0 1 0 0 4 1 1 0 1 1-.128 1.992 8.665 8.665 0 0 1-.372.008Zm-3.918-7.01a1.25 1.25 0 1 0-2.415-.648 1.25 1.25 0 0 0 2.415.647ZM5.723 8.18a1.25 1.25 0 1 0 .647-2.414 1.25 1.25 0 0 0-.647 2.414ZM9.76 6.155a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Zm4.028 1.759a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Z"/></svg>';
        class nb {
            constructor(t) {
                if (this.crashes = [], this.state = "initializing", this._now = Date.now, this.crashes = [], this._crashNumberLimit = "number" == typeof t.crashNumberLimit ? t.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = "number" == typeof t.minimumNonErrorTimePeriod ? t.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = t => {
                        const e = "error" in t ? t.error : t.reason;
                        e instanceof Error && this._handleError(e, t)
                    }, this._listeners = {}, !this._restart) throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.")
            }
            destroy() {
                this._stopErrorHandling(), this._listeners = {}
            }
            on(t, e) {
                this._listeners[t] || (this._listeners[t] = []), this._listeners[t].push(e)
            }
            off(t, e) {
                this._listeners[t] = this._listeners[t].filter((t => t !== e))
            }
            _fire(t, ...e) {
                const n = this._listeners[t] || [];
                for (const t of n) t.apply(this, [null, ...e])
            }
            _startErrorHandling() {
                window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler)
            }
            _stopErrorHandling() {
                window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler)
            }
            _handleError(t, e) {
                if (this._shouldReactToError(t)) {
                    this.crashes.push({
                        message: t.message,
                        stack: t.stack,
                        filename: e instanceof ErrorEvent ? e.filename : void 0,
                        lineno: e instanceof ErrorEvent ? e.lineno : void 0,
                        colno: e instanceof ErrorEvent ? e.colno : void 0,
                        date: this._now()
                    });
                    const n = this._shouldRestart();
                    this.state = "crashed", this._fire("stateChange"), this._fire("error", {
                        error: t,
                        causesRestart: n
                    }), n ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"))
                }
            }
            _shouldReactToError(t) {
                return t.is && t.is("CKEditorError") && void 0 !== t.context && null !== t.context && "ready" === this.state && this._isErrorComingFromThisItem(t)
            }
            _shouldRestart() {
                if (this.crashes.length <= this._crashNumberLimit) return !0;
                return (this.crashes[this.crashes.length - 1].date - this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date) / this._crashNumberLimit > this._minimumNonErrorTimePeriod
            }
        }

        function ob(t, e = new Set) {
            const n = [t],
                o = new Set;
            let i = 0;
            for (; n.length > i;) {
                const t = n[i++];
                if (!o.has(t) && ib(t) && !e.has(t))
                    if (o.add(t), Symbol.iterator in t) try {
                        for (const e of t) n.push(e)
                    } catch (t) {} else
                        for (const e in t) "defaultValue" !== e && n.push(t[e])
            }
            return o
        }

        function ib(t) {
            const e = Object.prototype.toString.call(t),
                n = typeof t;
            return !("number" === n || "boolean" === n || "string" === n || "symbol" === n || "function" === n || "[object Date]" === e || "[object RegExp]" === e || "[object Module]" === e || null == t || t._watchdogExcluded || t instanceof EventTarget || t instanceof Event)
        }

        function rb(t, e, n = new Set) {
            if (t === e && ("object" == typeof(o = t) && null !== o)) return !0;
            var o;
            const i = ob(t, n),
                r = ob(e, n);
            for (const t of i)
                if (r.has(t)) return !0;
            return !1
        }
        class sb extends nb {
            constructor(t, e = {}) {
                super(e), this._editor = null, this._throttledSave = of(this._save.bind(this), "number" == typeof e.saveInterval ? e.saveInterval : 5e3), t && (this._creator = (e, n) => t.create(e, n)), this._destructor = t => t.destroy()
            }
            get editor() {
                return this._editor
            }
            get _item() {
                return this._editor
            }
            setCreator(t) {
                this._creator = t
            }
            setDestructor(t) {
                this._destructor = t
            }
            _restart() {
                return Promise.resolve().then((() => (this.state = "initializing", this._fire("stateChange"), this._destroy()))).catch((t => {
                    console.error("An error happened during the editor destroying.", t)
                })).then((() => {
                    if ("string" == typeof this._elementOrData) return this.create(this._data, this._config, this._config.context);
                    {
                        const t = Object.assign({}, this._config, {
                            initialData: this._data
                        });
                        return this.create(this._elementOrData, t, t.context)
                    }
                })).then((() => {
                    this._fire("restart")
                }))
            }
            create(t = this._elementOrData, e = this._config, n) {
                return Promise.resolve().then((() => (super._startErrorHandling(), this._elementOrData = t, this._config = this._cloneEditorConfiguration(e) || {}, this._config.context = n, this._creator(t, this._config)))).then((t => {
                    this._editor = t, t.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = t.model.document.version, this._data = this._getData(), this.state = "ready", this._fire("stateChange")
                }))
            }
            destroy() {
                return Promise.resolve().then((() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy())))
            }
            _destroy() {
                return Promise.resolve().then((() => {
                    this._stopErrorHandling(), this._throttledSave.flush();
                    const t = this._editor;
                    return this._editor = null, t.model.document.off("change:data", this._throttledSave), this._destructor(t)
                }))
            }
            _save() {
                const t = this._editor.model.document.version;
                try {
                    this._data = this._getData(), this._lastDocumentVersion = t
                } catch (t) {
                    console.error(t, "An error happened during restoring editor data. Editor will be restored from the previously saved data.")
                }
            }
            _setExcludedProperties(t) {
                this._excludedProps = t
            }
            _getData() {
                const t = {};
                for (const e of this._editor.model.document.getRootNames()) t[e] = this._editor.data.get({
                    rootName: e
                });
                return t
            }
            _isErrorComingFromThisItem(t) {
                return rb(this._editor, t.context, this._excludedProps)
            }
            _cloneEditorConfiguration(t) {
                return Ao(t, ((t, e) => Co(t) || "context" === e ? t : void 0))
            }
        }
        const ab = Symbol("MainQueueId");
        class lb {
            constructor() {
                this._onEmptyCallbacks = [], this._queues = new Map, this._activeActions = 0
            }
            onEmpty(t) {
                this._onEmptyCallbacks.push(t)
            }
            enqueue(t, e) {
                const n = t === ab;
                this._activeActions++, this._queues.get(t) || this._queues.set(t, Promise.resolve());
                const o = (n ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(ab), this._queues.get(t)])).then(e),
                    i = o.catch((() => {}));
                return this._queues.set(t, i), o.finally((() => {
                    this._activeActions--, this._queues.get(t) === i && 0 === this._activeActions && this._onEmptyCallbacks.forEach((t => t()))
                }))
            }
        }

        function cb(t) {
            return Array.isArray(t) ? t : [t]
        }
        class db extends yf {
            constructor(t, e) {
                super(t), this.view = e
            }
            get element() {
                return this.view.editable.element
            }
            init() {
                const t = this.editor,
                    e = this.view,
                    n = t.editing.view,
                    o = e.editable,
                    i = n.document.getRoot();
                o.name = i.rootName, e.render();
                const r = o.element;
                this.setEditableElement(o.name, r), o.bind("isFocused").to(this.focusTracker), n.attachDomRoot(r), this._initPlaceholder(), this.fire("ready")
            }
            destroy() {
                super.destroy();
                const t = this.view;
                this.editor.editing.view.detachDomRoot(t.editable.name), t.destroy()
            }
            _initPlaceholder() {
                const t = this.editor,
                    e = t.editing.view,
                    n = e.document.getRoot(),
                    o = (t.sourceElement, t.config.get("placeholder"));
                if (o) {
                    const t = "string" == typeof o ? o : o[n.rootName];
                    t && Zi({
                        view: e,
                        element: n,
                        text: t,
                        isDirectHost: !1,
                        keepOnFocus: !0
                    })
                }
            }
        }
        class hb extends Sf {
            constructor(t, e, n) {
                super(t);
                const o = t.t;
                this.editable = new Bf(t, e, n, {
                    label: t => o("Rich Text Editor. Editing area: %0", t.name)
                })
            }
            render() {
                super.render(), this.registerChild(this.editable)
            }
        }
        class ub extends(Qu(Xu(Yu))) {
            constructor(t, e = {}) {
                if (!gb(t) && void 0 !== e.initialData) throw new b("editor-create-initial-data", null);
                super(e), void 0 === this.config.get("initialData") && this.config.set("initialData", function(t) {
                    return gb(t) ? (e = t, e instanceof HTMLTextAreaElement ? e.value : e.innerHTML) : t;
                    var e
                }(t)), gb(t) && (this.sourceElement = t, function(t, e) {
                    if (e.ckeditorInstance) throw new b("editor-source-element-already-used", t);
                    e.ckeditorInstance = t, t.once("destroy", (() => {
                        delete e.ckeditorInstance
                    }))
                }(this, t));
                const n = this.config.get("plugins");
                n.push(Kf), this.config.set("plugins", n), this.config.define("balloonToolbar", this.config.get("toolbar")), this.model.document.createRoot();
                const o = new hb(this.locale, this.editing.view, this.sourceElement);
                this.ui = new db(this, o),
                    function(t) {
                        if (!Mt(t.updateSourceElement)) throw new b("attachtoform-missing-elementapi-interface", t);
                        const e = t.sourceElement;
                        if (function(t) {
                                return !!t && "textarea" === t.tagName.toLowerCase()
                            }(e) && e.form) {
                            let n;
                            const o = e.form,
                                i = () => t.updateSourceElement();
                            Mt(o.submit) && (n = o.submit, o.submit = () => {
                                i(), n.apply(o)
                            }), o.addEventListener("submit", i), t.on("destroy", (() => {
                                o.removeEventListener("submit", i), n && (o.submit = n)
                            }))
                        }
                    }(this)
            }
            destroy() {
                const t = this.getData();
                return this.ui.destroy(), super.destroy().then((() => {
                    this.sourceElement && this.updateSourceElement(t)
                }))
            }
            static create(t, e = {}) {
                return new Promise((n => {
                    if (gb(t) && "TEXTAREA" === t.tagName) throw new b("editor-wrong-element", null);
                    const o = new this(t, e);
                    n(o.initPlugins().then((() => o.ui.init())).then((() => o.data.init(o.config.get("initialData")))).then((() => o.fire("ready"))).then((() => o)))
                }))
            }
        }

        function gb(t) {
            return Co(t)
        }
        ub.Context = Hi, ub.EditorWatchdog = sb, ub.ContextWatchdog = class extends nb {
            constructor(t, e = {}) {
                super(e), this._watchdogs = new Map, this._context = null, this._contextProps = new Set, this._actionQueues = new lb, this._watchdogConfig = e, this._creator = e => t.create(e), this._destructor = t => t.destroy(), this._actionQueues.onEmpty((() => {
                    "initializing" === this.state && (this.state = "ready", this._fire("stateChange"))
                }))
            }
            setCreator(t) {
                this._creator = t
            }
            setDestructor(t) {
                this._destructor = t
            }
            get context() {
                return this._context
            }
            create(t = {}) {
                return this._actionQueues.enqueue(ab, (() => (this._contextConfig = t, this._create())))
            }
            getItem(t) {
                return this._getWatchdog(t)._item
            }
            getItemState(t) {
                return this._getWatchdog(t).state
            }
            add(t) {
                const e = cb(t);
                return Promise.all(e.map((t => this._actionQueues.enqueue(t.id, (() => {
                    if ("destroyed" === this.state) throw new Error("Cannot add items to destroyed watchdog.");
                    if (!this._context) throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
                    let e;
                    if (this._watchdogs.has(t.id)) throw new Error(`Item with the given id is already added: '${t.id}'.`);
                    if ("editor" === t.type) return e = new sb(null, this._watchdogConfig), e.setCreator(t.creator), e._setExcludedProperties(this._contextProps), t.destructor && e.setDestructor(t.destructor), this._watchdogs.set(t.id, e), e.on("error", ((n, {
                        error: o,
                        causesRestart: i
                    }) => {
                        this._fire("itemError", {
                            itemId: t.id,
                            error: o
                        }), i && this._actionQueues.enqueue(t.id, (() => new Promise((n => {
                            const o = () => {
                                e.off("restart", o), this._fire("itemRestart", {
                                    itemId: t.id
                                }), n()
                            };
                            e.on("restart", o)
                        }))))
                    })), e.create(t.sourceElementOrData, t.config, this._context);
                    throw new Error(`Not supported item type: '${t.type}'.`)
                })))))
            }
            remove(t) {
                const e = cb(t);
                return Promise.all(e.map((t => this._actionQueues.enqueue(t, (() => {
                    const e = this._getWatchdog(t);
                    return this._watchdogs.delete(t), e.destroy()
                })))))
            }
            destroy() {
                return this._actionQueues.enqueue(ab, (() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy())))
            }
            _restart() {
                return this._actionQueues.enqueue(ab, (() => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch((t => {
                    console.error("An error happened during destroying the context or items.", t)
                })).then((() => this._create())).then((() => this._fire("restart"))))))
            }
            _create() {
                return Promise.resolve().then((() => (this._startErrorHandling(), this._creator(this._contextConfig)))).then((t => (this._context = t, this._contextProps = ob(this._context), Promise.all(Array.from(this._watchdogs.values()).map((t => (t._setExcludedProperties(this._contextProps), t.create(void 0, void 0, this._context))))))))
            }
            _destroy() {
                return Promise.resolve().then((() => {
                    this._stopErrorHandling();
                    const t = this._context;
                    return this._context = null, this._contextProps = new Set, Promise.all(Array.from(this._watchdogs.values()).map((t => t.destroy()))).then((() => this._destructor(t)))
                }))
            }
            _getWatchdog(t) {
                const e = this._watchdogs.get(t);
                if (!e) throw new Error(`Item with the given id was not registered: ${t}.`);
                return e
            }
            _isErrorComingFromThisItem(t) {
                for (const e of this._watchdogs.values())
                    if (e._isErrorComingFromThisItem(t)) return !1;
                return rb(this._context, t.context)
            }
        };
        var mb = n(6764),
            pb = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(mb.Z, pb);
        mb.Z.locals;
        var fb = n(2822),
            bb = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(fb.Z, bb);
        fb.Z.locals;
        class kb extends cg {
            constructor(t) {
                super(t);
                const e = t.t;
                this.set("matchCount", 0), this.set("highlightOffset", 0), this.set("isDirty", !1), this.set("_areCommandsEnabled", {}), this.set("_resultsCounterText", ""), this.set("_matchCase", !1), this.set("_wholeWordsOnly", !1), this.bind("_searchResultsFound").to(this, "matchCount", this, "isDirty", ((t, e) => t > 0 && !e)), this._findInputView = this._createInputField(e("Find in text…")), this._replaceInputView = this._createInputField(e("Replace with…")), this._findButtonView = this._createButton({
                    label: e("Find"),
                    class: "ck-button-find ck-button-action",
                    withText: !0
                }), this._findPrevButtonView = this._createButton({
                    label: e("Previous result"),
                    class: "ck-button-prev",
                    icon: Of,
                    keystroke: "Shift+F3",
                    tooltip: !0
                }), this._findNextButtonView = this._createButton({
                    label: e("Next result"),
                    class: "ck-button-next",
                    icon: Of,
                    keystroke: "F3",
                    tooltip: !0
                }), this._optionsDropdown = this._createOptionsDropdown(), this._replaceButtonView = this._createButton({
                    label: e("Replace"),
                    class: "ck-button-replace",
                    withText: !0
                }), this._replaceAllButtonView = this._createButton({
                    label: e("Replace all"),
                    class: "ck-button-replaceall",
                    withText: !0
                }), this._findFieldsetView = this._createFindFieldset(), this._replaceFieldsetView = this._createReplaceFieldset(), this._focusTracker = new Di, this._keystrokes = new Si, this._focusables = new sg, this._focusCycler = new wm({
                    focusables: this._focusables,
                    focusTracker: this._focusTracker,
                    keystrokeHandler: this._keystrokes,
                    actions: {
                        focusPrevious: "shift + tab",
                        focusNext: "tab"
                    }
                }), this.setTemplate({
                    tag: "form",
                    attributes: {
                        class: ["ck", "ck-find-and-replace-form"],
                        tabindex: "-1"
                    },
                    children: [new Rf(t, {
                        label: e("Find and replace")
                    }), this._findFieldsetView, this._replaceFieldsetView]
                })
            }
            render() {
                super.render(), ig({
                    view: this
                }), this._initFocusCycling(), this._initKeystrokeHandling()
            }
            destroy() {
                super.destroy(), this._focusTracker.destroy(), this._keystrokes.destroy()
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            reset() {
                this._findInputView.errorText = null, this.isDirty = !0
            }
            get _textToFind() {
                return this._findInputView.fieldView.element.value
            }
            get _textToReplace() {
                return this._replaceInputView.fieldView.element.value
            }
            _createFindFieldset() {
                const t = this.locale,
                    e = new cg(t);
                return this._findInputView.fieldView.on("input", (() => {
                    this.isDirty = !0
                })), this._findButtonView.on("execute", this._onFindButtonExecute.bind(this)), this._findPrevButtonView.delegate("execute").to(this, "findPrevious"), this._findNextButtonView.delegate("execute").to(this, "findNext"), this._findPrevButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", (({
                    findPrevious: t
                }) => t)), this._findNextButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", (({
                    findNext: t
                }) => t)), this._injectFindResultsCounter(), e.setTemplate({
                    tag: "fieldset",
                    attributes: {
                        class: ["ck", "ck-find-and-replace-form__find"]
                    },
                    children: [this._findInputView, this._findButtonView, this._findPrevButtonView, this._findNextButtonView]
                }), e
            }
            _onFindButtonExecute() {
                if (this._textToFind) this.isDirty = !1, this.fire("findNext", {
                    searchText: this._textToFind,
                    matchCase: this._matchCase,
                    wholeWords: this._wholeWordsOnly
                });
                else {
                    const t = this.t;
                    this._findInputView.errorText = t("Text to find must not be empty.")
                }
            }
            _injectFindResultsCounter() {
                const t = this.locale,
                    e = t.t,
                    n = this.bindTemplate,
                    o = new cg(this.locale);
                this.bind("_resultsCounterText").to(this, "highlightOffset", this, "matchCount", ((t, n) => e("%0 of %1", [t, n]))), o.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-results-counter", n.if("isDirty", "ck-hidden")]
                    },
                    children: [{
                        text: n.to("_resultsCounterText")
                    }]
                });
                const i = () => {
                    const e = this._findInputView.fieldView.element;
                    if (!e || !Jo(e)) return;
                    const n = new Mo(o.element).width,
                        i = "ltr" === t.uiLanguageDirection ? "paddingRight" : "paddingLeft";
                    e.style[i] = n ? `calc( 2 * var(--ck-spacing-standard) + ${n}px )` : ""
                };
                this.on("change:_resultsCounterText", i, {
                    priority: "low"
                }), this.on("change:isDirty", i, {
                    priority: "low"
                }), this._findInputView.template.children[0].children.push(o)
            }
            _createReplaceFieldset() {
                const t = this.locale.t,
                    e = new cg(this.locale);
                return this._replaceButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", (({
                    replace: t
                }, e) => t && e)), this._replaceAllButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", (({
                    replaceAll: t
                }, e) => t && e)), this._replaceInputView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", (({
                    replace: t
                }, e) => t && e)), this._replaceInputView.bind("infoText").to(this._replaceInputView, "isEnabled", this._replaceInputView, "isFocused", ((e, n) => e || !n ? "" : t("Tip: Find some text first in order to replace it."))), this._replaceButtonView.on("execute", (() => {
                    this.fire("replace", {
                        searchText: this._textToFind,
                        replaceText: this._textToReplace
                    })
                })), this._replaceAllButtonView.on("execute", (() => {
                    this.fire("replaceAll", {
                        searchText: this._textToFind,
                        replaceText: this._textToReplace
                    }), this.focus()
                })), e.setTemplate({
                    tag: "fieldset",
                    attributes: {
                        class: ["ck", "ck-find-and-replace-form__replace"]
                    },
                    children: [this._replaceInputView, this._optionsDropdown, this._replaceButtonView, this._replaceAllButtonView]
                }), e
            }
            _createOptionsDropdown() {
                const t = this.locale.t,
                    e = Wm(this.locale);
                e.class = "ck-options-dropdown", e.buttonView.set({
                    withText: !1,
                    label: t("Show options"),
                    icon: eg.cog,
                    tooltip: !0
                });
                const n = new Vf({
                        withText: !0,
                        label: t("Match case"),
                        _isMatchCaseSwitch: !0
                    }),
                    o = new Vf({
                        withText: !0,
                        label: t("Whole words only")
                    });
                return n.bind("isOn").to(this, "_matchCase"), o.bind("isOn").to(this, "_wholeWordsOnly"), e.on("execute", (t => {
                    t.source._isMatchCaseSwitch ? this._matchCase = !this._matchCase : this._wholeWordsOnly = !this._wholeWordsOnly, this.isDirty = !0
                })), Gm(e, new xi([{
                    type: "switchbutton",
                    model: n
                }, {
                    type: "switchbutton",
                    model: o
                }])), e
            }
            _initFocusCycling() {
                [this._findInputView, this._findButtonView, this._findPrevButtonView, this._findNextButtonView, this._replaceInputView, this._optionsDropdown, this._replaceButtonView, this._replaceAllButtonView].forEach((t => {
                    this._focusables.add(t), this._focusTracker.add(t.element)
                }))
            }
            _initKeystrokeHandling() {
                const t = t => t.stopPropagation(),
                    e = t => {
                        t.stopPropagation(), t.preventDefault()
                    };
                this._keystrokes.listenTo(this.element), this._keystrokes.set("f3", (t => {
                    e(t), this._findNextButtonView.fire("execute")
                })), this._keystrokes.set("shift+f3", (t => {
                    e(t), this._findPrevButtonView.fire("execute")
                })), this._keystrokes.set("enter", (t => {
                    const n = t.target;
                    n === this._findInputView.fieldView.element ? (this._areCommandsEnabled.findNext ? this._findNextButtonView.fire("execute") : this._findButtonView.fire("execute"), e(t)) : n !== this._replaceInputView.fieldView.element || this.isDirty || (this._replaceButtonView.fire("execute"), e(t))
                })), this._keystrokes.set("shift+enter", (t => {
                    t.target === this._findInputView.fieldView.element && (this._areCommandsEnabled.findPrevious ? this._findPrevButtonView.fire("execute") : this._findButtonView.fire("execute"), e(t))
                })), this._keystrokes.set("arrowright", t), this._keystrokes.set("arrowleft", t), this._keystrokes.set("arrowup", t), this._keystrokes.set("arrowdown", t)
            }
            _createButton(t) {
                const e = new Mg(this.locale);
                return e.set(t), e
            }
            _createInputField(t) {
                const e = new sm(this.locale, Jm);
                return e.label = t, e
            }
        }
        class wb extends Vi {
            constructor(t) {
                super(t), this.formView = null
            }
            static get pluginName() {
                return "FindAndReplaceUI"
            }
            init() {
                const t = this.editor;
                t.ui.componentFactory.add("findAndReplace", (e => {
                    const n = Wm(e),
                        o = t.commands.get("find");
                    return n.bind("isEnabled").to(o), n.once("change:isOpen", (() => {
                        this.formView = new(og(kb))(t.locale), n.panelView.children.add(this.formView), this._setupFormView(this.formView)
                    })), n.on("change:isOpen", ((t, e, n) => {
                        n ? (this.formView.disableCssTransitions(), this.formView.reset(), this.formView._findInputView.fieldView.select(), this.formView.enableCssTransitions()) : this.fire("searchReseted")
                    }), {
                        priority: "low"
                    }), this._setupDropdownButton(n), n
                }))
            }
            _setupDropdownButton(t) {
                const e = this.editor.locale.t;
                t.buttonView.set({
                    icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.87 13.786 1.532-1.286 3.857 4.596a1 1 0 1 1-1.532 1.286l-3.857-4.596z"/><path d="M16.004 8.5a6.5 6.5 0 0 1-9.216 5.905c-1.154-.53-.863-1.415-.663-1.615.194-.194.564-.592 1.635-.141a4.5 4.5 0 0 0 5.89-5.904l-.104-.227 1.332-1.331c.045-.046.196-.041.224.007a6.47 6.47 0 0 1 .902 3.306zm-3.4-5.715c.562.305.742 1.106.354 1.494-.388.388-.995.414-1.476.178a4.5 4.5 0 0 0-6.086 5.882l.114.236-1.348 1.349c-.038.037-.17.022-.198-.023a6.5 6.5 0 0 1 5.54-9.9 6.469 6.469 0 0 1 3.1.784z"/><path d="M4.001 11.93.948 8.877a.2.2 0 0 1 .141-.341h6.106a.2.2 0 0 1 .141.341L4.283 11.93a.2.2 0 0 1-.282 0zm11.083-6.789 3.053 3.053a.2.2 0 0 1-.14.342H11.89a.2.2 0 0 1-.14-.342l3.052-3.053a.2.2 0 0 1 .282 0z"/></svg>',
                    label: e("Find and replace"),
                    tooltip: !0
                })
            }
            _setupFormView(t) {
                const e = this.editor.commands,
                    n = this.editor.plugins.get("FindAndReplaceEditing").state,
                    o = {
                        before: -1,
                        same: 0,
                        after: 1,
                        different: 1
                    };
                t.bind("highlightOffset").to(n, "highlightedResult", (t => t ? Array.from(n.results).sort(((t, e) => o[t.marker.getStart().compareWith(e.marker.getStart())])).indexOf(t) + 1 : 0)), t.listenTo(n.results, "change", (() => {
                    t.matchCount = n.results.length
                }));
                const i = e.get("findNext"),
                    r = e.get("findPrevious"),
                    s = e.get("replace"),
                    a = e.get("replaceAll");
                t.bind("_areCommandsEnabled").to(i, "isEnabled", r, "isEnabled", s, "isEnabled", a, "isEnabled", ((t, e, n, o) => ({
                    findNext: t,
                    findPrevious: e,
                    replace: n,
                    replaceAll: o
                }))), t.delegate("findNext", "findPrevious", "replace", "replaceAll").to(this), t.on("change:isDirty", ((t, e, n) => {
                    n && this.fire("searchReseted")
                }))
            }
        }
        class Ab extends Fi {
            constructor(t, e) {
                super(t), this.isEnabled = !0, this.affectsData = !1, this._state = e
            }
            execute(t, {
                matchCase: e,
                wholeWords: n
            } = {}) {
                const {
                    editor: o
                } = this, {
                    model: i
                } = o, r = o.plugins.get("FindAndReplaceUtils");
                let s;
                "string" == typeof t ? (s = r.findByTextCallback(t, {
                    matchCase: e,
                    wholeWords: n
                }), this._state.searchText = t) : s = t;
                const a = i.document.getRootNames().reduce(((t, e) => r.updateFindResultFromRange(i.createRangeIn(i.document.getRoot(e)), i, s, t)), null);
                return this._state.clear(i), this._state.results.addMany(a), this._state.highlightedResult = a.get(0), "string" == typeof t && (this._state.searchText = t), this._state.matchCase = !!e, this._state.matchWholeWords = !!n, {
                    results: a,
                    findCallback: s
                }
            }
        }
        class Cb extends Fi {
            constructor(t, e) {
                super(t), this.isEnabled = !0, this._state = e, this._isEnabledBasedOnSelection = !1
            }
            _replace(t, e) {
                const {
                    model: n
                } = this.editor, o = e.marker.getRange();
                n.canEditAt(o) && n.change((i => {
                    if ("$graveyard" === o.root.rootName) return void this._state.results.remove(e);
                    let r = {};
                    for (const t of o.getItems())
                        if (t.is("$text") || t.is("$textProxy")) {
                            r = t.getAttributes();
                            break
                        } n.insertContent(i.createText(t, r), o), this._state.results.has(e) && this._state.results.remove(e)
                }))
            }
        }
        class _b extends Cb {
            execute(t, e) {
                this._replace(t, e)
            }
        }
        class vb extends Cb {
            execute(t, e) {
                const {
                    editor: n
                } = this, {
                    model: o
                } = n, i = n.plugins.get("FindAndReplaceUtils"), r = e instanceof xi ? e : o.document.getRootNames().reduce(((t, n) => i.updateFindResultFromRange(o.createRangeIn(o.document.getRoot(n)), o, i.findByTextCallback(e, this._state), t)), null);
                r.length && [...r].forEach((e => {
                    this._replace(t, e)
                }))
            }
        }
        class yb extends Fi {
            constructor(t, e) {
                super(t), this.affectsData = !1, this._state = e, this.isEnabled = !1, this.listenTo(this._state.results, "change", (() => {
                    this.isEnabled = this._state.results.length > 1
                }))
            }
            refresh() {
                this.isEnabled = this._state.results.length > 1
            }
            execute() {
                const t = this._state.results,
                    e = t.getIndex(this._state.highlightedResult),
                    n = e + 1 >= t.length ? 0 : e + 1;
                this._state.highlightedResult = this._state.results.get(n)
            }
        }
        class xb extends yb {
            execute() {
                const t = this._state.results.getIndex(this._state.highlightedResult),
                    e = t - 1 < 0 ? this._state.results.length - 1 : t - 1;
                this._state.highlightedResult = this._state.results.get(e)
            }
        }
        class Eb extends(q()) {
            constructor(t) {
                super(), this.set("results", new xi), this.set("highlightedResult", null), this.set("searchText", ""), this.set("replaceText", ""), this.set("matchCase", !1), this.set("matchWholeWords", !1), this.results.on("change", ((e, {
                    removed: n,
                    index: o
                }) => {
                    if (Array.from(n).length) {
                        let e = !1;
                        if (t.change((o => {
                                for (const i of n) this.highlightedResult === i && (e = !0), t.markers.has(i.marker.name) && o.removeMarker(i.marker)
                            })), e) {
                            const t = o >= this.results.length ? 0 : o;
                            this.highlightedResult = this.results.get(t)
                        }
                    }
                }))
            }
            clear(t) {
                this.searchText = "", t.change((e => {
                    if (this.highlightedResult) {
                        const n = this.highlightedResult.marker.name.split(":")[1],
                            o = t.markers.get(`findResultHighlighted:${n}`);
                        o && e.removeMarker(o)
                    } [...this.results].forEach((({
                        marker: t
                    }) => {
                        e.removeMarker(t)
                    }))
                })), this.results.clear()
            }
        }
        var Db = /[\\^$.*+?()[\]{}|]/g,
            Sb = RegExp(Db.source);
        const Tb = function(t) {
            return (t = vr(t)) && Sb.test(t) ? t.replace(Db, "\\$&") : t
        };
        class Bb extends Vi {
            static get pluginName() {
                return "FindAndReplaceUtils"
            }
            updateFindResultFromRange(t, e, n, o) {
                const i = o || new xi;
                return e.change((o => {
                    [...t].forEach((({
                        type: t,
                        item: r
                    }) => {
                        if ("elementStart" === t && e.schema.checkChild(r, "$text")) {
                            const t = n({
                                item: r,
                                text: this.rangeToText(e.createRangeIn(r))
                            });
                            if (!t) return;
                            t.forEach((t => {
                                const e = `findResult:${g()}`,
                                    n = o.addMarker(e, {
                                        usingOperation: !1,
                                        affectsData: !1,
                                        range: o.createRange(o.createPositionAt(r, t.start), o.createPositionAt(r, t.end))
                                    }),
                                    s = function(t, e) {
                                        const n = t.find((({
                                            marker: t
                                        }) => e.getStart().isBefore(t.getStart())));
                                        return n ? t.getIndex(n) : t.length
                                    }(i, n);
                                i.add({
                                    id: e,
                                    label: t.label,
                                    marker: n
                                }, s)
                            }))
                        }
                    }))
                })), i
            }
            rangeToText(t) {
                return Array.from(t.getItems()).reduce(((t, e) => e.is("$text") || e.is("$textProxy") ? t + e.data : `${t}\n`), "")
            }
            findByTextCallback(t, e) {
                let n = "gu";
                e.matchCase || (n += "i");
                let o = `(${Tb(t)})`;
                if (e.wholeWords) {
                    const e = "[^a-zA-ZÀ-ɏḀ-ỿ]";
                    new RegExp("^" + e).test(t) || (o = `(^|${e}|_)${o}`), new RegExp(e + "$").test(t) || (o = `${o}(?=_|${e}|$)`)
                }
                const i = new RegExp(o, n);
                return function({
                    text: t
                }) {
                    return [...t.matchAll(i)].map(Ib)
                }
            }
        }

        function Ib(t) {
            const e = t.length - 1;
            let n = t.index;
            return 3 === t.length && (n += t[1].length), {
                label: t[e],
                start: n,
                end: n + t[e].length
            }
        }
        var Pb = n(9932),
            Rb = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Pb.Z, Rb);
        Pb.Z.locals;
        class zb extends Vi {
            static get requires() {
                return [Bb]
            }
            static get pluginName() {
                return "FindAndReplaceEditing"
            }
            init() {
                this._activeResults = null, this.state = new Eb(this.editor.model), this._defineConverters(), this._defineCommands(), this.listenTo(this.state, "change:highlightedResult", ((t, e, n, o) => {
                    const {
                        model: i
                    } = this.editor;
                    i.change((t => {
                        if (o) {
                            const e = o.marker.name.split(":")[1],
                                n = i.markers.get(`findResultHighlighted:${e}`);
                            n && t.removeMarker(n)
                        }
                        if (n) {
                            const e = n.marker.name.split(":")[1];
                            t.addMarker(`findResultHighlighted:${e}`, {
                                usingOperation: !1,
                                affectsData: !1,
                                range: n.marker.getRange()
                            })
                        }
                    }))
                }));
                const t = Fa(((t, e, n) => {
                    if (n) {
                        const t = this.editor.editing.view.domConverter,
                            e = this.editor.editing.mapper.toViewRange(n.marker.getRange());
                        ni({
                            target: t.viewRangeToDom(e),
                            viewportOffset: 40
                        })
                    }
                }).bind(this), 32);
                this.listenTo(this.state, "change:highlightedResult", t, {
                    priority: "low"
                }), this.listenTo(this.editor, "destroy", t.cancel)
            }
            find(t) {
                const {
                    editor: e
                } = this, {
                    model: n
                } = e, {
                    findCallback: o,
                    results: i
                } = e.execute("find", t);
                return this._activeResults = i, this.listenTo(n.document, "change:data", (() => function(t, e, n) {
                    const o = new Set,
                        i = new Set,
                        r = e.model;
                    r.document.differ.getChanges().forEach((t => {
                        "$text" === t.name || r.schema.isInline(t.position.nodeAfter) ? (o.add(t.position.parent), [...r.markers.getMarkersAtPosition(t.position)].forEach((t => {
                            i.add(t.name)
                        }))) : "insert" === t.type && o.add(t.position.nodeAfter)
                    })), r.document.differ.getChangedMarkers().forEach((({
                        name: t,
                        data: {
                            newRange: e
                        }
                    }) => {
                        e && "$graveyard" === e.start.root.rootName && i.add(t)
                    })), o.forEach((t => {
                        [...r.markers.getMarkersIntersectingRange(r.createRangeIn(t))].forEach((t => i.add(t.name)))
                    })), r.change((e => {
                        i.forEach((n => {
                            t.has(n) && t.remove(n), e.removeMarker(n)
                        }))
                    })), o.forEach((o => {
                        e.plugins.get("FindAndReplaceUtils").updateFindResultFromRange(r.createRangeOn(o), r, n, t)
                    }))
                }(this._activeResults, e, o))), this._activeResults
            }
            stop() {
                this._activeResults && (this.stopListening(this.editor.model.document), this.state.clear(this.editor.model), this._activeResults = null)
            }
            _defineCommands() {
                this.editor.commands.add("find", new Ab(this.editor, this.state)), this.editor.commands.add("findNext", new yb(this.editor, this.state)), this.editor.commands.add("findPrevious", new xb(this.editor, this.state)), this.editor.commands.add("replace", new _b(this.editor, this.state)), this.editor.commands.add("replaceAll", new vb(this.editor, this.state))
            }
            _defineConverters() {
                const {
                    editor: t
                } = this;
                t.conversion.for("editingDowncast").markerToHighlight({
                    model: "findResult",
                    view: ({
                        markerName: t
                    }) => {
                        const [, e] = t.split(":");
                        return {
                            name: "span",
                            classes: ["ck-find-result"],
                            attributes: {
                                "data-find-result": e
                            }
                        }
                    }
                }), t.conversion.for("editingDowncast").markerToHighlight({
                    model: "findResultHighlighted",
                    view: ({
                        markerName: t
                    }) => {
                        const [, e] = t.split(":");
                        return {
                            name: "span",
                            classes: ["ck-find-result_selected"],
                            attributes: {
                                "data-find-result": e
                            }
                        }
                    }
                })
            }
        }
        class Vb extends(q()) {
            constructor() {
                super();
                const t = new window.FileReader;
                this._reader = t, this._data = void 0, this.set("loaded", 0), t.onprogress = t => {
                    this.loaded = t.loaded
                }
            }
            get error() {
                return this._reader.error
            }
            get data() {
                return this._data
            }
            read(t) {
                const e = this._reader;
                return this.total = t.size, new Promise(((n, o) => {
                    e.onload = () => {
                        const t = e.result;
                        this._data = t, n(t)
                    }, e.onerror = () => {
                        o("error")
                    }, e.onabort = () => {
                        o("aborted")
                    }, this._reader.readAsDataURL(t)
                }))
            }
            abort() {
                this._reader.abort()
            }
        }
        class Ob extends Vi {
            constructor() {
                super(...arguments), this.loaders = new xi, this._loadersMap = new Map, this._pendingAction = null
            }
            static get pluginName() {
                return "FileRepository"
            }
            static get requires() {
                return [tg]
            }
            init() {
                this.loaders.on("change", (() => this._updatePendingAction())), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", ((t, e) => e ? t / e * 100 : 0))
            }
            getLoader(t) {
                return this._loadersMap.get(t) || null
            }
            createLoader(t) {
                if (!this.createUploadAdapter) return k("filerepository-no-upload-adapter"), null;
                const e = new Fb(Promise.resolve(t), this.createUploadAdapter);
                return this.loaders.add(e), this._loadersMap.set(t, e), t instanceof Promise && e.file.then((t => {
                    this._loadersMap.set(t, e)
                })).catch((() => {})), e.on("change:uploaded", (() => {
                    let t = 0;
                    for (const e of this.loaders) t += e.uploaded;
                    this.uploaded = t
                })), e.on("change:uploadTotal", (() => {
                    let t = 0;
                    for (const e of this.loaders) e.uploadTotal && (t += e.uploadTotal);
                    this.uploadTotal = t
                })), e
            }
            destroyLoader(t) {
                const e = t instanceof Fb ? t : this.getLoader(t);
                e._destroy(), this.loaders.remove(e), this._loadersMap.forEach(((t, n) => {
                    t === e && this._loadersMap.delete(n)
                }))
            }
            _updatePendingAction() {
                const t = this.editor.plugins.get(tg);
                if (this.loaders.length) {
                    if (!this._pendingAction) {
                        const e = this.editor.t,
                            n = t => `${e("Upload in progress")} ${parseInt(t)}%.`;
                        this._pendingAction = t.add(n(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", n)
                    }
                } else t.remove(this._pendingAction), this._pendingAction = null
            }
        }
        class Fb extends(q()) {
            constructor(t, e) {
                super(), this.id = g(), this._filePromiseWrapper = this._createFilePromiseWrapper(t), this._adapter = e(this), this._reader = new Vb, this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", ((t, e) => e ? t / e * 100 : 0)), this.set("uploadResponse", null)
            }
            get file() {
                return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then((t => this._filePromiseWrapper ? t : null)) : Promise.resolve(null)
            }
            get data() {
                return this._reader.data
            }
            read() {
                if ("idle" != this.status) throw new b("filerepository-read-wrong-status", this);
                return this.status = "reading", this.file.then((t => this._reader.read(t))).then((t => {
                    if ("reading" !== this.status) throw this.status;
                    return this.status = "idle", t
                })).catch((t => {
                    if ("aborted" === t) throw this.status = "aborted", "aborted";
                    throw this.status = "error", this._reader.error ? this._reader.error : t
                }))
            }
            upload() {
                if ("idle" != this.status) throw new b("filerepository-upload-wrong-status", this);
                return this.status = "uploading", this.file.then((() => this._adapter.upload())).then((t => (this.uploadResponse = t, this.status = "idle", t))).catch((t => {
                    if ("aborted" === this.status) throw "aborted";
                    throw this.status = "error", t
                }))
            }
            abort() {
                const t = this.status;
                this.status = "aborted", this._filePromiseWrapper.isFulfilled ? "reading" == t ? this._reader.abort() : "uploading" == t && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch((() => {})), this._filePromiseWrapper.rejecter("aborted")), this._destroy()
            }
            _destroy() {
                this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0
            }
            _createFilePromiseWrapper(t) {
                const e = {};
                return e.promise = new Promise(((n, o) => {
                    e.rejecter = o, e.isFulfilled = !1, t.then((t => {
                        e.isFulfilled = !0, n(t)
                    })).catch((t => {
                        e.isFulfilled = !0, o(t)
                    }))
                })), e
            }
        }
        class Mb extends cg {
            constructor(t) {
                super(t), this.buttonView = new Mg(t), this._fileInputView = new Nb(t), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.setTemplate({
                    tag: "span",
                    attributes: {
                        class: "ck-file-dialog-button"
                    },
                    children: [this.buttonView, this._fileInputView]
                }), this.buttonView.on("execute", (() => {
                    this._fileInputView.open()
                }))
            }
            focus() {
                this.buttonView.focus()
            }
        }
        class Nb extends cg {
            constructor(t) {
                super(t), this.set("acceptedType", void 0), this.set("allowMultipleFiles", !1);
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "input",
                    attributes: {
                        class: ["ck-hidden"],
                        type: "file",
                        tabindex: "-1",
                        accept: e.to("acceptedType"),
                        multiple: e.to("allowMultipleFiles")
                    },
                    on: {
                        change: e.to((() => {
                            this.element && this.element.files && this.element.files.length && this.fire("done", this.element.files), this.element.value = ""
                        }))
                    }
                })
            }
            open() {
                this.element.click()
            }
        }
        Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable;
        const Lb = "ckCsrfToken",
            Hb = "abcdefghijklmnopqrstuvwxyz0123456789";

        function jb() {
            let t = function(t) {
                t = t.toLowerCase();
                const e = document.cookie.split(";");
                for (const n of e) {
                    const e = n.split("=");
                    if (decodeURIComponent(e[0].trim().toLowerCase()) === t) return decodeURIComponent(e[1])
                }
                return null
            }(Lb);
            var e, n;
            return t && 40 == t.length || (t = function(t) {
                let e = "";
                const n = new Uint8Array(t);
                window.crypto.getRandomValues(n);
                for (let t = 0; t < n.length; t++) {
                    const o = Hb.charAt(n[t] % Hb.length);
                    e += Math.random() > .5 ? o.toUpperCase() : o
                }
                return e
            }(40), e = Lb, n = t, document.cookie = encodeURIComponent(e) + "=" + encodeURIComponent(n) + ";path=/"), t
        }
        class qb {
            constructor(t, e, n) {
                this.loader = t, this.url = e, this.t = n
            }
            upload() {
                return this.loader.file.then((t => new Promise(((e, n) => {
                    this._initRequest(), this._initListeners(e, n, t), this._sendRequest(t)
                }))))
            }
            abort() {
                this.xhr && this.xhr.abort()
            }
            _initRequest() {
                const t = this.xhr = new XMLHttpRequest;
                t.open("POST", this.url, !0), t.responseType = "json"
            }
            _initListeners(t, e, n) {
                const o = this.xhr,
                    i = this.loader,
                    r = (0, this.t)("Cannot upload file:") + ` ${n.name}.`;
                o.addEventListener("error", (() => e(r))), o.addEventListener("abort", (() => e())), o.addEventListener("load", (() => {
                    const n = o.response;
                    if (!n || !n.uploaded) return e(n && n.error && n.error.message ? n.error.message : r);
                    t({
                        default: n.url
                    })
                })), o.upload && o.upload.addEventListener("progress", (t => {
                    t.lengthComputable && (i.uploadTotal = t.total, i.uploaded = t.loaded)
                }))
            }
            _sendRequest(t) {
                const e = new FormData;
                e.append("upload", t), e.append("ckCsrfToken", jb()), this.xhr.send(e)
            }
        }
        class Wb {
            constructor(t, e = 20) {
                this._batch = null, this.model = t, this._size = 0, this.limit = e, this._isLocked = !1, this._changeCallback = (t, e) => {
                    e.isLocal && e.isUndoable && e !== this._batch && this._reset(!0)
                }, this._selectionChangeCallback = () => {
                    this._reset()
                }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback)
            }
            get batch() {
                return this._batch || (this._batch = this.model.createBatch({
                    isTyping: !0
                })), this._batch
            }
            get size() {
                return this._size
            }
            input(t) {
                this._size += t, this._size >= this.limit && this._reset(!0)
            }
            get isLocked() {
                return this._isLocked
            }
            lock() {
                this._isLocked = !0
            }
            unlock() {
                this._isLocked = !1
            }
            destroy() {
                this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback)
            }
            _reset(t = !1) {
                this.isLocked && !t || (this._batch = null, this._size = 0)
            }
        }
        class Ub extends Fi {
            constructor(t, e) {
                super(t), this._buffer = new Wb(t.model, e), this._isEnabledBasedOnSelection = !1
            }
            get buffer() {
                return this._buffer
            }
            destroy() {
                super.destroy(), this._buffer.destroy()
            }
            execute(t = {}) {
                const e = this.editor.model,
                    n = e.document,
                    o = t.text || "",
                    i = o.length;
                let r = n.selection;
                if (t.selection ? r = t.selection : t.range && (r = e.createSelection(t.range)), !e.canEditAt(r)) return;
                const s = t.resultRange;
                e.enqueueChange(this._buffer.batch, (t => {
                    this._buffer.lock(), e.deleteContent(r), o && e.insertContent(t.createText(o, n.selection.getAttributes()), r), s ? t.setSelection(s) : r.is("documentSelection") || t.setSelection(r), this._buffer.unlock(), this._buffer.input(i)
                }))
            }
        }
        const $b = ["insertText", "insertReplacementText"];
        class Gb extends Aa {
            constructor(t) {
                super(t), i.isAndroid && $b.push("insertCompositionText");
                const e = t.document;
                e.on("beforeinput", ((n, o) => {
                    if (!this.isEnabled) return;
                    const {
                        data: i,
                        targetRanges: r,
                        inputType: s,
                        domEvent: a
                    } = o;
                    if (!$b.includes(s)) return;
                    const l = new h(e, "insertText");
                    e.fire(l, new _a(t, a, {
                        text: i,
                        selection: t.createSelection(r)
                    })), l.stop.called && n.stop()
                })), e.on("compositionend", ((n, {
                    data: o,
                    domEvent: r
                }) => {
                    this.isEnabled && !i.isAndroid && o && e.fire("insertText", new _a(t, r, {
                        text: o,
                        selection: e.selection
                    }))
                }), {
                    priority: "lowest"
                })
            }
            observe() {}
            stopObserving() {}
        }
        class Kb extends Vi {
            static get pluginName() {
                return "Input"
            }
            init() {
                const t = this.editor,
                    e = t.model,
                    n = t.editing.view,
                    o = e.document.selection;
                n.addObserver(Gb);
                const r = new Ub(t, t.config.get("typing.undoStep") || 20);
                t.commands.add("insertText", r), t.commands.add("input", r), this.listenTo(n.document, "insertText", ((o, r) => {
                    n.document.isComposing || r.preventDefault();
                    const {
                        text: s,
                        selection: a,
                        resultRange: l
                    } = r, c = Array.from(a.getRanges()).map((e => t.editing.mapper.toModelRange(e)));
                    let d = s;
                    if (i.isAndroid) {
                        const t = Array.from(c[0].getItems()).reduce(((t, e) => t + (e.is("$textProxy") ? e.data : "")), "");
                        t && (t.length <= d.length ? d.startsWith(t) && (d = d.substring(t.length), c[0].start = c[0].start.getShiftedBy(t.length)) : t.startsWith(d) && (c[0].start = c[0].start.getShiftedBy(d.length), d = ""))
                    }
                    const h = {
                        text: d,
                        selection: e.createSelection(c)
                    };
                    l && (h.resultRange = t.editing.mapper.toModelRange(l)), t.execute("insertText", h)
                })), i.isAndroid ? this.listenTo(n.document, "keydown", ((t, i) => {
                    !o.isCollapsed && 229 == i.keyCode && n.document.isComposing && Zb(e, r)
                })) : this.listenTo(n.document, "compositionstart", (() => {
                    o.isCollapsed || Zb(e, r)
                }))
            }
        }

        function Zb(t, e) {
            if (!e.isEnabled) return;
            const n = e.buffer;
            n.lock(), t.enqueueChange(n.batch, (() => {
                t.deleteContent(t.document.selection)
            })), n.unlock()
        }
        class Jb extends Fi {
            constructor(t, e) {
                super(t), this.direction = e, this._buffer = new Wb(t.model, t.config.get("typing.undoStep")), this._isEnabledBasedOnSelection = !1
            }
            get buffer() {
                return this._buffer
            }
            execute(t = {}) {
                const e = this.editor.model,
                    n = e.document;
                e.enqueueChange(this._buffer.batch, (o => {
                    this._buffer.lock();
                    const i = o.createSelection(t.selection || n.selection);
                    if (!e.canEditAt(i)) return;
                    const r = t.sequence || 1,
                        s = i.isCollapsed;
                    if (i.isCollapsed && e.modifySelection(i, {
                            direction: this.direction,
                            unit: t.unit,
                            treatEmojiAsSingleUnit: !0
                        }), this._shouldEntireContentBeReplacedWithParagraph(r)) return void this._replaceEntireContentWithParagraph(o);
                    if (this._shouldReplaceFirstBlockWithParagraph(i, r)) return void this.editor.execute("paragraph", {
                        selection: i
                    });
                    if (i.isCollapsed) return;
                    let a = 0;
                    i.getFirstRange().getMinimalFlatRanges().forEach((t => {
                        a += J(t.getWalker({
                            singleCharacters: !0,
                            ignoreElementEnd: !0,
                            shallow: !0
                        }))
                    })), e.deleteContent(i, {
                        doNotResetEntireContent: s,
                        direction: this.direction
                    }), this._buffer.input(a), o.setSelection(i), this._buffer.unlock()
                }))
            }
            _shouldEntireContentBeReplacedWithParagraph(t) {
                if (t > 1) return !1;
                const e = this.editor.model,
                    n = e.document.selection,
                    o = e.schema.getLimitElement(n);
                if (!(n.isCollapsed && n.containsEntireContent(o))) return !1;
                if (!e.schema.checkChild(o, "paragraph")) return !1;
                const i = o.getChild(0);
                return !i || !i.is("element", "paragraph")
            }
            _replaceEntireContentWithParagraph(t) {
                const e = this.editor.model,
                    n = e.document.selection,
                    o = e.schema.getLimitElement(n),
                    i = t.createElement("paragraph");
                t.remove(t.createRangeIn(o)), t.insert(i, o), t.setSelection(i, 0)
            }
            _shouldReplaceFirstBlockWithParagraph(t, e) {
                const n = this.editor.model;
                if (e > 1 || "backward" != this.direction) return !1;
                if (!t.isCollapsed) return !1;
                const o = t.getFirstPosition(),
                    i = n.schema.getLimitElement(o),
                    r = i.getChild(0);
                return o.parent == r && (!!t.containsEntireContent(r) && (!!n.schema.checkChild(i, "paragraph") && "paragraph" != r.name))
            }
        }
        const Yb = "word",
            Qb = "selection",
            Xb = "backward",
            tk = "forward",
            ek = {
                deleteContent: {
                    unit: Qb,
                    direction: Xb
                },
                deleteContentBackward: {
                    unit: "codePoint",
                    direction: Xb
                },
                deleteWordBackward: {
                    unit: Yb,
                    direction: Xb
                },
                deleteHardLineBackward: {
                    unit: Qb,
                    direction: Xb
                },
                deleteSoftLineBackward: {
                    unit: Qb,
                    direction: Xb
                },
                deleteContentForward: {
                    unit: "character",
                    direction: tk
                },
                deleteWordForward: {
                    unit: Yb,
                    direction: tk
                },
                deleteHardLineForward: {
                    unit: Qb,
                    direction: tk
                },
                deleteSoftLineForward: {
                    unit: Qb,
                    direction: tk
                }
            };
        class nk extends Aa {
            constructor(t) {
                super(t);
                const e = t.document;
                let n = 0;
                e.on("keydown", (() => {
                    n++
                })), e.on("keyup", (() => {
                    n = 0
                })), e.on("beforeinput", ((o, r) => {
                    if (!this.isEnabled) return;
                    const {
                        targetRanges: s,
                        domEvent: a,
                        inputType: l
                    } = r, c = ek[l];
                    if (!c) return;
                    const d = {
                        direction: c.direction,
                        unit: c.unit,
                        sequence: n
                    };
                    d.unit == Qb && (d.selectionToRemove = t.createSelection(s[0])), "deleteContentBackward" === l && (i.isAndroid && (d.sequence = 1), function(t) {
                        if (1 != t.length || t[0].isCollapsed) return !1;
                        const e = t[0].getWalker({
                            direction: "backward",
                            singleCharacters: !0,
                            ignoreElementEnd: !0
                        });
                        let n = 0;
                        for (const {
                                nextPosition: t
                            }
                            of e) {
                            if (t.parent.is("$text")) {
                                const e = t.parent.data,
                                    o = t.offset;
                                if (Ii(e, o) || Pi(e, o) || zi(e, o)) continue;
                                n++
                            } else n++;
                            if (n > 1) return !0
                        }
                        return !1
                    }(s) && (d.unit = Qb, d.selectionToRemove = t.createSelection(s)));
                    const h = new ks(e, "delete", s[0]);
                    e.fire(h, new _a(t, a, d)), h.stop.called && o.stop()
                })), i.isBlink && function(t) {
                    const e = t.view,
                        n = e.document;
                    let o = null,
                        i = !1;

                    function r(t) {
                        return t == mi.backspace || t == mi.delete
                    }

                    function s(t) {
                        return t == mi.backspace ? Xb : tk
                    }
                    n.on("keydown", ((t, {
                        keyCode: e
                    }) => {
                        o = e, i = !1
                    })), n.on("keyup", ((a, {
                        keyCode: l,
                        domEvent: c
                    }) => {
                        const d = n.selection,
                            h = t.isEnabled && l == o && r(l) && !d.isCollapsed && !i;
                        if (o = null, h) {
                            const t = d.getFirstRange(),
                                o = new ks(n, "delete", t),
                                i = {
                                    unit: Qb,
                                    direction: s(l),
                                    selectionToRemove: d
                                };
                            n.fire(o, new _a(e, c, i))
                        }
                    })), n.on("beforeinput", ((t, {
                        inputType: e
                    }) => {
                        const n = ek[e];
                        r(o) && n && n.direction == s(o) && (i = !0)
                    }), {
                        priority: "high"
                    }), n.on("beforeinput", ((t, {
                        inputType: e,
                        data: n
                    }) => {
                        o == mi.delete && "insertText" == e && "" == n && t.stop()
                    }), {
                        priority: "high"
                    })
                }(this)
            }
            observe() {}
            stopObserving() {}
        }
        class ok extends Vi {
            static get pluginName() {
                return "Delete"
            }
            init() {
                const t = this.editor,
                    e = t.editing.view,
                    n = e.document,
                    o = t.model.document;
                e.addObserver(nk), this._undoOnBackspace = !1;
                const i = new Jb(t, "forward");
                t.commands.add("deleteForward", i), t.commands.add("forwardDelete", i), t.commands.add("delete", new Jb(t, "backward")), this.listenTo(n, "delete", ((o, i) => {
                    n.isComposing || i.preventDefault();
                    const {
                        direction: r,
                        sequence: s,
                        selectionToRemove: a,
                        unit: l
                    } = i, c = "forward" === r ? "deleteForward" : "delete", d = {
                        sequence: s
                    };
                    if ("selection" == l) {
                        const e = Array.from(a.getRanges()).map((e => t.editing.mapper.toModelRange(e)));
                        d.selection = t.model.createSelection(e)
                    } else d.unit = l;
                    t.execute(c, d), e.scrollToTheSelection()
                }), {
                    priority: "low"
                }), this.editor.plugins.has("UndoEditing") && (this.listenTo(n, "delete", ((e, n) => {
                    this._undoOnBackspace && "backward" == n.direction && 1 == n.sequence && "codePoint" == n.unit && (this._undoOnBackspace = !1, t.execute("undo"), n.preventDefault(), e.stop())
                }), {
                    context: "$capture"
                }), this.listenTo(o, "change", (() => {
                    this._undoOnBackspace = !1
                })))
            }
            requestUndoOnBackspace() {
                this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = !0)
            }
        }

        function ik(t, e) {
            let n = t.start;
            return {
                text: Array.from(t.getWalker({
                    ignoreElementEnd: !1
                })).reduce(((t, {
                    item: o
                }) => o.is("$text") || o.is("$textProxy") ? t + o.data : (n = e.createPositionAfter(o), "")), ""),
                range: e.createRange(n, t.end)
            }
        }
        class rk extends(q()) {
            constructor(t, e) {
                super(), this.model = t, this.testCallback = e, this._hasMatch = !1, this.set("isEnabled", !0), this.on("change:isEnabled", (() => {
                    this.isEnabled ? this._startListening() : (this.stopListening(t.document.selection), this.stopListening(t.document))
                })), this._startListening()
            }
            get hasMatch() {
                return this._hasMatch
            }
            _startListening() {
                const t = this.model.document;
                this.listenTo(t.selection, "change:range", ((e, {
                    directChange: n
                }) => {
                    n && (t.selection.isCollapsed ? this._evaluateTextBeforeSelection("selection") : this.hasMatch && (this.fire("unmatched"), this._hasMatch = !1))
                })), this.listenTo(t, "change:data", ((t, e) => {
                    !e.isUndo && e.isLocal && this._evaluateTextBeforeSelection("data", {
                        batch: e
                    })
                }))
            }
            _evaluateTextBeforeSelection(t, e = {}) {
                const n = this.model,
                    o = n.document.selection,
                    i = n.createRange(n.createPositionAt(o.focus.parent, 0), o.focus),
                    {
                        text: r,
                        range: s
                    } = ik(i, n),
                    a = this.testCallback(r);
                if (!a && this.hasMatch && this.fire("unmatched"), this._hasMatch = !!a, a) {
                    const n = Object.assign(e, {
                        text: r,
                        range: s
                    });
                    "object" == typeof a && Object.assign(n, a), this.fire(`matched:${t}`, n)
                }
            }
        }
        class sk extends Vi {
            constructor(t) {
                super(t), this.attributes = new Set, this._overrideUid = null
            }
            static get pluginName() {
                return "TwoStepCaretMovement"
            }
            init() {
                const t = this.editor,
                    e = t.model,
                    n = t.editing.view,
                    o = t.locale,
                    i = e.document.selection;
                this.listenTo(n.document, "arrowKey", ((t, e) => {
                    if (!i.isCollapsed) return;
                    if (e.shiftKey || e.altKey || e.ctrlKey) return;
                    const n = e.keyCode == mi.arrowright,
                        r = e.keyCode == mi.arrowleft;
                    if (!n && !r) return;
                    const s = o.contentLanguageDirection;
                    let a = !1;
                    a = "ltr" === s && n || "rtl" === s && r ? this._handleForwardMovement(e) : this._handleBackwardMovement(e), !0 === a && t.stop()
                }), {
                    context: "$text",
                    priority: "highest"
                }), this._isNextGravityRestorationSkipped = !1, this.listenTo(i, "change:range", ((t, e) => {
                    this._isNextGravityRestorationSkipped ? this._isNextGravityRestorationSkipped = !1 : this._isGravityOverridden && (!e.directChange && dk(i.getFirstPosition(), this.attributes) || this._restoreGravity())
                }))
            }
            registerAttribute(t) {
                this.attributes.add(t)
            }
            _handleForwardMovement(t) {
                const e = this.attributes,
                    n = this.editor.model.document.selection,
                    o = n.getFirstPosition();
                return !this._isGravityOverridden && ((!o.isAtStart || !ak(n, e)) && (!!dk(o, e) && (ck(t), this._overrideGravity(), !0)))
            }
            _handleBackwardMovement(t) {
                const e = this.attributes,
                    n = this.editor.model,
                    o = n.document.selection,
                    i = o.getFirstPosition();
                return this._isGravityOverridden ? (ck(t), this._restoreGravity(), lk(n, e, i), !0) : i.isAtStart ? !!ak(o, e) && (ck(t), lk(n, e, i), !0) : !! function(t, e) {
                    const n = t.getShiftedBy(-1);
                    return dk(n, e)
                }(i, e) && (i.isAtEnd && !ak(o, e) && dk(i, e) ? (ck(t), lk(n, e, i), !0) : (this._isNextGravityRestorationSkipped = !0, this._overrideGravity(), !1))
            }
            get _isGravityOverridden() {
                return !!this._overrideUid
            }
            _overrideGravity() {
                this._overrideUid = this.editor.model.change((t => t.overrideSelectionGravity()))
            }
            _restoreGravity() {
                this.editor.model.change((t => {
                    t.restoreSelectionGravity(this._overrideUid), this._overrideUid = null
                }))
            }
        }

        function ak(t, e) {
            for (const n of e)
                if (t.hasAttribute(n)) return !0;
            return !1
        }

        function lk(t, e, n) {
            const o = n.nodeBefore;
            t.change((t => {
                o ? t.setSelectionAttribute(o.getAttributes()) : t.removeSelectionAttribute(e)
            }))
        }

        function ck(t) {
            t.preventDefault()
        }

        function dk(t, e) {
            const {
                nodeBefore: n,
                nodeAfter: o
            } = t;
            for (const t of e) {
                const e = n ? n.getAttribute(t) : void 0;
                if ((o ? o.getAttribute(t) : void 0) !== e) return !0
            }
            return !1
        }
        const hk = {
                copyright: {
                    from: "(c)",
                    to: "©"
                },
                registeredTrademark: {
                    from: "(r)",
                    to: "®"
                },
                trademark: {
                    from: "(tm)",
                    to: "™"
                },
                oneHalf: {
                    from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i,
                    to: [null, "½", null]
                },
                oneThird: {
                    from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i,
                    to: [null, "⅓", null]
                },
                twoThirds: {
                    from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i,
                    to: [null, "⅔", null]
                },
                oneForth: {
                    from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i,
                    to: [null, "¼", null]
                },
                threeQuarters: {
                    from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i,
                    to: [null, "¾", null]
                },
                lessThanOrEqual: {
                    from: "<=",
                    to: "≤"
                },
                greaterThanOrEqual: {
                    from: ">=",
                    to: "≥"
                },
                notEqual: {
                    from: "!=",
                    to: "≠"
                },
                arrowLeft: {
                    from: "<-",
                    to: "←"
                },
                arrowRight: {
                    from: "->",
                    to: "→"
                },
                horizontalEllipsis: {
                    from: "...",
                    to: "…"
                },
                enDash: {
                    from: /(^| )(--)( )$/,
                    to: [null, "–", null]
                },
                emDash: {
                    from: /(^| )(---)( )$/,
                    to: [null, "—", null]
                },
                quotesPrimary: {
                    from: bk('"'),
                    to: [null, "“", null, "”"]
                },
                quotesSecondary: {
                    from: bk("'"),
                    to: [null, "‘", null, "’"]
                },
                quotesPrimaryEnGb: {
                    from: bk("'"),
                    to: [null, "‘", null, "’"]
                },
                quotesSecondaryEnGb: {
                    from: bk('"'),
                    to: [null, "“", null, "”"]
                },
                quotesPrimaryPl: {
                    from: bk('"'),
                    to: [null, "„", null, "”"]
                },
                quotesSecondaryPl: {
                    from: bk("'"),
                    to: [null, "‚", null, "’"]
                }
            },
            uk = {
                symbols: ["copyright", "registeredTrademark", "trademark"],
                mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"],
                typography: ["horizontalEllipsis", "enDash", "emDash"],
                quotes: ["quotesPrimary", "quotesSecondary"]
            },
            gk = ["symbols", "mathematical", "typography", "quotes"];

        function mk(t) {
            return "string" == typeof t ? new RegExp(`(${Tb(t)})$`) : t
        }

        function pk(t) {
            return "string" == typeof t ? () => [t] : t instanceof Array ? () => t : t
        }

        function fk(t) {
            return (t.textNode ? t.textNode : t.nodeAfter).getAttributes()
        }

        function bk(t) {
            return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`)
        }

        function kk(t, e, n, o) {
            return o.createRange(wk(t, e, n, !0, o), wk(t, e, n, !1, o))
        }

        function wk(t, e, n, o, i) {
            let r = t.textNode || (o ? t.nodeBefore : t.nodeAfter),
                s = null;
            for (; r && r.getAttribute(e) == n;) s = r, r = o ? r.previousSibling : r.nextSibling;
            return s ? i.createPositionAt(s, o ? "before" : "after") : t
        }

        function Ak(t, e, n, o) {
            const i = t.editing.view,
                r = new Set;
            i.document.registerPostFixer((i => {
                const s = t.model.document.selection;
                let a = !1;
                if (s.hasAttribute(e)) {
                    const l = kk(s.getFirstPosition(), e, s.getAttribute(e), t.model),
                        c = t.editing.mapper.toViewRange(l);
                    for (const t of c.getItems()) t.is("element", n) && !t.hasClass(o) && (i.addClass(o, t), r.add(t), a = !0)
                }
                return a
            })), t.conversion.for("editingDowncast").add((t => {
                function e() {
                    i.change((t => {
                        for (const e of r.values()) t.removeClass(o, e), r.delete(e)
                    }))
                }
                t.on("insert", e, {
                    priority: "highest"
                }), t.on("remove", e, {
                    priority: "highest"
                }), t.on("attribute", e, {
                    priority: "highest"
                }), t.on("selection", e, {
                    priority: "highest"
                })
            }))
        }

        function Ck(t, e, n, o) {
            let i, r = null;
            "function" == typeof o ? i = o : (r = t.commands.get(o), i = () => {
                t.execute(o)
            }), t.model.document.on("change:data", ((s, a) => {
                if (r && !r.isEnabled || !e.isEnabled) return;
                const l = Ei(t.model.document.selection.getRanges());
                if (!l.isCollapsed) return;
                if (a.isUndo || !a.isLocal) return;
                const c = Array.from(t.model.document.differ.getChanges()),
                    d = c[0];
                if (1 != c.length || "insert" !== d.type || "$text" != d.name || 1 != d.length) return;
                const h = d.position.parent;
                if (h.is("element", "codeBlock")) return;
                if (h.is("element", "listItem") && "function" != typeof o && !["numberedList", "bulletedList", "todoList"].includes(o)) return;
                if (r && !0 === r.value) return;
                const u = h.getChild(0),
                    g = t.model.createRangeOn(u);
                if (!g.containsRange(l) && !l.end.isEqual(g.end)) return;
                const m = n.exec(u.data.substr(0, l.end.offset));
                m && t.model.enqueueChange((e => {
                    const n = e.createPositionAt(h, 0),
                        o = e.createPositionAt(h, m[0].length),
                        r = new ec(n, o);
                    if (!1 !== i({
                            match: m
                        })) {
                        e.remove(r);
                        const n = t.model.document.selection.getFirstRange(),
                            o = e.createRangeIn(h);
                        !h.isEmpty || o.isEqual(n) || o.containsRange(n, !0) || e.remove(h)
                    }
                    r.detach(), t.model.enqueueChange((() => {
                        t.plugins.get("Delete").requestUndoOnBackspace()
                    }))
                }))
            }))
        }

        function _k(t, e, n, o) {
            let i, r;
            n instanceof RegExp ? i = n : r = n, r = r || (t => {
                let e;
                const n = [],
                    o = [];
                for (; null !== (e = i.exec(t)) && !(e && e.length < 4);) {
                    let {
                        index: t,
                        1: i,
                        2: r,
                        3: s
                    } = e;
                    const a = i + r + s;
                    t += e[0].length - a.length;
                    const l = [t, t + i.length],
                        c = [t + i.length + r.length, t + i.length + r.length + s.length];
                    n.push(l), n.push(c), o.push([t + i.length, t + i.length + r.length])
                }
                return {
                    remove: n,
                    format: o
                }
            }), t.model.document.on("change:data", ((n, i) => {
                if (i.isUndo || !i.isLocal || !e.isEnabled) return;
                const s = t.model,
                    a = s.document.selection;
                if (!a.isCollapsed) return;
                const l = Array.from(s.document.differ.getChanges()),
                    c = l[0];
                if (1 != l.length || "insert" !== c.type || "$text" != c.name || 1 != c.length) return;
                const d = a.focus,
                    h = d.parent,
                    {
                        text: u,
                        range: g
                    } = function(t, e) {
                        let n = t.start;
                        const o = Array.from(t.getItems()).reduce(((t, o) => !o.is("$text") && !o.is("$textProxy") || o.getAttribute("code") ? (n = e.createPositionAfter(o), "") : t + o.data), "");
                        return {
                            text: o,
                            range: e.createRange(n, t.end)
                        }
                    }(s.createRange(s.createPositionAt(h, 0), d), s),
                    m = r(u),
                    p = vk(g.start, m.format, s),
                    f = vk(g.start, m.remove, s);
                p.length && f.length && s.enqueueChange((e => {
                    if (!1 !== o(e, p)) {
                        for (const t of f.reverse()) e.remove(t);
                        s.enqueueChange((() => {
                            t.plugins.get("Delete").requestUndoOnBackspace()
                        }))
                    }
                }))
            }))
        }

        function vk(t, e, n) {
            return e.filter((t => void 0 !== t[0] && void 0 !== t[1])).map((e => n.createRange(t.getShiftedBy(e[0]), t.getShiftedBy(e[1]))))
        }

        function yk(t, e) {
            return (n, o) => {
                if (!t.commands.get(e).isEnabled) return !1;
                const i = t.model.schema.getValidRanges(o, e);
                for (const t of i) n.setAttribute(e, !0, t);
                n.removeSelectionAttribute(e)
            }
        }
        class xk extends Fi {
            constructor(t, e) {
                super(t), this.attributeKey = e
            }
            refresh() {
                const t = this.editor.model,
                    e = t.document;
                this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey)
            }
            execute(t = {}) {
                const e = this.editor.model,
                    n = e.document.selection,
                    o = void 0 === t.forceValue ? !this.value : t.forceValue;
                e.change((t => {
                    if (n.isCollapsed) o ? t.setSelectionAttribute(this.attributeKey, !0) : t.removeSelectionAttribute(this.attributeKey);
                    else {
                        const i = e.schema.getValidRanges(n.getRanges(), this.attributeKey);
                        for (const e of i) o ? t.setAttribute(this.attributeKey, o, e) : t.removeAttribute(this.attributeKey, e)
                    }
                }))
            }
            _getValueFromFirstAllowedNode() {
                const t = this.editor.model,
                    e = t.schema,
                    n = t.document.selection;
                if (n.isCollapsed) return n.hasAttribute(this.attributeKey);
                for (const t of n.getRanges())
                    for (const n of t.getItems())
                        if (e.checkAttribute(n, this.attributeKey)) return n.hasAttribute(this.attributeKey);
                return !1
            }
        }
        const Ek = "bold";
        class Dk extends Vi {
            static get pluginName() {
                return "BoldEditing"
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: Ek
                }), t.model.schema.setAttributeProperties(Ek, {
                    isFormatting: !0,
                    copyOnEnter: !0
                }), t.conversion.attributeToElement({
                    model: Ek,
                    view: "strong",
                    upcastAlso: ["b", t => {
                        const e = t.getStyle("font-weight");
                        return e && ("bold" == e || Number(e) >= 600) ? {
                            name: !0,
                            styles: ["font-weight"]
                        } : null
                    }]
                }), t.commands.add(Ek, new xk(t, Ek)), t.keystrokes.set("CTRL+B", Ek)
            }
        }
        const Sk = "bold";
        class Tk extends Vi {
            static get pluginName() {
                return "BoldUI"
            }
            init() {
                const t = this.editor,
                    e = t.t;
                t.ui.componentFactory.add(Sk, (n => {
                    const o = t.commands.get(Sk),
                        i = new Mg(n);
                    return i.set({
                        label: e("Bold"),
                        icon: eg.bold,
                        keystroke: "CTRL+B",
                        tooltip: !0,
                        isToggleable: !0
                    }), i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), this.listenTo(i, "execute", (() => {
                        t.execute(Sk), t.editing.view.focus()
                    })), i
                }))
            }
        }
        const Bk = "code";
        class Ik extends Vi {
            static get pluginName() {
                return "CodeEditing"
            }
            static get requires() {
                return [sk]
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: Bk
                }), t.model.schema.setAttributeProperties(Bk, {
                    isFormatting: !0,
                    copyOnEnter: !1
                }), t.conversion.attributeToElement({
                    model: Bk,
                    view: "code",
                    upcastAlso: {
                        styles: {
                            "word-wrap": "break-word"
                        }
                    }
                }), t.commands.add(Bk, new xk(t, Bk)), t.plugins.get(sk).registerAttribute(Bk), Ak(t, Bk, "code", "ck-code_selected")
            }
        }
        var Pk = n(8603),
            Rk = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Pk.Z, Rk);
        Pk.Z.locals;
        const zk = "code";
        class Vk extends Vi {
            static get pluginName() {
                return "CodeUI"
            }
            init() {
                const t = this.editor,
                    e = t.t;
                t.ui.componentFactory.add(zk, (n => {
                    const o = t.commands.get(zk),
                        i = new Mg(n);
                    return i.set({
                        label: e("Code"),
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 5.7 5.2 3.9v1.3l-5.6 4c-.1.2-.3.2-.5.2-.3-.1-.6-.7-.6-1l.3-.4 4.7-3.5L11.5 7l-.2-.2c-.1-.3-.1-.6 0-.8.2-.2.5-.4.8-.4a.8.8 0 0 1 .4.1zm-5.2 0L2 9.6v1.3l5.6 4c.1.2.3.2.5.2.3-.1.7-.7.6-1 0-.1 0-.3-.2-.4l-5-3.5L8.2 7l.2-.2c.1-.3.1-.6 0-.8-.2-.2-.5-.4-.8-.4a.8.8 0 0 0-.3.1z"/></svg>',
                        tooltip: !0,
                        isToggleable: !0
                    }), i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), this.listenTo(i, "execute", (() => {
                        t.execute(zk), t.editing.view.focus()
                    })), i
                }))
            }
        }
        const Ok = "italic";
        class Fk extends Vi {
            static get pluginName() {
                return "ItalicEditing"
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: Ok
                }), t.model.schema.setAttributeProperties(Ok, {
                    isFormatting: !0,
                    copyOnEnter: !0
                }), t.conversion.attributeToElement({
                    model: Ok,
                    view: "i",
                    upcastAlso: ["em", {
                        styles: {
                            "font-style": "italic"
                        }
                    }]
                }), t.commands.add(Ok, new xk(t, Ok)), t.keystrokes.set("CTRL+I", Ok)
            }
        }
        const Mk = "italic";
        class Nk extends Vi {
            static get pluginName() {
                return "ItalicUI"
            }
            init() {
                const t = this.editor,
                    e = t.t;
                t.ui.componentFactory.add(Mk, (n => {
                    const o = t.commands.get(Mk),
                        i = new Mg(n);
                    return i.set({
                        label: e("Italic"),
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>',
                        keystroke: "CTRL+I",
                        tooltip: !0,
                        isToggleable: !0
                    }), i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), this.listenTo(i, "execute", (() => {
                        t.execute(Mk), t.editing.view.focus()
                    })), i
                }))
            }
        }
        const Lk = "strikethrough";
        class Hk extends Vi {
            static get pluginName() {
                return "StrikethroughEditing"
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: Lk
                }), t.model.schema.setAttributeProperties(Lk, {
                    isFormatting: !0,
                    copyOnEnter: !0
                }), t.conversion.attributeToElement({
                    model: Lk,
                    view: "s",
                    upcastAlso: ["del", "strike", {
                        styles: {
                            "text-decoration": "line-through"
                        }
                    }]
                }), t.commands.add(Lk, new xk(t, Lk)), t.keystrokes.set("CTRL+SHIFT+X", "strikethrough")
            }
        }
        const jk = "strikethrough";
        class qk extends Vi {
            static get pluginName() {
                return "StrikethroughUI"
            }
            init() {
                const t = this.editor,
                    e = t.t;
                t.ui.componentFactory.add(jk, (n => {
                    const o = t.commands.get(jk),
                        i = new Mg(n);
                    return i.set({
                        label: e("Strikethrough"),
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>',
                        keystroke: "CTRL+SHIFT+X",
                        tooltip: !0,
                        isToggleable: !0
                    }), i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), this.listenTo(i, "execute", (() => {
                        t.execute(jk), t.editing.view.focus()
                    })), i
                }))
            }
        }
        const Wk = "subscript";
        class Uk extends Vi {
            static get pluginName() {
                return "SubscriptEditing"
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: Wk
                }), t.model.schema.setAttributeProperties(Wk, {
                    isFormatting: !0,
                    copyOnEnter: !0
                }), t.conversion.attributeToElement({
                    model: Wk,
                    view: "sub",
                    upcastAlso: [{
                        styles: {
                            "vertical-align": "sub"
                        }
                    }]
                }), t.commands.add(Wk, new xk(t, Wk))
            }
        }
        const $k = "subscript";
        class Gk extends Vi {
            static get pluginName() {
                return "SubscriptUI"
            }
            init() {
                const t = this.editor,
                    e = t.t;
                t.ui.componentFactory.add($k, (n => {
                    const o = t.commands.get($k),
                        i = new Mg(n);
                    return i.set({
                        label: e("Subscript"),
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.03 10.349 3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z"/></svg>',
                        tooltip: !0,
                        isToggleable: !0
                    }), i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), this.listenTo(i, "execute", (() => {
                        t.execute($k), t.editing.view.focus()
                    })), i
                }))
            }
        }
        const Kk = "superscript";
        class Zk extends Vi {
            static get pluginName() {
                return "SuperscriptEditing"
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: Kk
                }), t.model.schema.setAttributeProperties(Kk, {
                    isFormatting: !0,
                    copyOnEnter: !0
                }), t.conversion.attributeToElement({
                    model: Kk,
                    view: "sup",
                    upcastAlso: [{
                        styles: {
                            "vertical-align": "super"
                        }
                    }]
                }), t.commands.add(Kk, new xk(t, Kk))
            }
        }
        const Jk = "superscript";
        class Yk extends Vi {
            static get pluginName() {
                return "SuperscriptUI"
            }
            init() {
                const t = this.editor,
                    e = t.t;
                t.ui.componentFactory.add(Jk, (n => {
                    const o = t.commands.get(Jk),
                        i = new Mg(n);
                    return i.set({
                        label: e("Superscript"),
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z"/></svg>',
                        tooltip: !0,
                        isToggleable: !0
                    }), i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), this.listenTo(i, "execute", (() => {
                        t.execute(Jk), t.editing.view.focus()
                    })), i
                }))
            }
        }
        const Qk = "underline";
        class Xk extends Vi {
            static get pluginName() {
                return "UnderlineEditing"
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: Qk
                }), t.model.schema.setAttributeProperties(Qk, {
                    isFormatting: !0,
                    copyOnEnter: !0
                }), t.conversion.attributeToElement({
                    model: Qk,
                    view: "u",
                    upcastAlso: {
                        styles: {
                            "text-decoration": "underline"
                        }
                    }
                }), t.commands.add(Qk, new xk(t, Qk)), t.keystrokes.set("CTRL+U", "underline")
            }
        }
        const tw = "underline";
        class ew extends Vi {
            static get pluginName() {
                return "UnderlineUI"
            }
            init() {
                const t = this.editor,
                    e = t.t;
                t.ui.componentFactory.add(tw, (n => {
                    const o = t.commands.get(tw),
                        i = new Mg(n);
                    return i.set({
                        label: e("Underline"),
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>',
                        keystroke: "CTRL+U",
                        tooltip: !0,
                        isToggleable: !0
                    }), i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), this.listenTo(i, "execute", (() => {
                        t.execute(tw), t.editing.view.focus()
                    })), i
                }))
            }
        }

        function* nw(t, e) {
            for (const n of e) n && t.getAttributeProperties(n[0]).copyOnEnter && (yield n)
        }
        class ow extends Fi {
            execute() {
                this.editor.model.change((t => {
                    this.enterBlock(t), this.fire("afterExecute", {
                        writer: t
                    })
                }))
            }
            enterBlock(t) {
                const e = this.editor.model,
                    n = e.document.selection,
                    o = e.schema,
                    i = n.isCollapsed,
                    r = n.getFirstRange(),
                    s = r.start.parent,
                    a = r.end.parent;
                if (o.isLimit(s) || o.isLimit(a)) return i || s != a || e.deleteContent(n), !1;
                if (i) {
                    const e = nw(t.model.schema, n.getAttributes());
                    return iw(t, r.start), t.setSelectionAttribute(e), !0
                } {
                    const o = !(r.start.isAtStart && r.end.isAtEnd),
                        i = s == a;
                    if (e.deleteContent(n, {
                            leaveUnmerged: o
                        }), o) {
                        if (i) return iw(t, n.focus), !0;
                        t.setSelection(a, 0)
                    }
                }
                return !1
            }
        }

        function iw(t, e) {
            t.split(e), t.setSelection(e.parent.nextSibling, 0)
        }
        const rw = {
            insertParagraph: {
                isSoft: !1
            },
            insertLineBreak: {
                isSoft: !0
            }
        };
        class sw extends Aa {
            constructor(t) {
                super(t);
                const e = this.document;
                let n = !1;
                e.on("keydown", ((t, e) => {
                    n = e.shiftKey
                })), e.on("beforeinput", ((o, r) => {
                    if (!this.isEnabled) return;
                    let s = r.inputType;
                    i.isSafari && n && "insertParagraph" == s && (s = "insertLineBreak");
                    const a = r.domEvent,
                        l = rw[s];
                    if (!l) return;
                    const c = new ks(e, "enter", r.targetRanges[0]);
                    e.fire(c, new _a(t, a, {
                        isSoft: l.isSoft
                    })), c.stop.called && o.stop()
                }))
            }
            observe() {}
            stopObserving() {}
        }
        class aw extends Vi {
            static get pluginName() {
                return "Enter"
            }
            init() {
                const t = this.editor,
                    e = t.editing.view,
                    n = e.document;
                e.addObserver(sw), t.commands.add("enter", new ow(t)), this.listenTo(n, "enter", ((o, i) => {
                    n.isComposing || i.preventDefault(), i.isSoft || (t.execute("enter"), e.scrollToTheSelection())
                }), {
                    priority: "low"
                })
            }
        }
        class lw extends Fi {
            execute() {
                const t = this.editor.model,
                    e = t.document;
                t.change((n => {
                    ! function(t, e, n) {
                        const o = n.isCollapsed,
                            i = n.getFirstRange(),
                            r = i.start.parent,
                            s = i.end.parent,
                            a = r == s;
                        if (o) {
                            const o = nw(t.schema, n.getAttributes());
                            cw(t, e, i.end), e.removeSelectionAttribute(n.getAttributeKeys()), e.setSelectionAttribute(o)
                        } else {
                            const o = !(i.start.isAtStart && i.end.isAtEnd);
                            t.deleteContent(n, {
                                leaveUnmerged: o
                            }), a ? cw(t, e, n.focus) : o && e.setSelection(s, 0)
                        }
                    }(t, n, e.selection), this.fire("afterExecute", {
                        writer: n
                    })
                }))
            }
            refresh() {
                const t = this.editor.model,
                    e = t.document;
                this.isEnabled = function(t, e) {
                    if (e.rangeCount > 1) return !1;
                    const n = e.anchor;
                    if (!n || !t.checkChild(n, "softBreak")) return !1;
                    const o = e.getFirstRange(),
                        i = o.start.parent,
                        r = o.end.parent;
                    if ((dw(i, t) || dw(r, t)) && i !== r) return !1;
                    return !0
                }(t.schema, e.selection)
            }
        }

        function cw(t, e, n) {
            const o = e.createElement("softBreak");
            t.insertContent(o, n), e.setSelection(o, "after")
        }

        function dw(t, e) {
            return !t.is("rootElement") && (e.isLimit(t) || dw(t.parent, e))
        }
        class hw extends Vi {
            static get pluginName() {
                return "ShiftEnter"
            }
            init() {
                const t = this.editor,
                    e = t.model.schema,
                    n = t.conversion,
                    o = t.editing.view,
                    i = o.document;
                e.register("softBreak", {
                    allowWhere: "$text",
                    isInline: !0
                }), n.for("upcast").elementToElement({
                    model: "softBreak",
                    view: "br"
                }), n.for("downcast").elementToElement({
                    model: "softBreak",
                    view: (t, {
                        writer: e
                    }) => e.createEmptyElement("br")
                }), o.addObserver(sw), t.commands.add("shiftEnter", new lw(t)), this.listenTo(i, "enter", ((e, n) => {
                    i.isComposing || n.preventDefault(), n.isSoft && (t.execute("shiftEnter"), o.scrollToTheSelection())
                }), {
                    priority: "low"
                })
            }
        }
        class uw extends Fi {
            refresh() {
                this.value = this._getValue(), this.isEnabled = this._checkEnabled()
            }
            execute(t = {}) {
                const e = this.editor.model,
                    n = e.schema,
                    o = e.document.selection,
                    i = Array.from(o.getSelectedBlocks()),
                    r = void 0 === t.forceValue ? !this.value : t.forceValue;
                e.change((t => {
                    if (r) {
                        const e = i.filter((t => gw(t) || pw(n, t)));
                        this._applyQuote(t, e)
                    } else this._removeQuote(t, i.filter(gw))
                }))
            }
            _getValue() {
                const t = Ei(this.editor.model.document.selection.getSelectedBlocks());
                return !(!t || !gw(t))
            }
            _checkEnabled() {
                if (this.value) return !0;
                const t = this.editor.model.document.selection,
                    e = this.editor.model.schema,
                    n = Ei(t.getSelectedBlocks());
                return !!n && pw(e, n)
            }
            _removeQuote(t, e) {
                mw(t, e).reverse().forEach((e => {
                    if (e.start.isAtStart && e.end.isAtEnd) return void t.unwrap(e.start.parent);
                    if (e.start.isAtStart) {
                        const n = t.createPositionBefore(e.start.parent);
                        return void t.move(e, n)
                    }
                    e.end.isAtEnd || t.split(e.end);
                    const n = t.createPositionAfter(e.end.parent);
                    t.move(e, n)
                }))
            }
            _applyQuote(t, e) {
                const n = [];
                mw(t, e).reverse().forEach((e => {
                    let o = gw(e.start);
                    o || (o = t.createElement("blockQuote"), t.wrap(e, o)), n.push(o)
                })), n.reverse().reduce(((e, n) => e.nextSibling == n ? (t.merge(t.createPositionAfter(e)), e) : n))
            }
        }

        function gw(t) {
            return "blockQuote" == t.parent.name ? t.parent : null
        }

        function mw(t, e) {
            let n, o = 0;
            const i = [];
            for (; o < e.length;) {
                const r = e[o],
                    s = e[o + 1];
                n || (n = t.createPositionBefore(r)), s && r.nextSibling == s || (i.push(t.createRange(n, t.createPositionAfter(r))), n = null), o++
            }
            return i
        }

        function pw(t, e) {
            const n = t.checkChild(e.parent, "blockQuote"),
                o = t.checkChild(["$root", "blockQuote"], e);
            return n && o
        }
        class fw extends Vi {
            static get pluginName() {
                return "BlockQuoteEditing"
            }
            static get requires() {
                return [aw, ok]
            }
            init() {
                const t = this.editor,
                    e = t.model.schema;
                t.commands.add("blockQuote", new uw(t)), e.register("blockQuote", {
                    inheritAllFrom: "$container"
                }), t.conversion.elementToElement({
                    model: "blockQuote",
                    view: "blockquote"
                }), t.model.document.registerPostFixer((n => {
                    const o = t.model.document.differ.getChanges();
                    for (const t of o)
                        if ("insert" == t.type) {
                            const o = t.position.nodeAfter;
                            if (!o) continue;
                            if (o.is("element", "blockQuote") && o.isEmpty) return n.remove(o), !0;
                            if (o.is("element", "blockQuote") && !e.checkChild(t.position, o)) return n.unwrap(o), !0;
                            if (o.is("element")) {
                                const t = n.createRangeIn(o);
                                for (const o of t.getItems())
                                    if (o.is("element", "blockQuote") && !e.checkChild(n.createPositionBefore(o), o)) return n.unwrap(o), !0
                            }
                        } else if ("remove" == t.type) {
                        const e = t.position.parent;
                        if (e.is("element", "blockQuote") && e.isEmpty) return n.remove(e), !0
                    }
                    return !1
                }));
                const n = this.editor.editing.view.document,
                    o = t.model.document.selection,
                    i = t.commands.get("blockQuote");
                this.listenTo(n, "enter", ((e, n) => {
                    if (!o.isCollapsed || !i.value) return;
                    o.getLastPosition().parent.isEmpty && (t.execute("blockQuote"), t.editing.view.scrollToTheSelection(), n.preventDefault(), e.stop())
                }), {
                    context: "blockquote"
                }), this.listenTo(n, "delete", ((e, n) => {
                    if ("backward" != n.direction || !o.isCollapsed || !i.value) return;
                    const r = o.getLastPosition().parent;
                    r.isEmpty && !r.previousSibling && (t.execute("blockQuote"), t.editing.view.scrollToTheSelection(), n.preventDefault(), e.stop())
                }), {
                    context: "blockquote"
                })
            }
        }
        var bw = n(3062),
            kw = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(bw.Z, kw);
        bw.Z.locals;
        class ww extends Vi {
            static get pluginName() {
                return "BlockQuoteUI"
            }
            init() {
                const t = this.editor,
                    e = t.t;
                t.ui.componentFactory.add("blockQuote", (n => {
                    const o = t.commands.get("blockQuote"),
                        i = new Mg(n);
                    return i.set({
                        label: e("Block quote"),
                        icon: eg.quote,
                        tooltip: !0,
                        isToggleable: !0
                    }), i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), this.listenTo(i, "execute", (() => {
                        t.execute("blockQuote"), t.editing.view.focus()
                    })), i
                }))
            }
        }
        class Aw extends Fi {
            constructor(t) {
                super(t), this._isEnabledBasedOnSelection = !1
            }
            refresh() {
                const t = this.editor.model,
                    e = Ei(t.document.selection.getSelectedBlocks());
                this.value = !!e && e.is("element", "paragraph"), this.isEnabled = !!e && Cw(e, t.schema)
            }
            execute(t = {}) {
                const e = this.editor.model,
                    n = e.document,
                    o = t.selection || n.selection;
                e.canEditAt(o) && e.change((t => {
                    const n = o.getSelectedBlocks();
                    for (const o of n) !o.is("element", "paragraph") && Cw(o, e.schema) && t.rename(o, "paragraph")
                }))
            }
        }

        function Cw(t, e) {
            return e.checkChild(t.parent, "paragraph") && !e.isObject(t)
        }
        class _w extends Fi {
            constructor(t) {
                super(t), this._isEnabledBasedOnSelection = !1
            }
            execute(t) {
                const e = this.editor.model,
                    n = t.attributes;
                let o = t.position;
                e.canEditAt(o) && e.change((t => {
                    const i = t.createElement("paragraph");
                    if (n && e.schema.setAllowedAttributes(i, n, t), !e.schema.checkChild(o.parent, i)) {
                        const n = e.schema.findAllowedParent(o, i);
                        if (!n) return;
                        o = t.split(o, n).position
                    }
                    e.insertContent(i, o), t.setSelection(i, "in")
                }))
            }
        }
        const vw = class extends Vi {
            static get pluginName() {
                return "Paragraph"
            }
            init() {
                const t = this.editor,
                    e = t.model;
                t.commands.add("paragraph", new Aw(t)), t.commands.add("insertParagraph", new _w(t)), e.schema.register("paragraph", {
                    inheritAllFrom: "$block"
                }), t.conversion.elementToElement({
                    model: "paragraph",
                    view: "p"
                }), t.conversion.for("upcast").elementToElement({
                    model: (t, {
                        writer: e
                    }) => vw.paragraphLikeElements.has(t.name) ? t.isEmpty ? null : e.createElement("paragraph") : null,
                    view: /.+/,
                    converterPriority: "low"
                })
            }
        };
        let yw = vw;
        yw.paragraphLikeElements = new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]);
        const xw = eg.paragraph;
        class Ew extends Fi {
            constructor(t, e) {
                super(t), this.modelElements = e
            }
            refresh() {
                const t = Ei(this.editor.model.document.selection.getSelectedBlocks());
                this.value = !!t && this.modelElements.includes(t.name) && t.name, this.isEnabled = !!t && this.modelElements.some((e => Dw(t, e, this.editor.model.schema)))
            }
            execute(t) {
                const e = this.editor.model,
                    n = e.document,
                    o = t.value;
                e.change((t => {
                    const i = Array.from(n.selection.getSelectedBlocks()).filter((t => Dw(t, o, e.schema)));
                    for (const e of i) e.is("element", o) || t.rename(e, o)
                }))
            }
        }

        function Dw(t, e, n) {
            return n.checkChild(t.parent, e) && !n.isObject(t)
        }
        const Sw = "paragraph";
        class Tw extends Vi {
            static get pluginName() {
                return "HeadingEditing"
            }
            constructor(t) {
                super(t), t.config.define("heading", {
                    options: [{
                        model: "paragraph",
                        title: "Paragraph",
                        class: "ck-heading_paragraph"
                    }, {
                        model: "heading1",
                        view: "h2",
                        title: "Heading 1",
                        class: "ck-heading_heading1"
                    }, {
                        model: "heading2",
                        view: "h3",
                        title: "Heading 2",
                        class: "ck-heading_heading2"
                    }, {
                        model: "heading3",
                        view: "h4",
                        title: "Heading 3",
                        class: "ck-heading_heading3"
                    }]
                })
            }
            static get requires() {
                return [yw]
            }
            init() {
                const t = this.editor,
                    e = t.config.get("heading.options"),
                    n = [];
                for (const o of e) "paragraph" !== o.model && (t.model.schema.register(o.model, {
                    inheritAllFrom: "$block"
                }), t.conversion.elementToElement(o), n.push(o.model));
                this._addDefaultH1Conversion(t), t.commands.add("heading", new Ew(t, n))
            }
            afterInit() {
                const t = this.editor,
                    e = t.commands.get("enter"),
                    n = t.config.get("heading.options");
                e && this.listenTo(e, "afterExecute", ((e, o) => {
                    const i = t.model.document.selection.getFirstPosition().parent;
                    n.some((t => i.is("element", t.model))) && !i.is("element", Sw) && 0 === i.childCount && o.writer.rename(i, Sw)
                }))
            }
            _addDefaultH1Conversion(t) {
                t.conversion.for("upcast").elementToElement({
                    model: "heading1",
                    view: "h1",
                    converterPriority: m.low + 1
                })
            }
        }

        function Bw(t) {
            const e = t.t,
                n = {
                    Paragraph: e("Paragraph"),
                    "Heading 1": e("Heading 1"),
                    "Heading 2": e("Heading 2"),
                    "Heading 3": e("Heading 3"),
                    "Heading 4": e("Heading 4"),
                    "Heading 5": e("Heading 5"),
                    "Heading 6": e("Heading 6")
                };
            return t.config.get("heading.options").map((t => {
                const e = n[t.title];
                return e && e != t.title && (t.title = e), t
            }))
        }
        var Iw = n(8733),
            Pw = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Iw.Z, Pw);
        Iw.Z.locals;
        class Rw extends Vi {
            static get pluginName() {
                return "HeadingUI"
            }
            init() {
                const t = this.editor,
                    e = t.t,
                    n = Bw(t),
                    o = e("Choose heading"),
                    i = e("Heading");
                t.ui.componentFactory.add("heading", (e => {
                    const r = {},
                        s = new xi,
                        a = t.commands.get("heading"),
                        l = t.commands.get("paragraph"),
                        c = [a];
                    for (const t of n) {
                        const e = {
                            type: "button",
                            model: new Vf({
                                label: t.title,
                                class: t.class,
                                role: "menuitemradio",
                                withText: !0
                            })
                        };
                        "paragraph" === t.model ? (e.model.bind("isOn").to(l, "value"), e.model.set("commandName", "paragraph"), c.push(l)) : (e.model.bind("isOn").to(a, "value", (e => e === t.model)), e.model.set({
                            commandName: "heading",
                            commandValue: t.model
                        })), s.add(e), r[t.model] = t.title
                    }
                    const d = Wm(e);
                    return Gm(d, s, {
                        ariaLabel: i,
                        role: "menu"
                    }), d.buttonView.set({
                        ariaLabel: i,
                        ariaLabelledBy: void 0,
                        isOn: !1,
                        withText: !0,
                        tooltip: i
                    }), d.extendTemplate({
                        attributes: {
                            class: ["ck-heading-dropdown"]
                        }
                    }), d.bind("isEnabled").toMany(c, "isEnabled", ((...t) => t.some((t => t)))), d.buttonView.bind("label").to(a, "value", l, "value", ((t, e) => {
                        const n = t || e && "paragraph";
                        return "boolean" == typeof n ? o : r[n] ? r[n] : o
                    })), this.listenTo(d, "execute", (e => {
                        const {
                            commandName: n,
                            commandValue: o
                        } = e.source;
                        t.execute(n, o ? {
                            value: o
                        } : void 0), t.editing.view.focus()
                    })), d
                }))
            }
        }
        const zw = {
            heading1: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 9v10h-2v-8h-2V9h4zM4 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H10a1 1 0 0 1-1-1V11H4v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H3a1 1 0 0 1 1 1v4.5z"/></svg>',
            heading2: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V11H3v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H2a1 1 0 0 1 1 1v4.5zm16.076 8.343V18.5h-6.252c.067-.626.27-1.22.61-1.78.338-.561 1.006-1.305 2.005-2.232.804-.749 1.297-1.257 1.479-1.523.245-.368.368-.732.368-1.092 0-.398-.107-.703-.32-.917-.214-.214-.51-.32-.886-.32-.372 0-.669.111-.889.336-.22.224-.347.596-.38 1.117l-1.778-.178c.106-.982.438-1.686.997-2.114.558-.427 1.257-.64 2.095-.64.918 0 1.64.247 2.164.742.525.495.787 1.11.787 1.847 0 .419-.075.818-.225 1.197-.15.378-.388.775-.714 1.19-.216.275-.605.67-1.168 1.187-.563.516-.92.859-1.07 1.028a3.11 3.11 0 0 0-.365.495h3.542z"/></svg>',
            heading3: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V11H3v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H2a1 1 0 0 1 1 1v4.5zm9.989 7.53 1.726-.209c.055.44.203.777.445 1.01.24.232.533.349.876.349.368 0 .678-.14.93-.42.251-.279.377-.655.377-1.13 0-.448-.12-.803-.362-1.066a1.153 1.153 0 0 0-.882-.393c-.228 0-.501.044-.819.133l.197-1.453c.482.012.85-.092 1.105-.315.253-.222.38-.517.38-.885 0-.313-.093-.563-.279-.75-.186-.185-.434-.278-.743-.278a1.07 1.07 0 0 0-.78.317c-.216.212-.347.52-.394.927l-1.644-.28c.114-.562.287-1.012.517-1.348.231-.337.553-.601.965-.794a3.24 3.24 0 0 1 1.387-.289c.876 0 1.579.28 2.108.838.436.457.653.973.653 1.549 0 .817-.446 1.468-1.339 1.955.533.114.96.37 1.28.768.319.398.478.878.478 1.441 0 .817-.298 1.513-.895 2.088-.596.576-1.339.864-2.228.864-.842 0-1.54-.243-2.094-.727-.555-.485-.876-1.118-.965-1.901z"/></svg>',
            heading4: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm13.55 10v-1.873h-3.81v-1.561l4.037-5.91h1.498v5.904h1.156v1.567h-1.156V18.5H17.05zm0-3.44v-3.18l-2.14 3.18h2.14z"/></svg>',
            heading5: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm9.578 7.607 1.777-.184c.05.402.201.72.45.955a1.223 1.223 0 0 0 1.81-.101c.258-.303.387-.759.387-1.368 0-.572-.128-1-.384-1.286-.256-.285-.59-.428-1-.428-.512 0-.971.226-1.377.679l-1.448-.21.915-4.843h4.716v1.67H15.56l-.28 1.58a2.697 2.697 0 0 1 1.219-.298 2.68 2.68 0 0 1 2.012.863c.55.576.825 1.323.825 2.241a3.36 3.36 0 0 1-.666 2.05c-.605.821-1.445 1.232-2.52 1.232-.86 0-1.56-.23-2.101-.692-.542-.461-.866-1.081-.971-1.86z"/></svg>',
            heading6: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm15.595 2.973-1.726.19c-.043-.355-.153-.617-.33-.787-.178-.169-.409-.253-.692-.253-.377 0-.695.169-.956.507-.26.339-.424 1.043-.492 2.114.445-.525.997-.787 1.657-.787.745 0 1.383.284 1.914.85.531.568.797 1.3.797 2.197 0 .952-.28 1.716-.838 2.291-.559.576-1.276.864-2.152.864-.94 0-1.712-.365-2.317-1.095-.605-.73-.908-1.927-.908-3.59 0-1.705.316-2.935.946-3.688.63-.753 1.45-1.13 2.457-1.13.706 0 1.291.198 1.755.594.463.395.758.97.885 1.723zm-4.043 3.891c0 .58.133 1.028.4 1.343.266.315.57.473.914.473.33 0 .605-.13.825-.388.22-.258.33-.68.33-1.27 0-.604-.118-1.047-.355-1.329a1.115 1.115 0 0 0-.89-.422c-.342 0-.632.134-.869.403s-.355.666-.355 1.19z"/></svg>'
        };
        class Vw extends va {
            constructor(t) {
                super(t), this.domEventType = ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"];
                const e = this.document;

                function n(t) {
                    return (n, o) => {
                        o.preventDefault();
                        const i = o.dropRange ? [o.dropRange] : null,
                            r = new h(e, t);
                        e.fire(r, {
                            dataTransfer: o.dataTransfer,
                            method: n.name,
                            targetRanges: i,
                            target: o.target,
                            domEvent: o.domEvent
                        }), r.stop.called && o.stopPropagation()
                    }
                }
                this.listenTo(e, "paste", n("clipboardInput"), {
                    priority: "low"
                }), this.listenTo(e, "drop", n("clipboardInput"), {
                    priority: "low"
                }), this.listenTo(e, "dragover", n("dragging"), {
                    priority: "low"
                })
            }
            onDomEvent(t) {
                const e = "clipboardData" in t ? t.clipboardData : t.dataTransfer,
                    n = "drop" == t.type || "paste" == t.type,
                    o = {
                        dataTransfer: new hl(e, {
                            cacheFiles: n
                        })
                    };
                "drop" != t.type && "dragover" != t.type || (o.dropRange = function(t, e) {
                    const n = e.target.ownerDocument,
                        o = e.clientX,
                        i = e.clientY;
                    let r;
                    n.caretRangeFromPoint && n.caretRangeFromPoint(o, i) ? r = n.caretRangeFromPoint(o, i) : e.rangeParent && (r = n.createRange(), r.setStart(e.rangeParent, e.rangeOffset), r.collapse(!0));
                    if (r) return t.domConverter.domRangeToView(r);
                    return null
                }(this.view, t)), this.fire(t.type, t, o)
            }
        }
        const Ow = ["figcaption", "li"];

        function Fw(t) {
            let e = "";
            if (t.is("$text") || t.is("$textProxy")) e = t.data;
            else if (t.is("element", "img") && t.hasAttribute("alt")) e = t.getAttribute("alt");
            else if (t.is("element", "br")) e = "\n";
            else {
                let n = null;
                for (const o of t.getChildren()) {
                    const t = Fw(o);
                    n && (n.is("containerElement") || o.is("containerElement")) && (Ow.includes(n.name) || Ow.includes(o.name) ? e += "\n" : e += "\n\n"), e += t, n = o
                }
            }
            return e
        }
        class Mw extends Vi {
            static get pluginName() {
                return "ClipboardPipeline"
            }
            init() {
                this.editor.editing.view.addObserver(Vw), this._setupPasteDrop(), this._setupCopyCut()
            }
            _setupPasteDrop() {
                const t = this.editor,
                    e = t.model,
                    n = t.editing.view,
                    o = n.document;
                this.listenTo(o, "clipboardInput", ((e, n) => {
                    "paste" != n.method || t.model.canEditAt(t.model.document.selection) || e.stop()
                }), {
                    priority: "highest"
                }), this.listenTo(o, "clipboardInput", ((t, e) => {
                    const o = e.dataTransfer;
                    let i;
                    if (e.content) i = e.content;
                    else {
                        let t = "";
                        o.getData("text/html") ? t = function(t) {
                            return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, ((t, e) => 1 == e.length ? " " : e)).replace(/<!--[\s\S]*?-->/g, "")
                        }(o.getData("text/html")) : o.getData("text/plain") && (((r = (r = o.getData("text/plain")).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;")).includes("</p><p>") || r.includes("<br>")) && (r = `<p>${r}</p>`), t = r), i = this.editor.data.htmlProcessor.toView(t)
                    }
                    var r;
                    const s = new h(this, "inputTransformation");
                    this.fire(s, {
                        content: i,
                        dataTransfer: o,
                        targetRanges: e.targetRanges,
                        method: e.method
                    }), s.stop.called && t.stop(), n.scrollToTheSelection()
                }), {
                    priority: "low"
                }), this.listenTo(this, "inputTransformation", ((t, n) => {
                    if (n.content.isEmpty) return;
                    const o = this.editor.data.toModel(n.content, "$clipboardHolder");
                    0 != o.childCount && (t.stop(), e.change((() => {
                        this.fire("contentInsertion", {
                            content: o,
                            method: n.method,
                            dataTransfer: n.dataTransfer,
                            targetRanges: n.targetRanges
                        })
                    })))
                }), {
                    priority: "low"
                }), this.listenTo(this, "contentInsertion", ((t, n) => {
                    n.resultRange = e.insertContent(n.content)
                }), {
                    priority: "low"
                })
            }
            _setupCopyCut() {
                const t = this.editor,
                    e = t.model.document,
                    n = t.editing.view.document,
                    o = (o, i) => {
                        const r = i.dataTransfer;
                        i.preventDefault();
                        const s = t.data.toView(t.model.getSelectedContent(e.selection));
                        n.fire("clipboardOutput", {
                            dataTransfer: r,
                            content: s,
                            method: o.name
                        })
                    };
                this.listenTo(n, "copy", o, {
                    priority: "low"
                }), this.listenTo(n, "cut", ((e, n) => {
                    t.model.canEditAt(t.model.document.selection) ? o(e, n) : n.preventDefault()
                }), {
                    priority: "low"
                }), this.listenTo(n, "clipboardOutput", ((n, o) => {
                    o.content.isEmpty || (o.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(o.content)), o.dataTransfer.setData("text/plain", Fw(o.content))), "cut" == o.method && t.model.deleteContent(e.selection)
                }), {
                    priority: "low"
                })
            }
        }
        class Nw extends(S()) {
            constructor() {
                super(...arguments), this._stack = []
            }
            add(t, e) {
                const n = this._stack,
                    o = n[0];
                this._insertDescriptor(t);
                const i = n[0];
                o === i || Lw(o, i) || this.fire("change:top", {
                    oldDescriptor: o,
                    newDescriptor: i,
                    writer: e
                })
            }
            remove(t, e) {
                const n = this._stack,
                    o = n[0];
                this._removeDescriptor(t);
                const i = n[0];
                o === i || Lw(o, i) || this.fire("change:top", {
                    oldDescriptor: o,
                    newDescriptor: i,
                    writer: e
                })
            }
            _insertDescriptor(t) {
                const e = this._stack,
                    n = e.findIndex((e => e.id === t.id));
                if (Lw(t, e[n])) return;
                n > -1 && e.splice(n, 1);
                let o = 0;
                for (; e[o] && Hw(e[o], t);) o++;
                e.splice(o, 0, t)
            }
            _removeDescriptor(t) {
                const e = this._stack,
                    n = e.findIndex((e => e.id === t));
                n > -1 && e.splice(n, 1)
            }
        }

        function Lw(t, e) {
            return t && e && t.priority == e.priority && jw(t.classes) == jw(e.classes)
        }

        function Hw(t, e) {
            return t.priority > e.priority || !(t.priority < e.priority) && jw(t.classes) > jw(e.classes)
        }

        function jw(t) {
            return Array.isArray(t) ? t.sort().join(",") : t
        }
        const qw = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>',
            Ww = "ck-widget",
            Uw = "ck-widget_selected";

        function $w(t) {
            return !!t.is("element") && !!t.getCustomProperty("widget")
        }

        function Gw(t, e, n = {}) {
            if (!t.is("containerElement")) throw new b("widget-to-widget-wrong-element-type", null, {
                element: t
            });
            return e.setAttribute("contenteditable", "false", t), e.addClass(Ww, t), e.setCustomProperty("widget", !0, t), t.getFillerOffset = tA, e.setCustomProperty("widgetLabel", [], t), n.label && function(t, e) {
                const n = t.getCustomProperty("widgetLabel");
                n.push(e)
            }(t, n.label), n.hasSelectionHandle && function(t, e) {
                const n = e.createUIElement("div", {
                    class: "ck ck-widget__selection-handle"
                }, (function(t) {
                    const e = this.toDomElement(t),
                        n = new Vg;
                    return n.set("content", qw), n.render(), e.appendChild(n.element), e
                }));
                e.insert(e.createPositionAt(t, 0), n), e.addClass(["ck-widget_with-selection-handle"], t)
            }(t, e), Jw(t, e), t
        }

        function Kw(t, e, n) {
            if (e.classes && n.addClass(Ai(e.classes), t), e.attributes)
                for (const o in e.attributes) n.setAttribute(o, e.attributes[o], t)
        }

        function Zw(t, e, n) {
            if (e.classes && n.removeClass(Ai(e.classes), t), e.attributes)
                for (const o in e.attributes) n.removeAttribute(o, t)
        }

        function Jw(t, e, n = Kw, o = Zw) {
            const i = new Nw;
            i.on("change:top", ((e, i) => {
                i.oldDescriptor && o(t, i.oldDescriptor, i.writer), i.newDescriptor && n(t, i.newDescriptor, i.writer)
            }));
            e.setCustomProperty("addHighlight", ((t, e, n) => i.add(e, n)), t), e.setCustomProperty("removeHighlight", ((t, e, n) => i.remove(e, n)), t)
        }

        function Yw(t, e, n = {}) {
            return e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t), e.setAttribute("role", "textbox", t), n.label && e.setAttribute("aria-label", n.label, t), e.setAttribute("contenteditable", t.isReadOnly ? "false" : "true", t), t.on("change:isReadOnly", ((n, o, i) => {
                e.setAttribute("contenteditable", i ? "false" : "true", t)
            })), t.on("change:isFocused", ((n, o, i) => {
                i ? e.addClass("ck-editor__nested-editable_focused", t) : e.removeClass("ck-editor__nested-editable_focused", t)
            })), Jw(t, e), t
        }

        function Qw(t, e) {
            const n = t.getSelectedElement();
            if (n) {
                const o = oA(t);
                if (o) return e.createRange(e.createPositionAt(n, o))
            }
            return Qh(t, e)
        }

        function Xw(t, e) {
            return (n, o) => {
                const {
                    mapper: i,
                    viewPosition: r
                } = o, s = i.findMappedViewAncestor(r);
                if (!e(s)) return;
                const a = i.toModelElement(s);
                o.modelPosition = t.createPositionAt(a, r.isAtStart ? "before" : "after")
            }
        }

        function tA() {
            return null
        }
        const eA = "widget-type-around";

        function nA(t, e, n) {
            return !!t && $w(t) && !n.isInline(e)
        }

        function oA(t) {
            return t.getAttribute(eA)
        }
        var iA = n(4921),
            rA = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(iA.Z, rA);
        iA.Z.locals;
        const sA = ["before", "after"],
            aA = (new DOMParser).parseFromString('<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>', "image/svg+xml").firstChild,
            lA = "ck-widget__type-around_disabled";
        class cA extends Vi {
            constructor() {
                super(...arguments), this._currentFakeCaretModelElement = null
            }
            static get pluginName() {
                return "WidgetTypeAround"
            }
            static get requires() {
                return [aw, ok]
            }
            init() {
                const t = this.editor,
                    e = t.editing.view;
                this.on("change:isEnabled", ((n, o, i) => {
                    e.change((t => {
                        for (const n of e.document.roots) i ? t.removeClass(lA, n) : t.addClass(lA, n)
                    })), i || t.model.change((t => {
                        t.removeSelectionAttribute(eA)
                    }))
                })), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableInsertObjectIntegration(), this._enableDeleteContentIntegration()
            }
            destroy() {
                super.destroy(), this._currentFakeCaretModelElement = null
            }
            _insertParagraph(t, e) {
                const n = this.editor,
                    o = n.editing.view,
                    i = n.model.schema.getAttributesWithProperty(t, "copyOnReplace", !0);
                n.execute("insertParagraph", {
                    position: n.model.createPositionAt(t, e),
                    attributes: i
                }), o.focus(), o.scrollToTheSelection()
            }
            _listenToIfEnabled(t, e, n, o) {
                this.listenTo(t, e, ((...t) => {
                    this.isEnabled && n(...t)
                }), o)
            }
            _insertParagraphAccordingToFakeCaretPosition() {
                const t = this.editor.model.document.selection,
                    e = oA(t);
                if (!e) return !1;
                const n = t.getSelectedElement();
                return this._insertParagraph(n, e), !0
            }
            _enableTypeAroundUIInjection() {
                const t = this.editor,
                    e = t.model.schema,
                    n = t.locale.t,
                    o = {
                        before: n("Insert paragraph before block"),
                        after: n("Insert paragraph after block")
                    };
                t.editing.downcastDispatcher.on("insert", ((t, i, r) => {
                    const s = r.mapper.toViewElement(i.item);
                    if (s && nA(s, i.item, e)) {
                        ! function(t, e, n) {
                            const o = t.createUIElement("div", {
                                class: "ck ck-reset_all ck-widget__type-around"
                            }, (function(t) {
                                const n = this.toDomElement(t);
                                return function(t, e) {
                                        for (const n of sA) {
                                            const o = new dg({
                                                tag: "div",
                                                attributes: {
                                                    class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${n}`],
                                                    title: e[n],
                                                    "aria-hidden": "true"
                                                },
                                                children: [t.ownerDocument.importNode(aA, !0)]
                                            });
                                            t.appendChild(o.render())
                                        }
                                    }(n, e),
                                    function(t) {
                                        const e = new dg({
                                            tag: "div",
                                            attributes: {
                                                class: ["ck", "ck-widget__type-around__fake-caret"]
                                            }
                                        });
                                        t.appendChild(e.render())
                                    }(n), n
                            }));
                            t.insert(t.createPositionAt(n, "end"), o)
                        }(r.writer, o, s);
                        s.getCustomProperty("widgetLabel").push((() => this.isEnabled ? n("Press Enter to type after or press Shift + Enter to type before the widget") : ""))
                    }
                }), {
                    priority: "low"
                })
            }
            _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
                const t = this.editor,
                    e = t.model,
                    n = e.document.selection,
                    o = e.schema,
                    i = t.editing.view;

                function r(t) {
                    return `ck-widget_type-around_show-fake-caret_${t}`
                }
                this._listenToIfEnabled(i.document, "arrowKey", ((t, e) => {
                    this._handleArrowKeyPress(t, e)
                }), {
                    context: [$w, "$text"],
                    priority: "high"
                }), this._listenToIfEnabled(n, "change:range", ((e, n) => {
                    n.directChange && t.model.change((t => {
                        t.removeSelectionAttribute(eA)
                    }))
                })), this._listenToIfEnabled(e.document, "change:data", (() => {
                    const e = n.getSelectedElement();
                    if (e) {
                        if (nA(t.editing.mapper.toViewElement(e), e, o)) return
                    }
                    t.model.change((t => {
                        t.removeSelectionAttribute(eA)
                    }))
                })), this._listenToIfEnabled(t.editing.downcastDispatcher, "selection", ((t, e, n) => {
                    const i = n.writer;
                    if (this._currentFakeCaretModelElement) {
                        const t = n.mapper.toViewElement(this._currentFakeCaretModelElement);
                        t && (i.removeClass(sA.map(r), t), this._currentFakeCaretModelElement = null)
                    }
                    const s = e.selection.getSelectedElement();
                    if (!s) return;
                    const a = n.mapper.toViewElement(s);
                    if (!nA(a, s, o)) return;
                    const l = oA(e.selection);
                    l && (i.addClass(r(l), a), this._currentFakeCaretModelElement = s)
                })), this._listenToIfEnabled(t.ui.focusTracker, "change:isFocused", ((e, n, o) => {
                    o || t.model.change((t => {
                        t.removeSelectionAttribute(eA)
                    }))
                }))
            }
            _handleArrowKeyPress(t, e) {
                const n = this.editor,
                    o = n.model,
                    i = o.document.selection,
                    r = o.schema,
                    s = n.editing.view,
                    a = function(t, e) {
                        const n = wi(t, e);
                        return "down" === n || "right" === n
                    }(e.keyCode, n.locale.contentLanguageDirection),
                    l = s.document.selection.getSelectedElement();
                let c;
                nA(l, n.editing.mapper.toModelElement(l), r) ? c = this._handleArrowKeyPressOnSelectedWidget(a) : i.isCollapsed ? c = this._handleArrowKeyPressWhenSelectionNextToAWidget(a) : e.shiftKey || (c = this._handleArrowKeyPressWhenNonCollapsedSelection(a)), c && (e.preventDefault(), t.stop())
            }
            _handleArrowKeyPressOnSelectedWidget(t) {
                const e = this.editor.model,
                    n = oA(e.document.selection);
                return e.change((e => {
                    if (!n) return e.setSelectionAttribute(eA, t ? "after" : "before"), !0;
                    if (!(n === (t ? "after" : "before"))) return e.removeSelectionAttribute(eA), !0;
                    return !1
                }))
            }
            _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
                const e = this.editor,
                    n = e.model,
                    o = n.schema,
                    i = e.plugins.get("Widget"),
                    r = i._getObjectElementNextToSelection(t);
                return !!nA(e.editing.mapper.toViewElement(r), r, o) && (n.change((e => {
                    i._setSelectionOverElement(r), e.setSelectionAttribute(eA, t ? "before" : "after")
                })), !0)
            }
            _handleArrowKeyPressWhenNonCollapsedSelection(t) {
                const e = this.editor,
                    n = e.model,
                    o = n.schema,
                    i = e.editing.mapper,
                    r = n.document.selection,
                    s = t ? r.getLastPosition().nodeBefore : r.getFirstPosition().nodeAfter;
                return !!nA(i.toViewElement(s), s, o) && (n.change((e => {
                    e.setSelection(s, "on"), e.setSelectionAttribute(eA, t ? "after" : "before")
                })), !0)
            }
            _enableInsertingParagraphsOnButtonClick() {
                const t = this.editor,
                    e = t.editing.view;
                this._listenToIfEnabled(e.document, "mousedown", ((n, o) => {
                    const i = o.domTarget.closest(".ck-widget__type-around__button");
                    if (!i) return;
                    const r = function(t) {
                            return t.classList.contains("ck-widget__type-around__button_before") ? "before" : "after"
                        }(i),
                        s = function(t, e) {
                            const n = t.closest(".ck-widget");
                            return e.mapDomToView(n)
                        }(i, e.domConverter),
                        a = t.editing.mapper.toModelElement(s);
                    this._insertParagraph(a, r), o.preventDefault(), n.stop()
                }))
            }
            _enableInsertingParagraphsOnEnterKeypress() {
                const t = this.editor,
                    e = t.model.document.selection,
                    n = t.editing.view;
                this._listenToIfEnabled(n.document, "enter", ((n, o) => {
                    if ("atTarget" != n.eventPhase) return;
                    const i = e.getSelectedElement(),
                        r = t.editing.mapper.toViewElement(i),
                        s = t.model.schema;
                    let a;
                    this._insertParagraphAccordingToFakeCaretPosition() ? a = !0 : nA(r, i, s) && (this._insertParagraph(i, o.isSoft ? "before" : "after"), a = !0), a && (o.preventDefault(), n.stop())
                }), {
                    context: $w
                })
            }
            _enableInsertingParagraphsOnTypingKeystroke() {
                const t = this.editor.editing.view.document;
                this._listenToIfEnabled(t, "insertText", ((e, n) => {
                    this._insertParagraphAccordingToFakeCaretPosition() && (n.selection = t.selection)
                }), {
                    priority: "high"
                }), i.isAndroid ? this._listenToIfEnabled(t, "keydown", ((t, e) => {
                    229 == e.keyCode && this._insertParagraphAccordingToFakeCaretPosition()
                })) : this._listenToIfEnabled(t, "compositionstart", (() => {
                    this._insertParagraphAccordingToFakeCaretPosition()
                }), {
                    priority: "high"
                })
            }
            _enableDeleteIntegration() {
                const t = this.editor,
                    e = t.editing.view,
                    n = t.model,
                    o = n.schema;
                this._listenToIfEnabled(e.document, "delete", ((e, i) => {
                    if ("atTarget" != e.eventPhase) return;
                    const r = oA(n.document.selection);
                    if (!r) return;
                    const s = i.direction,
                        a = n.document.selection.getSelectedElement(),
                        l = "forward" == s;
                    if ("before" === r === l) t.execute("delete", {
                        selection: n.createSelection(a, "on")
                    });
                    else {
                        const e = o.getNearestSelectionRange(n.createPositionAt(a, r), s);
                        if (e)
                            if (e.isCollapsed) {
                                const i = n.createSelection(e.start);
                                if (n.modifySelection(i, {
                                        direction: s
                                    }), i.focus.isEqual(e.start)) {
                                    const t = function(t, e) {
                                        let n = e;
                                        for (const o of e.getAncestors({
                                                parentFirst: !0
                                            })) {
                                            if (o.childCount > 1 || t.isLimit(o)) break;
                                            n = o
                                        }
                                        return n
                                    }(o, e.start.parent);
                                    n.deleteContent(n.createSelection(t, "on"), {
                                        doNotAutoparagraph: !0
                                    })
                                } else n.change((n => {
                                    n.setSelection(e), t.execute(l ? "deleteForward" : "delete")
                                }))
                            } else n.change((n => {
                                n.setSelection(e), t.execute(l ? "deleteForward" : "delete")
                            }))
                    }
                    i.preventDefault(), e.stop()
                }), {
                    context: $w
                })
            }
            _enableInsertContentIntegration() {
                const t = this.editor,
                    e = this.editor.model,
                    n = e.document.selection;
                this._listenToIfEnabled(t.model, "insertContent", ((t, [o, i]) => {
                    if (i && !i.is("documentSelection")) return;
                    const r = oA(n);
                    return r ? (t.stop(), e.change((t => {
                        const i = n.getSelectedElement(),
                            s = e.createPositionAt(i, r),
                            a = t.createSelection(s),
                            l = e.insertContent(o, a);
                        return t.setSelection(a), l
                    }))) : void 0
                }), {
                    priority: "high"
                })
            }
            _enableInsertObjectIntegration() {
                const t = this.editor,
                    e = this.editor.model.document.selection;
                this._listenToIfEnabled(t.model, "insertObject", ((t, n) => {
                    const [, o, i = {}] = n;
                    if (o && !o.is("documentSelection")) return;
                    const r = oA(e);
                    r && (i.findOptimalPosition = r, n[3] = i)
                }), {
                    priority: "high"
                })
            }
            _enableDeleteContentIntegration() {
                const t = this.editor,
                    e = this.editor.model.document.selection;
                this._listenToIfEnabled(t.model, "deleteContent", ((t, [n]) => {
                    if (n && !n.is("documentSelection")) return;
                    oA(e) && t.stop()
                }), {
                    priority: "high"
                })
            }
        }

        function dA(t) {
            const e = t.model;
            return (n, o) => {
                const i = o.keyCode == mi.arrowup,
                    r = o.keyCode == mi.arrowdown,
                    s = o.shiftKey,
                    a = e.document.selection;
                if (!i && !r) return;
                const l = r;
                if (s && function(t, e) {
                        return !t.isCollapsed && t.isBackward == e
                    }(a, l)) return;
                const c = function(t, e, n) {
                    const o = t.model;
                    if (n) {
                        const t = e.isCollapsed ? e.focus : e.getLastPosition(),
                            n = hA(o, t, "forward");
                        if (!n) return null;
                        const i = o.createRange(t, n),
                            r = uA(o.schema, i, "backward");
                        return r ? o.createRange(t, r) : null
                    } {
                        const t = e.isCollapsed ? e.focus : e.getFirstPosition(),
                            n = hA(o, t, "backward");
                        if (!n) return null;
                        const i = o.createRange(n, t),
                            r = uA(o.schema, i, "forward");
                        return r ? o.createRange(r, t) : null
                    }
                }(t, a, l);
                if (c) {
                    if (c.isCollapsed) {
                        if (a.isCollapsed) return;
                        if (s) return
                    }(c.isCollapsed || function(t, e, n) {
                        const o = t.model,
                            i = t.view.domConverter;
                        if (n) {
                            const t = o.createSelection(e.start);
                            o.modifySelection(t), t.focus.isAtEnd || e.start.isEqual(t.focus) || (e = o.createRange(t.focus, e.end))
                        }
                        const r = t.mapper.toViewRange(e),
                            s = i.viewRangeToDom(r),
                            a = Mo.getDomRangeRects(s);
                        let l;
                        for (const t of a)
                            if (void 0 !== l) {
                                if (Math.round(t.top) >= l) return !1;
                                l = Math.max(l, Math.round(t.bottom))
                            } else l = Math.round(t.bottom);
                        return !0
                    }(t, c, l)) && (e.change((t => {
                        const n = l ? c.end : c.start;
                        if (s) {
                            const o = e.createSelection(a.anchor);
                            o.setFocus(n), t.setSelection(o)
                        } else t.setSelection(n)
                    })), n.stop(), o.preventDefault(), o.stopPropagation())
                }
            }
        }

        function hA(t, e, n) {
            const o = t.schema,
                i = t.createRangeIn(e.root),
                r = "forward" == n ? "elementStart" : "elementEnd";
            for (const {
                    previousPosition: t,
                    item: s,
                    type: a
                }
                of i.getWalker({
                    startPosition: e,
                    direction: n
                })) {
                if (o.isLimit(s) && !o.isInline(s)) return t;
                if (a == r && o.isBlock(s)) return null
            }
            return null
        }

        function uA(t, e, n) {
            const o = "backward" == n ? e.end : e.start;
            if (t.checkChild(o, "$text")) return o;
            for (const {
                    nextPosition: o
                }
                of e.getWalker({
                    direction: n
                }))
                if (t.checkChild(o, "$text")) return o;
            return null
        }
        var gA = n(3488),
            mA = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(gA.Z, mA);
        gA.Z.locals;
        class pA extends Vi {
            constructor() {
                super(...arguments), this._previouslySelected = new Set
            }
            static get pluginName() {
                return "Widget"
            }
            static get requires() {
                return [cA, ok]
            }
            init() {
                const t = this.editor,
                    e = t.editing.view,
                    n = e.document;
                this.editor.editing.downcastDispatcher.on("selection", ((e, n, o) => {
                    const i = o.writer,
                        r = n.selection;
                    if (r.isCollapsed) return;
                    const s = r.getSelectedElement();
                    if (!s) return;
                    const a = t.editing.mapper.toViewElement(s);
                    var l;
                    $w(a) && (o.consumable.consume(r, "selection") && i.setSelection(i.createRangeOn(a), {
                        fake: !0,
                        label: (l = a, l.getCustomProperty("widgetLabel").reduce(((t, e) => "function" == typeof e ? t ? t + ". " + e() : e() : t ? t + ". " + e : e), ""))
                    }))
                })), this.editor.editing.downcastDispatcher.on("selection", ((t, e, n) => {
                    this._clearPreviouslySelectedWidgets(n.writer);
                    const o = n.writer,
                        i = o.document.selection;
                    let r = null;
                    for (const t of i.getRanges())
                        for (const e of t) {
                            const t = e.item;
                            $w(t) && !fA(t, r) && (o.addClass(Uw, t), this._previouslySelected.add(t), r = t)
                        }
                }), {
                    priority: "low"
                }), e.addObserver(lu), this.listenTo(n, "mousedown", ((...t) => this._onMousedown(...t))), this.listenTo(n, "arrowKey", ((...t) => {
                    this._handleSelectionChangeOnArrowKeyPress(...t)
                }), {
                    context: [$w, "$text"]
                }), this.listenTo(n, "arrowKey", ((...t) => {
                    this._preventDefaultOnArrowKeyPress(...t)
                }), {
                    context: "$root"
                }), this.listenTo(n, "arrowKey", dA(this.editor.editing), {
                    context: "$text"
                }), this.listenTo(n, "delete", ((t, e) => {
                    this._handleDelete("forward" == e.direction) && (e.preventDefault(), t.stop())
                }), {
                    context: "$root"
                })
            }
            _onMousedown(t, e) {
                const n = this.editor,
                    o = n.editing.view,
                    r = o.document;
                let s = e.target;
                if (function(t) {
                        let e = t;
                        for (; e;) {
                            if (e.is("editableElement") && !e.is("rootElement")) return !0;
                            if ($w(e)) return !1;
                            e = e.parent
                        }
                        return !1
                    }(s)) {
                    if ((i.isSafari || i.isGecko) && e.domEvent.detail >= 3) {
                        const t = n.editing.mapper,
                            o = s.is("attributeElement") ? s.findAncestor((t => !t.is("attributeElement"))) : s,
                            i = t.toModelElement(o);
                        e.preventDefault(), this.editor.model.change((t => {
                            t.setSelection(i, "in")
                        }))
                    }
                    return
                }
                if (!$w(s) && (s = s.findAncestor($w), !s)) return;
                i.isAndroid && e.preventDefault(), r.isFocused || o.focus();
                const a = n.editing.mapper.toModelElement(s);
                this._setSelectionOverElement(a)
            }
            _handleSelectionChangeOnArrowKeyPress(t, e) {
                const n = e.keyCode,
                    o = this.editor.model,
                    i = o.schema,
                    r = o.document.selection,
                    s = r.getSelectedElement(),
                    a = wi(n, this.editor.locale.contentLanguageDirection),
                    l = "down" == a || "right" == a,
                    c = "up" == a || "down" == a;
                if (s && i.isObject(s)) {
                    const n = l ? r.getLastPosition() : r.getFirstPosition(),
                        s = i.getNearestSelectionRange(n, l ? "forward" : "backward");
                    return void(s && (o.change((t => {
                        t.setSelection(s)
                    })), e.preventDefault(), t.stop()))
                }
                if (!r.isCollapsed && !e.shiftKey) {
                    const n = r.getFirstPosition(),
                        s = r.getLastPosition(),
                        a = n.nodeAfter,
                        c = s.nodeBefore;
                    return void((a && i.isObject(a) || c && i.isObject(c)) && (o.change((t => {
                        t.setSelection(l ? s : n)
                    })), e.preventDefault(), t.stop()))
                }
                if (!r.isCollapsed) return;
                const d = this._getObjectElementNextToSelection(l);
                if (d && i.isObject(d)) {
                    if (i.isInline(d) && c) return;
                    this._setSelectionOverElement(d), e.preventDefault(), t.stop()
                }
            }
            _preventDefaultOnArrowKeyPress(t, e) {
                const n = this.editor.model,
                    o = n.schema,
                    i = n.document.selection.getSelectedElement();
                i && o.isObject(i) && (e.preventDefault(), t.stop())
            }
            _handleDelete(t) {
                const e = this.editor.model.document.selection;
                if (!this.editor.model.canEditAt(e)) return;
                if (!e.isCollapsed) return;
                const n = this._getObjectElementNextToSelection(t);
                return n ? (this.editor.model.change((t => {
                    let o = e.anchor.parent;
                    for (; o.isEmpty;) {
                        const e = o;
                        o = e.parent, t.remove(e)
                    }
                    this._setSelectionOverElement(n)
                })), !0) : void 0
            }
            _setSelectionOverElement(t) {
                this.editor.model.change((e => {
                    e.setSelection(e.createRangeOn(t))
                }))
            }
            _getObjectElementNextToSelection(t) {
                const e = this.editor.model,
                    n = e.schema,
                    o = e.document.selection,
                    i = e.createSelection(o);
                if (e.modifySelection(i, {
                        direction: t ? "forward" : "backward"
                    }), i.isEqual(o)) return null;
                const r = t ? i.focus.nodeBefore : i.focus.nodeAfter;
                return r && n.isObject(r) ? r : null
            }
            _clearPreviouslySelectedWidgets(t) {
                for (const e of this._previouslySelected) t.removeClass(Uw, e);
                this._previouslySelected.clear()
            }
        }

        function fA(t, e) {
            return !!e && Array.from(t.getAncestors()).includes(e)
        }
        class bA extends Vi {
            constructor() {
                super(...arguments), this._toolbarDefinitions = new Map
            }
            static get requires() {
                return [jf]
            }
            static get pluginName() {
                return "WidgetToolbarRepository"
            }
            init() {
                const t = this.editor;
                if (t.plugins.has("BalloonToolbar")) {
                    const e = t.plugins.get("BalloonToolbar");
                    this.listenTo(e, "show", (e => {
                        (function(t) {
                            const e = t.getSelectedElement();
                            return !(!e || !$w(e))
                        })(t.editing.view.document.selection) && e.stop()
                    }), {
                        priority: "high"
                    })
                }
                this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", (() => {
                    this._updateToolbarsVisibility()
                })), this.listenTo(t.ui, "update", (() => {
                    this._updateToolbarsVisibility()
                })), this.listenTo(t.ui.focusTracker, "change:isFocused", (() => {
                    this._updateToolbarsVisibility()
                }), {
                    priority: "low"
                })
            }
            destroy() {
                super.destroy();
                for (const t of this._toolbarDefinitions.values()) t.view.destroy()
            }
            register(t, {
                ariaLabel: e,
                items: n,
                getRelatedElement: o,
                balloonClassName: i = "ck-toolbar-container"
            }) {
                if (!n.length) return void k("widget-toolbar-no-items", {
                    toolbarId: t
                });
                const r = this.editor,
                    s = r.t,
                    a = new Sm(r.locale);
                if (a.ariaLabel = e || s("Widget toolbar"), this._toolbarDefinitions.has(t)) throw new b("widget-toolbar-duplicated", this, {
                    toolbarId: t
                });
                const l = {
                    view: a,
                    getRelatedElement: o,
                    balloonClassName: i,
                    itemsConfig: n,
                    initialized: !1
                };
                r.ui.addToolbar(a, {
                    isContextual: !0,
                    beforeFocus: () => {
                        const t = o(r.editing.view.document.selection);
                        t && this._showToolbar(l, t)
                    },
                    afterBlur: () => {
                        this._hideToolbar(l)
                    }
                }), this._toolbarDefinitions.set(t, l)
            }
            _updateToolbarsVisibility() {
                let t = 0,
                    e = null,
                    n = null;
                for (const o of this._toolbarDefinitions.values()) {
                    const i = o.getRelatedElement(this.editor.editing.view.document.selection);
                    if (this.isEnabled && i)
                        if (this.editor.ui.focusTracker.isFocused) {
                            const r = i.getAncestors().length;
                            r > t && (t = r, e = i, n = o)
                        } else this._isToolbarVisible(o) && this._hideToolbar(o);
                    else this._isToolbarInBalloon(o) && this._hideToolbar(o)
                }
                n && this._showToolbar(n, e)
            }
            _hideToolbar(t) {
                this._balloon.remove(t.view), this.stopListening(this._balloon, "change:visibleView")
            }
            _showToolbar(t, e) {
                this._isToolbarVisible(t) ? kA(this.editor, e) : this._isToolbarInBalloon(t) || (t.initialized || (t.initialized = !0, t.view.fillFromConfig(t.itemsConfig, this.editor.ui.componentFactory)), this._balloon.add({
                    view: t.view,
                    position: wA(this.editor, e),
                    balloonClassName: t.balloonClassName
                }), this.listenTo(this._balloon, "change:visibleView", (() => {
                    for (const t of this._toolbarDefinitions.values())
                        if (this._isToolbarVisible(t)) {
                            const e = t.getRelatedElement(this.editor.editing.view.document.selection);
                            kA(this.editor, e)
                        }
                })))
            }
            _isToolbarVisible(t) {
                return this._balloon.visibleView === t.view
            }
            _isToolbarInBalloon(t) {
                return this._balloon.hasView(t.view)
            }
        }

        function kA(t, e) {
            const n = t.plugins.get("ContextualBalloon"),
                o = wA(t, e);
            n.updatePosition(o)
        }

        function wA(t, e) {
            const n = t.editing.view,
                o = Kp.defaultPositions;
            return {
                target: n.domConverter.mapViewToDom(e),
                positions: [o.northArrowSouth, o.northArrowSouthWest, o.northArrowSouthEast, o.southArrowNorth, o.southArrowNorthWest, o.southArrowNorthEast, o.viewportStickyNorth]
            }
        }
        class AA extends(q()) {
            constructor(t) {
                super(), this.set("activeHandlePosition", null), this.set("proposedWidthPercents", null), this.set("proposedWidth", null), this.set("proposedHeight", null), this.set("proposedHandleHostWidth", null), this.set("proposedHandleHostHeight", null), this._options = t, this._referenceCoordinates = null
            }
            get originalWidth() {
                return this._originalWidth
            }
            get originalHeight() {
                return this._originalHeight
            }
            get originalWidthPercents() {
                return this._originalWidthPercents
            }
            get aspectRatio() {
                return this._aspectRatio
            }
            begin(t, e, n) {
                const o = new Mo(e);
                this.activeHandlePosition = function(t) {
                    const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
                    for (const n of e)
                        if (t.classList.contains(CA(n))) return n
                }(t), this._referenceCoordinates = function(t, e) {
                    const n = new Mo(t),
                        o = e.split("-"),
                        i = {
                            x: "right" == o[1] ? n.right : n.left,
                            y: "bottom" == o[0] ? n.bottom : n.top
                        };
                    return i.x += t.ownerDocument.defaultView.scrollX, i.y += t.ownerDocument.defaultView.scrollY, i
                }(e, function(t) {
                    const e = t.split("-"),
                        n = {
                            top: "bottom",
                            bottom: "top",
                            left: "right",
                            right: "left"
                        };
                    return `${n[e[0]]}-${n[e[1]]}`
                }(this.activeHandlePosition)), this._originalWidth = o.width, this._originalHeight = o.height, this._aspectRatio = o.width / o.height;
                const i = n.style.width;
                i && i.match(/^\d+(\.\d*)?%$/) ? this._originalWidthPercents = parseFloat(i) : this._originalWidthPercents = function(t, e) {
                    const n = t.parentElement;
                    let o = parseFloat(n.ownerDocument.defaultView.getComputedStyle(n).width);
                    const i = 5;
                    let r = 0,
                        s = n;
                    for (; isNaN(o);) {
                        if (s = s.parentElement, ++r > i) return 0;
                        o = parseFloat(n.ownerDocument.defaultView.getComputedStyle(s).width)
                    }
                    return e.width / o * 100
                }(n, o)
            }
            update(t) {
                this.proposedWidth = t.width, this.proposedHeight = t.height, this.proposedWidthPercents = t.widthPercents, this.proposedHandleHostWidth = t.handleHostWidth, this.proposedHandleHostHeight = t.handleHostHeight
            }
        }

        function CA(t) {
            return `ck-widget__resizer__handle-${t}`
        }
        class _A extends cg {
            constructor() {
                super();
                const t = this.bindTemplate;
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-size-view", t.to("_viewPosition", (t => t ? `ck-orientation-${t}` : ""))],
                        style: {
                            display: t.if("_isVisible", "none", (t => !t))
                        }
                    },
                    children: [{
                        text: t.to("_label")
                    }]
                })
            }
            _bindToState(t, e) {
                this.bind("_isVisible").to(e, "proposedWidth", e, "proposedHeight", ((t, e) => null !== t && null !== e)), this.bind("_label").to(e, "proposedHandleHostWidth", e, "proposedHandleHostHeight", e, "proposedWidthPercents", ((e, n, o) => "px" === t.unit ? `${e}×${n}` : `${o}%`)), this.bind("_viewPosition").to(e, "activeHandlePosition", e, "proposedHandleHostWidth", e, "proposedHandleHostHeight", ((t, e, n) => e < 50 || n < 50 ? "above-center" : t))
            }
            _dismiss() {
                this.unbind(), this._isVisible = !1
            }
        }
        var vA = Object.defineProperty,
            yA = Object.defineProperties,
            xA = Object.getOwnPropertyDescriptors,
            EA = Object.getOwnPropertySymbols,
            DA = Object.prototype.hasOwnProperty,
            SA = Object.prototype.propertyIsEnumerable,
            TA = (t, e, n) => e in t ? vA(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n;
        class BA extends(q()) {
            constructor(t) {
                super(), this._viewResizerWrapper = null, this._options = t, this.set("isEnabled", !0), this.set("isSelected", !1), this.bind("isVisible").to(this, "isEnabled", this, "isSelected", ((t, e) => t && e)), this.decorate("begin"), this.decorate("cancel"), this.decorate("commit"), this.decorate("updateSize"), this.on("commit", (t => {
                    this.state.proposedWidth || this.state.proposedWidthPercents || (this._cleanup(), t.stop())
                }), {
                    priority: "high"
                })
            }
            get state() {
                return this._state
            }
            show() {
                this._options.editor.editing.view.change((t => {
                    t.removeClass("ck-hidden", this._viewResizerWrapper)
                }))
            }
            hide() {
                this._options.editor.editing.view.change((t => {
                    t.addClass("ck-hidden", this._viewResizerWrapper)
                }))
            }
            attach() {
                const t = this,
                    e = this._options.viewElement;
                this._options.editor.editing.view.change((n => {
                    const o = n.createUIElement("div", {
                        class: "ck ck-reset_all ck-widget__resizer"
                    }, (function(e) {
                        const n = this.toDomElement(e);
                        return t._appendHandles(n), t._appendSizeUI(n), n
                    }));
                    n.insert(n.createPositionAt(e, "end"), o), n.addClass("ck-widget_with-resizer", e), this._viewResizerWrapper = o, this.isVisible || this.hide()
                })), this.on("change:isVisible", (() => {
                    this.isVisible ? (this.show(), this.redraw()) : this.hide()
                }))
            }
            begin(t) {
                this._state = new AA(this._options), this._sizeView._bindToState(this._options, this.state), this._initialViewWidth = this._options.viewElement.getStyle("width"), this.state.begin(t, this._getHandleHost(), this._getResizeHost())
            }
            updateSize(t) {
                const e = this._proposeNewSize(t);
                this._options.editor.editing.view.change((t => {
                    const n = this._options.unit || "%",
                        o = ("%" === n ? e.widthPercents : e.width) + n;
                    t.setStyle("width", o, this._options.viewElement)
                }));
                const n = this._getHandleHost(),
                    o = new Mo(n),
                    i = Math.round(o.width),
                    r = Math.round(o.height),
                    s = new Mo(n);
                var a;
                e.width = Math.round(s.width), e.height = Math.round(s.height), this.redraw(o), this.state.update((a = ((t, e) => {
                    for (var n in e || (e = {})) DA.call(e, n) && TA(t, n, e[n]);
                    if (EA)
                        for (var n of EA(e)) SA.call(e, n) && TA(t, n, e[n]);
                    return t
                })({}, e), yA(a, xA({
                    handleHostWidth: i,
                    handleHostHeight: r
                }))))
            }
            commit() {
                const t = this._options.unit || "%",
                    e = ("%" === t ? this.state.proposedWidthPercents : this.state.proposedWidth) + t;
                this._options.editor.editing.view.change((() => {
                    this._cleanup(), this._options.onCommit(e)
                }))
            }
            cancel() {
                this._cleanup()
            }
            destroy() {
                this.cancel()
            }
            redraw(t) {
                const e = this._domResizerWrapper;
                if (!((n = e) && n.ownerDocument && n.ownerDocument.contains(n))) return;
                var n;
                const o = e.parentElement,
                    i = this._getHandleHost(),
                    r = this._viewResizerWrapper,
                    s = [r.getStyle("width"), r.getStyle("height"), r.getStyle("left"), r.getStyle("top")];
                let a;
                if (o.isSameNode(i)) {
                    const e = t || new Mo(i);
                    a = [e.width + "px", e.height + "px", void 0, void 0]
                } else a = [i.offsetWidth + "px", i.offsetHeight + "px", i.offsetLeft + "px", i.offsetTop + "px"];
                "same" !== Y(s, a) && this._options.editor.editing.view.change((t => {
                    t.setStyle({
                        width: a[0],
                        height: a[1],
                        left: a[2],
                        top: a[3]
                    }, r)
                }))
            }
            containsHandle(t) {
                return this._domResizerWrapper.contains(t)
            }
            static isResizeHandle(t) {
                return t.classList.contains("ck-widget__resizer__handle")
            }
            _cleanup() {
                this._sizeView._dismiss();
                this._options.editor.editing.view.change((t => {
                    t.setStyle("width", this._initialViewWidth, this._options.viewElement)
                }))
            }
            _proposeNewSize(t) {
                const e = this.state,
                    n = {
                        x: (o = t).pageX,
                        y: o.pageY
                    };
                var o;
                const i = !this._options.isCentered || this._options.isCentered(this),
                    r = {
                        x: e._referenceCoordinates.x - (n.x + e.originalWidth),
                        y: n.y - e.originalHeight - e._referenceCoordinates.y
                    };
                i && e.activeHandlePosition.endsWith("-right") && (r.x = n.x - (e._referenceCoordinates.x + e.originalWidth)), i && (r.x *= 2);
                let s = Math.abs(e.originalWidth + r.x),
                    a = Math.abs(e.originalHeight + r.y);
                return "width" == (s / e.aspectRatio > a ? "width" : "height") ? a = s / e.aspectRatio : s = a * e.aspectRatio, {
                    width: Math.round(s),
                    height: Math.round(a),
                    widthPercents: Math.min(Math.round(e.originalWidthPercents / e.originalWidth * s * 100) / 100, 100)
                }
            }
            _getResizeHost() {
                const t = this._domResizerWrapper.parentElement;
                return this._options.getResizeHost(t)
            }
            _getHandleHost() {
                const t = this._domResizerWrapper.parentElement;
                return this._options.getHandleHost(t)
            }
            get _domResizerWrapper() {
                return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper)
            }
            _appendHandles(t) {
                const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
                for (const o of e) t.appendChild(new dg({
                    tag: "div",
                    attributes: {
                        class: "ck-widget__resizer__handle " + (n = o, `ck-widget__resizer__handle-${n}`)
                    }
                }).render());
                var n
            }
            _appendSizeUI(t) {
                this._sizeView = new _A, this._sizeView.render(), t.appendChild(this._sizeView.element)
            }
        }
        var IA = n(8506),
            PA = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(IA.Z, PA);
        IA.Z.locals;
        class RA extends Vi {
            constructor() {
                super(...arguments), this._resizers = new Map
            }
            static get pluginName() {
                return "WidgetResize"
            }
            init() {
                const t = this.editor.editing,
                    e = Po.window.document;
                this.set("selectedResizer", null), this.set("_activeResizer", null), t.view.addObserver(lu), this._observer = new(So()), this.listenTo(t.view.document, "mousedown", this._mouseDownListener.bind(this), {
                    priority: "high"
                }), this._observer.listenTo(e, "mousemove", this._mouseMoveListener.bind(this)), this._observer.listenTo(e, "mouseup", this._mouseUpListener.bind(this)), this._redrawSelectedResizerThrottled = of((() => this.redrawSelectedResizer()), 200), this.editor.ui.on("update", this._redrawSelectedResizerThrottled), this.editor.model.document.on("change", (() => {
                    for (const [t, e] of this._resizers) t.isAttached() || (this._resizers.delete(t), e.destroy())
                }), {
                    priority: "lowest"
                }), this._observer.listenTo(Po.window, "resize", this._redrawSelectedResizerThrottled);
                const n = this.editor.editing.view.document.selection;
                n.on("change", (() => {
                    const t = n.getSelectedElement(),
                        e = this.getResizerByViewElement(t) || null;
                    e ? this.select(e) : this.deselect()
                }))
            }
            redrawSelectedResizer() {
                this.selectedResizer && this.selectedResizer.isVisible && this.selectedResizer.redraw()
            }
            destroy() {
                super.destroy(), this._observer.stopListening();
                for (const t of this._resizers.values()) t.destroy();
                this._redrawSelectedResizerThrottled.cancel()
            }
            select(t) {
                this.deselect(), this.selectedResizer = t, this.selectedResizer.isSelected = !0
            }
            deselect() {
                this.selectedResizer && (this.selectedResizer.isSelected = !1), this.selectedResizer = null
            }
            attachTo(t) {
                const e = new BA(t),
                    n = this.editor.plugins;
                if (e.attach(), n.has("WidgetToolbarRepository")) {
                    const t = n.get("WidgetToolbarRepository");
                    e.on("begin", (() => {
                        t.forceDisabled("resize")
                    }), {
                        priority: "lowest"
                    }), e.on("cancel", (() => {
                        t.clearForceDisabled("resize")
                    }), {
                        priority: "highest"
                    }), e.on("commit", (() => {
                        t.clearForceDisabled("resize")
                    }), {
                        priority: "highest"
                    })
                }
                this._resizers.set(t.viewElement, e);
                const o = this.editor.editing.view.document.selection.getSelectedElement();
                return this.getResizerByViewElement(o) == e && this.select(e), e
            }
            getResizerByViewElement(t) {
                return this._resizers.get(t)
            }
            _getResizerByHandle(t) {
                for (const e of this._resizers.values())
                    if (e.containsHandle(t)) return e
            }
            _mouseDownListener(t, e) {
                const n = e.domTarget;
                BA.isResizeHandle(n) && (this._activeResizer = this._getResizerByHandle(n) || null, this._activeResizer && (this._activeResizer.begin(n), t.stop(), e.preventDefault()))
            }
            _mouseMoveListener(t, e) {
                this._activeResizer && this._activeResizer.updateSize(e)
            }
            _mouseUpListener() {
                this._activeResizer && (this._activeResizer.commit(), this._activeResizer = null)
            }
        }
        var zA = n(903),
            VA = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(zA.Z, VA);
        zA.Z.locals;
        class OA extends Vi {
            static get pluginName() {
                return "DragDrop"
            }
            static get requires() {
                return [Mw, pA]
            }
            init() {
                const t = this.editor,
                    e = t.editing.view;
                this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, this._updateDropMarkerThrottled = of((t => this._updateDropMarker(t)), 40), this._removeDropMarkerDelayed = Bi((() => this._removeDropMarker()), 40), this._clearDraggableAttributesDelayed = Bi((() => this._clearDraggableAttributes()), 40), t.plugins.has("DragDropExperimental") ? this.forceDisabled("DragDropExperimental") : (e.addObserver(Vw), e.addObserver(lu), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDropMarker(), this._setupDraggableAttributeHandling(), this.listenTo(t, "change:isReadOnly", ((t, e, n) => {
                    n ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode")
                })), this.on("change:isEnabled", ((t, e, n) => {
                    n || this._finalizeDragging(!1)
                })), i.isAndroid && this.forceDisabled("noAndroidSupport"))
            }
            destroy() {
                return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._updateDropMarkerThrottled.cancel(), this._removeDropMarkerDelayed.cancel(), this._clearDraggableAttributesDelayed.cancel(), super.destroy()
            }
            _setupDragging() {
                const t = this.editor,
                    e = t.model,
                    n = e.document,
                    o = t.editing.view,
                    r = o.document;
                this.listenTo(r, "dragstart", ((o, i) => {
                    const s = n.selection;
                    if (i.target && i.target.is("editableElement")) return void i.preventDefault();
                    const a = i.target ? NA(i.target) : null;
                    if (a) {
                        const n = t.editing.mapper.toModelElement(a);
                        if (this._draggedRange = ec.fromRange(e.createRangeOn(n)), t.plugins.has("WidgetToolbarRepository")) {
                            t.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop")
                        }
                    } else if (!r.selection.isCollapsed) {
                        const t = r.selection.getSelectedElement();
                        t && $w(t) || (this._draggedRange = ec.fromRange(s.getFirstRange()))
                    }
                    if (!this._draggedRange) return void i.preventDefault();
                    this._draggingUid = g();
                    const l = this.isEnabled && t.model.canEditAt(this._draggedRange);
                    i.dataTransfer.effectAllowed = l ? "copyMove" : "copy", i.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
                    const c = e.createSelection(this._draggedRange.toRange()),
                        d = t.data.toView(e.getSelectedContent(c));
                    r.fire("clipboardOutput", {
                        dataTransfer: i.dataTransfer,
                        content: d,
                        method: "dragstart"
                    }), l || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "")
                }), {
                    priority: "low"
                }), this.listenTo(r, "dragend", ((t, e) => {
                    this._finalizeDragging(!e.dataTransfer.isCanceled && "move" == e.dataTransfer.dropEffect)
                }), {
                    priority: "low"
                }), this.listenTo(r, "dragenter", (() => {
                    this.isEnabled && o.focus()
                })), this.listenTo(r, "dragleave", (() => {
                    this._removeDropMarkerDelayed()
                })), this.listenTo(r, "dragging", ((e, n) => {
                    if (!this.isEnabled) return void(n.dataTransfer.dropEffect = "none");
                    this._removeDropMarkerDelayed.cancel();
                    const o = FA(t, n.targetRanges, n.target);
                    t.model.canEditAt(o) ? (this._draggedRange || (n.dataTransfer.dropEffect = "copy"), i.isGecko || ("copy" == n.dataTransfer.effectAllowed ? n.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(n.dataTransfer.effectAllowed) && (n.dataTransfer.dropEffect = "move")), o && this._updateDropMarkerThrottled(o)) : n.dataTransfer.dropEffect = "none"
                }), {
                    priority: "low"
                })
            }
            _setupClipboardInputIntegration() {
                const t = this.editor,
                    e = t.editing.view.document;
                this.listenTo(e, "clipboardInput", ((e, n) => {
                    if ("drop" != n.method) return;
                    const o = FA(t, n.targetRanges, n.target);
                    if (this._removeDropMarker(), !o || !t.model.canEditAt(o)) return this._finalizeDragging(!1), void e.stop();
                    this._draggedRange && this._draggingUid != n.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
                    if ("move" == MA(n.dataTransfer) && this._draggedRange && this._draggedRange.containsRange(o, !0)) return this._finalizeDragging(!1), void e.stop();
                    n.targetRanges = [t.editing.mapper.toViewRange(o)]
                }), {
                    priority: "high"
                })
            }
            _setupContentInsertionIntegration() {
                const t = this.editor.plugins.get(Mw);
                t.on("contentInsertion", ((t, e) => {
                    if (!this.isEnabled || "drop" !== e.method) return;
                    const n = e.targetRanges.map((t => this.editor.editing.mapper.toModelRange(t)));
                    this.editor.model.change((t => t.setSelection(n)))
                }), {
                    priority: "high"
                }), t.on("contentInsertion", ((t, e) => {
                    if (!this.isEnabled || "drop" !== e.method) return;
                    const n = "move" == MA(e.dataTransfer),
                        o = !e.resultRange || !e.resultRange.isCollapsed;
                    this._finalizeDragging(o && n)
                }), {
                    priority: "lowest"
                })
            }
            _setupDraggableAttributeHandling() {
                const t = this.editor,
                    e = t.editing.view,
                    n = e.document;
                this.listenTo(n, "mousedown", ((o, r) => {
                    if (i.isAndroid || !r) return;
                    this._clearDraggableAttributesDelayed.cancel();
                    let s = NA(r.target);
                    if (i.isBlink && !s && !n.selection.isCollapsed) {
                        const t = n.selection.getSelectedElement();
                        if (!t || !$w(t)) {
                            const t = n.selection.editableElement;
                            t && !t.isReadOnly && (s = t)
                        }
                    }
                    s && (e.change((t => {
                        t.setAttribute("draggable", "true", s)
                    })), this._draggableElement = t.editing.mapper.toModelElement(s))
                })), this.listenTo(n, "mouseup", (() => {
                    i.isAndroid || this._clearDraggableAttributesDelayed()
                }))
            }
            _clearDraggableAttributes() {
                const t = this.editor.editing;
                t.view.change((e => {
                    this._draggableElement && "$graveyard" != this._draggableElement.root.rootName && e.removeAttribute("draggable", t.mapper.toViewElement(this._draggableElement)), this._draggableElement = null
                }))
            }
            _setupDropMarker() {
                const t = this.editor;
                t.conversion.for("editingDowncast").markerToHighlight({
                    model: "drop-target",
                    view: {
                        classes: ["ck-clipboard-drop-target-range"]
                    }
                }), t.conversion.for("editingDowncast").markerToElement({
                    model: "drop-target",
                    view: (e, {
                        writer: n
                    }) => {
                        if (t.model.schema.checkChild(e.markerRange.start, "$text")) return n.createUIElement("span", {
                            class: "ck ck-clipboard-drop-target-position"
                        }, (function(t) {
                            const e = this.toDomElement(t);
                            return e.append("⁠", t.createElement("span"), "⁠"), e
                        }))
                    }
                })
            }
            _updateDropMarker(t) {
                const e = this.editor,
                    n = e.model.markers;
                e.model.change((e => {
                    n.has("drop-target") ? n.get("drop-target").getRange().isEqual(t) || e.updateMarker("drop-target", {
                        range: t
                    }) : e.addMarker("drop-target", {
                        range: t,
                        usingOperation: !1,
                        affectsData: !1
                    })
                }))
            }
            _removeDropMarker() {
                const t = this.editor.model;
                this._removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), t.markers.has("drop-target") && t.change((t => {
                    t.removeMarker("drop-target")
                }))
            }
            _finalizeDragging(t) {
                const e = this.editor,
                    n = e.model;
                if (this._removeDropMarker(), this._clearDraggableAttributes(), e.plugins.has("WidgetToolbarRepository")) {
                    e.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop")
                }
                this._draggingUid = "", this._draggedRange && (t && this.isEnabled && n.deleteContent(n.createSelection(this._draggedRange), {
                    doNotAutoparagraph: !0
                }), this._draggedRange.detach(), this._draggedRange = null)
            }
        }

        function FA(t, e, n) {
            const o = t.model,
                r = t.editing.mapper;
            let s = null;
            const a = e ? e[0].start : null;
            if (n.is("uiElement") && (n = n.parent), s = function(t, e) {
                    const n = t.model,
                        o = t.editing.mapper;
                    if ($w(e)) return n.createRangeOn(o.toModelElement(e));
                    if (!e.is("editableElement")) {
                        const t = e.findAncestor((t => $w(t) || t.is("editableElement")));
                        if ($w(t)) return n.createRangeOn(o.toModelElement(t))
                    }
                    return null
                }(t, n), s) return s;
            const l = function(t, e) {
                    const n = t.editing.mapper,
                        o = t.editing.view,
                        i = n.toModelElement(e);
                    if (i) return i;
                    const r = o.createPositionBefore(e),
                        s = n.findMappedViewAncestor(r);
                    return n.toModelElement(s)
                }(t, n),
                c = a ? r.toModelPosition(a) : null;
            return c ? (s = function(t, e, n) {
                const o = t.model;
                if (!o.schema.checkChild(n, "$block")) return null;
                const i = o.createPositionAt(n, 0),
                    r = e.path.slice(0, i.path.length),
                    s = o.createPositionFromPath(e.root, r),
                    a = s.nodeAfter;
                if (a && o.schema.isObject(a)) return o.createRangeOn(a);
                return null
            }(t, c, l), s || (s = o.schema.getNearestSelectionRange(c, i.isGecko ? "forward" : "backward"), s || function(t, e) {
                const n = t.model;
                let o = e;
                for (; o;) {
                    if (n.schema.isObject(o)) return n.createRangeOn(o);
                    o = o.parent
                }
                return null
            }(t, c.parent))) : function(t, e) {
                const n = t.model,
                    o = n.schema,
                    i = n.createPositionAt(e, 0);
                return o.getNearestSelectionRange(i, "forward")
            }(t, l)
        }

        function MA(t) {
            return i.isGecko ? t.dropEffect : ["all", "copyMove"].includes(t.effectAllowed) ? "move" : "copy"
        }

        function NA(t) {
            if (t.is("editableElement")) return null;
            if (t.hasClass("ck-widget__selection-handle")) return t.findAncestor($w);
            if ($w(t)) return t;
            const e = t.findAncestor((t => $w(t) || t.is("editableElement")));
            return $w(e) ? e : null
        }
        class LA extends Vi {
            static get pluginName() {
                return "PastePlainText"
            }
            static get requires() {
                return [Mw]
            }
            init() {
                const t = this.editor,
                    e = t.model,
                    n = t.editing.view,
                    o = n.document,
                    i = e.document.selection;
                let r = !1;
                n.addObserver(Vw), this.listenTo(o, "keydown", ((t, e) => {
                    r = e.shiftKey
                })), t.plugins.get(Mw).on("contentInsertion", ((t, n) => {
                    (r || function(t, e) {
                        if (t.childCount > 1) return !1;
                        const n = t.getChild(0);
                        if (e.isObject(n)) return !1;
                        return 0 == Array.from(n.getAttributeKeys()).length
                    }(n.content, e.schema)) && e.change((t => {
                        const o = Array.from(i.getAttributes()).filter((([t]) => e.schema.getAttributeProperties(t).isFormatting));
                        i.isCollapsed || e.deleteContent(i, {
                            doNotAutoparagraph: !0
                        }), o.push(...i.getAttributes());
                        const r = t.createRangeIn(n.content);
                        for (const e of r.getItems()) e.is("$textProxy") && t.setAttributes(o, e)
                    }))
                }))
            }
        }
        class HA extends Vi {
            static get pluginName() {
                return "Clipboard"
            }
            static get requires() {
                return [Mw, OA, LA]
            }
        }
        $o("px");
        Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable;
        var jA = Object.defineProperty,
            qA = Object.getOwnPropertySymbols,
            WA = Object.prototype.hasOwnProperty,
            UA = Object.prototype.propertyIsEnumerable,
            $A = (t, e, n) => e in t ? jA(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n;
        class GA extends Fi {
            constructor(t) {
                super(t), this._stack = [], this._createdBatches = new WeakSet, this.refresh(), this._isEnabledBasedOnSelection = !1, this.listenTo(t.data, "set", ((t, e) => {
                    e[1] = ((t, e) => {
                        for (var n in e || (e = {})) WA.call(e, n) && $A(t, n, e[n]);
                        if (qA)
                            for (var n of qA(e)) UA.call(e, n) && $A(t, n, e[n]);
                        return t
                    })({}, e[1]);
                    const n = e[1];
                    n.batchType || (n.batchType = {
                        isUndoable: !1
                    })
                }), {
                    priority: "high"
                }), this.listenTo(t.data, "set", ((t, e) => {
                    e[1].batchType.isUndoable || this.clearStack()
                }))
            }
            refresh() {
                this.isEnabled = this._stack.length > 0
            }
            get createdBatches() {
                return this._createdBatches
            }
            addBatch(t) {
                const e = this.editor.model.document.selection,
                    n = {
                        ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [],
                        isBackward: e.isBackward
                    };
                this._stack.push({
                    batch: t,
                    selection: n
                }), this.refresh()
            }
            clearStack() {
                this._stack = [], this.refresh()
            }
            _restoreSelection(t, e, n) {
                const o = this.editor.model,
                    i = o.document,
                    r = [],
                    s = t.map((t => t.getTransformedByOperations(n))),
                    a = s.flat();
                for (const t of s) {
                    const e = t.filter((t => t.root != i.graveyard)).filter((t => !ZA(t, a)));
                    e.length && (KA(e), r.push(e[0]))
                }
                r.length && o.change((t => {
                    t.setSelection(r, {
                        backward: e
                    })
                }))
            }
            _undo(t, e) {
                const n = this.editor.model,
                    o = n.document;
                this._createdBatches.add(e);
                const i = t.operations.slice().filter((t => t.isDocumentOperation));
                i.reverse();
                for (const t of i) {
                    const i = t.baseVersion + 1,
                        r = Array.from(o.history.getOperations(i)),
                        s = Gd([t.getReversed()], r, {
                            useRelations: !0,
                            document: this.editor.model.document,
                            padWithNoOps: !1,
                            forceWeakRemove: !0
                        }).operationsA;
                    for (let i of s) {
                        const r = i.affectedSelectable;
                        r && !n.canEditAt(r) && (i = new Fd(i.baseVersion)), e.addOperation(i), n.applyOperation(i), o.history.setOperationAsUndone(t, i)
                    }
                }
            }
        }

        function KA(t) {
            t.sort(((t, e) => t.start.isBefore(e.start) ? -1 : 1));
            for (let e = 1; e < t.length; e++) {
                const n = t[e - 1].getJoined(t[e], !0);
                n && (e--, t.splice(e, 2, n))
            }
        }

        function ZA(t, e) {
            return e.some((e => e !== t && e.containsRange(t, !0)))
        }
        class JA extends GA {
            execute(t = null) {
                const e = t ? this._stack.findIndex((e => e.batch == t)) : this._stack.length - 1,
                    n = this._stack.splice(e, 1)[0],
                    o = this.editor.model.createBatch({
                        isUndo: !0
                    });
                this.editor.model.enqueueChange(o, (() => {
                    this._undo(n.batch, o);
                    const t = this.editor.model.document.history.getOperations(n.batch.baseVersion);
                    this._restoreSelection(n.selection.ranges, n.selection.isBackward, t), this.fire("revert", n.batch, o)
                })), this.refresh()
            }
        }
        class YA extends GA {
            execute() {
                const t = this._stack.pop(),
                    e = this.editor.model.createBatch({
                        isUndo: !0
                    });
                this.editor.model.enqueueChange(e, (() => {
                    const n = t.batch.operations[t.batch.operations.length - 1].baseVersion + 1,
                        o = this.editor.model.document.history.getOperations(n);
                    this._restoreSelection(t.selection.ranges, t.selection.isBackward, o), this._undo(t.batch, e)
                })), this.refresh()
            }
        }
        class QA extends Vi {
            constructor() {
                super(...arguments), this._batchRegistry = new WeakSet
            }
            static get pluginName() {
                return "UndoEditing"
            }
            init() {
                const t = this.editor;
                this._undoCommand = new JA(t), this._redoCommand = new YA(t), t.commands.add("undo", this._undoCommand), t.commands.add("redo", this._redoCommand), this.listenTo(t.model, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (!n.isDocumentOperation) return;
                    const o = n.batch,
                        i = this._redoCommand.createdBatches.has(o),
                        r = this._undoCommand.createdBatches.has(o);
                    this._batchRegistry.has(o) || (this._batchRegistry.add(o), o.isUndoable && (i ? this._undoCommand.addBatch(o) : r || (this._undoCommand.addBatch(o), this._redoCommand.clearStack())))
                }), {
                    priority: "highest"
                }), this.listenTo(this._undoCommand, "revert", ((t, e, n) => {
                    this._redoCommand.addBatch(n)
                })), t.keystrokes.set("CTRL+Z", "undo"), t.keystrokes.set("CTRL+Y", "redo"), t.keystrokes.set("CTRL+SHIFT+Z", "redo")
            }
        }
        const XA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>',
            tC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
        class eC extends Vi {
            static get pluginName() {
                return "UndoUI"
            }
            init() {
                const t = this.editor,
                    e = t.locale,
                    n = t.t,
                    o = "ltr" == e.uiLanguageDirection ? XA : tC,
                    i = "ltr" == e.uiLanguageDirection ? tC : XA;
                this._addButton("undo", n("Undo"), "CTRL+Z", o), this._addButton("redo", n("Redo"), "CTRL+Y", i)
            }
            _addButton(t, e, n, o) {
                const i = this.editor;
                i.ui.componentFactory.add(t, (r => {
                    const s = i.commands.get(t),
                        a = new Mg(r);
                    return a.set({
                        label: e,
                        icon: o,
                        keystroke: n,
                        tooltip: !0
                    }), a.bind("isEnabled").to(s, "isEnabled"), this.listenTo(a, "execute", (() => {
                        i.execute(t), i.editing.view.focus()
                    })), a
                }))
            }
        }
        class nC extends Vi {
            static get requires() {
                return [QA, eC]
            }
            static get pluginName() {
                return "Undo"
            }
        }

        function oC(t) {
            return t.createContainerElement("figure", {
                class: "image"
            }, [t.createEmptyElement("img"), t.createSlot("children")])
        }

        function iC(t, e) {
            const n = t.plugins.get("ImageUtils"),
                o = t.plugins.has("ImageInlineEditing") && t.plugins.has("ImageBlockEditing");
            return t => {
                if (!n.isInlineImageView(t)) return null;
                if (!o) return i(t);
                return ("block" == t.getStyle("display") || t.findAncestor(n.isBlockImageView) ? "imageBlock" : "imageInline") !== e ? null : i(t)
            };

            function i(t) {
                const e = {
                    name: !0
                };
                return t.hasAttribute("src") && (e.attributes = ["src"]), e
            }
        }

        function rC(t, e) {
            const n = Ei(e.getSelectedBlocks());
            return !n || t.isObject(n) || n.isEmpty && "listItem" != n.name ? "imageBlock" : "imageInline"
        }
        var sC = Object.defineProperty,
            aC = Object.getOwnPropertySymbols,
            lC = Object.prototype.hasOwnProperty,
            cC = Object.prototype.propertyIsEnumerable,
            dC = (t, e, n) => e in t ? sC(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n,
            hC = (t, e) => {
                for (var n in e || (e = {})) lC.call(e, n) && dC(t, n, e[n]);
                if (aC)
                    for (var n of aC(e)) cC.call(e, n) && dC(t, n, e[n]);
                return t
            };
        class uC extends Vi {
            static get pluginName() {
                return "ImageUtils"
            }
            isImage(t) {
                return this.isInlineImage(t) || this.isBlockImage(t)
            }
            isInlineImageView(t) {
                return !!t && t.is("element", "img")
            }
            isBlockImageView(t) {
                return !!t && t.is("element", "figure") && t.hasClass("image")
            }
            insertImage(t = {}, e = null, n = null) {
                const o = this.editor,
                    i = o.model,
                    r = i.document.selection;
                n = gC(o, e || r, n), t = hC(hC({}, Object.fromEntries(r.getAttributes())), t);
                for (const e in t) i.schema.checkAttribute(n, e) || delete t[e];
                return i.change((o => {
                    const r = o.createElement(n, t);
                    return i.insertObject(r, e, null, {
                        setSelection: "on",
                        findOptimalPosition: e || "imageInline" == n ? void 0 : "auto"
                    }), r.parent ? r : null
                }))
            }
            getClosestSelectedImageWidget(t) {
                const e = t.getFirstPosition();
                if (!e) return null;
                const n = t.getSelectedElement();
                if (n && this.isImageWidget(n)) return n;
                let o = e.parent;
                for (; o;) {
                    if (o.is("element") && this.isImageWidget(o)) return o;
                    o = o.parent
                }
                return null
            }
            getClosestSelectedImageElement(t) {
                const e = t.getSelectedElement();
                return this.isImage(e) ? e : t.getFirstPosition().findAncestor("imageBlock")
            }
            isImageAllowed() {
                const t = this.editor.model.document.selection;
                return function(t, e) {
                    const n = gC(t, e, null);
                    if ("imageBlock" == n) {
                        const n = function(t, e) {
                            const n = Qw(t, e),
                                o = n.start.parent;
                            if (o.isEmpty && !o.is("element", "$root")) return o.parent;
                            return o
                        }(e, t.model);
                        if (t.model.schema.checkChild(n, "imageBlock")) return !0
                    } else if (t.model.schema.checkChild(e.focus, "imageInline")) return !0;
                    return !1
                }(this.editor, t) && function(t) {
                    return [...t.focus.getAncestors()].every((t => !t.is("element", "imageBlock")))
                }(t)
            }
            toImageWidget(t, e, n) {
                e.setCustomProperty("image", !0, t);
                return Gw(t, e, {
                    label: () => {
                        const e = this.findViewImgElement(t).getAttribute("alt");
                        return e ? `${e} ${n}` : n
                    }
                })
            }
            isImageWidget(t) {
                return !!t.getCustomProperty("image") && $w(t)
            }
            isBlockImage(t) {
                return !!t && t.is("element", "imageBlock")
            }
            isInlineImage(t) {
                return !!t && t.is("element", "imageInline")
            }
            findViewImgElement(t) {
                if (this.isInlineImageView(t)) return t;
                const e = this.editor.editing.view;
                for (const {
                        item: n
                    }
                    of e.createRangeIn(t))
                    if (this.isInlineImageView(n)) return n
            }
        }

        function gC(t, e, n) {
            const o = t.model.schema,
                i = t.config.get("image.insert.type");
            return t.plugins.has("ImageBlockEditing") ? t.plugins.has("ImageInlineEditing") ? n || ("inline" === i ? "imageInline" : "block" === i ? "imageBlock" : e.is("selection") ? rC(o, e) : o.checkChild(e, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline"
        }
        Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable;
        new RegExp(String(/^(http(s)?:\/\/)?[\w-]+\.[\w.~:/[\]@!$&'()*+,;=%-]+/.source + /\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/.source + /(\?[\w.~:/[\]@!$&'()*+,;=%-]*)?/.source + /(#[\w.~:/[\]@!$&'()*+,;=%-]*)?$/.source));
        class mC extends Fi {
            refresh() {
                const t = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
                this.isEnabled = !!t, this.isEnabled && t.hasAttribute("alt") ? this.value = t.getAttribute("alt") : this.value = !1
            }
            execute(t) {
                const e = this.editor,
                    n = e.plugins.get("ImageUtils"),
                    o = e.model,
                    i = n.getClosestSelectedImageElement(o.document.selection);
                o.change((e => {
                    e.setAttribute("alt", t.newValue, i)
                }))
            }
        }
        class pC extends Vi {
            static get requires() {
                return [uC]
            }
            static get pluginName() {
                return "ImageTextAlternativeEditing"
            }
            init() {
                this.editor.commands.add("imageTextAlternative", new mC(this.editor))
            }
        }
        var fC = n(1905),
            bC = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(fC.Z, bC);
        fC.Z.locals;
        class kC extends cg {
            constructor(t) {
                super(t);
                const e = this.locale.t;
                this.focusTracker = new Di, this.keystrokes = new Si, this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(e("Save"), eg.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(e("Cancel"), eg.cancel, "ck-button-cancel", "cancel"), this._focusables = new sg, this._focusCycler = new wm({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "shift + tab",
                        focusNext: "tab"
                    }
                }), this.setTemplate({
                    tag: "form",
                    attributes: {
                        class: ["ck", "ck-text-alternative-form", "ck-responsive-form"],
                        tabindex: "-1"
                    },
                    children: [this.labeledInput, this.saveButtonView, this.cancelButtonView]
                })
            }
            render() {
                super.render(), this.keystrokes.listenTo(this.element), ig({
                    view: this
                }), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((t => {
                    this._focusables.add(t), this.focusTracker.add(t.element)
                }))
            }
            destroy() {
                super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
            }
            _createButton(t, e, n, o) {
                const i = new Mg(this.locale);
                return i.set({
                    label: t,
                    icon: e,
                    tooltip: !0
                }), i.extendTemplate({
                    attributes: {
                        class: n
                    }
                }), o && i.delegate("execute").to(this, o), i
            }
            _createLabeledInputView() {
                const t = this.locale.t,
                    e = new sm(this.locale, Jm);
                return e.label = t("Text alternative"), e
            }
        }

        function wC(t) {
            const e = t.editing.view,
                n = Kp.defaultPositions,
                o = t.plugins.get("ImageUtils");
            return {
                target: e.domConverter.mapViewToDom(o.getClosestSelectedImageWidget(e.document.selection)),
                positions: [n.northArrowSouth, n.northArrowSouthWest, n.northArrowSouthEast, n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast, n.viewportStickyNorth]
            }
        }
        class AC extends Vi {
            static get requires() {
                return [jf]
            }
            static get pluginName() {
                return "ImageTextAlternativeUI"
            }
            init() {
                this._createButton()
            }
            destroy() {
                super.destroy(), this._form && this._form.destroy()
            }
            _createButton() {
                const t = this.editor,
                    e = t.t;
                t.ui.componentFactory.add("imageTextAlternative", (n => {
                    const o = t.commands.get("imageTextAlternative"),
                        i = new Mg(n);
                    return i.set({
                        label: e("Change image text alternative"),
                        icon: eg.lowVision,
                        tooltip: !0
                    }), i.bind("isEnabled").to(o, "isEnabled"), i.bind("isOn").to(o, "value", (t => !!t)), this.listenTo(i, "execute", (() => {
                        this._showForm()
                    })), i
                }))
            }
            _createForm() {
                const t = this.editor,
                    e = t.editing.view.document,
                    n = t.plugins.get("ImageUtils");
                this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new(og(kC))(t.locale), this._form.render(), this.listenTo(this._form, "submit", (() => {
                    t.execute("imageTextAlternative", {
                        newValue: this._form.labeledInput.fieldView.element.value
                    }), this._hideForm(!0)
                })), this.listenTo(this._form, "cancel", (() => {
                    this._hideForm(!0)
                })), this._form.keystrokes.set("Esc", ((t, e) => {
                    this._hideForm(!0), e()
                })), this.listenTo(t.ui, "update", (() => {
                    n.getClosestSelectedImageWidget(e.selection) ? this._isVisible && function(t) {
                        const e = t.plugins.get("ContextualBalloon");
                        if (t.plugins.get("ImageUtils").getClosestSelectedImageWidget(t.editing.view.document.selection)) {
                            const n = wC(t);
                            e.updatePosition(n)
                        }
                    }(t) : this._hideForm(!0)
                })), ng({
                    emitter: this._form,
                    activator: () => this._isVisible,
                    contextElements: () => [this._balloon.view.element],
                    callback: () => this._hideForm()
                })
            }
            _showForm() {
                if (this._isVisible) return;
                this._form || this._createForm();
                const t = this.editor,
                    e = t.commands.get("imageTextAlternative"),
                    n = this._form.labeledInput;
                this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({
                    view: this._form,
                    position: wC(t)
                }), n.fieldView.value = n.fieldView.element.value = e.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions()
            }
            _hideForm(t = !1) {
                this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), t && this.editor.editing.view.focus())
            }
            get _isVisible() {
                return !!this._balloon && this._balloon.visibleView === this._form
            }
            get _isInBalloon() {
                return !!this._balloon && this._balloon.hasView(this._form)
            }
        }
        class CC extends Vi {
            static get requires() {
                return [pC, AC]
            }
            static get pluginName() {
                return "ImageTextAlternative"
            }
        }

        function _C(t, e) {
            const n = (e, n, o) => {
                if (!o.consumable.consume(n.item, e.name)) return;
                const i = o.writer,
                    r = o.mapper.toViewElement(n.item),
                    s = t.findViewImgElement(r);
                if (null === n.attributeNewValue) {
                    const t = n.attributeOldValue;
                    t && t.data && (i.removeAttribute("srcset", s), i.removeAttribute("sizes", s), t.width && i.removeAttribute("width", s))
                } else {
                    const t = n.attributeNewValue;
                    t && t.data && (i.setAttribute("srcset", t.data, s), i.setAttribute("sizes", "100vw", s), t.width && i.setAttribute("width", t.width, s))
                }
            };
            return t => {
                t.on(`attribute:srcset:${e}`, n)
            }
        }

        function vC(t, e, n) {
            const o = (e, n, o) => {
                if (!o.consumable.consume(n.item, e.name)) return;
                const i = o.writer,
                    r = o.mapper.toViewElement(n.item),
                    s = t.findViewImgElement(r);
                i.setAttribute(n.attributeKey, n.attributeNewValue || "", s)
            };
            return t => {
                t.on(`attribute:${n}:${e}`, o)
            }
        }
        class yC extends Aa {
            observe(t) {
                this.listenTo(t, "load", ((t, e) => {
                    const n = e.target;
                    this.checkShouldIgnoreEventFromTarget(n) || "IMG" == n.tagName && this._fireEvents(e)
                }), {
                    useCapture: !0
                })
            }
            stopObserving(t) {
                this.stopListening(t)
            }
            _fireEvents(t) {
                this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", t))
            }
        }
        var xC = Object.defineProperty,
            EC = Object.getOwnPropertySymbols,
            DC = Object.prototype.hasOwnProperty,
            SC = Object.prototype.propertyIsEnumerable,
            TC = (t, e, n) => e in t ? xC(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n,
            BC = (t, e) => {
                for (var n in e || (e = {})) DC.call(e, n) && TC(t, n, e[n]);
                if (EC)
                    for (var n of EC(e)) SC.call(e, n) && TC(t, n, e[n]);
                return t
            };
        class IC extends Fi {
            constructor(t) {
                super(t);
                const e = t.config.get("image.insert.type");
                t.plugins.has("ImageBlockEditing") || "block" === e && k("image-block-plugin-required"), t.plugins.has("ImageInlineEditing") || "inline" === e && k("image-inline-plugin-required")
            }
            refresh() {
                const t = this.editor.plugins.get("ImageUtils");
                this.isEnabled = t.isImageAllowed()
            }
            execute(t) {
                const e = Ai(t.source),
                    n = this.editor.model.document.selection,
                    o = this.editor.plugins.get("ImageUtils"),
                    i = Object.fromEntries(n.getAttributes());
                e.forEach(((t, e) => {
                    const r = n.getSelectedElement();
                    if ("string" == typeof t && (t = {
                            src: t
                        }), e && r && o.isImage(r)) {
                        const e = this.editor.model.createPositionAfter(r);
                        o.insertImage(BC(BC({}, t), i), e)
                    } else o.insertImage(BC(BC({}, t), i))
                }))
            }
        }
        class PC extends Fi {
            refresh() {
                const t = this.editor.plugins.get("ImageUtils"),
                    e = this.editor.model.document.selection.getSelectedElement();
                this.isEnabled = t.isImage(e), this.value = this.isEnabled ? e.getAttribute("src") : null
            }
            execute(t) {
                const e = this.editor.model.document.selection.getSelectedElement();
                this.editor.model.change((n => {
                    n.setAttribute("src", t.source, e), n.removeAttribute("srcset", e), n.removeAttribute("sizes", e)
                }))
            }
        }
        class RC extends Vi {
            static get requires() {
                return [uC]
            }
            static get pluginName() {
                return "ImageEditing"
            }
            init() {
                const t = this.editor,
                    e = t.conversion;
                t.editing.view.addObserver(yC), e.for("upcast").attributeToAttribute({
                    view: {
                        name: "img",
                        key: "alt"
                    },
                    model: "alt"
                }).attributeToAttribute({
                    view: {
                        name: "img",
                        key: "srcset"
                    },
                    model: {
                        key: "srcset",
                        value: t => {
                            const e = {
                                data: t.getAttribute("srcset")
                            };
                            return t.hasAttribute("width") && (e.width = t.getAttribute("width")), e
                        }
                    }
                });
                const n = new IC(t),
                    o = new PC(t);
                t.commands.add("insertImage", n), t.commands.add("replaceImageSource", o), t.commands.add("imageInsert", n)
            }
        }
        class zC extends Fi {
            constructor(t, e) {
                super(t), this._modelElementName = e
            }
            refresh() {
                const t = this.editor.plugins.get("ImageUtils"),
                    e = t.getClosestSelectedImageElement(this.editor.model.document.selection);
                "imageBlock" === this._modelElementName ? this.isEnabled = t.isInlineImage(e) : this.isEnabled = t.isBlockImage(e)
            }
            execute() {
                const t = this.editor,
                    e = this.editor.model,
                    n = t.plugins.get("ImageUtils"),
                    o = n.getClosestSelectedImageElement(e.document.selection),
                    i = Object.fromEntries(o.getAttributes());
                return i.src || i.uploadId ? e.change((t => {
                    const r = Array.from(e.markers).filter((t => t.getRange().containsItem(o))),
                        s = n.insertImage(i, e.createSelection(o, "on"), this._modelElementName);
                    if (!s) return null;
                    const a = t.createRangeOn(s);
                    for (const e of r) {
                        const n = e.getRange(),
                            o = "$graveyard" != n.root.rootName ? n.getJoined(a, !0) : a;
                        t.updateMarker(e, {
                            range: o
                        })
                    }
                    return {
                        oldElement: o,
                        newElement: s
                    }
                })) : null
            }
        }
        class VC extends Vi {
            static get requires() {
                return [RC, uC, Mw]
            }
            static get pluginName() {
                return "ImageBlockEditing"
            }
            init() {
                const t = this.editor;
                t.model.schema.register("imageBlock", {
                    inheritAllFrom: "$blockObject",
                    allowAttributes: ["alt", "src", "srcset"]
                }), this._setupConversion(), t.plugins.has("ImageInlineEditing") && (t.commands.add("imageTypeBlock", new zC(this.editor, "imageBlock")), this._setupClipboardIntegration())
            }
            _setupConversion() {
                const t = this.editor,
                    e = t.t,
                    n = t.conversion,
                    o = t.plugins.get("ImageUtils");
                n.for("dataDowncast").elementToStructure({
                    model: "imageBlock",
                    view: (t, {
                        writer: e
                    }) => oC(e)
                }), n.for("editingDowncast").elementToStructure({
                    model: "imageBlock",
                    view: (t, {
                        writer: n
                    }) => o.toImageWidget(oC(n), n, e("image widget"))
                }), n.for("downcast").add(vC(o, "imageBlock", "src")).add(vC(o, "imageBlock", "alt")).add(_C(o, "imageBlock")), n.for("upcast").elementToElement({
                    view: iC(t, "imageBlock"),
                    model: (t, {
                        writer: e
                    }) => e.createElement("imageBlock", t.hasAttribute("src") ? {
                        src: t.getAttribute("src")
                    } : void 0)
                }).add(function(t) {
                    const e = (e, n, o) => {
                        if (!o.consumable.test(n.viewItem, {
                                name: !0,
                                classes: "image"
                            })) return;
                        const i = t.findViewImgElement(n.viewItem);
                        if (!i || !o.consumable.test(i, {
                                name: !0
                            })) return;
                        o.consumable.consume(n.viewItem, {
                            name: !0,
                            classes: "image"
                        });
                        const r = Ei(o.convertItem(i, n.modelCursor).modelRange.getItems());
                        r ? (o.convertChildren(n.viewItem, r), o.updateConversionResult(r, n)) : o.consumable.revert(n.viewItem, {
                            name: !0,
                            classes: "image"
                        })
                    };
                    return t => {
                        t.on("element:figure", e)
                    }
                }(o))
            }
            _setupClipboardIntegration() {
                const t = this.editor,
                    e = t.model,
                    n = t.editing.view,
                    o = t.plugins.get("ImageUtils"),
                    i = t.plugins.get("ClipboardPipeline");
                this.listenTo(i, "inputTransformation", ((i, r) => {
                    const s = Array.from(r.content.getChildren());
                    let a;
                    if (!s.every(o.isInlineImageView)) return;
                    a = r.targetRanges ? t.editing.mapper.toModelRange(r.targetRanges[0]) : e.document.selection.getFirstRange();
                    const l = e.createSelection(a);
                    if ("imageBlock" === rC(e.schema, l)) {
                        const t = new cu(n.document),
                            e = s.map((e => t.createElement("figure", {
                                class: "image"
                            }, e)));
                        r.content = t.createDocumentFragment(e)
                    }
                }))
            }
        }
        var OC = n(3508),
            FC = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(OC.Z, FC);
        OC.Z.locals;
        class MC extends Vi {
            static get requires() {
                return [VC, pA, CC]
            }
            static get pluginName() {
                return "ImageBlock"
            }
        }
        class NC extends Vi {
            static get requires() {
                return [RC, uC, Mw]
            }
            static get pluginName() {
                return "ImageInlineEditing"
            }
            init() {
                const t = this.editor,
                    e = t.model.schema;
                e.register("imageInline", {
                    inheritAllFrom: "$inlineObject",
                    allowAttributes: ["alt", "src", "srcset"]
                }), e.addChildCheck(((t, e) => {
                    if (t.endsWith("caption") && "imageInline" === e.name) return !1
                })), this._setupConversion(), t.plugins.has("ImageBlockEditing") && (t.commands.add("imageTypeInline", new zC(this.editor, "imageInline")), this._setupClipboardIntegration())
            }
            _setupConversion() {
                const t = this.editor,
                    e = t.t,
                    n = t.conversion,
                    o = t.plugins.get("ImageUtils");
                n.for("dataDowncast").elementToElement({
                    model: "imageInline",
                    view: (t, {
                        writer: e
                    }) => e.createEmptyElement("img")
                }), n.for("editingDowncast").elementToStructure({
                    model: "imageInline",
                    view: (t, {
                        writer: n
                    }) => o.toImageWidget(function(t) {
                        return t.createContainerElement("span", {
                            class: "image-inline"
                        }, t.createEmptyElement("img"))
                    }(n), n, e("image widget"))
                }), n.for("downcast").add(vC(o, "imageInline", "src")).add(vC(o, "imageInline", "alt")).add(_C(o, "imageInline")), n.for("upcast").elementToElement({
                    view: iC(t, "imageInline"),
                    model: (t, {
                        writer: e
                    }) => e.createElement("imageInline", t.hasAttribute("src") ? {
                        src: t.getAttribute("src")
                    } : void 0)
                })
            }
            _setupClipboardIntegration() {
                const t = this.editor,
                    e = t.model,
                    n = t.editing.view,
                    o = t.plugins.get("ImageUtils"),
                    i = t.plugins.get("ClipboardPipeline");
                this.listenTo(i, "inputTransformation", ((i, r) => {
                    const s = Array.from(r.content.getChildren());
                    let a;
                    if (!s.every(o.isBlockImageView)) return;
                    a = r.targetRanges ? t.editing.mapper.toModelRange(r.targetRanges[0]) : e.document.selection.getFirstRange();
                    const l = e.createSelection(a);
                    if ("imageInline" === rC(e.schema, l)) {
                        const t = new cu(n.document),
                            e = s.map((e => 1 === e.childCount ? (Array.from(e.getAttributes()).forEach((n => t.setAttribute(...n, o.findViewImgElement(e)))), e.getChild(0)) : e));
                        r.content = t.createDocumentFragment(e)
                    }
                }))
            }
        }
        class LC extends Vi {
            static get requires() {
                return [NC, pA, CC]
            }
            static get pluginName() {
                return "ImageInline"
            }
        }
        class HC extends Vi {
            static get pluginName() {
                return "ImageCaptionUtils"
            }
            static get requires() {
                return [uC]
            }
            getCaptionFromImageModelElement(t) {
                for (const e of t.getChildren())
                    if (e && e.is("element", "caption")) return e;
                return null
            }
            getCaptionFromModelSelection(t) {
                const e = this.editor.plugins.get("ImageUtils"),
                    n = t.getFirstPosition().findAncestor("caption");
                return n && e.isBlockImage(n.parent) ? n : null
            }
            matchImageCaptionViewElement(t) {
                const e = this.editor.plugins.get("ImageUtils");
                return "figcaption" == t.name && e.isBlockImageView(t.parent) ? {
                    name: !0
                } : null
            }
        }
        class jC extends Fi {
            refresh() {
                const t = this.editor,
                    e = t.plugins.get("ImageCaptionUtils"),
                    n = t.plugins.get("ImageUtils");
                if (!t.plugins.has(VC)) return this.isEnabled = !1, void(this.value = !1);
                const o = t.model.document.selection,
                    i = o.getSelectedElement();
                if (!i) {
                    const t = e.getCaptionFromModelSelection(o);
                    return this.isEnabled = !!t, void(this.value = !!t)
                }
                this.isEnabled = n.isImage(i), this.isEnabled ? this.value = !!e.getCaptionFromImageModelElement(i) : this.value = !1
            }
            execute(t = {}) {
                const {
                    focusCaptionOnShow: e
                } = t;
                this.editor.model.change((t => {
                    this.value ? this._hideImageCaption(t) : this._showImageCaption(t, e)
                }))
            }
            _showImageCaption(t, e) {
                const n = this.editor.model.document.selection,
                    o = this.editor.plugins.get("ImageCaptionEditing"),
                    i = this.editor.plugins.get("ImageUtils");
                let r = n.getSelectedElement();
                const s = o._getSavedCaption(r);
                i.isInlineImage(r) && (this.editor.execute("imageTypeBlock"), r = n.getSelectedElement());
                const a = s || t.createElement("caption");
                t.append(a, r), e && t.setSelection(a, "in")
            }
            _hideImageCaption(t) {
                const e = this.editor,
                    n = e.model.document.selection,
                    o = e.plugins.get("ImageCaptionEditing"),
                    i = e.plugins.get("ImageCaptionUtils");
                let r, s = n.getSelectedElement();
                s ? r = i.getCaptionFromImageModelElement(s) : (r = i.getCaptionFromModelSelection(n), s = r.parent), o._saveCaption(s, r), t.setSelection(s, "on"), t.remove(r)
            }
        }
        class qC extends Vi {
            constructor(t) {
                super(t), this._savedCaptionsMap = new WeakMap
            }
            static get requires() {
                return [uC, HC]
            }
            static get pluginName() {
                return "ImageCaptionEditing"
            }
            init() {
                const t = this.editor,
                    e = t.model.schema;
                e.isRegistered("caption") ? e.extend("caption", {
                    allowIn: "imageBlock"
                }) : e.register("caption", {
                    allowIn: "imageBlock",
                    allowContentOf: "$block",
                    isLimit: !0
                }), t.commands.add("toggleImageCaption", new jC(this.editor)), this._setupConversion(), this._setupImageTypeCommandsIntegration(), this._registerCaptionReconversion()
            }
            _setupConversion() {
                const t = this.editor,
                    e = t.editing.view,
                    n = t.plugins.get("ImageUtils"),
                    o = t.plugins.get("ImageCaptionUtils"),
                    i = t.t;
                t.conversion.for("upcast").elementToElement({
                    view: t => o.matchImageCaptionViewElement(t),
                    model: "caption"
                }), t.conversion.for("dataDowncast").elementToElement({
                    model: "caption",
                    view: (t, {
                        writer: e
                    }) => n.isBlockImage(t.parent) ? e.createContainerElement("figcaption") : null
                }), t.conversion.for("editingDowncast").elementToElement({
                    model: "caption",
                    view: (t, {
                        writer: o
                    }) => {
                        if (!n.isBlockImage(t.parent)) return null;
                        const r = o.createEditableElement("figcaption");
                        o.setCustomProperty("imageCaption", !0, r), Zi({
                            view: e,
                            element: r,
                            text: i("Enter image caption"),
                            keepOnFocus: !0
                        });
                        const s = t.parent.getAttribute("alt");
                        return Yw(r, o, {
                            label: s ? i("Caption for image: %0", [s]) : i("Caption for the image")
                        })
                    }
                })
            }
            _setupImageTypeCommandsIntegration() {
                const t = this.editor,
                    e = t.plugins.get("ImageUtils"),
                    n = t.plugins.get("ImageCaptionUtils"),
                    o = t.commands.get("imageTypeInline"),
                    i = t.commands.get("imageTypeBlock"),
                    r = t => {
                        if (!t.return) return;
                        const {
                            oldElement: o,
                            newElement: i
                        } = t.return;
                        if (!o) return;
                        if (e.isBlockImage(o)) {
                            const t = n.getCaptionFromImageModelElement(o);
                            if (t) return void this._saveCaption(i, t)
                        }
                        const r = this._getSavedCaption(o);
                        r && this._saveCaption(i, r)
                    };
                o && this.listenTo(o, "execute", r, {
                    priority: "low"
                }), i && this.listenTo(i, "execute", r, {
                    priority: "low"
                })
            }
            _getSavedCaption(t) {
                const e = this._savedCaptionsMap.get(t);
                return e ? vl.fromJSON(e) : null
            }
            _saveCaption(t, e) {
                this._savedCaptionsMap.set(t, e.toJSON())
            }
            _registerCaptionReconversion() {
                const t = this.editor,
                    e = t.model,
                    n = t.plugins.get("ImageUtils"),
                    o = t.plugins.get("ImageCaptionUtils");
                e.document.on("change:data", (() => {
                    const i = e.document.differ.getChanges();
                    for (const e of i) {
                        if ("alt" !== e.attributeKey) continue;
                        const i = e.range.start.nodeAfter;
                        if (n.isBlockImage(i)) {
                            const e = o.getCaptionFromImageModelElement(i);
                            if (!e) return;
                            t.editing.reconvertItem(e)
                        }
                    }
                }))
            }
        }
        class WC extends Vi {
            static get requires() {
                return [HC]
            }
            static get pluginName() {
                return "ImageCaptionUI"
            }
            init() {
                const t = this.editor,
                    e = t.editing.view,
                    n = t.plugins.get("ImageCaptionUtils"),
                    o = t.t;
                t.ui.componentFactory.add("toggleImageCaption", (i => {
                    const r = t.commands.get("toggleImageCaption"),
                        s = new Mg(i);
                    return s.set({
                        icon: eg.caption,
                        tooltip: !0,
                        isToggleable: !0
                    }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), s.bind("label").to(r, "value", (t => o(t ? "Toggle caption off" : "Toggle caption on"))), this.listenTo(s, "execute", (() => {
                        t.execute("toggleImageCaption", {
                            focusCaptionOnShow: !0
                        });
                        const o = n.getCaptionFromModelSelection(t.model.document.selection);
                        if (o) {
                            const n = t.editing.mapper.toViewElement(o);
                            e.scrollToTheSelection(), e.change((t => {
                                t.addClass("image__caption_highlighted", n)
                            }))
                        }
                        t.editing.view.focus()
                    })), s
                }))
            }
        }
        var UC = n(2640),
            $C = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(UC.Z, $C);
        UC.Z.locals;

        function GC(t) {
            const e = t.map((t => t.replace("+", "\\+")));
            return new RegExp(`^image\\/(${e.join("|")})$`)
        }

        function KC(t) {
            return new Promise(((e, n) => {
                const o = t.getAttribute("src");
                fetch(o).then((t => t.blob())).then((t => {
                    const n = ZC(t, o),
                        i = n.replace("image/", ""),
                        r = new File([t], `image.${i}`, {
                            type: n
                        });
                    e(r)
                })).catch((t => t && "TypeError" === t.name ? function(t) {
                    return function(t) {
                        return new Promise(((e, n) => {
                            const o = Po.document.createElement("img");
                            o.addEventListener("load", (() => {
                                const t = Po.document.createElement("canvas");
                                t.width = o.width, t.height = o.height;
                                t.getContext("2d").drawImage(o, 0, 0), t.toBlob((t => t ? e(t) : n()))
                            })), o.addEventListener("error", (() => n())), o.src = t
                        }))
                    }(t).then((e => {
                        const n = ZC(e, t),
                            o = n.replace("image/", "");
                        return new File([e], `image.${o}`, {
                            type: n
                        })
                    }))
                }(o).then(e).catch(n) : n(t)))
            }))
        }

        function ZC(t, e) {
            return t.type ? t.type : e.match(/data:(image\/\w+);base64/) ? e.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg"
        }
        class JC extends Vi {
            static get pluginName() {
                return "ImageUploadUI"
            }
            init() {
                const t = this.editor,
                    e = t.t,
                    n = n => {
                        const o = new Mb(n),
                            i = t.commands.get("uploadImage"),
                            r = t.config.get("image.upload.types"),
                            s = GC(r);
                        return o.set({
                            acceptedType: r.map((t => `image/${t}`)).join(","),
                            allowMultipleFiles: !0
                        }), o.buttonView.set({
                            label: e("Insert image"),
                            icon: eg.image,
                            tooltip: !0
                        }), o.buttonView.bind("isEnabled").to(i), o.on("done", ((e, n) => {
                            const o = Array.from(n).filter((t => s.test(t.type)));
                            o.length && (t.execute("uploadImage", {
                                file: o
                            }), t.editing.view.focus())
                        })), o
                    };
                t.ui.componentFactory.add("uploadImage", n), t.ui.componentFactory.add("imageUpload", n)
            }
        }
        var YC = n(3689),
            QC = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(YC.Z, QC);
        YC.Z.locals;
        var XC = n(4036),
            t_ = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(XC.Z, t_);
        XC.Z.locals;
        var e_ = n(3773),
            n_ = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(e_.Z, n_);
        e_.Z.locals;
        class o_ extends Vi {
            constructor(t) {
                super(t), this.uploadStatusChange = (t, e, n) => {
                    const o = this.editor,
                        i = e.item,
                        r = i.getAttribute("uploadId");
                    if (!n.consumable.consume(e.item, t.name)) return;
                    const s = o.plugins.get("ImageUtils"),
                        a = o.plugins.get(Ob),
                        l = r ? e.attributeNewValue : null,
                        c = this.placeholder,
                        d = o.editing.mapper.toViewElement(i),
                        h = n.writer;
                    if ("reading" == l) return i_(d, h), void r_(s, c, d, h);
                    if ("uploading" == l) {
                        const t = a.loaders.get(r);
                        return i_(d, h), void(t ? (s_(d, h), function(t, e, n, o) {
                            const i = function(t) {
                                const e = t.createUIElement("div", {
                                    class: "ck-progress-bar"
                                });
                                return t.setCustomProperty("progressBar", !0, e), e
                            }(e);
                            e.insert(e.createPositionAt(t, "end"), i), n.on("change:uploadedPercent", ((t, e, n) => {
                                o.change((t => {
                                    t.setStyle("width", n + "%", i)
                                }))
                            }))
                        }(d, h, t, o.editing.view), function(t, e, n, o) {
                            if (o.data) {
                                const i = t.findViewImgElement(e);
                                n.setAttribute("src", o.data, i)
                            }
                        }(s, d, h, t)) : r_(s, c, d, h))
                    }
                    "complete" == l && a.loaders.get(r) && function(t, e, n) {
                            const o = e.createUIElement("div", {
                                class: "ck-image-upload-complete-icon"
                            });
                            e.insert(e.createPositionAt(t, "end"), o), setTimeout((() => {
                                n.change((t => t.remove(t.createRangeOn(o))))
                            }), 3e3)
                        }(d, h, o.editing.view),
                        function(t, e) {
                            l_(t, e, "progressBar")
                        }(d, h), s_(d, h),
                        function(t, e) {
                            e.removeClass("ck-appear", t)
                        }(d, h)
                }, this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
            }
            static get pluginName() {
                return "ImageUploadProgress"
            }
            init() {
                const t = this.editor;
                t.plugins.has("ImageBlockEditing") && t.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange), t.plugins.has("ImageInlineEditing") && t.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange)
            }
        }

        function i_(t, e) {
            t.hasClass("ck-appear") || e.addClass("ck-appear", t)
        }

        function r_(t, e, n, o) {
            n.hasClass("ck-image-upload-placeholder") || o.addClass("ck-image-upload-placeholder", n);
            const i = t.findViewImgElement(n);
            i.getAttribute("src") !== e && o.setAttribute("src", e, i), a_(n, "placeholder") || o.insert(o.createPositionAfter(i), function(t) {
                const e = t.createUIElement("div", {
                    class: "ck-upload-placeholder-loader"
                });
                return t.setCustomProperty("placeholder", !0, e), e
            }(o))
        }

        function s_(t, e) {
            t.hasClass("ck-image-upload-placeholder") && e.removeClass("ck-image-upload-placeholder", t), l_(t, e, "placeholder")
        }

        function a_(t, e) {
            for (const n of t.getChildren())
                if (n.getCustomProperty(e)) return n
        }

        function l_(t, e, n) {
            const o = a_(t, n);
            o && e.remove(e.createRangeOn(o))
        }
        var c_ = Object.defineProperty,
            d_ = Object.defineProperties,
            h_ = Object.getOwnPropertyDescriptors,
            u_ = Object.getOwnPropertySymbols,
            g_ = Object.prototype.hasOwnProperty,
            m_ = Object.prototype.propertyIsEnumerable,
            p_ = (t, e, n) => e in t ? c_(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n;
        class f_ extends Fi {
            refresh() {
                const t = this.editor,
                    e = t.plugins.get("ImageUtils"),
                    n = t.model.document.selection.getSelectedElement();
                this.isEnabled = e.isImageAllowed() || e.isImage(n)
            }
            execute(t) {
                const e = Ai(t.file),
                    n = this.editor.model.document.selection,
                    o = this.editor.plugins.get("ImageUtils"),
                    i = Object.fromEntries(n.getAttributes());
                e.forEach(((t, e) => {
                    const r = n.getSelectedElement();
                    if (e && r && o.isImage(r)) {
                        const e = this.editor.model.createPositionAfter(r);
                        this._uploadImage(t, i, e)
                    } else this._uploadImage(t, i)
                }))
            }
            _uploadImage(t, e, n) {
                const o = this.editor,
                    i = o.plugins.get(Ob).createLoader(t),
                    r = o.plugins.get("ImageUtils");
                var s, a;
                i && r.insertImage((s = ((t, e) => {
                    for (var n in e || (e = {})) g_.call(e, n) && p_(t, n, e[n]);
                    if (u_)
                        for (var n of u_(e)) m_.call(e, n) && p_(t, n, e[n]);
                    return t
                })({}, e), a = {
                    uploadId: i.id
                }, d_(s, h_(a))), n)
            }
        }
        class b_ extends Vi {
            constructor(t) {
                super(t), t.config.define("image", {
                    upload: {
                        types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"]
                    }
                }), this._uploadImageElements = new Map
            }
            static get requires() {
                return [Ob, zf, Mw, uC]
            }
            static get pluginName() {
                return "ImageUploadEditing"
            }
            init() {
                const t = this.editor,
                    e = t.model.document,
                    n = t.conversion,
                    o = t.plugins.get(Ob),
                    i = t.plugins.get("ImageUtils"),
                    r = t.plugins.get("ClipboardPipeline"),
                    s = GC(t.config.get("image.upload.types")),
                    a = new f_(t);
                t.commands.add("uploadImage", a), t.commands.add("imageUpload", a), n.for("upcast").attributeToAttribute({
                    view: {
                        name: "img",
                        key: "uploadId"
                    },
                    model: "uploadId"
                }), this.listenTo(t.editing.view.document, "clipboardInput", ((e, n) => {
                    if (o = n.dataTransfer, Array.from(o.types).includes("text/html") && "" !== o.getData("text/html")) return;
                    var o;
                    const i = Array.from(n.dataTransfer.files).filter((t => !!t && s.test(t.type)));
                    i.length && (e.stop(), t.model.change((e => {
                        n.targetRanges && e.setSelection(n.targetRanges.map((e => t.editing.mapper.toModelRange(e)))), t.model.enqueueChange((() => {
                            t.execute("uploadImage", {
                                file: i
                            })
                        }))
                    })))
                })), this.listenTo(r, "inputTransformation", ((e, n) => {
                    const r = Array.from(t.editing.view.createRangeIn(n.content)).map((t => t.item)).filter((t => function(t, e) {
                        return !(!t.isInlineImageView(e) || !e.getAttribute("src") || !e.getAttribute("src").match(/^data:image\/\w+;base64,/g) && !e.getAttribute("src").match(/^blob:/g))
                    }(i, t) && !t.getAttribute("uploadProcessed"))).map((t => ({
                        promise: KC(t),
                        imageElement: t
                    })));
                    if (!r.length) return;
                    const s = new cu(t.editing.view.document);
                    for (const t of r) {
                        s.setAttribute("uploadProcessed", !0, t.imageElement);
                        const e = o.createLoader(t.promise);
                        e && (s.setAttribute("src", "", t.imageElement), s.setAttribute("uploadId", e.id, t.imageElement))
                    }
                })), t.editing.view.document.on("dragover", ((t, e) => {
                    e.preventDefault()
                })), e.on("change", (() => {
                    const n = e.differ.getChanges({
                            includeChangesInGraveyard: !0
                        }).reverse(),
                        i = new Set;
                    for (const e of n)
                        if ("insert" == e.type && "$text" != e.name) {
                            const n = e.position.nodeAfter,
                                r = "$graveyard" == e.position.root.rootName;
                            for (const e of k_(t, n)) {
                                const t = e.getAttribute("uploadId");
                                if (!t) continue;
                                const n = o.loaders.get(t);
                                n && (r ? i.has(t) || n.abort() : (i.add(t), this._uploadImageElements.set(t, e), "idle" == n.status && this._readAndUpload(n)))
                            }
                        }
                })), this.on("uploadComplete", ((t, {
                    imageElement: e,
                    data: n
                }) => {
                    const o = n.urls ? n.urls : n;
                    this.editor.model.change((t => {
                        t.setAttribute("src", o.default, e), this._parseAndSetSrcsetAttributeOnImage(o, e, t)
                    }))
                }), {
                    priority: "low"
                })
            }
            afterInit() {
                const t = this.editor.model.schema;
                this.editor.plugins.has("ImageBlockEditing") && t.extend("imageBlock", {
                    allowAttributes: ["uploadId", "uploadStatus"]
                }), this.editor.plugins.has("ImageInlineEditing") && t.extend("imageInline", {
                    allowAttributes: ["uploadId", "uploadStatus"]
                })
            }
            _readAndUpload(t) {
                const e = this.editor,
                    n = e.model,
                    o = e.locale.t,
                    r = e.plugins.get(Ob),
                    s = e.plugins.get(zf),
                    a = e.plugins.get("ImageUtils"),
                    l = this._uploadImageElements;
                return n.enqueueChange({
                    isUndoable: !1
                }, (e => {
                    e.setAttribute("uploadStatus", "reading", l.get(t.id))
                })), t.read().then((() => {
                    const o = t.upload(),
                        r = l.get(t.id);
                    if (i.isSafari) {
                        const t = e.editing.mapper.toViewElement(r),
                            n = a.findViewImgElement(t);
                        e.editing.view.once("render", (() => {
                            if (!n.parent) return;
                            const t = e.editing.view.domConverter.mapViewToDom(n.parent);
                            if (!t) return;
                            const o = t.style.display;
                            t.style.display = "none", t._ckHack = t.offsetHeight, t.style.display = o
                        }))
                    }
                    return n.enqueueChange({
                        isUndoable: !1
                    }, (t => {
                        t.setAttribute("uploadStatus", "uploading", r)
                    })), o
                })).then((e => {
                    n.enqueueChange({
                        isUndoable: !1
                    }, (n => {
                        const o = l.get(t.id);
                        n.setAttribute("uploadStatus", "complete", o), this.fire("uploadComplete", {
                            data: e,
                            imageElement: o
                        })
                    })), c()
                })).catch((e => {
                    if ("error" !== t.status && "aborted" !== t.status) throw e;
                    "error" == t.status && e && s.showWarning(e, {
                        title: o("Upload failed"),
                        namespace: "upload"
                    }), n.enqueueChange({
                        isUndoable: !1
                    }, (e => {
                        e.remove(l.get(t.id))
                    })), c()
                }));

                function c() {
                    n.enqueueChange({
                        isUndoable: !1
                    }, (e => {
                        const n = l.get(t.id);
                        e.removeAttribute("uploadId", n), e.removeAttribute("uploadStatus", n), l.delete(t.id)
                    })), r.destroyLoader(t)
                }
            }
            _parseAndSetSrcsetAttributeOnImage(t, e, n) {
                let o = 0;
                const i = Object.keys(t).filter((t => {
                    const e = parseInt(t, 10);
                    if (!isNaN(e)) return o = Math.max(o, e), !0
                })).map((e => `${t[e]} ${e}w`)).join(", ");
                "" != i && n.setAttribute("srcset", {
                    data: i,
                    width: o
                }, e)
            }
        }

        function k_(t, e) {
            const n = t.plugins.get("ImageUtils");
            return Array.from(t.model.createRangeOn(e)).filter((t => n.isImage(t.item))).map((t => t.item))
        }
        var w_ = n(1568),
            A_ = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(w_.Z, A_);
        w_.Z.locals;
        var C_ = n(3535),
            __ = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(C_.Z, __);
        C_.Z.locals;
        class v_ extends Fi {
            refresh() {
                const t = this.editor,
                    e = t.plugins.get("ImageUtils").getClosestSelectedImageElement(t.model.document.selection);
                this.isEnabled = !!e, e && e.hasAttribute("width") ? this.value = {
                    width: e.getAttribute("width"),
                    height: null
                } : this.value = null
            }
            execute(t) {
                const e = this.editor,
                    n = e.model,
                    o = e.plugins.get("ImageUtils").getClosestSelectedImageElement(n.document.selection);
                this.value = {
                    width: t.width,
                    height: null
                }, o && n.change((e => {
                    e.setAttribute("width", t.width, o)
                }))
            }
        }
        class y_ extends Vi {
            static get requires() {
                return [uC]
            }
            static get pluginName() {
                return "ImageResizeEditing"
            }
            constructor(t) {
                super(t), t.config.define("image", {
                    resizeUnit: "%",
                    resizeOptions: [{
                        name: "resizeImage:original",
                        value: null,
                        icon: "original"
                    }, {
                        name: "resizeImage:25",
                        value: "25",
                        icon: "small"
                    }, {
                        name: "resizeImage:50",
                        value: "50",
                        icon: "medium"
                    }, {
                        name: "resizeImage:75",
                        value: "75",
                        icon: "large"
                    }]
                })
            }
            init() {
                const t = this.editor,
                    e = new v_(t);
                this._registerSchema(), this._registerConverters("imageBlock"), this._registerConverters("imageInline"), t.commands.add("resizeImage", e), t.commands.add("imageResize", e)
            }
            _registerSchema() {
                this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", {
                    allowAttributes: "width"
                }), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", {
                    allowAttributes: "width"
                })
            }
            _registerConverters(t) {
                const e = this.editor;
                e.conversion.for("downcast").add((e => e.on(`attribute:width:${t}`, ((t, e, n) => {
                    if (!n.consumable.consume(e.item, t.name)) return;
                    const o = n.writer,
                        i = n.mapper.toViewElement(e.item);
                    null !== e.attributeNewValue ? (o.setStyle("width", e.attributeNewValue, i), o.addClass("image_resized", i)) : (o.removeStyle("width", i), o.removeClass("image_resized", i))
                })))), e.conversion.for("upcast").attributeToAttribute({
                    view: {
                        name: "imageBlock" === t ? "figure" : "img",
                        styles: {
                            width: /.+/
                        }
                    },
                    model: {
                        key: "width",
                        value: t => t.getStyle("width")
                    }
                })
            }
        }
        const x_ = {
            small: eg.objectSizeSmall,
            medium: eg.objectSizeMedium,
            large: eg.objectSizeLarge,
            original: eg.objectSizeFull
        };
        class E_ extends Vi {
            constructor(t) {
                super(t), this._resizeUnit = t.config.get("image.resizeUnit")
            }
            static get requires() {
                return [y_]
            }
            static get pluginName() {
                return "ImageResizeButtons"
            }
            init() {
                const t = this.editor,
                    e = t.config.get("image.resizeOptions"),
                    n = t.commands.get("resizeImage");
                this.bind("isEnabled").to(n);
                for (const t of e) this._registerImageResizeButton(t);
                this._registerImageResizeDropdown(e)
            }
            _registerImageResizeButton(t) {
                const e = this.editor,
                    {
                        name: n,
                        value: o,
                        icon: i
                    } = t,
                    r = o ? o + this._resizeUnit : null;
                e.ui.componentFactory.add(n, (n => {
                    const o = new Mg(n),
                        s = e.commands.get("resizeImage"),
                        a = this._getOptionLabelValue(t, !0);
                    if (!x_[i]) throw new b("imageresizebuttons-missing-icon", e, t);
                    return o.set({
                        label: a,
                        icon: x_[i],
                        tooltip: a,
                        isToggleable: !0
                    }), o.bind("isEnabled").to(this), o.bind("isOn").to(s, "value", D_(r)), this.listenTo(o, "execute", (() => {
                        e.execute("resizeImage", {
                            width: r
                        })
                    })), o
                }))
            }
            _registerImageResizeDropdown(t) {
                const e = this.editor,
                    n = e.t,
                    o = t.find((t => !t.value)),
                    i = i => {
                        const r = e.commands.get("resizeImage"),
                            s = Wm(i, km),
                            a = s.buttonView,
                            l = n("Resize image");
                        return a.set({
                            tooltip: l,
                            commandValue: o.value,
                            icon: x_.medium,
                            isToggleable: !0,
                            label: this._getOptionLabelValue(o),
                            withText: !0,
                            class: "ck-resize-image-button",
                            ariaLabel: l,
                            ariaLabelledBy: void 0
                        }), a.bind("label").to(r, "value", (t => t && t.width ? t.width : this._getOptionLabelValue(o))), s.bind("isEnabled").to(this), Gm(s, (() => this._getResizeDropdownListItemDefinitions(t, r)), {
                            ariaLabel: n("Image resize list"),
                            role: "menu"
                        }), this.listenTo(s, "execute", (t => {
                            e.execute(t.source.commandName, {
                                width: t.source.commandValue
                            }), e.editing.view.focus()
                        })), s
                    };
                e.ui.componentFactory.add("resizeImage", i), e.ui.componentFactory.add("imageResize", i)
            }
            _getOptionLabelValue(t, e = !1) {
                const n = this.editor.t;
                return t.label ? t.label : e ? t.value ? n("Resize image to %0", t.value + this._resizeUnit) : n("Resize image to the original size") : t.value ? t.value + this._resizeUnit : n("Original")
            }
            _getResizeDropdownListItemDefinitions(t, e) {
                const n = new xi;
                return t.map((t => {
                    const o = t.value ? t.value + this._resizeUnit : null,
                        i = {
                            type: "button",
                            model: new Vf({
                                commandName: "resizeImage",
                                commandValue: o,
                                label: this._getOptionLabelValue(t),
                                role: "menuitemradio",
                                withText: !0,
                                icon: null
                            })
                        };
                    i.model.bind("isOn").to(e, "value", D_(o)), n.add(i)
                })), n
            }
        }

        function D_(t) {
            return e => null === t && e === t || null !== e && e.width === t
        }
        const S_ = /(image|image-inline)/,
            T_ = "image_resized";
        class B_ extends Vi {
            static get requires() {
                return [RA]
            }
            static get pluginName() {
                return "ImageResizeHandles"
            }
            init() {
                const t = this.editor.commands.get("resizeImage");
                this.bind("isEnabled").to(t), this._setupResizerCreator()
            }
            _setupResizerCreator() {
                const t = this.editor,
                    e = t.editing.view;
                e.addObserver(yC), this.listenTo(e.document, "imageLoaded", ((n, o) => {
                    if (!o.target.matches("figure.image.ck-widget > img,figure.image.ck-widget > picture > img,figure.image.ck-widget > a > img,figure.image.ck-widget > a > picture > img,span.image-inline.ck-widget > img,span.image-inline.ck-widget > picture > img")) return;
                    const i = t.editing.view.domConverter,
                        r = i.domToView(o.target).findAncestor({
                            classes: S_
                        });
                    let s = this.editor.plugins.get(RA).getResizerByViewElement(r);
                    if (s) return void s.redraw();
                    const a = t.editing.mapper,
                        l = a.toModelElement(r);
                    s = t.plugins.get(RA).attachTo({
                        unit: t.config.get("image.resizeUnit"),
                        modelElement: l,
                        viewElement: r,
                        editor: t,
                        getHandleHost: t => t.querySelector("img"),
                        getResizeHost: () => i.mapViewToDom(a.toViewElement(l.parent)),
                        isCentered() {
                            const t = l.getAttribute("imageStyle");
                            return !t || "block" == t || "alignCenter" == t
                        },
                        onCommit(n) {
                            e.change((t => {
                                t.removeClass(T_, r)
                            })), t.execute("resizeImage", {
                                width: n
                            })
                        }
                    }), s.on("updateSize", (() => {
                        r.hasClass(T_) || e.change((t => {
                            t.addClass(T_, r)
                        }))
                    })), s.bind("isEnabled").to(this)
                }))
            }
        }
        var I_ = n(6270),
            P_ = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(I_.Z, P_);
        I_.Z.locals;
        class R_ extends Fi {
            constructor(t, e) {
                super(t), this._defaultStyles = {
                    imageBlock: !1,
                    imageInline: !1
                }, this._styles = new Map(e.map((t => {
                    if (t.isDefault)
                        for (const e of t.modelElements) this._defaultStyles[e] = t.name;
                    return [t.name, t]
                })))
            }
            refresh() {
                const t = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
                this.isEnabled = !!t, this.isEnabled ? t.hasAttribute("imageStyle") ? this.value = t.getAttribute("imageStyle") : this.value = this._defaultStyles[t.name] : this.value = !1
            }
            execute(t = {}) {
                const e = this.editor,
                    n = e.model,
                    o = e.plugins.get("ImageUtils");
                n.change((e => {
                    const i = t.value;
                    let r = o.getClosestSelectedImageElement(n.document.selection);
                    i && this.shouldConvertImageType(i, r) && (this.editor.execute(o.isBlockImage(r) ? "imageTypeInline" : "imageTypeBlock"), r = o.getClosestSelectedImageElement(n.document.selection)), !i || this._styles.get(i).isDefault ? e.removeAttribute("imageStyle", r) : e.setAttribute("imageStyle", i, r)
                }))
            }
            shouldConvertImageType(t, e) {
                return !this._styles.get(t).modelElements.includes(e.name)
            }
        }
        var z_ = Object.defineProperty,
            V_ = Object.getOwnPropertySymbols,
            O_ = Object.prototype.hasOwnProperty,
            F_ = Object.prototype.propertyIsEnumerable,
            M_ = (t, e, n) => e in t ? z_(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n,
            N_ = (t, e) => {
                for (var n in e || (e = {})) O_.call(e, n) && M_(t, n, e[n]);
                if (V_)
                    for (var n of V_(e)) F_.call(e, n) && M_(t, n, e[n]);
                return t
            };
        const {
            objectFullWidth: L_,
            objectInline: H_,
            objectLeft: j_,
            objectRight: q_,
            objectCenter: W_,
            objectBlockLeft: U_,
            objectBlockRight: $_
        } = eg, G_ = {
            get inline() {
                return {
                    name: "inline",
                    title: "In line",
                    icon: H_,
                    modelElements: ["imageInline"],
                    isDefault: !0
                }
            },
            get alignLeft() {
                return {
                    name: "alignLeft",
                    title: "Left aligned image",
                    icon: j_,
                    modelElements: ["imageBlock", "imageInline"],
                    className: "image-style-align-left"
                }
            },
            get alignBlockLeft() {
                return {
                    name: "alignBlockLeft",
                    title: "Left aligned image",
                    icon: U_,
                    modelElements: ["imageBlock"],
                    className: "image-style-block-align-left"
                }
            },
            get alignCenter() {
                return {
                    name: "alignCenter",
                    title: "Centered image",
                    icon: W_,
                    modelElements: ["imageBlock"],
                    className: "image-style-align-center"
                }
            },
            get alignRight() {
                return {
                    name: "alignRight",
                    title: "Right aligned image",
                    icon: q_,
                    modelElements: ["imageBlock", "imageInline"],
                    className: "image-style-align-right"
                }
            },
            get alignBlockRight() {
                return {
                    name: "alignBlockRight",
                    title: "Right aligned image",
                    icon: $_,
                    modelElements: ["imageBlock"],
                    className: "image-style-block-align-right"
                }
            },
            get block() {
                return {
                    name: "block",
                    title: "Centered image",
                    icon: W_,
                    modelElements: ["imageBlock"],
                    isDefault: !0
                }
            },
            get side() {
                return {
                    name: "side",
                    title: "Side image",
                    icon: q_,
                    modelElements: ["imageBlock"],
                    className: "image-style-side"
                }
            }
        }, K_ = {
            full: L_,
            left: U_,
            right: $_,
            center: W_,
            inlineLeft: j_,
            inlineRight: q_,
            inline: H_
        }, Z_ = [{
            name: "imageStyle:wrapText",
            title: "Wrap text",
            defaultItem: "imageStyle:alignLeft",
            items: ["imageStyle:alignLeft", "imageStyle:alignRight"]
        }, {
            name: "imageStyle:breakText",
            title: "Break text",
            defaultItem: "imageStyle:block",
            items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"]
        }];

        function J_(t) {
            k("image-style-configuration-definition-invalid", t)
        }
        const Y_ = {
            normalizeStyles: function(t) {
                return (t.configuredStyles.options || []).map((t => function(t) {
                    t = "string" == typeof t ? G_[t] ? N_({}, G_[t]) : {
                        name: t
                    } : function(t, e) {
                        const n = N_({}, e);
                        for (const o in t) Object.prototype.hasOwnProperty.call(e, o) || (n[o] = t[o]);
                        return n
                    }(G_[t.name], t);
                    "string" == typeof t.icon && (t.icon = K_[t.icon] || t.icon);
                    return t
                }(t))).filter((e => function(t, {
                    isBlockPluginLoaded: e,
                    isInlinePluginLoaded: n
                }) {
                    const {
                        modelElements: o,
                        name: i
                    } = t;
                    if (!(o && o.length && i)) return J_({
                        style: t
                    }), !1;
                    {
                        const i = [e ? "imageBlock" : null, n ? "imageInline" : null];
                        if (!o.some((t => i.includes(t)))) return k("image-style-missing-dependency", {
                            style: t,
                            missingPlugins: o.map((t => "imageBlock" === t ? "ImageBlockEditing" : "ImageInlineEditing"))
                        }), !1
                    }
                    return !0
                }(e, t)))
            },
            getDefaultStylesConfiguration: function(t, e) {
                return t && e ? {
                    options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"]
                } : t ? {
                    options: ["block", "side"]
                } : e ? {
                    options: ["inline", "alignLeft", "alignRight"]
                } : {}
            },
            getDefaultDropdownDefinitions: function(t) {
                return t.has("ImageBlockEditing") && t.has("ImageInlineEditing") ? [...Z_] : []
            },
            warnInvalidStyle: J_,
            DEFAULT_OPTIONS: G_,
            DEFAULT_ICONS: K_,
            DEFAULT_DROPDOWN_DEFINITIONS: Z_
        };

        function Q_(t, e) {
            for (const n of e)
                if (n.name === t) return n
        }
        class X_ extends Vi {
            static get pluginName() {
                return "ImageStyleEditing"
            }
            static get requires() {
                return [uC]
            }
            init() {
                const {
                    normalizeStyles: t,
                    getDefaultStylesConfiguration: e
                } = Y_, n = this.editor, o = n.plugins.has("ImageBlockEditing"), i = n.plugins.has("ImageInlineEditing");
                n.config.define("image.styles", e(o, i)), this.normalizedStyles = t({
                    configuredStyles: n.config.get("image.styles"),
                    isBlockPluginLoaded: o,
                    isInlinePluginLoaded: i
                }), this._setupConversion(o, i), this._setupPostFixer(), n.commands.add("imageStyle", new R_(n, this.normalizedStyles))
            }
            _setupConversion(t, e) {
                const n = this.editor,
                    o = n.model.schema,
                    i = (r = this.normalizedStyles, (t, e, n) => {
                        if (!n.consumable.consume(e.item, t.name)) return;
                        const o = Q_(e.attributeNewValue, r),
                            i = Q_(e.attributeOldValue, r),
                            s = n.mapper.toViewElement(e.item),
                            a = n.writer;
                        i && a.removeClass(i.className, s), o && a.addClass(o.className, s)
                    });
                var r;
                const s = function(t) {
                    const e = {
                        imageInline: t.filter((t => !t.isDefault && t.modelElements.includes("imageInline"))),
                        imageBlock: t.filter((t => !t.isDefault && t.modelElements.includes("imageBlock")))
                    };
                    return (t, n, o) => {
                        if (!n.modelRange) return;
                        const i = n.viewItem,
                            r = Ei(n.modelRange.getItems());
                        if (r && o.schema.checkAttribute(r, "imageStyle"))
                            for (const t of e[r.name]) o.consumable.consume(i, {
                                classes: t.className
                            }) && o.writer.setAttribute("imageStyle", t.name, r)
                    }
                }(this.normalizedStyles);
                n.editing.downcastDispatcher.on("attribute:imageStyle", i), n.data.downcastDispatcher.on("attribute:imageStyle", i), t && (o.extend("imageBlock", {
                    allowAttributes: "imageStyle"
                }), n.data.upcastDispatcher.on("element:figure", s, {
                    priority: "low"
                })), e && (o.extend("imageInline", {
                    allowAttributes: "imageStyle"
                }), n.data.upcastDispatcher.on("element:img", s, {
                    priority: "low"
                }))
            }
            _setupPostFixer() {
                const t = this.editor,
                    e = t.model.document,
                    n = t.plugins.get(uC),
                    o = new Map(this.normalizedStyles.map((t => [t.name, t])));
                e.registerPostFixer((t => {
                    let i = !1;
                    for (const r of e.differ.getChanges())
                        if ("insert" == r.type || "attribute" == r.type && "imageStyle" == r.attributeKey) {
                            let e = "insert" == r.type ? r.position.nodeAfter : r.range.start.nodeAfter;
                            if (e && e.is("element", "paragraph") && e.childCount > 0 && (e = e.getChild(0)), !n.isImage(e)) continue;
                            const s = e.getAttribute("imageStyle");
                            if (!s) continue;
                            const a = o.get(s);
                            a && a.modelElements.includes(e.name) || (t.removeAttribute("imageStyle", e), i = !0)
                        } return i
                }))
            }
        }
        var tv = n(5083),
            ev = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(tv.Z, ev);
        tv.Z.locals;
        class nv extends Vi {
            static get requires() {
                return [X_]
            }
            static get pluginName() {
                return "ImageStyleUI"
            }
            get localizedDefaultStylesTitles() {
                const t = this.editor.t;
                return {
                    "Wrap text": t("Wrap text"),
                    "Break text": t("Break text"),
                    "In line": t("In line"),
                    "Full size image": t("Full size image"),
                    "Side image": t("Side image"),
                    "Left aligned image": t("Left aligned image"),
                    "Centered image": t("Centered image"),
                    "Right aligned image": t("Right aligned image")
                }
            }
            init() {
                const t = this.editor.plugins,
                    e = this.editor.config.get("image.toolbar") || [],
                    n = ov(t.get("ImageStyleEditing").normalizedStyles, this.localizedDefaultStylesTitles);
                for (const t of n) this._createButton(t);
                const o = ov([...e.filter(O), ...Y_.getDefaultDropdownDefinitions(t)], this.localizedDefaultStylesTitles);
                for (const t of o) this._createDropdown(t, n)
            }
            _createDropdown(t, e) {
                const n = this.editor.ui.componentFactory;
                n.add(t.name, (o => {
                    let i;
                    const {
                        defaultItem: r,
                        items: s,
                        title: a
                    } = t, l = s.filter((t => e.find((({
                        name: e
                    }) => iv(e) === t)))).map((t => {
                        const e = n.create(t);
                        return t === r && (i = e), e
                    }));
                    s.length !== l.length && Y_.warnInvalidStyle({
                        dropdown: t
                    });
                    const c = Wm(o, Nm),
                        d = c.buttonView,
                        h = d.arrowView;
                    return Um(c, l, {
                        enableActiveItemFocusOnDropdownOpen: !0
                    }), d.set({
                        label: rv(a, i.label),
                        class: null,
                        tooltip: !0
                    }), h.unbind("label"), h.set({
                        label: a
                    }), d.bind("icon").toMany(l, "isOn", ((...t) => {
                        const e = t.findIndex(Lr);
                        return e < 0 ? i.icon : l[e].icon
                    })), d.bind("label").toMany(l, "isOn", ((...t) => {
                        const e = t.findIndex(Lr);
                        return rv(a, e < 0 ? i.label : l[e].label)
                    })), d.bind("isOn").toMany(l, "isOn", ((...t) => t.some(Lr))), d.bind("class").toMany(l, "isOn", ((...t) => t.some(Lr) ? "ck-splitbutton_flatten" : void 0)), d.on("execute", (() => {
                        l.some((({
                            isOn: t
                        }) => t)) ? c.isOpen = !c.isOpen : i.fire("execute")
                    })), c.bind("isEnabled").toMany(l, "isEnabled", ((...t) => t.some(Lr))), this.listenTo(c, "execute", (() => {
                        this.editor.editing.view.focus()
                    })), c
                }))
            }
            _createButton(t) {
                const e = t.name;
                this.editor.ui.componentFactory.add(iv(e), (n => {
                    const o = this.editor.commands.get("imageStyle"),
                        i = new Mg(n);
                    return i.set({
                        label: t.title,
                        icon: t.icon,
                        tooltip: !0,
                        isToggleable: !0
                    }), i.bind("isEnabled").to(o, "isEnabled"), i.bind("isOn").to(o, "value", (t => t === e)), i.on("execute", this._executeCommand.bind(this, e)), i
                }))
            }
            _executeCommand(t) {
                this.editor.execute("imageStyle", {
                    value: t
                }), this.editor.editing.view.focus()
            }
        }

        function ov(t, e) {
            for (const n of t) e[n.title] && (n.title = e[n.title]);
            return t
        }

        function iv(t) {
            return `imageStyle:${t}`
        }

        function rv(t, e) {
            return (t ? t + ": " : "") + e
        }
        class sv {
            constructor() {
                this._definitions = new Set
            }
            get length() {
                return this._definitions.size
            }
            add(t) {
                Array.isArray(t) ? t.forEach((t => this._definitions.add(t))) : this._definitions.add(t)
            }
            getDispatcher() {
                return t => {
                    t.on("attribute:linkHref", ((t, e, n) => {
                        if (!n.consumable.test(e.item, "attribute:linkHref")) return;
                        if (!e.item.is("selection") && !n.schema.isInline(e.item)) return;
                        const o = n.writer,
                            i = o.document.selection;
                        for (const t of this._definitions) {
                            const r = o.createAttributeElement("a", t.attributes, {
                                priority: 5
                            });
                            t.classes && o.addClass(t.classes, r);
                            for (const e in t.styles) o.setStyle(e, t.styles[e], r);
                            o.setCustomProperty("link", !0, r), t.callback(e.attributeNewValue) ? e.item.is("selection") ? o.wrap(i.getFirstRange(), r) : o.wrap(n.mapper.toViewRange(e.range), r) : o.unwrap(n.mapper.toViewRange(e.range), r)
                        }
                    }), {
                        priority: "high"
                    })
                }
            }
            getDispatcherForLinkedImage() {
                return t => {
                    t.on("attribute:linkHref:imageBlock", ((t, e, {
                        writer: n,
                        mapper: o
                    }) => {
                        const i = o.toViewElement(e.item),
                            r = Array.from(i.getChildren()).find((t => t.is("element", "a")));
                        for (const t of this._definitions) {
                            const o = Ti(t.attributes);
                            if (t.callback(e.attributeNewValue)) {
                                for (const [t, e] of o) "class" === t ? n.addClass(e, r) : n.setAttribute(t, e, r);
                                t.classes && n.addClass(t.classes, r);
                                for (const e in t.styles) n.setStyle(e, t.styles[e], r)
                            } else {
                                for (const [t, e] of o) "class" === t ? n.removeClass(e, r) : n.removeAttribute(t, r);
                                t.classes && n.removeClass(t.classes, r);
                                for (const e in t.styles) n.removeStyle(e, r)
                            }
                        }
                    }))
                }
            }
        }
        const av = function(t, e, n) {
            var o = t.length;
            return n = void 0 === n ? o : n, !e && n >= o ? t : Sr(t, e, n)
        };
        var lv = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
        const cv = function(t) {
            return lv.test(t)
        };
        const dv = function(t) {
            return t.split("")
        };
        var hv = "\\ud800-\\udfff",
            uv = "[" + hv + "]",
            gv = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
            mv = "\\ud83c[\\udffb-\\udfff]",
            pv = "[^" + hv + "]",
            fv = "(?:\\ud83c[\\udde6-\\uddff]){2}",
            bv = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            kv = "(?:" + gv + "|" + mv + ")" + "?",
            wv = "[\\ufe0e\\ufe0f]?",
            Av = wv + kv + ("(?:\\u200d(?:" + [pv, fv, bv].join("|") + ")" + wv + kv + ")*"),
            Cv = "(?:" + [pv + gv + "?", gv, fv, bv, uv].join("|") + ")",
            _v = RegExp(mv + "(?=" + mv + ")|" + Cv + Av, "g");
        const vv = function(t) {
            return t.match(_v) || []
        };
        const yv = function(t) {
            return cv(t) ? vv(t) : dv(t)
        };
        const xv = function(t) {
                return function(e) {
                    e = vr(e);
                    var n = cv(e) ? yv(e) : void 0,
                        o = n ? n[0] : e.charAt(0),
                        i = n ? av(n, 1).join("") : e.slice(1);
                    return o[t]() + i
                }
            }("toUpperCase"),
            Ev = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
            Dv = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i,
            Sv = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i,
            Tv = /^((\w+:(\/{2,})?)|(\W))/i,
            Bv = "Ctrl+K";

        function Iv(t, {
            writer: e
        }) {
            const n = e.createAttributeElement("a", {
                href: t
            }, {
                priority: 5
            });
            return e.setCustomProperty("link", !0, n), n
        }

        function Pv(t) {
            const e = String(t);
            return function(t) {
                const e = t.replace(Ev, "");
                return !!e.match(Dv)
            }(e) ? e : "#"
        }

        function Rv(t, e) {
            return !!t && e.checkAttribute(t.name, "linkHref")
        }

        function zv(t, e) {
            const n = (o = t, Sv.test(o) ? "mailto:" : e);
            var o;
            const i = !!n && !Vv(t);
            return t && i ? n + t : t
        }

        function Vv(t) {
            return Tv.test(t)
        }

        function Ov(t) {
            window.open(t, "_blank", "noopener")
        }
        class Fv extends Fi {
            constructor() {
                super(...arguments), this.manualDecorators = new xi, this.automaticDecorators = new sv
            }
            restoreManualDecoratorStates() {
                for (const t of this.manualDecorators) t.value = this._getDecoratorStateFromModel(t.id)
            }
            refresh() {
                const t = this.editor.model,
                    e = t.document.selection,
                    n = e.getSelectedElement() || Ei(e.getSelectedBlocks());
                Rv(n, t.schema) ? (this.value = n.getAttribute("linkHref"), this.isEnabled = t.schema.checkAttribute(n, "linkHref")) : (this.value = e.getAttribute("linkHref"), this.isEnabled = t.schema.checkAttributeInSelection(e, "linkHref"));
                for (const t of this.manualDecorators) t.value = this._getDecoratorStateFromModel(t.id)
            }
            execute(t, e = {}) {
                const n = this.editor.model,
                    o = n.document.selection,
                    i = [],
                    r = [];
                for (const t in e) e[t] ? i.push(t) : r.push(t);
                n.change((e => {
                    if (o.isCollapsed) {
                        const s = o.getFirstPosition();
                        if (o.hasAttribute("linkHref")) {
                            const a = Mv(o);
                            let l = kk(s, "linkHref", o.getAttribute("linkHref"), n);
                            o.getAttribute("linkHref") === a && (l = this._updateLinkContent(n, e, l, t)), e.setAttribute("linkHref", t, l), i.forEach((t => {
                                e.setAttribute(t, !0, l)
                            })), r.forEach((t => {
                                e.removeAttribute(t, l)
                            })), e.setSelection(e.createPositionAfter(l.end.nodeBefore))
                        } else if ("" !== t) {
                            const r = Ti(o.getAttributes());
                            r.set("linkHref", t), i.forEach((t => {
                                r.set(t, !0)
                            }));
                            const {
                                end: a
                            } = n.insertContent(e.createText(t, r), s);
                            e.setSelection(a)
                        } ["linkHref", ...i, ...r].forEach((t => {
                            e.removeSelectionAttribute(t)
                        }))
                    } else {
                        const s = n.schema.getValidRanges(o.getRanges(), "linkHref"),
                            a = [];
                        for (const t of o.getSelectedBlocks()) n.schema.checkAttribute(t, "linkHref") && a.push(e.createRangeOn(t));
                        const l = a.slice();
                        for (const t of s) this._isRangeToUpdate(t, a) && l.push(t);
                        for (const s of l) {
                            let a = s;
                            if (1 === l.length) {
                                const i = Mv(o);
                                o.getAttribute("linkHref") === i && (a = this._updateLinkContent(n, e, s, t), e.setSelection(e.createSelection(a)))
                            }
                            e.setAttribute("linkHref", t, a), i.forEach((t => {
                                e.setAttribute(t, !0, a)
                            })), r.forEach((t => {
                                e.removeAttribute(t, a)
                            }))
                        }
                    }
                }))
            }
            _getDecoratorStateFromModel(t) {
                const e = this.editor.model,
                    n = e.document.selection,
                    o = n.getSelectedElement();
                return Rv(o, e.schema) ? o.getAttribute(t) : n.getAttribute(t)
            }
            _isRangeToUpdate(t, e) {
                for (const n of e)
                    if (n.containsRange(t)) return !1;
                return !0
            }
            _updateLinkContent(t, e, n, o) {
                const i = e.createText(o, {
                    linkHref: o
                });
                return t.insertContent(i, n)
            }
        }

        function Mv(t) {
            if (t.isCollapsed) {
                const e = t.getFirstPosition();
                return e.textNode && e.textNode.data
            } {
                const e = Array.from(t.getFirstRange().getItems());
                if (e.length > 1) return null;
                const n = e[0];
                return n.is("$text") || n.is("$textProxy") ? n.data : null
            }
        }
        class Nv extends Fi {
            refresh() {
                const t = this.editor.model,
                    e = t.document.selection,
                    n = e.getSelectedElement();
                Rv(n, t.schema) ? this.isEnabled = t.schema.checkAttribute(n, "linkHref") : this.isEnabled = t.schema.checkAttributeInSelection(e, "linkHref")
            }
            execute() {
                const t = this.editor,
                    e = this.editor.model,
                    n = e.document.selection,
                    o = t.commands.get("link");
                e.change((t => {
                    const i = n.isCollapsed ? [kk(n.getFirstPosition(), "linkHref", n.getAttribute("linkHref"), e)] : e.schema.getValidRanges(n.getRanges(), "linkHref");
                    for (const e of i)
                        if (t.removeAttribute("linkHref", e), o)
                            for (const n of o.manualDecorators) t.removeAttribute(n.id, e)
                }))
            }
        }
        class Lv extends(q()) {
            constructor({
                id: t,
                label: e,
                attributes: n,
                classes: o,
                styles: i,
                defaultValue: r
            }) {
                super(), this.id = t, this.set("value", void 0), this.defaultValue = r, this.label = e, this.attributes = n, this.classes = o, this.styles = i
            }
            _createPattern() {
                return {
                    attributes: this.attributes,
                    classes: this.classes,
                    styles: this.styles
                }
            }
        }
        var Hv = n(1134),
            jv = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Hv.Z, jv);
        Hv.Z.locals;
        var qv = Object.defineProperty,
            Wv = Object.getOwnPropertySymbols,
            Uv = Object.prototype.hasOwnProperty,
            $v = Object.prototype.propertyIsEnumerable,
            Gv = (t, e, n) => e in t ? qv(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n,
            Kv = (t, e) => {
                for (var n in e || (e = {})) Uv.call(e, n) && Gv(t, n, e[n]);
                if (Wv)
                    for (var n of Wv(e)) $v.call(e, n) && Gv(t, n, e[n]);
                return t
            };
        const Zv = "automatic",
            Jv = /^(https?:)?\/\//;
        class Yv extends Vi {
            static get pluginName() {
                return "LinkEditing"
            }
            static get requires() {
                return [sk, Kb, Mw]
            }
            constructor(t) {
                super(t), t.config.define("link", {
                    addTargetToExternalLinks: !1
                })
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: "linkHref"
                }), t.conversion.for("dataDowncast").attributeToElement({
                    model: "linkHref",
                    view: Iv
                }), t.conversion.for("editingDowncast").attributeToElement({
                    model: "linkHref",
                    view: (t, e) => Iv(Pv(t), e)
                }), t.conversion.for("upcast").elementToAttribute({
                    view: {
                        name: "a",
                        attributes: {
                            href: !0
                        }
                    },
                    model: {
                        key: "linkHref",
                        value: t => t.getAttribute("href")
                    }
                }), t.commands.add("link", new Fv(t)), t.commands.add("unlink", new Nv(t));
                const e = function(t, e) {
                    const n = {
                        "Open in a new tab": t("Open in a new tab"),
                        Downloadable: t("Downloadable")
                    };
                    return e.forEach((t => ("label" in t && n[t.label] && (t.label = n[t.label]), t))), e
                }(t.t, function(t) {
                    const e = [];
                    if (t)
                        for (const [n, o] of Object.entries(t)) {
                            const t = Object.assign({}, o, {
                                id: `link${xv(n)}`
                            });
                            e.push(t)
                        }
                    return e
                }(t.config.get("link.decorators")));
                this._enableAutomaticDecorators(e.filter((t => t.mode === Zv))), this._enableManualDecorators(e.filter((t => "manual" === t.mode)));
                t.plugins.get(sk).registerAttribute("linkHref"), Ak(t, "linkHref", "a", "ck-link_selected"), this._enableInsertContentSelectionAttributesFixer(), this._enableClickingAfterLink(), this._enableTypingOverLink(), this._handleDeleteContentAfterLink(), this._enableClipboardIntegration()
            }
            _enableAutomaticDecorators(t) {
                const e = this.editor,
                    n = e.commands.get("link").automaticDecorators;
                e.config.get("link.addTargetToExternalLinks") && n.add({
                    id: "linkIsExternal",
                    mode: Zv,
                    callback: t => !!t && Jv.test(t),
                    attributes: {
                        target: "_blank",
                        rel: "noopener noreferrer"
                    }
                }), n.add(t), n.length && e.conversion.for("downcast").add(n.getDispatcher())
            }
            _enableManualDecorators(t) {
                if (!t.length) return;
                const e = this.editor,
                    n = e.commands.get("link").manualDecorators;
                t.forEach((t => {
                    e.model.schema.extend("$text", {
                        allowAttributes: t.id
                    });
                    const o = new Lv(t);
                    n.add(o), e.conversion.for("downcast").attributeToElement({
                        model: o.id,
                        view: (t, {
                            writer: e,
                            schema: n
                        }, {
                            item: i
                        }) => {
                            if ((i.is("selection") || n.isInline(i)) && t) {
                                const t = e.createAttributeElement("a", o.attributes, {
                                    priority: 5
                                });
                                o.classes && e.addClass(o.classes, t);
                                for (const n in o.styles) e.setStyle(n, o.styles[n], t);
                                return e.setCustomProperty("link", !0, t), t
                            }
                        }
                    }), e.conversion.for("upcast").elementToAttribute({
                        view: Kv({
                            name: "a"
                        }, o._createPattern()),
                        model: {
                            key: o.id
                        }
                    })
                }))
            }
            _enableLinkOpen() {
                const t = this.editor,
                    e = t.editing.view.document;
                this.listenTo(e, "click", ((t, e) => {
                    if (!(i.isMac ? e.domEvent.metaKey : e.domEvent.ctrlKey)) return;
                    let n = e.domTarget;
                    if ("a" != n.tagName.toLowerCase() && (n = n.closest("a")), !n) return;
                    const o = n.getAttribute("href");
                    o && (t.stop(), e.preventDefault(), Ov(o))
                }), {
                    context: "$capture"
                }), this.listenTo(e, "keydown", ((e, n) => {
                    const o = t.commands.get("link").value;
                    !!o && n.keyCode === mi.enter && n.altKey && (e.stop(), Ov(o))
                }))
            }
            _enableInsertContentSelectionAttributesFixer() {
                const t = this.editor.model,
                    e = t.document.selection;
                this.listenTo(t, "insertContent", (() => {
                    const n = e.anchor.nodeBefore,
                        o = e.anchor.nodeAfter;
                    e.hasAttribute("linkHref") && n && n.hasAttribute("linkHref") && (o && o.hasAttribute("linkHref") || t.change((e => {
                        Qv(e, ty(t.schema))
                    })))
                }), {
                    priority: "low"
                })
            }
            _enableClickingAfterLink() {
                const t = this.editor,
                    e = t.model;
                t.editing.view.addObserver(lu);
                let n = !1;
                this.listenTo(t.editing.view.document, "mousedown", (() => {
                    n = !0
                })), this.listenTo(t.editing.view.document, "selectionChange", (() => {
                    if (!n) return;
                    n = !1;
                    const t = e.document.selection;
                    if (!t.isCollapsed) return;
                    if (!t.hasAttribute("linkHref")) return;
                    const o = t.getFirstPosition(),
                        i = kk(o, "linkHref", t.getAttribute("linkHref"), e);
                    (o.isTouching(i.start) || o.isTouching(i.end)) && e.change((t => {
                        Qv(t, ty(e.schema))
                    }))
                }))
            }
            _enableTypingOverLink() {
                const t = this.editor,
                    e = t.editing.view;
                let n = null,
                    o = !1;
                this.listenTo(e.document, "delete", (() => {
                    o = !0
                }), {
                    priority: "high"
                }), this.listenTo(t.model, "deleteContent", (() => {
                    const e = t.model.document.selection;
                    e.isCollapsed || (o ? o = !1 : Xv(t) && function(t) {
                        const e = t.document.selection,
                            n = e.getFirstPosition(),
                            o = e.getLastPosition(),
                            i = n.nodeAfter;
                        if (!i) return !1;
                        if (!i.is("$text")) return !1;
                        if (!i.hasAttribute("linkHref")) return !1;
                        const r = o.textNode || o.nodeBefore;
                        if (i === r) return !0;
                        return kk(n, "linkHref", i.getAttribute("linkHref"), t).containsRange(t.createRange(n, o), !0)
                    }(t.model) && (n = e.getAttributes()))
                }), {
                    priority: "high"
                }), this.listenTo(t.model, "insertContent", ((e, [i]) => {
                    o = !1, Xv(t) && n && (t.model.change((t => {
                        for (const [e, o] of n) t.setAttribute(e, o, i)
                    })), n = null)
                }), {
                    priority: "high"
                })
            }
            _handleDeleteContentAfterLink() {
                const t = this.editor,
                    e = t.model,
                    n = e.document.selection,
                    o = t.editing.view;
                let i = !1,
                    r = !1;
                this.listenTo(o.document, "delete", ((t, e) => {
                    r = "backward" === e.direction
                }), {
                    priority: "high"
                }), this.listenTo(e, "deleteContent", (() => {
                    i = !1;
                    const t = n.getFirstPosition(),
                        o = n.getAttribute("linkHref");
                    if (!o) return;
                    const r = kk(t, "linkHref", o, e);
                    i = r.containsPosition(t) || r.end.isEqual(t)
                }), {
                    priority: "high"
                }), this.listenTo(e, "deleteContent", (() => {
                    r && (r = !1, i || t.model.enqueueChange((t => {
                        Qv(t, ty(e.schema))
                    })))
                }), {
                    priority: "low"
                })
            }
            _enableClipboardIntegration() {
                const t = this.editor,
                    e = t.model,
                    n = this.editor.config.get("link.defaultProtocol");
                n && this.listenTo(t.plugins.get("ClipboardPipeline"), "contentInsertion", ((t, o) => {
                    e.change((t => {
                        const e = t.createRangeIn(o.content);
                        for (const o of e.getItems())
                            if (o.hasAttribute("linkHref")) {
                                const e = zv(o.getAttribute("linkHref"), n);
                                t.setAttribute("linkHref", e, o)
                            }
                    }))
                }))
            }
        }

        function Qv(t, e) {
            t.removeSelectionAttribute("linkHref");
            for (const n of e) t.removeSelectionAttribute(n)
        }

        function Xv(t) {
            return t.model.change((t => t.batch)).isTyping
        }

        function ty(t) {
            return t.getDefinition("$text").allowAttributes.filter((t => t.startsWith("link")))
        }
        var ey = n(8117),
            ny = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(ey.Z, ny);
        ey.Z.locals;
        class oy extends cg {
            constructor(t, e) {
                super(t), this.focusTracker = new Di, this.keystrokes = new Si, this._focusables = new sg;
                const n = t.t;
                this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n("Save"), eg.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(n("Cancel"), eg.cancel, "ck-button-cancel", "cancel"), this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e), this.children = this._createFormChildren(e.manualDecorators), this._focusCycler = new wm({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "shift + tab",
                        focusNext: "tab"
                    }
                });
                const o = ["ck", "ck-link-form", "ck-responsive-form"];
                e.manualDecorators.length && o.push("ck-link-form_layout-vertical", "ck-vertical-form"), this.setTemplate({
                    tag: "form",
                    attributes: {
                        class: o,
                        tabindex: "-1"
                    },
                    children: this.children
                })
            }
            getDecoratorSwitchesState() {
                return Array.from(this._manualDecoratorSwitches).reduce(((t, e) => (t[e.name] = e.isOn, t)), {})
            }
            render() {
                super.render(), ig({
                    view: this
                });
                [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView].forEach((t => {
                    this._focusables.add(t), this.focusTracker.add(t.element)
                })), this.keystrokes.listenTo(this.element)
            }
            destroy() {
                super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            _createUrlInput() {
                const t = this.locale.t,
                    e = new sm(this.locale, Jm);
                return e.label = t("Link URL"), e
            }
            _createButton(t, e, n, o) {
                const i = new Mg(this.locale);
                return i.set({
                    label: t,
                    icon: e,
                    tooltip: !0
                }), i.extendTemplate({
                    attributes: {
                        class: n
                    }
                }), o && i.delegate("execute").to(this, o), i
            }
            _createManualDecoratorSwitches(t) {
                const e = this.createCollection();
                for (const n of t.manualDecorators) {
                    const o = new Hg(this.locale);
                    o.set({
                        name: n.id,
                        label: n.label,
                        withText: !0
                    }), o.bind("isOn").toMany([n, t], "value", ((t, e) => void 0 === e && void 0 === t ? !!n.defaultValue : !!t)), o.on("execute", (() => {
                        n.set("value", !o.isOn)
                    })), e.add(o)
                }
                return e
            }
            _createFormChildren(t) {
                const e = this.createCollection();
                if (e.add(this.urlInputView), t.length) {
                    const t = new cg;
                    t.setTemplate({
                        tag: "ul",
                        children: this._manualDecoratorSwitches.map((t => ({
                            tag: "li",
                            children: [t],
                            attributes: {
                                class: ["ck", "ck-list__item"]
                            }
                        }))),
                        attributes: {
                            class: ["ck", "ck-reset", "ck-list"]
                        }
                    }), e.add(t)
                }
                return e.add(this.saveButtonView), e.add(this.cancelButtonView), e
            }
        }
        var iy = n(9376),
            ry = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(iy.Z, ry);
        iy.Z.locals;
        class sy extends cg {
            constructor(t) {
                super(t), this.focusTracker = new Di, this.keystrokes = new Si, this._focusables = new sg;
                const e = t.t;
                this.previewButtonView = this._createPreviewButton(), this.unlinkButtonView = this._createButton(e("Unlink"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>', "unlink"), this.editButtonView = this._createButton(e("Edit link"), eg.pencil, "edit"), this.set("href", void 0), this._focusCycler = new wm({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "shift + tab",
                        focusNext: "tab"
                    }
                }), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-link-actions", "ck-responsive-form"],
                        tabindex: "-1"
                    },
                    children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView]
                })
            }
            render() {
                super.render();
                [this.previewButtonView, this.editButtonView, this.unlinkButtonView].forEach((t => {
                    this._focusables.add(t), this.focusTracker.add(t.element)
                })), this.keystrokes.listenTo(this.element)
            }
            destroy() {
                super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            _createButton(t, e, n) {
                const o = new Mg(this.locale);
                return o.set({
                    label: t,
                    icon: e,
                    tooltip: !0
                }), o.delegate("execute").to(this, n), o
            }
            _createPreviewButton() {
                const t = new Mg(this.locale),
                    e = this.bindTemplate,
                    n = this.t;
                return t.set({
                    withText: !0,
                    tooltip: n("Open link in new tab")
                }), t.extendTemplate({
                    attributes: {
                        class: ["ck", "ck-link-actions__preview"],
                        href: e.to("href", (t => t && Pv(t))),
                        target: "_blank",
                        rel: "noopener noreferrer"
                    }
                }), t.bind("label").to(this, "href", (t => t || n("This link has no URL"))), t.bind("isEnabled").to(this, "href", (t => !!t)), t.template.tag = "a", t.template.eventListeners = {}, t
            }
        }
        const ay = "link-ui";
        class ly extends Vi {
            constructor() {
                super(...arguments), this.actionsView = null, this.formView = null
            }
            static get requires() {
                return [jf]
            }
            static get pluginName() {
                return "LinkUI"
            }
            init() {
                const t = this.editor;
                t.editing.view.addObserver(au), this._balloon = t.plugins.get(jf), this._createToolbarLinkButton(), this._enableBalloonActivators(), t.conversion.for("editingDowncast").markerToHighlight({
                    model: ay,
                    view: {
                        classes: ["ck-fake-link-selection"]
                    }
                }), t.conversion.for("editingDowncast").markerToElement({
                    model: ay,
                    view: {
                        name: "span",
                        classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"]
                    }
                })
            }
            destroy() {
                super.destroy(), this.formView && this.formView.destroy(), this.actionsView && this.actionsView.destroy()
            }
            _createViews() {
                this.actionsView = this._createActionsView(), this.formView = this._createFormView(), this._enableUserBalloonInteractions()
            }
            _createActionsView() {
                const t = this.editor,
                    e = new sy(t.locale),
                    n = t.commands.get("link"),
                    o = t.commands.get("unlink");
                return e.bind("href").to(n, "value"), e.editButtonView.bind("isEnabled").to(n), e.unlinkButtonView.bind("isEnabled").to(o), this.listenTo(e, "edit", (() => {
                    this._addFormView()
                })), this.listenTo(e, "unlink", (() => {
                    t.execute("unlink"), this._hideUI()
                })), e.keystrokes.set("Esc", ((t, e) => {
                    this._hideUI(), e()
                })), e.keystrokes.set(Bv, ((t, e) => {
                    this._addFormView(), e()
                })), e
            }
            _createFormView() {
                const t = this.editor,
                    e = t.commands.get("link"),
                    n = t.config.get("link.defaultProtocol"),
                    o = new(og(oy))(t.locale, e);
                return o.urlInputView.fieldView.bind("value").to(e, "value"), o.urlInputView.bind("isEnabled").to(e, "isEnabled"), o.saveButtonView.bind("isEnabled").to(e), this.listenTo(o, "submit", (() => {
                    const {
                        value: e
                    } = o.urlInputView.fieldView.element, i = zv(e, n);
                    t.execute("link", i, o.getDecoratorSwitchesState()), this._closeFormView()
                })), this.listenTo(o, "cancel", (() => {
                    this._closeFormView()
                })), o.keystrokes.set("Esc", ((t, e) => {
                    this._closeFormView(), e()
                })), o
            }
            _createToolbarLinkButton() {
                const t = this.editor,
                    e = t.commands.get("link"),
                    n = t.t;
                t.ui.componentFactory.add("link", (t => {
                    const o = new Mg(t);
                    return o.isEnabled = !0, o.label = n("Link"), o.icon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>', o.keystroke = Bv, o.tooltip = !0, o.isToggleable = !0, o.bind("isEnabled").to(e, "isEnabled"), o.bind("isOn").to(e, "value", (t => !!t)), this.listenTo(o, "execute", (() => this._showUI(!0))), o
                }))
            }
            _enableBalloonActivators() {
                const t = this.editor,
                    e = t.editing.view.document;
                this.listenTo(e, "click", (() => {
                    this._getSelectedLinkElement() && this._showUI()
                })), t.keystrokes.set(Bv, ((e, n) => {
                    n(), t.commands.get("link").isEnabled && this._showUI(!0)
                }))
            }
            _enableUserBalloonInteractions() {
                this.editor.keystrokes.set("Tab", ((t, e) => {
                    this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(), e())
                }), {
                    priority: "high"
                }), this.editor.keystrokes.set("Esc", ((t, e) => {
                    this._isUIVisible && (this._hideUI(), e())
                })), ng({
                    emitter: this.formView,
                    activator: () => this._isUIInPanel,
                    contextElements: () => [this._balloon.view.element],
                    callback: () => this._hideUI()
                })
            }
            _addActionsView() {
                this.actionsView || this._createViews(), this._areActionsInPanel || this._balloon.add({
                    view: this.actionsView,
                    position: this._getBalloonPositionData()
                })
            }
            _addFormView() {
                if (this.formView || this._createViews(), this._isFormInPanel) return;
                const t = this.editor.commands.get("link");
                this.formView.disableCssTransitions(), this._balloon.add({
                    view: this.formView,
                    position: this._getBalloonPositionData()
                }), this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions(), this.formView.urlInputView.fieldView.element.value = t.value || ""
            }
            _closeFormView() {
                const t = this.editor.commands.get("link");
                t.restoreManualDecoratorStates(), void 0 !== t.value ? this._removeFormView() : this._hideUI()
            }
            _removeFormView() {
                this._isFormInPanel && (this.formView.saveButtonView.focus(), this._balloon.remove(this.formView), this.editor.editing.view.focus(), this._hideFakeVisualSelection())
            }
            _showUI(t = !1) {
                this.formView || this._createViews(), this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(), t && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addActionsView(), t && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI()
            }
            _hideUI() {
                if (!this._isUIInPanel) return;
                const t = this.editor;
                this.stopListening(t.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), t.editing.view.focus(), this._removeFormView(), this._balloon.remove(this.actionsView), this._hideFakeVisualSelection()
            }
            _startUpdatingUI() {
                const t = this.editor,
                    e = t.editing.view.document;
                let n = this._getSelectedLinkElement(),
                    o = r();
                const i = () => {
                    const t = this._getSelectedLinkElement(),
                        e = r();
                    n && !t || !n && e !== o ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), n = t, o = e
                };

                function r() {
                    return e.selection.focus.getAncestors().reverse().find((t => t.is("element")))
                }
                this.listenTo(t.ui, "update", i), this.listenTo(this._balloon, "change:visibleView", i)
            }
            get _isFormInPanel() {
                return !!this.formView && this._balloon.hasView(this.formView)
            }
            get _areActionsInPanel() {
                return !!this.actionsView && this._balloon.hasView(this.actionsView)
            }
            get _areActionsVisible() {
                return !!this.actionsView && this._balloon.visibleView === this.actionsView
            }
            get _isUIInPanel() {
                return this._isFormInPanel || this._areActionsInPanel
            }
            get _isUIVisible() {
                const t = this._balloon.visibleView;
                return !!this.formView && t == this.formView || this._areActionsVisible
            }
            _getBalloonPositionData() {
                const t = this.editor.editing.view,
                    e = this.editor.model,
                    n = t.document;
                let o;
                if (e.markers.has(ay)) {
                    const e = Array.from(this.editor.editing.mapper.markerNameToElements(ay)),
                        n = t.createRange(t.createPositionBefore(e[0]), t.createPositionAfter(e[e.length - 1]));
                    o = t.domConverter.viewRangeToDom(n)
                } else o = () => {
                    const e = this._getSelectedLinkElement();
                    return e ? t.domConverter.mapViewToDom(e) : t.domConverter.viewRangeToDom(n.selection.getFirstRange())
                };
                return {
                    target: o
                }
            }
            _getSelectedLinkElement() {
                const t = this.editor.editing.view,
                    e = t.document.selection,
                    n = e.getSelectedElement();
                if (e.isCollapsed || n && $w(n)) return cy(e.getFirstPosition());
                {
                    const n = e.getFirstRange().getTrimmed(),
                        o = cy(n.start),
                        i = cy(n.end);
                    return o && o == i && t.createRangeIn(o).getTrimmed().isEqual(n) ? o : null
                }
            }
            _showFakeVisualSelection() {
                const t = this.editor.model;
                t.change((e => {
                    const n = t.document.selection.getFirstRange();
                    if (t.markers.has(ay)) e.updateMarker(ay, {
                        range: n
                    });
                    else if (n.start.isAtEnd) {
                        const o = n.start.getLastMatchingPosition((({
                            item: e
                        }) => !t.schema.isContent(e)), {
                            boundaries: n
                        });
                        e.addMarker(ay, {
                            usingOperation: !1,
                            affectsData: !1,
                            range: e.createRange(o, n.end)
                        })
                    } else e.addMarker(ay, {
                        usingOperation: !1,
                        affectsData: !1,
                        range: n
                    })
                }))
            }
            _hideFakeVisualSelection() {
                const t = this.editor.model;
                t.markers.has(ay) && t.change((t => {
                    t.removeMarker(ay)
                }))
            }
        }

        function cy(t) {
            return t.getAncestors().find((t => {
                return (e = t).is("attributeElement") && !!e.getCustomProperty("link");
                var e
            })) || null
        }
        const dy = new RegExp("(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$", "i");
        class hy extends Vi {
            static get requires() {
                return [ok]
            }
            static get pluginName() {
                return "AutoLink"
            }
            init() {
                const t = this.editor.model.document.selection;
                t.on("change:range", (() => {
                    this.isEnabled = !t.anchor.parent.is("element", "codeBlock")
                })), this._enableTypingHandling()
            }
            afterInit() {
                this._enableEnterHandling(), this._enableShiftEnterHandling()
            }
            _enableTypingHandling() {
                const t = this.editor,
                    e = new rk(t.model, (t => {
                        if (! function(t) {
                                return t.length > 4 && " " === t[t.length - 1] && " " !== t[t.length - 2]
                            }(t)) return;
                        const e = uy(t.substr(0, t.length - 1));
                        return e ? {
                            url: e
                        } : void 0
                    }));
                e.on("matched:data", ((e, n) => {
                    const {
                        batch: o,
                        range: i,
                        url: r
                    } = n;
                    if (!o.isTyping) return;
                    const s = i.end.getShiftedBy(-1),
                        a = s.getShiftedBy(-r.length),
                        l = t.model.createRange(a, s);
                    this._applyAutoLink(r, l)
                })), e.bind("isEnabled").to(this)
            }
            _enableEnterHandling() {
                const t = this.editor,
                    e = t.model,
                    n = t.commands.get("enter");
                n && n.on("execute", (() => {
                    const t = e.document.selection.getFirstPosition();
                    if (!t.parent.previousSibling) return;
                    const n = e.createRangeIn(t.parent.previousSibling);
                    this._checkAndApplyAutoLinkOnRange(n)
                }))
            }
            _enableShiftEnterHandling() {
                const t = this.editor,
                    e = t.model,
                    n = t.commands.get("shiftEnter");
                n && n.on("execute", (() => {
                    const t = e.document.selection.getFirstPosition(),
                        n = e.createRange(e.createPositionAt(t.parent, 0), t.getShiftedBy(-1));
                    this._checkAndApplyAutoLinkOnRange(n)
                }))
            }
            _checkAndApplyAutoLinkOnRange(t) {
                const e = this.editor.model,
                    {
                        text: n,
                        range: o
                    } = ik(t, e),
                    i = uy(n);
                if (i) {
                    const t = e.createRange(o.end.getShiftedBy(-i.length), o.end);
                    this._applyAutoLink(i, t)
                }
            }
            _applyAutoLink(t, e) {
                const n = this.editor.model,
                    o = zv(t, this.editor.config.get("link.defaultProtocol"));
                this.isEnabled && function(t, e) {
                    return e.schema.checkAttributeInSelection(e.createSelection(t), "linkHref")
                }(e, n) && Vv(o) && ! function(t) {
                    const e = t.start.nodeAfter;
                    return !!e && e.hasAttribute("linkHref")
                }(e) && this._persistAutoLink(o, e)
            }
            _persistAutoLink(t, e) {
                const n = this.editor.model,
                    o = this.editor.plugins.get("Delete");
                n.enqueueChange((i => {
                    i.setAttribute("linkHref", t, e), n.enqueueChange((() => {
                        o.requestUndoOnBackspace()
                    }))
                }))
            }
        }

        function uy(t) {
            const e = dy.exec(t);
            return e ? e[2] : null
        }
        var gy = n(3088),
            my = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(gy.Z, my);
        gy.Z.locals;
        class py {
            constructor(t, e) {
                this._startElement = t, this._referenceIndent = t.getAttribute("listIndent"), this._isForward = "forward" == e.direction, this._includeSelf = !!e.includeSelf, this._sameAttributes = toArray(e.sameAttributes || []), this._sameIndent = !!e.sameIndent, this._lowerIndent = !!e.lowerIndent, this._higherIndent = !!e.higherIndent
            }
            static first(t, e) {
                const n = new this(t, e)[Symbol.iterator]();
                return first(n)
            }*[Symbol.iterator]() {
                const t = [];
                for (const {
                        node: e
                    }
                    of fy(this._getStartNode(), this._isForward ? "forward" : "backward")) {
                    const n = e.getAttribute("listIndent");
                    if (n < this._referenceIndent) {
                        if (!this._lowerIndent) break;
                        this._referenceIndent = n
                    } else if (n > this._referenceIndent) {
                        if (!this._higherIndent) continue;
                        if (!this._isForward) {
                            t.push(e);
                            continue
                        }
                    } else {
                        if (!this._sameIndent) {
                            if (this._higherIndent) {
                                t.length && (yield* t, t.length = 0);
                                break
                            }
                            continue
                        }
                        if (this._sameAttributes.some((t => e.getAttribute(t) !== this._startElement.getAttribute(t)))) break
                    }
                    t.length && (yield* t, t.length = 0), yield e
                }
            }
            _getStartNode() {
                return this._includeSelf ? this._startElement : this._isForward ? this._startElement.nextSibling : this._startElement.previousSibling
            }
        }

        function* fy(t, e = "forward") {
            const n = "forward" == e;
            let o = null;
            for (; isListItemBlock(t);) yield {
                node: t,
                previous: o
            }, o = t, t = n ? t.nextSibling : t.previousSibling
        }
        class by {
            constructor(t) {
                this._listHead = t
            } [Symbol.iterator]() {
                return fy(this._listHead, "forward")
            }
        }
        Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable;
        var ky = n(5730),
            wy = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(ky.Z, wy);
        ky.Z.locals;
        var Ay = n(4564),
            Cy = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Ay.Z, Cy);
        Ay.Z.locals;

        function _y(t, e) {
            const n = e.mapper,
                o = e.writer,
                i = "numbered" == t.getAttribute("listType") ? "ol" : "ul",
                r = function(t) {
                    const e = t.createContainerElement("li");
                    return e.getFillerOffset = zy, e
                }(o),
                s = o.createContainerElement(i, null);
            return o.insert(o.createPositionAt(s, 0), r), n.bindElements(t, r), r
        }

        function vy(t, e, n, o) {
            const i = e.parent,
                r = n.mapper,
                s = n.writer;
            let a = r.toViewPosition(o.createPositionBefore(t));
            const l = Ey(t.previousSibling, {
                    sameIndent: !0,
                    smallerIndent: !0,
                    listIndent: t.getAttribute("listIndent")
                }),
                c = t.previousSibling;
            if (l && l.getAttribute("listIndent") == t.getAttribute("listIndent")) {
                const t = r.toViewElement(l);
                a = s.breakContainer(s.createPositionAfter(t))
            } else if (c && "listItem" == c.name) {
                a = r.toViewPosition(o.createPositionAt(c, "end"));
                const t = r.findMappedViewAncestor(a),
                    e = Sy(t);
                a = e ? s.createPositionBefore(e) : s.createPositionAt(t, "end")
            } else a = r.toViewPosition(o.createPositionBefore(t));
            if (a = xy(a), s.insert(a, i), c && "listItem" == c.name) {
                const t = r.toViewElement(c),
                    n = s.createRange(s.createPositionAt(t, 0), a).getWalker({
                        ignoreElementEnd: !0
                    });
                for (const t of n)
                    if (t.item.is("element", "li")) {
                        const o = s.breakContainer(s.createPositionBefore(t.item)),
                            i = t.item.parent,
                            r = s.createPositionAt(e, "end");
                        yy(s, r.nodeBefore, r.nodeAfter), s.move(s.createRangeOn(i), r), n._position = o
                    }
            } else {
                const n = i.nextSibling;
                if (n && (n.is("element", "ul") || n.is("element", "ol"))) {
                    let o = null;
                    for (const e of n.getChildren()) {
                        const n = r.toModelElement(e);
                        if (!(n && n.getAttribute("listIndent") > t.getAttribute("listIndent"))) break;
                        o = e
                    }
                    o && (s.breakContainer(s.createPositionAfter(o)), s.move(s.createRangeOn(o.parent), s.createPositionAt(e, "end")))
                }
            }
            yy(s, i, i.nextSibling), yy(s, i.previousSibling, i)
        }

        function yy(t, e, n) {
            return !e || !n || "ul" != e.name && "ol" != e.name || e.name != n.name || e.getAttribute("class") !== n.getAttribute("class") ? null : t.mergeContainers(t.createPositionAfter(e))
        }

        function xy(t) {
            return t.getLastMatchingPosition((t => t.item.is("uiElement")))
        }

        function Ey(t, e) {
            const n = !!e.sameIndent,
                o = !!e.smallerIndent,
                i = e.listIndent;
            let r = t;
            for (; r && "listItem" == r.name;) {
                const t = r.getAttribute("listIndent");
                if (n && i == t || o && i > t) return r;
                r = "forward" === e.direction ? r.nextSibling : r.previousSibling
            }
            return null
        }

        function Dy(t, e, n, o) {
            t.ui.componentFactory.add(e, (i => {
                const r = t.commands.get(e),
                    s = new Mg(i);
                return s.set({
                    label: n,
                    icon: o,
                    tooltip: !0,
                    isToggleable: !0
                }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), s.on("execute", (() => {
                    t.execute(e), t.editing.view.focus()
                })), s
            }))
        }

        function Sy(t) {
            for (const e of t.getChildren())
                if ("ul" == e.name || "ol" == e.name) return e;
            return null
        }

        function Ty(t, e) {
            const n = [],
                o = t.parent,
                i = {
                    ignoreElementEnd: !1,
                    startPosition: t,
                    shallow: !0,
                    direction: e
                },
                r = o.getAttribute("listIndent"),
                s = [...new yl(i)].filter((t => t.item.is("element"))).map((t => t.item));
            for (const t of s) {
                if (!t.is("element", "listItem")) break;
                if (t.getAttribute("listIndent") < r) break;
                if (!(t.getAttribute("listIndent") > r)) {
                    if (t.getAttribute("listType") !== o.getAttribute("listType")) break;
                    if (t.getAttribute("listStyle") !== o.getAttribute("listStyle")) break;
                    if (t.getAttribute("listReversed") !== o.getAttribute("listReversed")) break;
                    if (t.getAttribute("listStart") !== o.getAttribute("listStart")) break;
                    "backward" === e ? n.unshift(t) : n.push(t)
                }
            }
            return n
        }

        function By(t) {
            let e = [...t.document.selection.getSelectedBlocks()].filter((t => t.is("element", "listItem"))).map((e => {
                const n = t.change((t => t.createPositionAt(e, 0)));
                return [...Ty(n, "backward"), ...Ty(n, "forward")]
            })).flat();
            return e = [...new Set(e)], e
        }
        const Iy = ["disc", "circle", "square"],
            Py = ["decimal", "decimal-leading-zero", "lower-roman", "upper-roman", "lower-latin", "upper-latin"];

        function Ry(t) {
            return Iy.includes(t) ? "bulleted" : Py.includes(t) ? "numbered" : null
        }

        function zy() {
            const t = !this.isEmpty && ("ul" == this.getChild(0).name || "ol" == this.getChild(0).name);
            return this.isEmpty || t ? 0 : ls.call(this)
        }
        const Vy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>',
            Oy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>';
        class Fy extends Vi {
            static get pluginName() {
                return "ListUI"
            }
            init() {
                const t = this.editor.t;
                Dy(this.editor, "numberedList", t("Numbered List"), Vy), Dy(this.editor, "bulletedList", t("Bulleted List"), Oy)
            }
        }
        const My = {},
            Ny = {},
            Ly = {},
            Hy = [{
                listStyle: "disc",
                typeAttribute: "disc",
                listType: "bulleted"
            }, {
                listStyle: "circle",
                typeAttribute: "circle",
                listType: "bulleted"
            }, {
                listStyle: "square",
                typeAttribute: "square",
                listType: "bulleted"
            }, {
                listStyle: "decimal",
                typeAttribute: "1",
                listType: "numbered"
            }, {
                listStyle: "decimal-leading-zero",
                typeAttribute: null,
                listType: "numbered"
            }, {
                listStyle: "lower-roman",
                typeAttribute: "i",
                listType: "numbered"
            }, {
                listStyle: "upper-roman",
                typeAttribute: "I",
                listType: "numbered"
            }, {
                listStyle: "lower-alpha",
                typeAttribute: "a",
                listType: "numbered"
            }, {
                listStyle: "upper-alpha",
                typeAttribute: "A",
                listType: "numbered"
            }, {
                listStyle: "lower-latin",
                typeAttribute: "a",
                listType: "numbered"
            }, {
                listStyle: "upper-latin",
                typeAttribute: "A",
                listType: "numbered"
            }];
        for (const {
                listStyle: t,
                typeAttribute: e,
                listType: n
            }
            of Hy) My[t] = n, Ny[t] = e, e && (Ly[e] = t);
        var jy = n(4721),
            qy = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(jy.Z, qy);
        jy.Z.locals;
        class Wy extends cg {
            constructor(t, e) {
                super(t);
                const n = this.bindTemplate;
                this.set("isCollapsed", !1), this.set("label", ""), this.buttonView = this._createButtonView(), this.children = this.createCollection(), this.set("_collapsibleAriaLabelUid", void 0), e && this.children.addMany(e), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-collapsible", n.if("isCollapsed", "ck-collapsible_collapsed")]
                    },
                    children: [this.buttonView, {
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-collapsible__children"],
                            role: "region",
                            hidden: n.if("isCollapsed", "hidden"),
                            "aria-labelledby": n.to("_collapsibleAriaLabelUid")
                        },
                        children: this.children
                    }]
                })
            }
            render() {
                super.render(), this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id
            }
            _createButtonView() {
                const t = new Mg(this.locale),
                    e = t.bindTemplate;
                return t.set({
                    withText: !0,
                    icon: bm
                }), t.extendTemplate({
                    attributes: {
                        "aria-expanded": e.to("isOn", (t => String(t)))
                    }
                }), t.bind("label").to(this), t.bind("isOn").to(this, "isCollapsed", (t => !t)), t.on("execute", (() => {
                    this.isCollapsed = !this.isCollapsed
                })), t
            }
        }
        var Uy = n(6082),
            $y = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Uy.Z, $y);
        Uy.Z.locals;
        class Gy extends cg {
            constructor(t, {
                enabledProperties: e,
                styleButtonViews: n,
                styleGridAriaLabel: o
            }) {
                super(t), this.stylesView = null, this.additionalPropertiesCollapsibleView = null, this.startIndexFieldView = null, this.reversedSwitchButtonView = null, this.focusTracker = new Di, this.keystrokes = new Si, this.focusables = new sg;
                const i = ["ck", "ck-list-properties"];
                this.children = this.createCollection(), this.focusCycler = new wm({
                    focusables: this.focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "shift + tab",
                        focusNext: "tab"
                    }
                }), e.styles ? (this.stylesView = this._createStylesView(n, o), this.children.add(this.stylesView)) : i.push("ck-list-properties_without-styles"), (e.startIndex || e.reversed) && (this._addNumberedListPropertyViews(e), i.push("ck-list-properties_with-numbered-properties")), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: i
                    },
                    children: this.children
                })
            }
            render() {
                if (super.render(), this.stylesView) {
                    this.focusables.add(this.stylesView), this.focusTracker.add(this.stylesView.element), (this.startIndexFieldView || this.reversedSwitchButtonView) && (this.focusables.add(this.children.last.buttonView), this.focusTracker.add(this.children.last.buttonView.element));
                    for (const t of this.stylesView.children) this.stylesView.focusTracker.add(t.element);
                    rg({
                        keystrokeHandler: this.stylesView.keystrokes,
                        focusTracker: this.stylesView.focusTracker,
                        gridItems: this.stylesView.children,
                        numberOfColumns: () => Po.window.getComputedStyle(this.stylesView.element).getPropertyValue("grid-template-columns").split(" ").length,
                        uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
                    })
                }
                if (this.startIndexFieldView) {
                    this.focusables.add(this.startIndexFieldView), this.focusTracker.add(this.startIndexFieldView.element);
                    const t = t => t.stopPropagation();
                    this.keystrokes.set("arrowright", t), this.keystrokes.set("arrowleft", t), this.keystrokes.set("arrowup", t), this.keystrokes.set("arrowdown", t)
                }
                this.reversedSwitchButtonView && (this.focusables.add(this.reversedSwitchButtonView), this.focusTracker.add(this.reversedSwitchButtonView.element)), this.keystrokes.listenTo(this.element)
            }
            focus() {
                this.focusCycler.focusFirst()
            }
            focusLast() {
                this.focusCycler.focusLast()
            }
            destroy() {
                super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
            }
            _createStylesView(t, e) {
                const n = new cg(this.locale);
                return n.children = n.createCollection(), n.children.addMany(t), n.setTemplate({
                    tag: "div",
                    attributes: {
                        "aria-label": e,
                        class: ["ck", "ck-list-styles-list"]
                    },
                    children: n.children
                }), n.children.delegate("execute").to(this), n.focus = function() {
                    this.children.first.focus()
                }, n.focusTracker = new Di, n.keystrokes = new Si, n.render(), n.keystrokes.listenTo(n.element), n
            }
            _addNumberedListPropertyViews(t) {
                const e = this.locale.t,
                    n = [];
                t.startIndex && (this.startIndexFieldView = this._createStartIndexField(), n.push(this.startIndexFieldView)), t.reversed && (this.reversedSwitchButtonView = this._createReversedSwitchButton(), n.push(this.reversedSwitchButtonView)), t.styles ? (this.additionalPropertiesCollapsibleView = new Wy(this.locale, n), this.additionalPropertiesCollapsibleView.set({
                    label: e("List properties"),
                    isCollapsed: !0
                }), this.additionalPropertiesCollapsibleView.buttonView.bind("isEnabled").toMany(n, "isEnabled", ((...t) => t.some((t => t)))), this.additionalPropertiesCollapsibleView.buttonView.on("change:isEnabled", ((t, e, n) => {
                    n || (this.additionalPropertiesCollapsibleView.isCollapsed = !0)
                })), this.children.add(this.additionalPropertiesCollapsibleView)) : this.children.addMany(n)
            }
            _createStartIndexField() {
                const t = this.locale.t,
                    e = new sm(this.locale, Ym);
                return e.set({
                    label: t("Start at"),
                    class: "ck-numbered-list-properties__start-index"
                }), e.fieldView.set({
                    min: 0,
                    step: 1,
                    value: 1,
                    inputMode: "numeric"
                }), e.fieldView.on("input", (() => {
                    const n = e.fieldView.element,
                        o = n.valueAsNumber;
                    Number.isNaN(o) || (n.checkValidity() ? this.fire("listStart", {
                        startIndex: o
                    }) : e.errorText = t("Start index must be greater than 0."))
                })), e
            }
            _createReversedSwitchButton() {
                const t = this.locale.t,
                    e = new Hg(this.locale);
                return e.set({
                    withText: !0,
                    label: t("Reversed order"),
                    class: "ck-numbered-list-properties__reversed-order"
                }), e.delegate("execute").to(this, "listReversed"), e
            }
        }
        var Ky = n(2417),
            Zy = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Ky.Z, Zy);
        Ky.Z.locals;
        class Jy extends Vi {
            static get pluginName() {
                return "ListPropertiesUI"
            }
            init() {
                const t = this.editor,
                    e = t.locale.t,
                    n = t.config.get("list.properties");
                n.styles && t.ui.componentFactory.add("bulletedList", Yy({
                    editor: t,
                    parentCommandName: "bulletedList",
                    buttonLabel: e("Bulleted List"),
                    buttonIcon: Oy,
                    styleGridAriaLabel: e("Bulleted list styles toolbar"),
                    styleDefinitions: [{
                        label: e("Toggle the disc list style"),
                        tooltip: e("Disc"),
                        type: "disc",
                        icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6z"/></svg>'
                    }, {
                        label: e("Toggle the circle list style"),
                        tooltip: e("Circle"),
                        type: "circle",
                        icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4z"/></svg>'
                    }, {
                        label: e("Toggle the square list style"),
                        tooltip: e("Square"),
                        type: "square",
                        icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M14 27v6H8v-6h6zm0-9v6H8v-6h6zm0-9v6H8V9h6z"/></svg>'
                    }]
                })), (n.styles || n.startIndex || n.reversed) && t.ui.componentFactory.add("numberedList", Yy({
                    editor: t,
                    parentCommandName: "numberedList",
                    buttonLabel: e("Numbered List"),
                    buttonIcon: Vy,
                    styleGridAriaLabel: e("Numbered list styles toolbar"),
                    styleDefinitions: [{
                        label: e("Toggle the decimal list style"),
                        tooltip: e("Decimal"),
                        type: "decimal",
                        icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M10.29 15V8.531H9.286c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.343 0v-1.235h-1.235V15h1.235zM11.3 24v-1.147H8.848c.064-.111.148-.226.252-.343.104-.117.351-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.494-.824.104-.263.156-.539.156-.829 0-.51-.182-.936-.545-1.279-.363-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.153-.155.358-.233.616-.233.26 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.468.536-1.024 1.055-.692.641-1.155 1.156-1.389 1.544-.234.389-.375.8-.422 1.233H11.3zm2.333 0v-1.235h-1.235V24h1.235zM9.204 34.11c.615 0 1.129-.2 1.542-.598.413-.398.62-.88.62-1.446 0-.39-.11-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.619-.337.928-.788.928-1.353 0-.399-.151-.756-.453-1.073-.366-.386-.852-.58-1.459-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.668.55c-.16.232-.28.544-.358.933l1.138.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.215 0 .386.065.515.194s.193.302.193.518c0 .255-.087.46-.263.613-.176.154-.43.227-.765.218l-.136 1.006c.22-.061.409-.092.567-.092.24 0 .444.09.61.272.168.182.251.428.251.739 0 .328-.087.589-.261.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.307-.698l-1.196.145c.062.542.285.98.668 1.316.384.335.868.503 1.45.503zm4.43-.11v-1.235h-1.236V34h1.235z"/></svg>'
                    }, {
                        label: e("Toggle the decimal with leading zero list style"),
                        tooltip: e("Decimal with leading zero"),
                        type: "decimal-leading-zero",
                        icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M5.714 15.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm6.078.914V8.531H10.79c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.344 0v-1.235h-1.235V15h1.235zm-9.422 9.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm7.088.914v-1.147H10.35c.065-.111.149-.226.253-.343.104-.117.35-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.493-.824.104-.263.156-.539.156-.829 0-.51-.181-.936-.544-1.279-.364-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.152-.155.357-.233.615-.233.261 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.467.536-1.024 1.055-.691.641-1.154 1.156-1.388 1.544-.235.389-.375.8-.422 1.233h4.328zm2.334 0v-1.235h-1.235V24h1.235zM5.714 34.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm4.992 1.024c.616 0 1.13-.2 1.543-.598.413-.398.62-.88.62-1.446 0-.39-.111-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.618-.337.927-.788.927-1.353 0-.399-.15-.756-.452-1.073-.366-.386-.853-.58-1.46-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.667.55c-.16.232-.28.544-.359.933l1.139.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.214 0 .386.065.515.194s.193.302.193.518c0 .255-.088.46-.264.613-.175.154-.43.227-.764.218l-.136 1.006c.22-.061.408-.092.566-.092.24 0 .444.09.611.272.167.182.25.428.25.739 0 .328-.086.589-.26.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.308-.698l-1.195.145c.062.542.284.98.668 1.316.384.335.867.503 1.45.503zm4.43-.11v-1.235h-1.235V34h1.235z"/></svg>'
                    }, {
                        label: e("Toggle the lower–roman list style"),
                        tooltip: e("Lower–roman"),
                        type: "lower-roman",
                        icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.88 8.7V7.558h-1.234V8.7h1.234zm0 5.3V9.333h-1.234V14h1.234zm2.5 0v-1.235h-1.234V14h1.235zm-4.75 4.7v-1.142H8.395V18.7H9.63zm0 5.3v-4.667H8.395V24H9.63zm2.5-5.3v-1.142h-1.234V18.7h1.235zm0 5.3v-4.667h-1.234V24h1.235zm2.501 0v-1.235h-1.235V24h1.235zM7.38 28.7v-1.142H6.145V28.7H7.38zm0 5.3v-4.667H6.145V34H7.38zm2.5-5.3v-1.142H8.646V28.7H9.88zm0 5.3v-4.667H8.646V34H9.88zm2.5-5.3v-1.142h-1.234V28.7h1.235zm0 5.3v-4.667h-1.234V34h1.235zm2.501 0v-1.235h-1.235V34h1.235z"/></svg>'
                    }, {
                        label: e("Toggle the upper–roman list style"),
                        tooltip: e("Upper-roman"),
                        type: "upper-roman",
                        icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.916 15V8.558h-1.301V15h1.3zm2.465 0v-1.235h-1.235V15h1.235zM9.665 25v-6.442h-1.3V25h1.3zm2.5 0v-6.442h-1.3V25h1.3zm2.466 0v-1.235h-1.235V25h1.235zm-7.216 9v-6.442h-1.3V34h1.3zm2.5 0v-6.442h-1.3V34h1.3zm2.501 0v-6.442h-1.3V34h1.3zm2.465 0v-1.235h-1.235V34h1.235z"/></svg>'
                    }, {
                        label: e("Toggle the lower–latin list style"),
                        tooltip: e("Lower-latin"),
                        type: "lower-latin",
                        icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M9.62 14.105c.272 0 .528-.05.768-.153s.466-.257.677-.462c.009.024.023.072.044.145.047.161.086.283.119.365h1.221a2.649 2.649 0 0 1-.222-.626c-.04-.195-.059-.498-.059-.908l.013-1.441c0-.536-.055-.905-.165-1.105-.11-.201-.3-.367-.569-.497-.27-.13-.68-.195-1.23-.195-.607 0-1.064.108-1.371.325-.308.217-.525.55-.65 1.002l1.12.202c.076-.217.176-.369.299-.455.123-.086.294-.13.514-.13.325 0 .546.05.663.152.118.101.176.27.176.508v.123c-.222.093-.622.194-1.2.303-.427.082-.755.178-.982.288-.227.11-.403.268-.53.474a1.327 1.327 0 0 0-.188.706c0 .398.138.728.415.988.277.261.656.391 1.136.391zm.368-.87a.675.675 0 0 1-.492-.189.606.606 0 0 1-.193-.448c0-.176.08-.32.241-.435.106-.07.33-.142.673-.215a7.19 7.19 0 0 0 .751-.19v.247c0 .296-.016.496-.048.602a.773.773 0 0 1-.295.409 1.07 1.07 0 0 1-.637.22zm4.645.765v-1.235h-1.235V14h1.235zM10.2 25.105c.542 0 1.003-.215 1.382-.646.38-.43.57-1.044.57-1.84 0-.771-.187-1.362-.559-1.774a1.82 1.82 0 0 0-1.41-.617c-.522 0-.973.216-1.354.65v-2.32H7.594V25h1.147v-.686a1.9 1.9 0 0 0 .67.592c.26.133.523.2.79.2zm-.299-.975c-.354 0-.638-.164-.852-.492-.153-.232-.229-.59-.229-1.073 0-.468.098-.818.295-1.048a.93.93 0 0 1 .738-.345c.302 0 .55.118.743.354.193.236.29.62.29 1.154 0 .5-.096.868-.288 1.1-.192.233-.424.35-.697.35zm4.478.87v-1.235h-1.234V25h1.234zm-4.017 9.105c.6 0 1.08-.142 1.437-.426.357-.284.599-.704.725-1.261l-1.213-.207c-.061.326-.167.555-.316.688a.832.832 0 0 1-.576.2.916.916 0 0 1-.75-.343c-.185-.228-.278-.62-.278-1.173 0-.498.091-.853.274-1.066.183-.212.429-.318.736-.318.232 0 .42.061.565.184.145.123.238.306.28.55l1.216-.22c-.146-.501-.387-.874-.722-1.119-.336-.244-.788-.366-1.356-.366-.695 0-1.245.214-1.653.643-.407.43-.61 1.03-.61 1.8 0 .762.202 1.358.608 1.788.406.431.95.646 1.633.646zM14.633 34v-1.235h-1.235V34h1.235z"/></svg>'
                    }, {
                        label: e("Toggle the upper–latin list style"),
                        tooltip: e("Upper-latin"),
                        type: "upper-latin",
                        icon: '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="m7.88 15 .532-1.463h2.575L11.549 15h1.415l-2.58-6.442H9.01L6.5 15h1.38zm2.69-2.549H8.811l.87-2.39.887 2.39zM14.88 15v-1.235h-1.234V15h1.234zM9.352 25c.83-.006 1.352-.02 1.569-.044.346-.038.636-.14.872-.305.236-.166.422-.387.558-.664.137-.277.205-.562.205-.855 0-.372-.106-.695-.317-.97-.21-.276-.512-.471-.905-.585a1.51 1.51 0 0 0 .661-.567 1.5 1.5 0 0 0 .244-.83c0-.28-.066-.53-.197-.754a1.654 1.654 0 0 0-.495-.539 1.676 1.676 0 0 0-.672-.266c-.25-.042-.63-.063-1.14-.063H7.158V25h2.193zm.142-3.88H8.46v-1.49h.747c.612 0 .983.007 1.112.022.217.026.38.102.49.226.11.125.165.287.165.486a.68.68 0 0 1-.192.503.86.86 0 0 1-.525.23 11.47 11.47 0 0 1-.944.023h.18zm.17 2.795H8.46v-1.723h1.05c.592 0 .977.03 1.154.092.177.062.313.16.406.295a.84.84 0 0 1 .14.492c0 .228-.06.41-.181.547a.806.806 0 0 1-.473.257c-.126.026-.423.04-.892.04zM14.88 25v-1.235h-1.234V25h1.234zm-5.018 9.11c.691 0 1.262-.17 1.711-.512.45-.341.772-.864.965-1.567l-1.261-.4c-.109.472-.287.818-.536 1.037-.25.22-.547.33-.892.33-.47 0-.85-.173-1.143-.519-.293-.345-.44-.925-.44-1.74 0-.767.15-1.322.447-1.665.297-.343.684-.514 1.162-.514.346 0 .64.096.881.29.242.193.4.457.477.79l1.288-.307c-.147-.516-.367-.911-.66-1.187-.492-.465-1.132-.698-1.92-.698-.902 0-1.63.296-2.184.89-.554.593-.83 1.426-.83 2.498 0 1.014.275 1.813.825 2.397.551.585 1.254.877 2.11.877zM14.88 34v-1.235h-1.234V34h1.234z"/></svg>'
                    }]
                }))
            }
        }

        function Yy({
            editor: t,
            parentCommandName: e,
            buttonLabel: n,
            buttonIcon: o,
            styleGridAriaLabel: i,
            styleDefinitions: r
        }) {
            const s = t.commands.get(e);
            return a => {
                const l = Wm(a, Nm),
                    c = l.buttonView;
                return l.bind("isEnabled").to(s), l.class = "ck-list-styles-dropdown", c.on("execute", (() => {
                    t.execute(e), t.editing.view.focus()
                })), c.set({
                    label: n,
                    icon: o,
                    tooltip: !0,
                    isToggleable: !0
                }), c.bind("isOn").to(s, "value", (t => !!t)), l.once("change:isOpen", (() => {
                    const n = function({
                        editor: t,
                        dropdownView: e,
                        parentCommandName: n,
                        styleDefinitions: o,
                        styleGridAriaLabel: i
                    }) {
                        const r = t.locale,
                            s = t.config.get("list.properties");
                        let a = null;
                        "numberedList" != n && (s.startIndex = !1, s.reversed = !1);
                        if (s.styles) {
                            const e = t.commands.get("listStyle"),
                                i = function({
                                    editor: t,
                                    listStyleCommand: e,
                                    parentCommandName: n
                                }) {
                                    const o = t.locale,
                                        i = t.commands.get(n);
                                    return ({
                                        label: n,
                                        type: r,
                                        icon: s,
                                        tooltip: a
                                    }) => {
                                        const l = new Mg(o);
                                        return l.set({
                                            label: n,
                                            icon: s,
                                            tooltip: a
                                        }), e.on("change:value", (() => {
                                            l.isOn = e.value === r
                                        })), l.on("execute", (() => {
                                            i.value ? e.value !== r ? t.execute("listStyle", {
                                                type: r
                                            }) : t.execute("listStyle", {
                                                type: e.defaultType
                                            }) : t.model.change((() => {
                                                t.execute("listStyle", {
                                                    type: r
                                                })
                                            }))
                                        })), l
                                    }
                                }({
                                    editor: t,
                                    parentCommandName: n,
                                    listStyleCommand: e
                                }),
                                r = "function" == typeof e.isStyleTypeSupported ? t => e.isStyleTypeSupported(t.type) : () => !0;
                            a = o.filter(r).map(i)
                        }
                        const l = new Gy(r, {
                            styleGridAriaLabel: i,
                            enabledProperties: s,
                            styleButtonViews: a
                        });
                        s.styles && Zm(e, (() => l.stylesView.children.find((t => t.isOn))));
                        if (s.startIndex) {
                            const e = t.commands.get("listStart");
                            l.startIndexFieldView.bind("isEnabled").to(e), l.startIndexFieldView.fieldView.bind("value").to(e), l.on("listStart", ((e, n) => t.execute("listStart", n)))
                        }
                        if (s.reversed) {
                            const e = t.commands.get("listReversed");
                            l.reversedSwitchButtonView.bind("isEnabled").to(e), l.reversedSwitchButtonView.bind("isOn").to(e, "value", (t => !!t)), l.on("listReversed", (() => {
                                const n = e.value;
                                t.execute("listReversed", {
                                    reversed: !n
                                })
                            }))
                        }
                        return l.delegate("execute").to(e), l
                    }({
                        editor: t,
                        dropdownView: l,
                        parentCommandName: e,
                        styleGridAriaLabel: i,
                        styleDefinitions: r
                    });
                    l.panelView.children.add(n)
                })), l.on("execute", (() => {
                    t.editing.view.focus()
                })), l
            }
        }
        class Qy extends Fi {
            constructor(t, e) {
                super(t), this._indentBy = "forward" == e ? 1 : -1
            }
            refresh() {
                this.isEnabled = this._checkEnabled()
            }
            execute() {
                const t = this.editor.model,
                    e = t.document;
                let n = Array.from(e.selection.getSelectedBlocks());
                t.change((t => {
                    const e = n[n.length - 1];
                    let o = e.nextSibling;
                    for (; o && "listItem" == o.name && o.getAttribute("listIndent") > e.getAttribute("listIndent");) n.push(o), o = o.nextSibling;
                    this._indentBy < 0 && (n = n.reverse());
                    for (const e of n) {
                        const n = e.getAttribute("listIndent") + this._indentBy;
                        n < 0 ? t.rename(e, "paragraph") : t.setAttribute("listIndent", n, e)
                    }
                    this.fire("_executeCleanup", n)
                }))
            }
            _checkEnabled() {
                const t = Ei(this.editor.model.document.selection.getSelectedBlocks());
                if (!t || !t.is("element", "listItem")) return !1;
                if (this._indentBy > 0) {
                    const e = t.getAttribute("listIndent"),
                        n = t.getAttribute("listType");
                    let o = t.previousSibling;
                    for (; o && o.is("element", "listItem") && o.getAttribute("listIndent") >= e;) {
                        if (o.getAttribute("listIndent") == e) return o.getAttribute("listType") == n;
                        o = o.previousSibling
                    }
                    return !1
                }
                return !0
            }
        }
        class Xy extends Fi {
            constructor(t, e) {
                super(t), this.type = e
            }
            refresh() {
                this.value = this._getValue(), this.isEnabled = this._checkEnabled()
            }
            execute(t = {}) {
                const e = this.editor.model,
                    n = e.document,
                    o = Array.from(n.selection.getSelectedBlocks()).filter((t => ex(t, e.schema))),
                    i = void 0 !== t.forceValue ? !t.forceValue : this.value;
                e.change((t => {
                    if (i) {
                        let e = o[o.length - 1].nextSibling,
                            n = Number.POSITIVE_INFINITY,
                            i = [];
                        for (; e && "listItem" == e.name && 0 !== e.getAttribute("listIndent");) {
                            const t = e.getAttribute("listIndent");
                            t < n && (n = t);
                            const o = t - n;
                            i.push({
                                element: e,
                                listIndent: o
                            }), e = e.nextSibling
                        }
                        i = i.reverse();
                        for (const e of i) t.setAttribute("listIndent", e.listIndent, e.element)
                    }
                    if (!i) {
                        let t = Number.POSITIVE_INFINITY;
                        for (const e of o) e.is("element", "listItem") && e.getAttribute("listIndent") < t && (t = e.getAttribute("listIndent"));
                        t = 0 === t ? 1 : t, tx(o, !0, t), tx(o, !1, t)
                    }
                    for (const e of o.reverse()) i && "listItem" == e.name ? t.rename(e, "paragraph") : i || "listItem" == e.name ? i || "listItem" != e.name || e.getAttribute("listType") == this.type || t.setAttribute("listType", this.type, e) : (t.setAttributes({
                        listType: this.type,
                        listIndent: 0
                    }, e), t.rename(e, "listItem"));
                    this.fire("_executeCleanup", o)
                }))
            }
            _getValue() {
                const t = Ei(this.editor.model.document.selection.getSelectedBlocks());
                return !!t && t.is("element", "listItem") && t.getAttribute("listType") == this.type
            }
            _checkEnabled() {
                if (this.value) return !0;
                const t = this.editor.model.document.selection,
                    e = this.editor.model.schema,
                    n = Ei(t.getSelectedBlocks());
                return !!n && ex(n, e)
            }
        }

        function tx(t, e, n) {
            const o = e ? t[0] : t[t.length - 1];
            if (o.is("element", "listItem")) {
                let i = o[e ? "previousSibling" : "nextSibling"],
                    r = o.getAttribute("listIndent");
                for (; i && i.is("element", "listItem") && i.getAttribute("listIndent") >= n;) r > i.getAttribute("listIndent") && (r = i.getAttribute("listIndent")), i.getAttribute("listIndent") == r && t[e ? "unshift" : "push"](i), i = i[e ? "previousSibling" : "nextSibling"]
            }
        }

        function ex(t, e) {
            return e.checkChild(t.parent, "listItem") && !e.isObject(t)
        }
        class nx extends Vi {
            static get pluginName() {
                return "ListUtils"
            }
            getListTypeFromListStyleType(t) {
                return Ry(t)
            }
            getSelectedListItems(t) {
                return By(t)
            }
            getSiblingNodes(t, e) {
                return Ty(t, e)
            }
        }

        function ox(t) {
            return (e, n, o) => {
                const i = o.consumable;
                if (!i.test(n.item, "insert") || !i.test(n.item, "attribute:listType") || !i.test(n.item, "attribute:listIndent")) return;
                i.consume(n.item, "insert"), i.consume(n.item, "attribute:listType"), i.consume(n.item, "attribute:listIndent");
                const r = n.item;
                vy(r, _y(r, o), o, t)
            }
        }
        const ix = (t, e, n) => {
                if (!n.consumable.test(e.item, t.name)) return;
                const o = n.mapper.toViewElement(e.item),
                    i = n.writer;
                i.breakContainer(i.createPositionBefore(o)), i.breakContainer(i.createPositionAfter(o));
                const r = o.parent,
                    s = "numbered" == e.attributeNewValue ? "ol" : "ul";
                i.rename(s, r)
            },
            rx = (t, e, n) => {
                n.consumable.consume(e.item, t.name);
                const o = n.mapper.toViewElement(e.item).parent,
                    i = n.writer;
                yy(i, o, o.nextSibling), yy(i, o.previousSibling, o)
            };
        const sx = (t, e, n) => {
                if (n.consumable.test(e.item, t.name) && "listItem" != e.item.name) {
                    let t = n.mapper.toViewPosition(e.range.start);
                    const o = n.writer,
                        i = [];
                    for (;
                        ("ul" == t.parent.name || "ol" == t.parent.name) && (t = o.breakContainer(t), "li" == t.parent.name);) {
                        const e = t,
                            n = o.createPositionAt(t.parent, "end");
                        if (!e.isEqual(n)) {
                            const t = o.remove(o.createRange(e, n));
                            i.push(t)
                        }
                        t = o.createPositionAfter(t.parent)
                    }
                    if (i.length > 0) {
                        for (let e = 0; e < i.length; e++) {
                            const n = t.nodeBefore;
                            if (t = o.insert(t, i[e]).end, e > 0) {
                                const e = yy(o, n, n.nextSibling);
                                e && e.parent == n && t.offset--
                            }
                        }
                        yy(o, t.nodeBefore, t.nodeAfter)
                    }
                }
            },
            ax = (t, e, n) => {
                const o = n.mapper.toViewPosition(e.position),
                    i = o.nodeBefore,
                    r = o.nodeAfter;
                yy(n.writer, i, r)
            },
            lx = (t, e, n) => {
                if (n.consumable.consume(e.viewItem, {
                        name: !0
                    })) {
                    const t = n.writer,
                        o = t.createElement("listItem"),
                        i = function(t) {
                            let e = 0,
                                n = t.parent;
                            for (; n;) {
                                if (n.is("element", "li")) e++;
                                else {
                                    const t = n.previousSibling;
                                    t && t.is("element", "li") && e++
                                }
                                n = n.parent
                            }
                            return e
                        }(e.viewItem);
                    t.setAttribute("listIndent", i, o);
                    const r = e.viewItem.parent && "ol" == e.viewItem.parent.name ? "numbered" : "bulleted";
                    if (t.setAttribute("listType", r, o), !n.safeInsert(o, e.modelCursor)) return;
                    const s = function(t, e, n) {
                        const {
                            writer: o,
                            schema: i
                        } = n;
                        let r = o.createPositionAfter(t);
                        for (const s of e)
                            if ("ul" == s.name || "ol" == s.name) r = n.convertItem(s, r).modelCursor;
                            else {
                                const e = n.convertItem(s, o.createPositionAt(t, "end")),
                                    a = e.modelRange.start.nodeAfter;
                                a && a.is("element") && !i.checkChild(t, a.name) && (t = e.modelCursor.parent.is("element", "listItem") ? e.modelCursor.parent : gx(e.modelCursor), r = o.createPositionAfter(t))
                            } return r
                    }(o, e.viewItem.getChildren(), n);
                    e.modelRange = t.createRange(e.modelCursor, s), n.updateConversionResult(o, e)
                }
            },
            cx = (t, e, n) => {
                if (n.consumable.test(e.viewItem, {
                        name: !0
                    })) {
                    const t = Array.from(e.viewItem.getChildren());
                    for (const e of t) {
                        !(e.is("element", "li") || px(e)) && e._remove()
                    }
                }
            },
            dx = (t, e, n) => {
                if (n.consumable.test(e.viewItem, {
                        name: !0
                    })) {
                    if (0 === e.viewItem.childCount) return;
                    const t = [...e.viewItem.getChildren()];
                    let n = !1;
                    for (const e of t) n && !px(e) && e._remove(), px(e) && (n = !0)
                }
            };

        function hx(t) {
            return (e, n) => {
                if (n.isPhantom) return;
                const o = n.modelPosition.nodeBefore;
                if (o && o.is("element", "listItem")) {
                    const e = n.mapper.toViewElement(o),
                        i = e.getAncestors().find(px),
                        r = t.createPositionAt(e, 0).getWalker();
                    for (const t of r) {
                        if ("elementStart" == t.type && t.item.is("element", "li")) {
                            n.viewPosition = t.previousPosition;
                            break
                        }
                        if ("elementEnd" == t.type && t.item == i) {
                            n.viewPosition = t.nextPosition;
                            break
                        }
                    }
                }
            }
        }
        const ux = function(t, [e, n]) {
            const o = this;
            let i, r = e.is("documentFragment") ? e.getChild(0) : e;
            if (i = n ? o.createSelection(n) : o.document.selection, r && r.is("element", "listItem")) {
                const t = i.getFirstPosition();
                let e = null;
                if (t.parent.is("element", "listItem") ? e = t.parent : t.nodeBefore && t.nodeBefore.is("element", "listItem") && (e = t.nodeBefore), e) {
                    const t = e.getAttribute("listIndent");
                    if (t > 0)
                        for (; r && r.is("element", "listItem");) r._setAttribute("listIndent", r.getAttribute("listIndent") + t), r = r.nextSibling
                }
            }
        };

        function gx(t) {
            const e = new yl({
                startPosition: t
            });
            let n;
            do {
                n = e.next()
            } while (!n.value.item.is("element", "listItem"));
            return n.value.item
        }

        function mx(t, e, n, o, i, r) {
            const s = Ey(e.nodeBefore, {
                    sameIndent: !0,
                    smallerIndent: !0,
                    listIndent: t
                }),
                a = i.mapper,
                l = i.writer,
                c = s ? s.getAttribute("listIndent") : null;
            let d;
            if (s)
                if (c == t) {
                    const t = a.toViewElement(s).parent;
                    d = l.createPositionAfter(t)
                } else {
                    const t = r.createPositionAt(s, "end");
                    d = a.toViewPosition(t)
                }
            else d = n;
            d = xy(d);
            for (const t of [...o.getChildren()]) px(t) && (d = l.move(l.createRangeOn(t), d).end, yy(l, t, t.nextSibling), yy(l, t.previousSibling, t))
        }

        function px(t) {
            return t.is("element", "ol") || t.is("element", "ul")
        }
        class fx extends Vi {
            static get pluginName() {
                return "ListEditing"
            }
            static get requires() {
                return [aw, ok, nx]
            }
            init() {
                const t = this.editor;
                t.model.schema.register("listItem", {
                    inheritAllFrom: "$block",
                    allowAttributes: ["listType", "listIndent"]
                });
                const e = t.data,
                    n = t.editing;
                var o;
                t.model.document.registerPostFixer((e => function(t, e) {
                    const n = t.document.differ.getChanges(),
                        o = new Map;
                    let i = !1;
                    for (const o of n)
                        if ("insert" == o.type && "listItem" == o.name) r(o.position);
                        else if ("insert" == o.type && "listItem" != o.name) {
                        if ("$text" != o.name) {
                            const n = o.position.nodeAfter;
                            n.hasAttribute("listIndent") && (e.removeAttribute("listIndent", n), i = !0), n.hasAttribute("listType") && (e.removeAttribute("listType", n), i = !0), n.hasAttribute("listStyle") && (e.removeAttribute("listStyle", n), i = !0), n.hasAttribute("listReversed") && (e.removeAttribute("listReversed", n), i = !0), n.hasAttribute("listStart") && (e.removeAttribute("listStart", n), i = !0);
                            for (const e of Array.from(t.createRangeIn(n)).filter((t => t.item.is("element", "listItem")))) r(e.previousPosition)
                        }
                        r(o.position.getShiftedBy(o.length))
                    } else "remove" == o.type && "listItem" == o.name ? r(o.position) : ("attribute" == o.type && "listIndent" == o.attributeKey || "attribute" == o.type && "listType" == o.attributeKey) && r(o.range.start);
                    for (const t of o.values()) s(t), a(t);
                    return i;

                    function r(t) {
                        const e = t.nodeBefore;
                        if (e && e.is("element", "listItem")) {
                            let t = e;
                            if (o.has(t)) return;
                            for (let e = t.previousSibling; e && e.is("element", "listItem"); e = t.previousSibling)
                                if (t = e, o.has(t)) return;
                            o.set(e, t)
                        } else {
                            const e = t.nodeAfter;
                            e && e.is("element", "listItem") && o.set(e, e)
                        }
                    }

                    function s(t) {
                        let n = 0,
                            o = null;
                        for (; t && t.is("element", "listItem");) {
                            const r = t.getAttribute("listIndent");
                            if (r > n) {
                                let s;
                                null === o ? (o = r - n, s = n) : (o > r && (o = r), s = r - o), e.setAttribute("listIndent", s, t), i = !0
                            } else o = null, n = t.getAttribute("listIndent") + 1;
                            t = t.nextSibling
                        }
                    }

                    function a(t) {
                        let n = [],
                            o = null;
                        for (; t && t.is("element", "listItem");) {
                            const r = t.getAttribute("listIndent");
                            if (o && o.getAttribute("listIndent") > r && (n = n.slice(0, r + 1)), 0 != r)
                                if (n[r]) {
                                    const o = n[r];
                                    t.getAttribute("listType") != o && (e.setAttribute("listType", o, t), i = !0)
                                } else n[r] = t.getAttribute("listType");
                            o = t, t = t.nextSibling
                        }
                    }
                }(t.model, e))), n.mapper.registerViewToModelLength("li", bx), e.mapper.registerViewToModelLength("li", bx), n.mapper.on("modelToViewPosition", hx(n.view)), n.mapper.on("viewToModelPosition", (o = t.model, (t, e) => {
                    const n = e.viewPosition,
                        i = n.parent,
                        r = e.mapper;
                    if ("ul" == i.name || "ol" == i.name) {
                        if (n.isAtEnd) {
                            const t = r.toModelElement(n.nodeBefore),
                                i = r.getModelLength(n.nodeBefore);
                            e.modelPosition = o.createPositionBefore(t).getShiftedBy(i)
                        } else {
                            const t = r.toModelElement(n.nodeAfter);
                            e.modelPosition = o.createPositionBefore(t)
                        }
                        t.stop()
                    } else if ("li" == i.name && n.nodeBefore && ("ul" == n.nodeBefore.name || "ol" == n.nodeBefore.name)) {
                        const s = r.toModelElement(i);
                        let a = 1,
                            l = n.nodeBefore;
                        for (; l && px(l);) a += r.getModelLength(l), l = l.previousSibling;
                        e.modelPosition = o.createPositionBefore(s).getShiftedBy(a), t.stop()
                    }
                })), e.mapper.on("modelToViewPosition", hx(n.view)), t.conversion.for("editingDowncast").add((e => {
                    e.on("insert", sx, {
                        priority: "high"
                    }), e.on("insert:listItem", ox(t.model)), e.on("attribute:listType:listItem", ix, {
                        priority: "high"
                    }), e.on("attribute:listType:listItem", rx, {
                        priority: "low"
                    }), e.on("attribute:listIndent:listItem", function(t) {
                        return (e, n, o) => {
                            if (!o.consumable.consume(n.item, "attribute:listIndent")) return;
                            const i = o.mapper.toViewElement(n.item),
                                r = o.writer;
                            r.breakContainer(r.createPositionBefore(i)), r.breakContainer(r.createPositionAfter(i));
                            const s = i.parent,
                                a = s.previousSibling,
                                l = r.createRangeOn(s);
                            r.remove(l), a && a.nextSibling && yy(r, a, a.nextSibling), mx(n.attributeOldValue + 1, n.range.start, l.start, i, o, t), vy(n.item, i, o, t);
                            for (const t of n.item.getChildren()) o.consumable.consume(t, "insert")
                        }
                    }(t.model)), e.on("remove:listItem", function(t) {
                        return (e, n, o) => {
                            const i = o.mapper.toViewPosition(n.position).getLastMatchingPosition((t => !t.item.is("element", "li"))).nodeAfter,
                                r = o.writer;
                            r.breakContainer(r.createPositionBefore(i)), r.breakContainer(r.createPositionAfter(i));
                            const s = i.parent,
                                a = s.previousSibling,
                                l = r.createRangeOn(s),
                                c = r.remove(l);
                            a && a.nextSibling && yy(r, a, a.nextSibling), mx(o.mapper.toModelElement(i).getAttribute("listIndent") + 1, n.position, l.start, i, o, t);
                            for (const t of r.createRangeIn(c).getItems()) o.mapper.unbindViewElement(t);
                            e.stop()
                        }
                    }(t.model)), e.on("remove", ax, {
                        priority: "low"
                    })
                })), t.conversion.for("dataDowncast").add((e => {
                    e.on("insert", sx, {
                        priority: "high"
                    }), e.on("insert:listItem", ox(t.model))
                })), t.conversion.for("upcast").add((t => {
                    t.on("element:ul", cx, {
                        priority: "high"
                    }), t.on("element:ol", cx, {
                        priority: "high"
                    }), t.on("element:li", dx, {
                        priority: "high"
                    }), t.on("element:li", lx)
                })), t.model.on("insertContent", ux, {
                    priority: "high"
                }), t.commands.add("numberedList", new Xy(t, "numbered")), t.commands.add("bulletedList", new Xy(t, "bulleted")), t.commands.add("indentList", new Qy(t, "forward")), t.commands.add("outdentList", new Qy(t, "backward"));
                const i = n.view.document;
                this.listenTo(i, "enter", ((t, e) => {
                    const n = this.editor.model.document,
                        o = n.selection.getLastPosition().parent;
                    n.selection.isCollapsed && "listItem" == o.name && o.isEmpty && (this.editor.execute("outdentList"), e.preventDefault(), t.stop())
                }), {
                    context: "li"
                }), this.listenTo(i, "delete", ((t, e) => {
                    if ("backward" !== e.direction) return;
                    const n = this.editor.model.document.selection;
                    if (!n.isCollapsed) return;
                    const o = n.getFirstPosition();
                    if (!o.isAtStart) return;
                    const i = o.parent;
                    if ("listItem" !== i.name) return;
                    i.previousSibling && "listItem" === i.previousSibling.name || (this.editor.execute("outdentList"), e.preventDefault(), t.stop())
                }), {
                    context: "li"
                }), this.listenTo(t.editing.view.document, "tab", ((e, n) => {
                    const o = n.shiftKey ? "outdentList" : "indentList";
                    this.editor.commands.get(o).isEnabled && (t.execute(o), n.stopPropagation(), n.preventDefault(), e.stop())
                }), {
                    context: "li"
                })
            }
            afterInit() {
                const t = this.editor.commands,
                    e = t.get("indent"),
                    n = t.get("outdent");
                e && e.registerChildCommand(t.get("indentList")), n && n.registerChildCommand(t.get("outdentList"))
            }
        }

        function bx(t) {
            let e = 1;
            for (const n of t.getChildren())
                if ("ul" == n.name || "ol" == n.name)
                    for (const t of n.getChildren()) e += bx(t);
            return e
        }
        class kx extends Fi {
            constructor(t, e) {
                super(t), this.defaultType = e
            }
            refresh() {
                this.value = this._getValue(), this.isEnabled = this._checkEnabled()
            }
            execute(t = {}) {
                this._tryToConvertItemsToList(t);
                const e = this.editor.model,
                    n = By(e);
                n.length && e.change((e => {
                    for (const o of n) e.setAttribute("listStyle", t.type || this.defaultType, o)
                }))
            }
            _getValue() {
                const t = this.editor.model.document.selection.getFirstPosition().parent;
                return t && t.is("element", "listItem") ? t.getAttribute("listStyle") : null
            }
            _checkEnabled() {
                const t = this.editor,
                    e = t.commands.get("numberedList"),
                    n = t.commands.get("bulletedList");
                return e.isEnabled || n.isEnabled
            }
            _tryToConvertItemsToList(t) {
                if (!t.type) return;
                const e = Ry(t.type);
                if (!e) return;
                const n = this.editor,
                    o = `${e}List`;
                n.commands.get(o).value || n.execute(o)
            }
        }
        class wx extends Fi {
            refresh() {
                const t = this._getValue();
                this.value = t, this.isEnabled = null != t
            }
            execute(t = {}) {
                const e = this.editor.model,
                    n = By(e).filter((t => "numbered" == t.getAttribute("listType")));
                e.change((e => {
                    for (const o of n) e.setAttribute("listReversed", !!t.reversed, o)
                }))
            }
            _getValue() {
                const t = this.editor.model.document.selection.getFirstPosition().parent;
                return t && t.is("element", "listItem") && "numbered" == t.getAttribute("listType") ? t.getAttribute("listReversed") : null
            }
        }
        class Ax extends Fi {
            refresh() {
                const t = this._getValue();
                this.value = t, this.isEnabled = null != t
            }
            execute({
                startIndex: t = 1
            } = {}) {
                const e = this.editor.model,
                    n = By(e).filter((t => "numbered" == t.getAttribute("listType")));
                e.change((e => {
                    for (const o of n) e.setAttribute("listStart", t >= 0 ? t : 1, o)
                }))
            }
            _getValue() {
                const t = this.editor.model.document.selection.getFirstPosition().parent;
                return t && t.is("element", "listItem") && "numbered" == t.getAttribute("listType") ? t.getAttribute("listStart") : null
            }
        }
        const Cx = "default";
        class _x extends Vi {
            static get requires() {
                return [fx]
            }
            static get pluginName() {
                return "ListPropertiesEditing"
            }
            constructor(t) {
                super(t), t.config.define("list", {
                    properties: {
                        styles: !0,
                        startIndex: !1,
                        reversed: !1
                    }
                })
            }
            init() {
                const t = this.editor,
                    e = t.model,
                    n = function(t) {
                        const e = [];
                        t.styles && e.push({
                            attributeName: "listStyle",
                            defaultValue: Cx,
                            addCommand(t) {
                                t.commands.add("listStyle", new kx(t, Cx))
                            },
                            appliesToListItem: () => !0,
                            setAttributeOnDowncast(t, e, n) {
                                e && e !== Cx ? t.setStyle("list-style-type", e, n) : t.removeStyle("list-style-type", n)
                            },
                            getAttributeOnUpcast: t => t.getStyle("list-style-type") || Cx
                        });
                        t.reversed && e.push({
                            attributeName: "listReversed",
                            defaultValue: !1,
                            addCommand(t) {
                                t.commands.add("listReversed", new wx(t))
                            },
                            appliesToListItem: t => "numbered" == t.getAttribute("listType"),
                            setAttributeOnDowncast(t, e, n) {
                                e ? t.setAttribute("reversed", "reversed", n) : t.removeAttribute("reversed", n)
                            },
                            getAttributeOnUpcast: t => t.hasAttribute("reversed")
                        });
                        t.startIndex && e.push({
                            attributeName: "listStart",
                            defaultValue: 1,
                            addCommand(t) {
                                t.commands.add("listStart", new Ax(t))
                            },
                            appliesToListItem: t => "numbered" == t.getAttribute("listType"),
                            setAttributeOnDowncast(t, e, n) {
                                0 == e || e > 1 ? t.setAttribute("start", e, n) : t.removeAttribute("start", n)
                            },
                            getAttributeOnUpcast(t) {
                                const e = t.getAttribute("start");
                                return e >= 0 ? e : 1
                            }
                        });
                        return e
                    }(t.config.get("list.properties"));
                e.schema.extend("listItem", {
                    allowAttributes: n.map((t => t.attributeName))
                });
                for (const e of n) e.addCommand(t);
                var o;
                this.listenTo(t.commands.get("indentList"), "_executeCleanup", function(t, e) {
                    return (n, o) => {
                        const i = o[0],
                            r = i.getAttribute("listIndent"),
                            s = o.filter((t => t.getAttribute("listIndent") === r));
                        let a = null;
                        i.previousSibling.getAttribute("listIndent") + 1 !== r && (a = Ey(i.previousSibling, {
                            sameIndent: !0,
                            direction: "backward",
                            listIndent: r
                        })), t.model.change((t => {
                            for (const n of s)
                                for (const o of e)
                                    if (o.appliesToListItem(n)) {
                                        const e = null == a ? o.defaultValue : a.getAttribute(o.attributeName);
                                        t.setAttribute(o.attributeName, e, n)
                                    }
                        }))
                    }
                }(t, n)), this.listenTo(t.commands.get("outdentList"), "_executeCleanup", function(t, e) {
                    return (n, o) => {
                        if (!(o = o.reverse().filter((t => t.is("element", "listItem")))).length) return;
                        const i = o[0].getAttribute("listIndent"),
                            r = o[0].getAttribute("listType");
                        let s = o[0].previousSibling;
                        if (s.is("element", "listItem"))
                            for (; s.getAttribute("listIndent") !== i;) s = s.previousSibling;
                        else s = null;
                        s || (s = o[o.length - 1].nextSibling), s && s.is("element", "listItem") && s.getAttribute("listType") === r && t.model.change((t => {
                            const n = o.filter((t => t.getAttribute("listIndent") === i));
                            for (const o of n)
                                for (const n of e)
                                    if (n.appliesToListItem(o)) {
                                        const e = n.attributeName,
                                            i = s.getAttribute(e);
                                        t.setAttribute(e, i, o)
                                    }
                        }))
                    }
                }(t, n)), this.listenTo(t.commands.get("bulletedList"), "_executeCleanup", xx(t)), this.listenTo(t.commands.get("numberedList"), "_executeCleanup", xx(t)), e.document.registerPostFixer(function(t, e) {
                    return n => {
                        let o = !1;
                        const i = Ex(t.model.document.differ.getChanges()).filter((t => "todo" !== t.getAttribute("listType")));
                        if (!i.length) return o;
                        let r = i[i.length - 1].nextSibling;
                        if ((!r || !r.is("element", "listItem")) && (r = i[0].previousSibling, r)) {
                            const t = i[0].getAttribute("listIndent");
                            for (; r.is("element", "listItem") && r.getAttribute("listIndent") !== t && (r = r.previousSibling, r););
                        }
                        for (const t of e) {
                            const e = t.attributeName;
                            for (const s of i)
                                if (t.appliesToListItem(s))
                                    if (s.hasAttribute(e)) {
                                        const i = s.previousSibling;
                                        yx(i, s, t.attributeName) && (n.setAttribute(e, i.getAttribute(e), s), o = !0)
                                    } else vx(r, s, t) ? n.setAttribute(e, r.getAttribute(e), s) : n.setAttribute(e, t.defaultValue, s), o = !0;
                            else n.removeAttribute(e, s)
                        }
                        return o
                    }
                }(t, n)), t.conversion.for("upcast").add((o = n, t => {
                    t.on("element:li", ((t, e, n) => {
                        if (!e.modelRange) return;
                        const i = e.viewItem.parent,
                            r = e.modelRange.start.nodeAfter || e.modelRange.end.nodeBefore;
                        for (const t of o)
                            if (t.appliesToListItem(r)) {
                                const e = t.getAttributeOnUpcast(i);
                                n.writer.setAttribute(t.attributeName, e, r)
                            }
                    }), {
                        priority: "low"
                    })
                })), t.conversion.for("downcast").add(function(t) {
                    return n => {
                        for (const o of t) n.on(`attribute:${o.attributeName}:listItem`, ((t, n, i) => {
                            const r = i.writer,
                                s = n.item,
                                a = Ey(s.previousSibling, {
                                    sameIndent: !0,
                                    listIndent: s.getAttribute("listIndent"),
                                    direction: "backward"
                                }),
                                l = i.mapper.toViewElement(s);
                            e(s, a) || r.breakContainer(r.createPositionBefore(l)), o.setAttributeOnDowncast(r, n.attributeNewValue, l.parent)
                        }), {
                            priority: "low"
                        })
                    };

                    function e(t, e) {
                        return e && t.getAttribute("listType") === e.getAttribute("listType") && t.getAttribute("listIndent") === e.getAttribute("listIndent") && t.getAttribute("listStyle") === e.getAttribute("listStyle") && t.getAttribute("listReversed") === e.getAttribute("listReversed") && t.getAttribute("listStart") === e.getAttribute("listStart")
                    }
                }(n)), this._mergeListAttributesWhileMergingLists(n)
            }
            afterInit() {
                const t = this.editor;
                t.commands.get("todoList") && t.model.document.registerPostFixer(function(t) {
                    return e => {
                        const n = Ex(t.model.document.differ.getChanges()).filter((t => "todo" === t.getAttribute("listType") && (t.hasAttribute("listStyle") || t.hasAttribute("listReversed") || t.hasAttribute("listStart"))));
                        if (!n.length) return !1;
                        for (const t of n) e.removeAttribute("listStyle", t), e.removeAttribute("listReversed", t), e.removeAttribute("listStart", t);
                        return !0
                    }
                }(t))
            }
            _mergeListAttributesWhileMergingLists(t) {
                const e = this.editor.model;
                let n;
                this.listenTo(e, "deleteContent", ((t, [e]) => {
                    const o = e.getFirstPosition(),
                        i = e.getLastPosition();
                    if (o.parent === i.parent) return;
                    if (!o.parent.is("element", "listItem")) return;
                    const r = i.parent.nextSibling;
                    if (!r || !r.is("element", "listItem")) return;
                    const s = Ey(o.parent, {
                        sameIndent: !0,
                        listIndent: r.getAttribute("listIndent")
                    });
                    s && s.getAttribute("listType") === r.getAttribute("listType") && (n = s)
                }), {
                    priority: "high"
                }), this.listenTo(e, "deleteContent", (() => {
                    n && (e.change((e => {
                        const o = Ey(n.nextSibling, {
                            sameIndent: !0,
                            listIndent: n.getAttribute("listIndent"),
                            direction: "forward"
                        });
                        if (!o) return void(n = null);
                        const i = [o, ...Ty(e.createPositionAt(o, 0), "forward")];
                        for (const o of i)
                            for (const i of t)
                                if (i.appliesToListItem(o)) {
                                    const t = i.attributeName,
                                        r = n.getAttribute(t);
                                    e.setAttribute(t, r, o)
                                }
                    })), n = null)
                }), {
                    priority: "low"
                })
            }
        }

        function vx(t, e, n) {
            if (!t) return !1;
            const o = t.getAttribute(n.attributeName);
            return !!o && (o != n.defaultValue && t.getAttribute("listType") === e.getAttribute("listType"))
        }

        function yx(t, e, n) {
            if (!t || !t.is("element", "listItem")) return !1;
            if (e.getAttribute("listType") !== t.getAttribute("listType")) return !1;
            const o = t.getAttribute("listIndent");
            if (o < 1 || o !== e.getAttribute("listIndent")) return !1;
            const i = t.getAttribute(n);
            return !(!i || i === e.getAttribute(n))
        }

        function xx(t) {
            return (e, n) => {
                n = n.filter((t => t.is("element", "listItem"))), t.model.change((t => {
                    for (const e of n) t.removeAttribute("listStyle", e)
                }))
            }
        }

        function Ex(t) {
            const e = [];
            for (const n of t) {
                const t = Dx(n);
                t && t.is("element", "listItem") && e.push(t)
            }
            return e
        }

        function Dx(t) {
            return "attribute" === t.type ? t.range.start.nodeAfter : "insert" === t.type ? t.position.nodeAfter : null
        }
        const Sx = "todoListChecked";
        class Tx extends Fi {
            constructor(t) {
                super(t), this._selectedElements = [], this.on("execute", (() => {
                    this.refresh()
                }), {
                    priority: "highest"
                })
            }
            refresh() {
                this._selectedElements = this._getSelectedItems(), this.value = this._selectedElements.every((t => !!t.getAttribute(Sx))), this.isEnabled = !!this._selectedElements.length
            }
            _getSelectedItems() {
                const t = this.editor.model,
                    e = t.schema,
                    n = t.document.selection.getFirstRange(),
                    o = n.start.parent,
                    i = [];
                e.checkAttribute(o, Sx) && i.push(o);
                for (const t of n.getItems()) e.checkAttribute(t, Sx) && !i.includes(t) && i.push(t);
                return i
            }
            execute(t = {}) {
                this.editor.model.change((e => {
                    for (const n of this._selectedElements) {
                        (void 0 === t.forceValue ? !this.value : t.forceValue) ? e.setAttribute(Sx, !0, n): e.removeAttribute(Sx, n)
                    }
                }))
            }
        }
        const Bx = (t, e, n) => {
            const o = e.modelCursor,
                i = o.parent,
                r = e.viewItem;
            if ("checkbox" != r.getAttribute("type") || "listItem" != i.name || !o.isAtStart) return;
            if (!n.consumable.consume(r, {
                    name: !0
                })) return;
            const s = n.writer;
            s.setAttribute("listType", "todo", i), e.viewItem.hasAttribute("checked") && s.setAttribute("todoListChecked", !0, i), e.modelRange = s.createRange(o)
        };

        function Ix(t) {
            return (e, n) => {
                const o = n.modelPosition,
                    i = o.parent;
                if (!i.is("element", "listItem") || "todo" != i.getAttribute("listType")) return;
                const r = Rx(n.mapper.toViewElement(i), t);
                r && (n.viewPosition = n.mapper.findPositionIn(r, o.offset))
            }
        }

        function Px(t, e, n, o) {
            return e.createUIElement("label", {
                class: "todo-list__label",
                contenteditable: !1
            }, (function(e) {
                const i = pt(document, "input", {
                    type: "checkbox",
                    tabindex: "-1"
                });
                n && i.setAttribute("checked", "checked"), i.addEventListener("change", (() => o(t)));
                const r = this.toDomElement(e);
                return r.appendChild(i), r
            }))
        }

        function Rx(t, e) {
            const n = e.createRangeIn(t);
            for (const t of n)
                if (t.item.is("containerElement", "span") && t.item.hasClass("todo-list__label__description")) return t.item
        }
        const zx = bi("Ctrl+Enter");
        class Vx extends Vi {
            static get pluginName() {
                return "TodoListEditing"
            }
            static get requires() {
                return [fx]
            }
            init() {
                const t = this.editor,
                    {
                        editing: e,
                        data: n,
                        model: o
                    } = t;
                o.schema.extend("listItem", {
                    allowAttributes: ["todoListChecked"]
                }), o.schema.addAttributeCheck(((t, e) => {
                    const n = t.last;
                    if ("todoListChecked" == e && "listItem" == n.name && "todo" != n.getAttribute("listType")) return !1
                })), t.commands.add("todoList", new Xy(t, "todo"));
                const i = new Tx(t);
                var r, s;
                t.commands.add("checkTodoList", i), t.commands.add("todoListCheck", i), n.downcastDispatcher.on("insert:listItem", function(t) {
                    return (e, n, o) => {
                        const i = o.consumable;
                        if (!i.test(n.item, "insert") || !i.test(n.item, "attribute:listType") || !i.test(n.item, "attribute:listIndent")) return;
                        if ("todo" != n.item.getAttribute("listType")) return;
                        const r = n.item;
                        i.consume(r, "insert"), i.consume(r, "attribute:listType"), i.consume(r, "attribute:listIndent"), i.consume(r, "attribute:todoListChecked");
                        const s = o.writer,
                            a = _y(r, o);
                        s.addClass("todo-list", a.parent);
                        const l = s.createContainerElement("label", {
                                class: "todo-list__label"
                            }),
                            c = s.createEmptyElement("input", {
                                type: "checkbox",
                                disabled: "disabled"
                            }),
                            d = s.createContainerElement("span", {
                                class: "todo-list__label__description"
                            });
                        r.getAttribute("todoListChecked") && s.setAttribute("checked", "checked", c), s.insert(s.createPositionAt(a, 0), l), s.insert(s.createPositionAt(l, 0), c), s.insert(s.createPositionAfter(c), d), vy(r, a, o, t)
                    }
                }(o), {
                    priority: "high"
                }), n.upcastDispatcher.on("element:input", Bx, {
                    priority: "high"
                }), e.downcastDispatcher.on("insert:listItem", function(t, e) {
                    return (n, o, i) => {
                        const r = i.consumable;
                        if (!r.test(o.item, "insert") || !r.test(o.item, "attribute:listType") || !r.test(o.item, "attribute:listIndent")) return;
                        if ("todo" != o.item.getAttribute("listType")) return;
                        const s = o.item;
                        r.consume(s, "insert"), r.consume(s, "attribute:listType"), r.consume(s, "attribute:listIndent"), r.consume(s, "attribute:todoListChecked");
                        const a = i.writer,
                            l = _y(s, i),
                            c = !!s.getAttribute("todoListChecked"),
                            d = Px(s, a, c, e),
                            h = a.createContainerElement("span", {
                                class: "todo-list__label__description"
                            });
                        a.addClass("todo-list", l.parent), a.insert(a.createPositionAt(l, 0), d), a.insert(a.createPositionAfter(d), h), vy(s, l, i, t)
                    }
                }(o, (t => this._handleCheckmarkChange(t))), {
                    priority: "high"
                }), e.downcastDispatcher.on("attribute:listType:listItem", (r = t => this._handleCheckmarkChange(t), s = e.view, (t, e, n) => {
                    if (!n.consumable.consume(e.item, t.name)) return;
                    const o = n.mapper.toViewElement(e.item),
                        i = n.writer,
                        a = function(t, e) {
                            const n = e.createRangeIn(t);
                            for (const t of n)
                                if (t.item.is("uiElement", "label")) return t.item
                        }(o, s);
                    if ("todo" == e.attributeNewValue) {
                        const t = !!e.item.getAttribute("todoListChecked"),
                            n = Px(e.item, i, t, r),
                            s = i.createContainerElement("span", {
                                class: "todo-list__label__description"
                            }),
                            a = i.createRangeIn(o),
                            l = Sy(o),
                            c = xy(a.start),
                            d = l ? i.createPositionBefore(l) : a.end,
                            h = i.createRange(c, d);
                        i.addClass("todo-list", o.parent), i.move(h, i.createPositionAt(s, 0)), i.insert(i.createPositionAt(o, 0), n), i.insert(i.createPositionAfter(n), s)
                    } else if ("todo" == e.attributeOldValue) {
                        const t = Rx(o, s);
                        i.removeClass("todo-list", o.parent), i.remove(a), i.move(i.createRangeIn(t), i.createPositionBefore(t)), i.remove(t)
                    }
                })), e.downcastDispatcher.on("attribute:todoListChecked:listItem", function(t) {
                    return (e, n, o) => {
                        if ("todo" != n.item.getAttribute("listType")) return;
                        if (!o.consumable.consume(n.item, "attribute:todoListChecked")) return;
                        const {
                            mapper: i,
                            writer: r
                        } = o, s = !!n.item.getAttribute("todoListChecked"), a = i.toViewElement(n.item).getChild(0), l = Px(n.item, r, s, t);
                        r.insert(r.createPositionAfter(a), l), r.remove(a)
                    }
                }((t => this._handleCheckmarkChange(t)))), e.mapper.on("modelToViewPosition", Ix(e.view)), n.mapper.on("modelToViewPosition", Ix(e.view)), this.listenTo(e.view.document, "arrowKey", function(t, e) {
                    return (n, o) => {
                        if ("left" != wi(o.keyCode, e.contentLanguageDirection)) return;
                        const i = t.schema,
                            r = t.document.selection;
                        if (!r.isCollapsed) return;
                        const s = r.getFirstPosition(),
                            a = s.parent;
                        if ("listItem" === a.name && "todo" == a.getAttribute("listType") && s.isAtStart) {
                            const e = i.getNearestSelectionRange(t.createPositionBefore(a), "backward");
                            e && t.change((t => t.setSelection(e))), o.preventDefault(), o.stopPropagation(), n.stop()
                        }
                    }
                }(o, t.locale), {
                    context: "li"
                }), this.listenTo(e.view.document, "keydown", ((e, n) => {
                    fi(n) === zx && (t.execute("checkTodoList"), e.stop())
                }), {
                    priority: "high"
                });
                const a = new Set;
                this.listenTo(o, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if ("rename" == n.type && "listItem" == n.oldName) {
                        const t = n.position.nodeAfter;
                        t.hasAttribute("todoListChecked") && a.add(t)
                    } else if ("changeAttribute" == n.type && "listType" == n.key && "todo" === n.oldValue)
                        for (const t of n.range.getItems()) t.hasAttribute("todoListChecked") && "todo" !== t.getAttribute("listType") && a.add(t)
                })), o.document.registerPostFixer((t => {
                    let e = !1;
                    for (const n of a) t.removeAttribute("todoListChecked", n), e = !0;
                    return a.clear(), e
                }))
            }
            _handleCheckmarkChange(t) {
                const e = this.editor,
                    n = e.model,
                    o = Array.from(n.document.selection.getRanges());
                n.change((n => {
                    n.setSelection(t, "end"), e.execute("checkTodoList"), n.setSelection(o)
                }))
            }
        }
        class Ox extends Vi {
            static get pluginName() {
                return "TodoListUI"
            }
            init() {
                const t = this.editor.t;
                Dy(this.editor, "todoList", t("To-do List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m2.315 14.705 2.224-2.24a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .949L2.865 16.07a.682.682 0 0 1-.112.089.647.647 0 0 1-.852-.051L.688 14.886a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.717.722zm5.185.045a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75zM2.329 5.745l2.21-2.226a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .95L2.865 7.125a.685.685 0 0 1-.496.196.644.644 0 0 1-.468-.187L.688 5.912a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.73.736zM7.5 5.75A.75.75 0 0 1 8.25 5h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>')
            }
        }
        var Fx = n(1199),
            Mx = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(Fx.Z, Mx);
        Fx.Z.locals;

        function Nx(t, e) {
            if (!t.childCount) return;
            const n = new cu(t.document),
                o = function(t, e) {
                    const n = e.createRangeIn(t),
                        o = new rr({
                            name: /^p|h\d+$/,
                            styles: {
                                "mso-list": /.*/
                            }
                        }),
                        i = [];
                    for (const t of n)
                        if ("elementStart" === t.type && o.match(t.item)) {
                            const e = jx(t.item);
                            i.push({
                                element: t.item,
                                id: e.id,
                                order: e.order,
                                indent: e.indent
                            })
                        } return i
                }(t, n);
            if (!o.length) return;
            let i = null,
                r = 1;
            o.forEach(((t, s) => {
                const a = function(t, e) {
                        if (!t) return !0;
                        if (t.id !== e.id) return e.indent - t.indent != 1;
                        const n = e.element.previousSibling;
                        if (!n) return !0;
                        return o = n, !(o.is("element", "ol") || o.is("element", "ul"));
                        var o
                    }(o[s - 1], t),
                    l = a ? null : o[s - 1],
                    c = (h = t, (d = l) ? h.indent - d.indent : h.indent - 1);
                var d, h;
                if (a && (i = null, r = 1), !i || 0 !== c) {
                    const o = function(t, e) {
                        const n = new RegExp(`@list l${t.id}:level${t.indent}\\s*({[^}]*)`, "gi"),
                            o = /mso-level-number-format:([^;]{0,100});/gi,
                            i = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi,
                            r = n.exec(e);
                        let s = "decimal",
                            a = "ol",
                            l = null;
                        if (r && r[1]) {
                            const e = o.exec(r[1]);
                            if (e && e[1] && (s = e[1].trim(), a = "bullet" !== s && "image" !== s ? "ol" : "ul"), "bullet" === s) {
                                const e = function(t) {
                                    const e = function(t) {
                                        if (t.getChild(0).is("$text")) return null;
                                        for (const e of t.getChildren()) {
                                            if (!e.is("element", "span")) continue;
                                            const t = e.getChild(0);
                                            if (t) return t.is("$text") ? t : t.getChild(0)
                                        }
                                        return null
                                    }(t);
                                    if (!e) return null;
                                    const n = e._data;
                                    if ("o" === n) return "circle";
                                    if ("·" === n) return "disc";
                                    if ("§" === n) return "square";
                                    return null
                                }(t.element);
                                e && (s = e)
                            } else {
                                const t = i.exec(r[1]);
                                t && t[1] && (l = parseInt(t[1]))
                            }
                        }
                        return {
                            type: a,
                            startIndex: l,
                            style: Lx(s)
                        }
                    }(t, e);
                    if (i) {
                        if (t.indent > r) {
                            const t = i.getChild(i.childCount - 1),
                                e = t.getChild(t.childCount - 1);
                            i = Hx(o, e, n), r += 1
                        } else if (t.indent < r) {
                            const e = r - t.indent;
                            i = function(t, e) {
                                const n = t.getAncestors({
                                    parentFirst: !0
                                });
                                let o = null,
                                    i = 0;
                                for (const t of n)
                                    if ((t.is("element", "ul") || t.is("element", "ol")) && i++, i === e) {
                                        o = t;
                                        break
                                    } return o
                            }(i, e), r = t.indent
                        }
                    } else i = Hx(o, t.element, n);
                    t.indent <= r && (i.is("element", o.type) || (i = n.rename(o.type, i)))
                }
                const u = function(t, e) {
                    return function(t, e) {
                        const n = new rr({
                                name: "span",
                                styles: {
                                    "mso-list": "Ignore"
                                }
                            }),
                            o = e.createRangeIn(t);
                        for (const t of o) "elementStart" === t.type && n.match(t.item) && e.remove(t.item)
                    }(t, e), e.removeStyle("text-indent", t), e.rename("li", t)
                }(t.element, n);
                n.appendChild(u, i)
            }))
        }

        function Lx(t) {
            if (t.startsWith("arabic-leading-zero")) return "decimal-leading-zero";
            switch (t) {
                case "alpha-upper":
                    return "upper-alpha";
                case "alpha-lower":
                    return "lower-alpha";
                case "roman-upper":
                    return "upper-roman";
                case "roman-lower":
                    return "lower-roman";
                case "circle":
                case "disc":
                case "square":
                    return t;
                default:
                    return null
            }
        }

        function Hx(t, e, n) {
            const o = e.parent,
                i = n.createElement(t.type),
                r = o.getChildIndex(e) + 1;
            return n.insertChild(r, i, o), t.style && n.setStyle("list-style-type", t.style, i), t.startIndex && t.startIndex > 1 && n.setAttribute("start", t.startIndex, i), i
        }

        function jx(t) {
            const e = {},
                n = t.getStyle("mso-list");
            if (n) {
                const t = n.match(/(^|\s{1,100})l(\d+)/i),
                    o = n.match(/\s{0,100}lfo(\d+)/i),
                    i = n.match(/\s{0,100}level(\d+)/i);
                t && o && i && (e.id = t[2], e.order = o[1], e.indent = parseInt(i[1]))
            }
            return e
        }

        function qx(t, e) {
            if (!t.childCount) return;
            const n = new cu(t.document),
                o = function(t, e) {
                    const n = e.createRangeIn(t),
                        o = new rr({
                            name: /v:(.+)/
                        }),
                        i = [];
                    for (const t of n) {
                        if ("elementStart" != t.type) continue;
                        const e = t.item,
                            n = e.previousSibling,
                            r = n && n.is("element") ? n.name : null;
                        o.match(e) && e.getAttribute("o:gfxdata") && "v:shapetype" !== r && i.push(t.item.getAttribute("id"))
                    }
                    return i
                }(t, n);
            ! function(t, e, n) {
                const o = n.createRangeIn(e),
                    i = new rr({
                        name: "img"
                    }),
                    r = [];
                for (const e of o)
                    if (e.item.is("element") && i.match(e.item)) {
                        const n = e.item,
                            o = n.getAttribute("v:shapes") ? n.getAttribute("v:shapes").split(" ") : [];
                        o.length && o.every((e => t.indexOf(e) > -1)) ? r.push(n) : n.getAttribute("src") || r.push(n)
                    } for (const t of r) n.remove(t)
            }(o, t, n),
            function(t, e, n) {
                const o = n.createRangeIn(e),
                    i = [];
                for (const e of o)
                    if ("elementStart" == e.type && e.item.is("element", "v:shape")) {
                        const n = e.item.getAttribute("id");
                        if (t.includes(n)) continue;
                        r(e.item.parent.getChildren(), n) || i.push(e.item)
                    } for (const t of i) {
                    const e = {
                        src: s(t)
                    };
                    t.hasAttribute("alt") && (e.alt = t.getAttribute("alt"));
                    const o = n.createElement("img", e);
                    n.insertChild(t.index + 1, o, t.parent)
                }

                function r(t, e) {
                    for (const n of t)
                        if (n.is("element")) {
                            if ("img" == n.name && n.getAttribute("v:shapes") == e) return !0;
                            if (r(n.getChildren(), e)) return !0
                        } return !1
                }

                function s(t) {
                    for (const e of t.getChildren())
                        if (e.is("element") && e.getAttribute("src")) return e.getAttribute("src")
                }
            }(o, t, n),
            function(t, e) {
                const n = e.createRangeIn(t),
                    o = new rr({
                        name: /v:(.+)/
                    }),
                    i = [];
                for (const t of n) "elementStart" == t.type && o.match(t.item) && i.push(t.item);
                for (const t of i) e.remove(t)
            }(t, n);
            const i = function(t, e) {
                const n = e.createRangeIn(t),
                    o = new rr({
                        name: "img"
                    }),
                    i = [];
                for (const t of n) t.item.is("element") && o.match(t.item) && t.item.getAttribute("src").startsWith("file://") && i.push(t.item);
                return i
            }(t, n);
            i.length && function(t, e, n) {
                if (t.length === e.length)
                    for (let o = 0; o < t.length; o++) {
                        const i = `data:${e[o].type};base64,${Wx(e[o].hex)}`;
                        n.setAttribute("src", i, t[o])
                    }
            }(i, function(t) {
                if (!t) return [];
                const e = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/,
                    n = new RegExp("(?:(" + e.source + "))([\\da-fA-F\\s]+)\\}", "g"),
                    o = t.match(n),
                    i = [];
                if (o)
                    for (const t of o) {
                        let n = !1;
                        t.includes("\\pngblip") ? n = "image/png" : t.includes("\\jpegblip") && (n = "image/jpeg"), n && i.push({
                            hex: t.replace(e, "").replace(/[^\da-fA-F]/g, ""),
                            type: n
                        })
                    }
                return i
            }(e), n)
        }

        function Wx(t) {
            return btoa(t.match(/\w{2}/g).map((t => String.fromCharCode(parseInt(t, 16)))).join(""))
        }
        const Ux = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i,
            $x = /xmlns:o="urn:schemas-microsoft-com/i;
        class Gx {
            constructor(t) {
                this.document = t
            }
            isActive(t) {
                return Ux.test(t) || $x.test(t)
            }
            execute(t) {
                const {
                    body: e,
                    stylesString: n
                } = t._parsedData;
                Nx(e, n), qx(e, t.dataTransfer.getData("text/rtf")), t.content = e
            }
        }

        function Kx(t, e, n, {
            blockElements: o,
            inlineObjectElements: i
        }) {
            let r = n.createPositionAt(t, "forward" == e ? "after" : "before");
            return r = r.getLastMatchingPosition((({
                item: t
            }) => t.is("element") && !o.includes(t.name) && !i.includes(t.name)), {
                direction: e
            }), "forward" == e ? r.nodeAfter : r.nodeBefore
        }

        function Zx(t, e) {
            return !!t && t.is("element") && e.includes(t.name)
        }
        const Jx = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
        class Yx {
            constructor(t) {
                this.document = t
            }
            isActive(t) {
                return Jx.test(t)
            }
            execute(t) {
                const e = new cu(this.document),
                    {
                        body: n
                    } = t._parsedData;
                ! function(t, e) {
                    for (const n of t.getChildren())
                        if (n.is("element", "b") && "normal" === n.getStyle("font-weight")) {
                            const o = t.getChildIndex(n);
                            e.remove(n), e.insertChild(o, n.getChildren(), t)
                        }
                }(n, e),
                function(t, e) {
                    for (const n of e.createRangeIn(t)) {
                        const t = n.item;
                        if (t.is("element", "li")) {
                            const n = t.getChild(0);
                            n && n.is("element", "p") && e.unwrapElement(n)
                        }
                    }
                }(n, e),
                function(t, e) {
                    const n = new xs(e.document.stylesProcessor),
                        o = new fa(n, {
                            renderingMode: "data"
                        }),
                        i = o.blockElements,
                        r = o.inlineObjectElements,
                        s = [];
                    for (const n of e.createRangeIn(t)) {
                        const t = n.item;
                        if (t.is("element", "br")) {
                            const n = Kx(t, "forward", e, {
                                    blockElements: i,
                                    inlineObjectElements: r
                                }),
                                o = Kx(t, "backward", e, {
                                    blockElements: i,
                                    inlineObjectElements: r
                                }),
                                a = Zx(n, i);
                            (Zx(o, i) || a) && s.push(t)
                        }
                    }
                    for (const t of s) t.hasClass("Apple-interchange-newline") ? e.remove(t) : e.replace(t, e.createElement("p"))
                }(n, e), t.content = n
            }
        }
        const Qx = /<google-sheets-html-origin/i;
        class Xx {
            constructor(t) {
                this.document = t
            }
            isActive(t) {
                return Qx.test(t)
            }
            execute(t) {
                const e = new cu(this.document),
                    {
                        body: n
                    } = t._parsedData;
                ! function(t, e) {
                    for (const n of t.getChildren())
                        if (n.is("element", "google-sheets-html-origin")) {
                            const o = t.getChildIndex(n);
                            e.remove(n), e.insertChild(o, n.getChildren(), t)
                        }
                }(n, e),
                function(t, e) {
                    for (const n of t.getChildren()) n.is("element", "table") && n.hasAttribute("xmlns") && e.removeAttribute("xmlns", n)
                }(n, e),
                function(t, e) {
                    for (const n of t.getChildren()) n.is("element", "table") && "0px" === n.getStyle("width") && e.removeStyle("width", n)
                }(n, e),
                function(t, e) {
                    for (const n of Array.from(t.getChildren())) n.is("element", "style") && e.remove(n)
                }(n, e), t.content = n
            }
        }

        function tE(t) {
            return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, ((t, e) => 1 === e.length ? " " : Array(e.length + 1).join("  ").substr(0, e.length)))
        }

        function eE(t, e) {
            const n = new DOMParser,
                o = function(t) {
                    return tE(tE(t)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, "$1 $2").replace(/ <\//g, " </").replace(/ <o:p><\/o:p>/g, " <o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><")
                }(function(t) {
                    const e = "</body>",
                        n = "</html>",
                        o = t.indexOf(e);
                    if (o < 0) return t;
                    const i = t.indexOf(n, o + e.length);
                    return t.substring(0, o + e.length) + (i >= 0 ? t.substring(i) : "")
                }(t = t.replace(/<!--\[if gte vml 1]>/g, ""))),
                i = n.parseFromString(o, "text/html");
            ! function(t) {
                t.querySelectorAll("span[style*=spacerun]").forEach((t => {
                    const e = t,
                        n = e.innerText.length || 0;
                    e.innerText = Array(n + 1).join("  ").substr(0, n)
                }))
            }(i);
            const r = i.body.innerHTML,
                s = function(t, e) {
                    const n = new xs(e),
                        o = new fa(n, {
                            renderingMode: "data"
                        }),
                        i = t.createDocumentFragment(),
                        r = t.body.childNodes;
                    for (; r.length > 0;) i.appendChild(r[0]);
                    return o.domToView(i, {
                        skipComments: !0
                    })
                }(i, e),
                a = function(t) {
                    const e = [],
                        n = [],
                        o = Array.from(t.getElementsByTagName("style"));
                    for (const t of o) t.sheet && t.sheet.cssRules && t.sheet.cssRules.length && (e.push(t.sheet), n.push(t.innerHTML));
                    return {
                        styles: e,
                        stylesString: n.join(" ")
                    }
                }(i);
            return {
                body: s,
                bodyString: r,
                styles: a.styles,
                stylesString: a.stylesString
            }
        }

        function nE(t, e) {
            const {
                modelAttribute: n,
                styleName: o,
                viewElement: i,
                defaultValue: r,
                reduceBoxSides: s = !1,
                shouldUpcast: a = (() => !0)
            } = e;
            t.for("upcast").attributeToAttribute({
                view: {
                    name: i,
                    styles: {
                        [o]: /[\s\S]+/
                    }
                },
                model: {
                    key: n,
                    value: t => {
                        if (!a(t)) return;
                        const e = t.getNormalizedStyle(o),
                            n = s ? sE(e) : e;
                        return r !== n ? n : void 0
                    }
                }
            })
        }

        function oE(t, e, n, o) {
            t.for("upcast").add((t => t.on("element:" + e, ((t, e, i) => {
                if (!e.modelRange) return;
                const r = ["border-top-width", "border-top-color", "border-top-style", "border-bottom-width", "border-bottom-color", "border-bottom-style", "border-right-width", "border-right-color", "border-right-style", "border-left-width", "border-left-color", "border-left-style"].filter((t => e.viewItem.hasStyle(t)));
                if (!r.length) return;
                const s = {
                    styles: r
                };
                if (!i.consumable.test(e.viewItem, s)) return;
                const a = [...e.modelRange.getItems({
                    shallow: !0
                })].pop();
                i.consumable.consume(e.viewItem, s);
                const l = {
                        style: e.viewItem.getNormalizedStyle("border-style"),
                        color: e.viewItem.getNormalizedStyle("border-color"),
                        width: e.viewItem.getNormalizedStyle("border-width")
                    },
                    c = {
                        style: sE(l.style),
                        color: sE(l.color),
                        width: sE(l.width)
                    };
                c.style !== o.style && i.writer.setAttribute(n.style, c.style, a), c.color !== o.color && i.writer.setAttribute(n.color, c.color, a), c.width !== o.width && i.writer.setAttribute(n.width, c.width, a)
            }))))
        }

        function iE(t, e) {
            const {
                modelElement: n,
                modelAttribute: o,
                styleName: i
            } = e;
            t.for("downcast").attributeToAttribute({
                model: {
                    name: n,
                    key: o
                },
                view: t => ({
                    key: "style",
                    value: {
                        [i]: t
                    }
                })
            })
        }

        function rE(t, e) {
            const {
                modelAttribute: n,
                styleName: o
            } = e;
            t.for("downcast").add((t => t.on(`attribute:${n}:table`, ((t, e, n) => {
                const {
                    item: i,
                    attributeNewValue: r
                } = e, {
                    mapper: s,
                    writer: a
                } = n;
                if (!n.consumable.consume(e.item, t.name)) return;
                const l = [...s.toViewElement(i).getChildren()].find((t => t.is("element", "table")));
                r ? a.setStyle(o, r, l) : a.removeStyle(o, l)
            }))))
        }

        function sE(t) {
            if (!t) return;
            const e = ["top", "right", "bottom", "left"];
            if (!e.every((e => t[e]))) return t;
            const n = t.top;
            return e.every((e => t[e] === n)) ? n : t
        }
        var aE = Object.defineProperty,
            lE = Object.getOwnPropertySymbols,
            cE = Object.prototype.hasOwnProperty,
            dE = Object.prototype.propertyIsEnumerable,
            hE = (t, e, n) => e in t ? aE(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n,
            uE = (t, e) => {
                for (var n in e || (e = {})) cE.call(e, n) && hE(t, n, e[n]);
                if (lE)
                    for (var n of lE(e)) dE.call(e, n) && hE(t, n, e[n]);
                return t
            };

        function gE(t, e, n, o, i = 1) {
            null != e && null != i && e > i ? o.setAttribute(t, e, n) : o.removeAttribute(t, n)
        }

        function mE(t, e, n = {}) {
            const o = t.createElement("tableCell", n);
            return t.insertElement("paragraph", o), t.insert(o, e), o
        }

        function pE(t, e) {
            const n = e.parent.parent,
                o = parseInt(n.getAttribute("headingColumns") || "0"),
                {
                    column: i
                } = t.getCellLocation(e);
            return !!o && i < o
        }

        function fE(t, e, n) {
            const {
                modelAttribute: o
            } = n;
            t.extend("tableCell", {
                allowAttributes: [o]
            }), nE(e, uE({
                viewElement: /^(td|th)$/
            }, n)), iE(e, uE({
                modelElement: "tableCell"
            }, n))
        }

        function bE() {
            return t => {
                t.on("element:table", ((t, e, n) => {
                    const o = e.viewItem;
                    if (!n.consumable.test(o, {
                            name: !0
                        })) return;
                    const {
                        rows: i,
                        headingRows: r,
                        headingColumns: s
                    } = function(t) {
                        let e, n = 0;
                        const o = [],
                            i = [];
                        let r;
                        for (const s of Array.from(t.getChildren())) {
                            if ("tbody" !== s.name && "thead" !== s.name && "tfoot" !== s.name) continue;
                            "thead" !== s.name || r || (r = s);
                            const t = Array.from(s.getChildren()).filter((t => t.is("element", "tr")));
                            for (const a of t)
                                if (r && s === r || "tbody" === s.name && Array.from(a.getChildren()).length && Array.from(a.getChildren()).every((t => t.is("element", "th")))) n++, o.push(a);
                                else {
                                    i.push(a);
                                    const t = wE(a);
                                    (!e || t < e) && (e = t)
                                }
                        }
                        return {
                            headingRows: n,
                            headingColumns: e || 0,
                            rows: [...o, ...i]
                        }
                    }(o), a = {};
                    s && (a.headingColumns = s), r && (a.headingRows = r);
                    const l = n.writer.createElement("table", a);
                    if (n.safeInsert(l, e.modelCursor)) {
                        if (n.consumable.consume(o, {
                                name: !0
                            }), i.forEach((t => n.convertItem(t, n.writer.createPositionAt(l, "end")))), n.convertChildren(o, n.writer.createPositionAt(l, "end")), l.isEmpty) {
                            const t = n.writer.createElement("tableRow");
                            n.writer.insert(t, n.writer.createPositionAt(l, "end")), mE(n.writer, n.writer.createPositionAt(t, "end"))
                        }
                        n.updateConversionResult(l, e)
                    }
                }))
            }
        }

        function kE(t) {
            return e => {
                e.on(`element:${t}`, ((t, e, {
                    writer: n
                }) => {
                    if (!e.modelRange) return;
                    const o = e.modelRange.start.nodeAfter,
                        i = n.createPositionAt(o, 0);
                    if (e.viewItem.isEmpty) return void n.insertElement("paragraph", i);
                    const r = Array.from(o.getChildren());
                    if (r.every((t => t.is("element", "$marker")))) {
                        const t = n.createElement("paragraph");
                        n.insert(t, n.createPositionAt(o, 0));
                        for (const e of r) n.move(n.createRangeOn(e), n.createPositionAt(t, "end"))
                    }
                }), {
                    priority: "low"
                })
            }
        }

        function wE(t) {
            let e = 0,
                n = 0;
            const o = Array.from(t.getChildren()).filter((t => "th" === t.name || "td" === t.name));
            for (; n < o.length && "th" === o[n].name;) {
                const t = o[n];
                e += parseInt(t.getAttribute("colspan") || "1"), n++
            }
            return e
        }
        class AE {
            constructor(t, e = {}) {
                this._table = t, this._startRow = void 0 !== e.row ? e.row : e.startRow || 0, this._endRow = void 0 !== e.row ? e.row : e.endRow, this._startColumn = void 0 !== e.column ? e.column : e.startColumn || 0, this._endColumn = void 0 !== e.column ? e.column : e.endColumn, this._includeAllSlots = !!e.includeAllSlots, this._skipRows = new Set, this._row = 0, this._rowIndex = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = new Map, this._nextCellAtColumn = -1
            } [Symbol.iterator]() {
                return this
            }
            next() {
                const t = this._table.getChild(this._rowIndex);
                if (!t || this._isOverEndRow()) return {
                    done: !0,
                    value: void 0
                };
                if (!t.is("element", "tableRow")) return this._rowIndex++, this.next();
                if (this._isOverEndColumn()) return this._advanceToNextRow();
                let e = null;
                const n = this._getSpanned();
                if (n) this._includeAllSlots && !this._shouldSkipSlot() && (e = this._formatOutValue(n.cell, n.row, n.column));
                else {
                    const n = t.getChild(this._cellIndex);
                    if (!n) return this._advanceToNextRow();
                    const o = parseInt(n.getAttribute("colspan") || "1"),
                        i = parseInt(n.getAttribute("rowspan") || "1");
                    (o > 1 || i > 1) && this._recordSpans(n, i, o), this._shouldSkipSlot() || (e = this._formatOutValue(n)), this._nextCellAtColumn = this._column + o
                }
                return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, e || this.next()
            }
            skipRow(t) {
                this._skipRows.add(t)
            }
            _advanceToNextRow() {
                return this._row++, this._rowIndex++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next()
            }
            _isOverEndRow() {
                return void 0 !== this._endRow && this._row > this._endRow
            }
            _isOverEndColumn() {
                return void 0 !== this._endColumn && this._column > this._endColumn
            }
            _formatOutValue(t, e = this._row, n = this._column) {
                return {
                    done: !1,
                    value: new CE(this, t, e, n)
                }
            }
            _shouldSkipSlot() {
                const t = this._skipRows.has(this._row),
                    e = this._row < this._startRow,
                    n = this._column < this._startColumn,
                    o = void 0 !== this._endColumn && this._column > this._endColumn;
                return t || e || n || o
            }
            _getSpanned() {
                const t = this._spannedCells.get(this._row);
                return t && t.get(this._column) || null
            }
            _recordSpans(t, e, n) {
                const o = {
                    cell: t,
                    row: this._row,
                    column: this._column
                };
                for (let t = this._row; t < this._row + e; t++)
                    for (let e = this._column; e < this._column + n; e++) t == this._row && e == this._column || this._markSpannedCell(t, e, o)
            }
            _markSpannedCell(t, e, n) {
                this._spannedCells.has(t) || this._spannedCells.set(t, new Map);
                this._spannedCells.get(t).set(e, n)
            }
        }
        class CE {
            constructor(t, e, n, o) {
                this.cell = e, this.row = t._row, this.column = t._column, this.cellAnchorRow = n, this.cellAnchorColumn = o, this._cellIndex = t._cellIndex, this._rowIndex = t._rowIndex, this._table = t._table
            }
            get isAnchor() {
                return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn
            }
            get cellWidth() {
                return parseInt(this.cell.getAttribute("colspan") || "1")
            }
            get cellHeight() {
                return parseInt(this.cell.getAttribute("rowspan") || "1")
            }
            get rowIndex() {
                return this._rowIndex
            }
            getPositionBefore() {
                return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex)
            }
        }

        function _E(t, e) {
            return (n, {
                writer: o
            }) => {
                const i = n.getAttribute("headingRows") || 0,
                    r = o.createContainerElement("table", null, []),
                    s = o.createContainerElement("figure", {
                        class: "table"
                    }, r);
                i > 0 && o.insert(o.createPositionAt(r, "end"), o.createContainerElement("thead", null, o.createSlot((t => t.is("element", "tableRow") && t.index < i)))), i < t.getRows(n) && o.insert(o.createPositionAt(r, "end"), o.createContainerElement("tbody", null, o.createSlot((t => t.is("element", "tableRow") && t.index >= i))));
                for (const {
                        positionOffset: t,
                        filter: n
                    }
                    of e.additionalSlots) o.insert(o.createPositionAt(r, t), o.createSlot(n));
                return o.insert(o.createPositionAt(r, "after"), o.createSlot((t => !t.is("element", "tableRow") && !e.additionalSlots.some((({
                    filter: e
                }) => e(t)))))), e.asWidget ? function(t, e) {
                    return e.setCustomProperty("table", !0, t), Gw(t, e, {
                        hasSelectionHandle: !0
                    })
                }(s, o) : s
            }
        }

        function vE(t = {}) {
            return (e, {
                writer: n
            }) => {
                const o = e.parent,
                    i = o.parent,
                    r = i.getChildIndex(o),
                    s = new AE(i, {
                        row: r
                    }),
                    a = i.getAttribute("headingRows") || 0,
                    l = i.getAttribute("headingColumns") || 0;
                let c = null;
                for (const o of s)
                    if (o.cell == e) {
                        const e = o.row < a || o.column < l ? "th" : "td";
                        c = t.asWidget ? Yw(n.createEditableElement(e), n) : n.createContainerElement(e);
                        break
                    } return c
            }
        }

        function yE(t = {}) {
            return (e, {
                writer: n
            }) => {
                if (!e.parent.is("element", "tableCell")) return null;
                if (!xE(e)) return null;
                if (t.asWidget) return n.createContainerElement("span", {
                    class: "ck-table-bogus-paragraph"
                });
                {
                    const t = n.createContainerElement("p");
                    return n.setCustomProperty("dataPipeline:transparentRendering", !0, t), t
                }
            }
        }

        function xE(t) {
            return 1 == t.parent.childCount && !!t.getAttributeKeys().next().done
        }
        class EE extends Fi {
            refresh() {
                const t = this.editor.model,
                    e = t.document.selection,
                    n = t.schema;
                this.isEnabled = function(t, e) {
                    const n = t.getFirstPosition().parent,
                        o = n === n.root ? n : n.parent;
                    return e.checkChild(o, "table")
                }(e, n)
            }
            execute(t = {}) {
                const e = this.editor,
                    n = e.model,
                    o = e.plugins.get("TableUtils"),
                    i = e.config.get("table.defaultHeadings.rows"),
                    r = e.config.get("table.defaultHeadings.columns");
                void 0 === t.headingRows && i && (t.headingRows = i), void 0 === t.headingColumns && r && (t.headingColumns = r), n.change((e => {
                    const i = o.createTable(e, t);
                    n.insertObject(i, null, null, {
                        findOptimalPosition: "auto"
                    }), e.setSelection(e.createPositionAt(i.getNodeByPath([0, 0, 0]), 0))
                }))
            }
        }
        class DE extends Fi {
            constructor(t, e = {}) {
                super(t), this.order = e.order || "below"
            }
            refresh() {
                const t = this.editor.model.document.selection,
                    e = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t).length;
                this.isEnabled = e
            }
            execute() {
                const t = this.editor,
                    e = t.model.document.selection,
                    n = t.plugins.get("TableUtils"),
                    o = "above" === this.order,
                    i = n.getSelectionAffectedTableCells(e),
                    r = n.getRowIndexes(i),
                    s = o ? r.first : r.last,
                    a = i[0].findAncestor("table");
                n.insertRows(a, {
                    at: o ? s : s + 1,
                    copyStructureFromAbove: !o
                })
            }
        }
        class SE extends Fi {
            constructor(t, e = {}) {
                super(t), this.order = e.order || "right"
            }
            refresh() {
                const t = this.editor.model.document.selection,
                    e = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t).length;
                this.isEnabled = e
            }
            execute() {
                const t = this.editor,
                    e = t.model.document.selection,
                    n = t.plugins.get("TableUtils"),
                    o = "left" === this.order,
                    i = n.getSelectionAffectedTableCells(e),
                    r = n.getColumnIndexes(i),
                    s = o ? r.first : r.last,
                    a = i[0].findAncestor("table");
                n.insertColumns(a, {
                    columns: 1,
                    at: o ? s : s + 1
                })
            }
        }
        class TE extends Fi {
            constructor(t, e = {}) {
                super(t), this.direction = e.direction || "horizontally"
            }
            refresh() {
                const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
                this.isEnabled = 1 === t.length
            }
            execute() {
                const t = this.editor.plugins.get("TableUtils"),
                    e = t.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
                "horizontally" === this.direction ? t.splitCellHorizontally(e, 2) : t.splitCellVertically(e, 2)
            }
        }

        function BE(t, e, n) {
            const {
                startRow: o,
                startColumn: i,
                endRow: r,
                endColumn: s
            } = e, a = n.createElement("table"), l = r - o + 1;
            for (let t = 0; t < l; t++) n.insertElement("tableRow", a, "end");
            const c = [...new AE(t, {
                startRow: o,
                endRow: r,
                startColumn: i,
                endColumn: s,
                includeAllSlots: !0
            })];
            for (const {
                    row: t,
                    column: e,
                    cell: l,
                    isAnchor: d,
                    cellAnchorRow: h,
                    cellAnchorColumn: u
                }
                of c) {
                const c = t - o,
                    g = a.getChild(c);
                if (d) {
                    const o = n.cloneElement(l);
                    n.append(o, g), VE(o, t, e, r, s, n)
                } else(h < o || u < i) && mE(n, n.createPositionAt(g, "end"))
            }
            return function(t, e, n, o, i) {
                const r = parseInt(e.getAttribute("headingRows") || "0");
                if (r > 0) {
                    gE("headingRows", r - n, t, i, 0)
                }
                const s = parseInt(e.getAttribute("headingColumns") || "0");
                if (s > 0) {
                    gE("headingColumns", s - o, t, i, 0)
                }
            }(a, t, o, i, n), a
        }

        function IE(t, e, n = 0) {
            const o = [],
                i = new AE(t, {
                    startRow: n,
                    endRow: e - 1
                });
            for (const t of i) {
                const {
                    row: n,
                    cellHeight: i
                } = t;
                n < e && e <= n + i - 1 && o.push(t)
            }
            return o
        }

        function PE(t, e, n) {
            const o = t.parent,
                i = o.parent,
                r = o.index,
                s = e - r,
                a = {},
                l = parseInt(t.getAttribute("rowspan")) - s;
            l > 1 && (a.rowspan = l);
            const c = parseInt(t.getAttribute("colspan") || "1");
            c > 1 && (a.colspan = c);
            const d = r + s,
                h = [...new AE(i, {
                    startRow: r,
                    endRow: d,
                    includeAllSlots: !0
                })];
            let u, g = null;
            for (const e of h) {
                const {
                    row: o,
                    column: i,
                    cell: r
                } = e;
                r === t && void 0 === u && (u = i), void 0 !== u && u === i && o === d && (g = mE(n, e.getPositionBefore(), a))
            }
            return gE("rowspan", s, t, n), g
        }

        function RE(t, e) {
            const n = [],
                o = new AE(t);
            for (const t of o) {
                const {
                    column: o,
                    cellWidth: i
                } = t;
                o < e && e <= o + i - 1 && n.push(t)
            }
            return n
        }

        function zE(t, e, n, o) {
            const i = n - e,
                r = {},
                s = parseInt(t.getAttribute("colspan")) - i;
            s > 1 && (r.colspan = s);
            const a = parseInt(t.getAttribute("rowspan") || "1");
            a > 1 && (r.rowspan = a);
            const l = mE(o, o.createPositionAfter(t), r);
            return gE("colspan", i, t, o), l
        }

        function VE(t, e, n, o, i, r) {
            const s = parseInt(t.getAttribute("colspan") || "1"),
                a = parseInt(t.getAttribute("rowspan") || "1");
            if (n + s - 1 > i) {
                gE("colspan", i - n + 1, t, r, 1)
            }
            if (e + a - 1 > o) {
                gE("rowspan", o - e + 1, t, r, 1)
            }
        }

        function OE(t, e) {
            const n = e.getColumns(t),
                o = new Array(n).fill(0);
            for (const {
                    column: e
                }
                of new AE(t)) o[e]++;
            const i = o.reduce(((t, e, n) => e ? t : [...t, n]), []);
            if (i.length > 0) {
                const n = i[i.length - 1];
                return e.removeColumns(t, {
                    at: n
                }), !0
            }
            return !1
        }

        function FE(t, e) {
            const n = [],
                o = e.getRows(t);
            for (let e = 0; e < o; e++) {
                t.getChild(e).isEmpty && n.push(e)
            }
            if (n.length > 0) {
                const o = n[n.length - 1];
                return e.removeRows(t, {
                    at: o
                }), !0
            }
            return !1
        }

        function ME(t, e) {
            OE(t, e) || FE(t, e)
        }

        function NE(t, e) {
            const n = Array.from(new AE(t, {
                startColumn: e.firstColumn,
                endColumn: e.lastColumn,
                row: e.lastRow
            }));
            if (n.every((({
                    cellHeight: t
                }) => 1 === t))) return e.lastRow;
            const o = n[0].cellHeight - 1;
            return e.lastRow + o
        }

        function LE(t, e) {
            const n = Array.from(new AE(t, {
                startRow: e.firstRow,
                endRow: e.lastRow,
                column: e.lastColumn
            }));
            if (n.every((({
                    cellWidth: t
                }) => 1 === t))) return e.lastColumn;
            const o = n[0].cellWidth - 1;
            return e.lastColumn + o
        }
        class HE extends Fi {
            constructor(t, e) {
                super(t), this.direction = e.direction, this.isHorizontal = "right" == this.direction || "left" == this.direction
            }
            refresh() {
                const t = this._getMergeableCell();
                this.value = t, this.isEnabled = !!t
            }
            execute() {
                const t = this.editor.model,
                    e = t.document,
                    n = this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(e.selection)[0],
                    o = this.value,
                    i = this.direction;
                t.change((t => {
                    const e = "right" == i || "down" == i,
                        r = e ? n : o,
                        s = e ? o : n,
                        a = s.parent;
                    ! function(t, e, n) {
                        jE(t) || (jE(e) && n.remove(n.createRangeIn(e)), n.move(n.createRangeIn(t), n.createPositionAt(e, "end")));
                        n.remove(t)
                    }(s, r, t);
                    const l = this.isHorizontal ? "colspan" : "rowspan",
                        c = parseInt(n.getAttribute(l) || "1"),
                        d = parseInt(o.getAttribute(l) || "1");
                    t.setAttribute(l, c + d, r), t.setSelection(t.createRangeIn(r));
                    const h = this.editor.plugins.get("TableUtils");
                    ME(a.findAncestor("table"), h)
                }))
            }
            _getMergeableCell() {
                const t = this.editor.model.document,
                    e = this.editor.plugins.get("TableUtils"),
                    n = e.getTableCellsContainingSelection(t.selection)[0];
                if (!n) return;
                const o = this.isHorizontal ? function(t, e, n) {
                    const o = t.parent,
                        i = o.parent,
                        r = "right" == e ? t.nextSibling : t.previousSibling,
                        s = (i.getAttribute("headingColumns") || 0) > 0;
                    if (!r) return;
                    const a = "right" == e ? t : r,
                        l = "right" == e ? r : t,
                        {
                            column: c
                        } = n.getCellLocation(a),
                        {
                            column: d
                        } = n.getCellLocation(l),
                        h = parseInt(a.getAttribute("colspan") || "1"),
                        u = pE(n, a),
                        g = pE(n, l);
                    if (s && u != g) return;
                    return c + h === d ? r : void 0
                }(n, this.direction, e) : function(t, e, n) {
                    const o = t.parent,
                        i = o.parent,
                        r = i.getChildIndex(o);
                    if ("down" == e && r === n.getRows(i) - 1 || "up" == e && 0 === r) return null;
                    const s = parseInt(t.getAttribute("rowspan") || "1"),
                        a = i.getAttribute("headingRows") || 0,
                        l = "down" == e && r + s === a,
                        c = "up" == e && r === a;
                    if (a && (l || c)) return null;
                    const d = parseInt(t.getAttribute("rowspan") || "1"),
                        h = "down" == e ? r + d : r,
                        u = [...new AE(i, {
                            endRow: h
                        })],
                        g = u.find((e => e.cell === t)),
                        m = g.column,
                        p = u.find((({
                            row: t,
                            cellHeight: n,
                            column: o
                        }) => o === m && ("down" == e ? t === h : h === t + n)));
                    return p && p.cell ? p.cell : null
                }(n, this.direction, e);
                if (!o) return;
                const i = this.isHorizontal ? "rowspan" : "colspan",
                    r = parseInt(n.getAttribute(i) || "1");
                return parseInt(o.getAttribute(i) || "1") === r ? o : void 0
            }
        }

        function jE(t) {
            const e = t.getChild(0);
            return 1 == t.childCount && e.is("element", "paragraph") && e.isEmpty
        }
        class qE extends Fi {
            refresh() {
                const t = this.editor.plugins.get("TableUtils"),
                    e = t.getSelectionAffectedTableCells(this.editor.model.document.selection),
                    n = e[0];
                if (n) {
                    const o = n.findAncestor("table"),
                        i = t.getRows(o) - 1,
                        r = t.getRowIndexes(e),
                        s = 0 === r.first && r.last === i;
                    this.isEnabled = !s
                } else this.isEnabled = !1
            }
            execute() {
                const t = this.editor.model,
                    e = this.editor.plugins.get("TableUtils"),
                    n = e.getSelectionAffectedTableCells(t.document.selection),
                    o = e.getRowIndexes(n),
                    i = n[0],
                    r = i.findAncestor("table"),
                    s = e.getCellLocation(i).column;
                t.change((t => {
                    const n = o.last - o.first + 1;
                    e.removeRows(r, {
                        at: o.first,
                        rows: n
                    });
                    const i = function(t, e, n, o) {
                        const i = t.getChild(Math.min(e, o - 1));
                        let r = i.getChild(0),
                            s = 0;
                        for (const t of i.getChildren()) {
                            if (s > n) return r;
                            r = t, s += parseInt(t.getAttribute("colspan") || "1")
                        }
                        return r
                    }(r, o.first, s, e.getRows(r));
                    t.setSelection(t.createPositionAt(i, 0))
                }))
            }
        }
        class WE extends Fi {
            refresh() {
                const t = this.editor.plugins.get("TableUtils"),
                    e = t.getSelectionAffectedTableCells(this.editor.model.document.selection),
                    n = e[0];
                if (n) {
                    const o = n.findAncestor("table"),
                        i = t.getColumns(o),
                        {
                            first: r,
                            last: s
                        } = t.getColumnIndexes(e);
                    this.isEnabled = s - r < i - 1
                } else this.isEnabled = !1
            }
            execute() {
                const t = this.editor.plugins.get("TableUtils"),
                    [e, n] = function(t, e) {
                        const n = e.getSelectionAffectedTableCells(t),
                            o = n[0],
                            i = n.pop(),
                            r = [o, i];
                        return o.isBefore(i) ? r : r.reverse()
                    }(this.editor.model.document.selection, t),
                    o = e.parent.parent,
                    i = [...new AE(o)],
                    r = {
                        first: i.find((t => t.cell === e)).column,
                        last: i.find((t => t.cell === n)).column
                    },
                    s = function(t, e, n, o) {
                        const i = parseInt(n.getAttribute("colspan") || "1");
                        return i > 1 ? n : e.previousSibling || n.nextSibling ? n.nextSibling || e.previousSibling : o.first ? t.reverse().find((({
                            column: t
                        }) => t < o.first)).cell : t.reverse().find((({
                            column: t
                        }) => t > o.last)).cell
                    }(i, e, n, r);
                this.editor.model.change((e => {
                    const n = r.last - r.first + 1;
                    t.removeColumns(o, {
                        at: r.first,
                        columns: n
                    }), e.setSelection(e.createPositionAt(s, 0))
                }))
            }
        }
        class UE extends Fi {
            refresh() {
                const t = this.editor.plugins.get("TableUtils"),
                    e = this.editor.model,
                    n = t.getSelectionAffectedTableCells(e.document.selection),
                    o = n.length > 0;
                this.isEnabled = o, this.value = o && n.every((t => this._isInHeading(t, t.parent.parent)))
            }
            execute(t = {}) {
                if (t.forceValue === this.value) return;
                const e = this.editor.plugins.get("TableUtils"),
                    n = this.editor.model,
                    o = e.getSelectionAffectedTableCells(n.document.selection),
                    i = o[0].findAncestor("table"),
                    {
                        first: r,
                        last: s
                    } = e.getRowIndexes(o),
                    a = this.value ? r : s + 1,
                    l = i.getAttribute("headingRows") || 0;
                n.change((t => {
                    if (a) {
                        const e = IE(i, a, a > l ? l : 0);
                        for (const {
                                cell: n
                            }
                            of e) PE(n, a, t)
                    }
                    gE("headingRows", a, i, t, 0)
                }))
            }
            _isInHeading(t, e) {
                const n = parseInt(e.getAttribute("headingRows") || "0");
                return !!n && t.parent.index < n
            }
        }
        class $E extends Fi {
            refresh() {
                const t = this.editor.model,
                    e = this.editor.plugins.get("TableUtils"),
                    n = e.getSelectionAffectedTableCells(t.document.selection),
                    o = n.length > 0;
                this.isEnabled = o, this.value = o && n.every((t => pE(e, t)))
            }
            execute(t = {}) {
                if (t.forceValue === this.value) return;
                const e = this.editor.plugins.get("TableUtils"),
                    n = this.editor.model,
                    o = e.getSelectionAffectedTableCells(n.document.selection),
                    i = o[0].findAncestor("table"),
                    {
                        first: r,
                        last: s
                    } = e.getColumnIndexes(o),
                    a = this.value ? r : s + 1;
                n.change((t => {
                    if (a) {
                        const e = RE(i, a);
                        for (const {
                                cell: n,
                                column: o
                            }
                            of e) zE(n, o, a, t)
                    }
                    gE("headingColumns", a, i, t, 0)
                }))
            }
        }
        class GE extends Vi {
            static get pluginName() {
                return "TableUtils"
            }
            init() {
                this.decorate("insertColumns"), this.decorate("insertRows")
            }
            getCellLocation(t) {
                const e = t.parent,
                    n = e.parent,
                    o = n.getChildIndex(e),
                    i = new AE(n, {
                        row: o
                    });
                for (const {
                        cell: e,
                        row: n,
                        column: o
                    }
                    of i)
                    if (e === t) return {
                        row: n,
                        column: o
                    }
            }
            createTable(t, e) {
                const n = t.createElement("table"),
                    o = e.rows || 2,
                    i = e.columns || 2;
                return KE(t, n, 0, o, i), e.headingRows && gE("headingRows", Math.min(e.headingRows, o), n, t, 0), e.headingColumns && gE("headingColumns", Math.min(e.headingColumns, i), n, t, 0), n
            }
            insertRows(t, e = {}) {
                const n = this.editor.model,
                    o = e.at || 0,
                    i = e.rows || 1,
                    r = void 0 !== e.copyStructureFromAbove,
                    s = e.copyStructureFromAbove ? o - 1 : o,
                    a = this.getRows(t),
                    l = this.getColumns(t);
                if (o > a) throw new b("tableutils-insertrows-insert-out-of-range", this, {
                    options: e
                });
                n.change((e => {
                    const n = t.getAttribute("headingRows") || 0;
                    if (n > o && gE("headingRows", n + i, t, e, 0), !r && (0 === o || o === a)) return void KE(e, t, o, i, l);
                    const c = r ? Math.max(o, s) : o,
                        d = new AE(t, {
                            endRow: c
                        }),
                        h = new Array(l).fill(1);
                    for (const {
                            row: t,
                            column: n,
                            cellHeight: a,
                            cellWidth: l,
                            cell: c
                        }
                        of d) {
                        const d = t + a - 1,
                            u = t <= s && s <= d;
                        t < o && o <= d ? (e.setAttribute("rowspan", a + i, c), h[n] = -l) : r && u && (h[n] = l)
                    }
                    for (let n = 0; n < i; n++) {
                        const n = e.createElement("tableRow");
                        e.insert(n, t, o);
                        for (let t = 0; t < h.length; t++) {
                            const o = h[t],
                                i = e.createPositionAt(n, "end");
                            o > 0 && mE(e, i, o > 1 ? {
                                colspan: o
                            } : void 0), t += Math.abs(o) - 1
                        }
                    }
                }))
            }
            insertColumns(t, e = {}) {
                const n = this.editor.model,
                    o = e.at || 0,
                    i = e.columns || 1;
                n.change((e => {
                    const n = t.getAttribute("headingColumns");
                    o < n && e.setAttribute("headingColumns", n + i, t);
                    const r = this.getColumns(t);
                    if (0 === o || r === o) {
                        for (const n of t.getChildren()) n.is("element", "tableRow") && ZE(i, e, e.createPositionAt(n, o ? "end" : 0));
                        return
                    }
                    const s = new AE(t, {
                        column: o,
                        includeAllSlots: !0
                    });
                    for (const t of s) {
                        const {
                            row: n,
                            cell: r,
                            cellAnchorColumn: a,
                            cellAnchorRow: l,
                            cellWidth: c,
                            cellHeight: d
                        } = t;
                        if (a < o) {
                            e.setAttribute("colspan", c + i, r);
                            const t = l + d - 1;
                            for (let e = n; e <= t; e++) s.skipRow(e)
                        } else ZE(i, e, t.getPositionBefore())
                    }
                }))
            }
            removeRows(t, e) {
                const n = this.editor.model,
                    o = e.rows || 1,
                    i = this.getRows(t),
                    r = e.at,
                    s = r + o - 1;
                if (s > i - 1) throw new b("tableutils-removerows-row-index-out-of-range", this, {
                    table: t,
                    options: e
                });
                n.change((e => {
                    const n = {
                            first: r,
                            last: s
                        },
                        {
                            cellsToMove: o,
                            cellsToTrim: i
                        } = function(t, {
                            first: e,
                            last: n
                        }) {
                            const o = new Map,
                                i = [];
                            for (const {
                                    row: r,
                                    column: s,
                                    cellHeight: a,
                                    cell: l
                                }
                                of new AE(t, {
                                    endRow: n
                                })) {
                                const t = r + a - 1;
                                if (r >= e && r <= n && t > n) {
                                    const t = a - (n - r + 1);
                                    o.set(s, {
                                        cell: l,
                                        rowspan: t
                                    })
                                }
                                if (r < e && t >= e) {
                                    let o;
                                    o = t >= n ? n - e + 1 : t - e + 1, i.push({
                                        cell: l,
                                        rowspan: a - o
                                    })
                                }
                            }
                            return {
                                cellsToMove: o,
                                cellsToTrim: i
                            }
                        }(t, n);
                    if (o.size) {
                        ! function(t, e, n, o) {
                            const i = new AE(t, {
                                    includeAllSlots: !0,
                                    row: e
                                }),
                                r = [...i],
                                s = t.getChild(e);
                            let a;
                            for (const {
                                    column: t,
                                    cell: e,
                                    isAnchor: i
                                }
                                of r)
                                if (n.has(t)) {
                                    const {
                                        cell: e,
                                        rowspan: i
                                    } = n.get(t), r = a ? o.createPositionAfter(a) : o.createPositionAt(s, 0);
                                    o.move(o.createRangeOn(e), r), gE("rowspan", i, e, o), a = e
                                } else i && (a = e)
                        }(t, s + 1, o, e)
                    }
                    for (let n = s; n >= r; n--) e.remove(t.getChild(n));
                    for (const {
                            rowspan: t,
                            cell: n
                        }
                        of i) gE("rowspan", t, n, e);
                    ! function(t, {
                        first: e,
                        last: n
                    }, o) {
                        const i = t.getAttribute("headingRows") || 0;
                        if (e < i) {
                            gE("headingRows", n < i ? i - (n - e + 1) : e, t, o, 0)
                        }
                    }(t, n, e), OE(t, this) || FE(t, this)
                }))
            }
            removeColumns(t, e) {
                const n = this.editor.model,
                    o = e.at,
                    i = e.columns || 1,
                    r = e.at + i - 1;
                n.change((e => {
                    ! function(t, e, n) {
                        const o = t.getAttribute("headingColumns") || 0;
                        if (o && e.first < o) {
                            const i = Math.min(o - 1, e.last) - e.first + 1;
                            n.setAttribute("headingColumns", o - i, t)
                        }
                    }(t, {
                        first: o,
                        last: r
                    }, e);
                    for (let n = r; n >= o; n--)
                        for (const {
                                cell: o,
                                column: i,
                                cellWidth: r
                            }
                            of [...new AE(t)]) i <= n && r > 1 && i + r > n ? gE("colspan", r - 1, o, e) : i === n && e.remove(o);
                    FE(t, this) || OE(t, this)
                }))
            }
            splitCellVertically(t, e = 2) {
                const n = this.editor.model,
                    o = t.parent.parent,
                    i = parseInt(t.getAttribute("rowspan") || "1"),
                    r = parseInt(t.getAttribute("colspan") || "1");
                n.change((n => {
                    if (r > 1) {
                        const {
                            newCellsSpan: o,
                            updatedSpan: s
                        } = JE(r, e);
                        gE("colspan", s, t, n);
                        const a = {};
                        o > 1 && (a.colspan = o), i > 1 && (a.rowspan = i);
                        ZE(r > e ? e - 1 : r - 1, n, n.createPositionAfter(t), a)
                    }
                    if (r < e) {
                        const s = e - r,
                            a = [...new AE(o)],
                            {
                                column: l
                            } = a.find((({
                                cell: e
                            }) => e === t)),
                            c = a.filter((({
                                cell: e,
                                cellWidth: n,
                                column: o
                            }) => e !== t && o === l || o < l && o + n > l));
                        for (const {
                                cell: t,
                                cellWidth: e
                            }
                            of c) n.setAttribute("colspan", e + s, t);
                        const d = {};
                        i > 1 && (d.rowspan = i), ZE(s, n, n.createPositionAfter(t), d);
                        const h = o.getAttribute("headingColumns") || 0;
                        h > l && gE("headingColumns", h + s, o, n)
                    }
                }))
            }
            splitCellHorizontally(t, e = 2) {
                const n = this.editor.model,
                    o = t.parent,
                    i = o.parent,
                    r = i.getChildIndex(o),
                    s = parseInt(t.getAttribute("rowspan") || "1"),
                    a = parseInt(t.getAttribute("colspan") || "1");
                n.change((n => {
                    if (s > 1) {
                        const o = [...new AE(i, {
                                startRow: r,
                                endRow: r + s - 1,
                                includeAllSlots: !0
                            })],
                            {
                                newCellsSpan: l,
                                updatedSpan: c
                            } = JE(s, e);
                        gE("rowspan", c, t, n);
                        const {
                            column: d
                        } = o.find((({
                            cell: e
                        }) => e === t)), h = {};
                        l > 1 && (h.rowspan = l), a > 1 && (h.colspan = a);
                        for (const t of o) {
                            const {
                                column: e,
                                row: o
                            } = t;
                            o >= r + c && e === d && (o + r + c) % l == 0 && ZE(1, n, t.getPositionBefore(), h)
                        }
                    }
                    if (s < e) {
                        const o = e - s,
                            l = [...new AE(i, {
                                startRow: 0,
                                endRow: r
                            })];
                        for (const {
                                cell: e,
                                cellHeight: i,
                                row: s
                            }
                            of l)
                            if (e !== t && s + i > r) {
                                const t = i + o;
                                n.setAttribute("rowspan", t, e)
                            } const c = {};
                        a > 1 && (c.colspan = a), KE(n, i, r + 1, o, 1, c);
                        const d = i.getAttribute("headingRows") || 0;
                        d > r && gE("headingRows", d + o, i, n)
                    }
                }))
            }
            getColumns(t) {
                return [...t.getChild(0).getChildren()].reduce(((t, e) => t + parseInt(e.getAttribute("colspan") || "1")), 0)
            }
            getRows(t) {
                return Array.from(t.getChildren()).reduce(((t, e) => e.is("element", "tableRow") ? t + 1 : t), 0)
            }
            createTableWalker(t, e = {}) {
                return new AE(t, e)
            }
            getSelectedTableCells(t) {
                const e = [];
                for (const n of this.sortRanges(t.getRanges())) {
                    const t = n.getContainedElement();
                    t && t.is("element", "tableCell") && e.push(t)
                }
                return e
            }
            getTableCellsContainingSelection(t) {
                const e = [];
                for (const n of t.getRanges()) {
                    const t = n.start.findAncestor("tableCell");
                    t && e.push(t)
                }
                return e
            }
            getSelectionAffectedTableCells(t) {
                const e = this.getSelectedTableCells(t);
                return e.length ? e : this.getTableCellsContainingSelection(t)
            }
            getRowIndexes(t) {
                const e = t.map((t => t.parent.index));
                return this._getFirstLastIndexesObject(e)
            }
            getColumnIndexes(t) {
                const e = t[0].findAncestor("table"),
                    n = [...new AE(e)].filter((e => t.includes(e.cell))).map((t => t.column));
                return this._getFirstLastIndexesObject(n)
            }
            isSelectionRectangular(t) {
                if (t.length < 2 || !this._areCellInTheSameTableSection(t)) return !1;
                const e = new Set,
                    n = new Set;
                let o = 0;
                for (const i of t) {
                    const {
                        row: t,
                        column: r
                    } = this.getCellLocation(i), s = parseInt(i.getAttribute("rowspan")) || 1, a = parseInt(i.getAttribute("colspan")) || 1;
                    e.add(t), n.add(r), s > 1 && e.add(t + s - 1), a > 1 && n.add(r + a - 1), o += s * a
                }
                const i = function(t, e) {
                    const n = Array.from(t.values()),
                        o = Array.from(e.values()),
                        i = Math.max(...n),
                        r = Math.min(...n),
                        s = Math.max(...o),
                        a = Math.min(...o);
                    return (i - r + 1) * (s - a + 1)
                }(e, n);
                return i == o
            }
            sortRanges(t) {
                return Array.from(t).sort(YE)
            }
            _getFirstLastIndexesObject(t) {
                const e = t.sort(((t, e) => t - e));
                return {
                    first: e[0],
                    last: e[e.length - 1]
                }
            }
            _areCellInTheSameTableSection(t) {
                const e = t[0].findAncestor("table"),
                    n = this.getRowIndexes(t),
                    o = parseInt(e.getAttribute("headingRows")) || 0;
                if (!this._areIndexesInSameSection(n, o)) return !1;
                const i = this.getColumnIndexes(t),
                    r = parseInt(e.getAttribute("headingColumns")) || 0;
                return this._areIndexesInSameSection(i, r)
            }
            _areIndexesInSameSection({
                first: t,
                last: e
            }, n) {
                return t < n === e < n
            }
        }

        function KE(t, e, n, o, i, r = {}) {
            for (let s = 0; s < o; s++) {
                const o = t.createElement("tableRow");
                t.insert(o, e, n), ZE(i, t, t.createPositionAt(o, "end"), r)
            }
        }

        function ZE(t, e, n, o = {}) {
            for (let i = 0; i < t; i++) mE(e, n, o)
        }

        function JE(t, e) {
            if (t < e) return {
                newCellsSpan: 1,
                updatedSpan: 1
            };
            const n = Math.floor(t / e);
            return {
                newCellsSpan: n,
                updatedSpan: t - n * e + n
            }
        }

        function YE(t, e) {
            const n = t.start,
                o = e.start;
            return n.isBefore(o) ? -1 : 1
        }
        class QE extends Fi {
            refresh() {
                const t = this.editor.plugins.get(GE),
                    e = t.getSelectedTableCells(this.editor.model.document.selection);
                this.isEnabled = t.isSelectionRectangular(e)
            }
            execute() {
                const t = this.editor.model,
                    e = this.editor.plugins.get(GE);
                t.change((n => {
                    const o = e.getSelectedTableCells(t.document.selection),
                        i = o.shift(),
                        {
                            mergeWidth: r,
                            mergeHeight: s
                        } = function(t, e, n) {
                            let o = 0,
                                i = 0;
                            for (const t of e) {
                                const {
                                    row: e,
                                    column: r
                                } = n.getCellLocation(t);
                                o = eD(t, r, o, "colspan"), i = eD(t, e, i, "rowspan")
                            }
                            const {
                                row: r,
                                column: s
                            } = n.getCellLocation(t), a = o - s, l = i - r;
                            return {
                                mergeWidth: a,
                                mergeHeight: l
                            }
                        }(i, o, e);
                    gE("colspan", r, i, n), gE("rowspan", s, i, n);
                    for (const t of o) XE(t, i, n);
                    ME(i.findAncestor("table"), e), n.setSelection(i, "in")
                }))
            }
        }

        function XE(t, e, n) {
            tD(t) || (tD(e) && n.remove(n.createRangeIn(e)), n.move(n.createRangeIn(t), n.createPositionAt(e, "end"))), n.remove(t)
        }

        function tD(t) {
            const e = t.getChild(0);
            return 1 == t.childCount && e.is("element", "paragraph") && e.isEmpty
        }

        function eD(t, e, n, o) {
            const i = parseInt(t.getAttribute(o) || "1");
            return Math.max(n, e + i)
        }
        class nD extends Fi {
            constructor(t) {
                super(t), this.affectsData = !1
            }
            refresh() {
                const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
                this.isEnabled = t.length > 0
            }
            execute() {
                const t = this.editor.model,
                    e = this.editor.plugins.get("TableUtils"),
                    n = e.getSelectionAffectedTableCells(t.document.selection),
                    o = e.getRowIndexes(n),
                    i = n[0].findAncestor("table"),
                    r = [];
                for (let e = o.first; e <= o.last; e++)
                    for (const n of i.getChild(e).getChildren()) r.push(t.createRangeOn(n));
                t.change((t => {
                    t.setSelection(r)
                }))
            }
        }
        class oD extends Fi {
            constructor(t) {
                super(t), this.affectsData = !1
            }
            refresh() {
                const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
                this.isEnabled = t.length > 0
            }
            execute() {
                const t = this.editor.plugins.get("TableUtils"),
                    e = this.editor.model,
                    n = t.getSelectionAffectedTableCells(e.document.selection),
                    o = n[0],
                    i = n.pop(),
                    r = o.findAncestor("table"),
                    s = t.getCellLocation(o),
                    a = t.getCellLocation(i),
                    l = Math.min(s.column, a.column),
                    c = Math.max(s.column, a.column),
                    d = [];
                for (const t of new AE(r, {
                        startColumn: l,
                        endColumn: c
                    })) d.push(e.createRangeOn(t.cell));
                e.change((t => {
                    t.setSelection(d)
                }))
            }
        }

        function iD(t) {
            t.document.registerPostFixer((e => function(t, e) {
                const n = e.document.differ.getChanges();
                let o = !1;
                const i = new Set;
                for (const e of n) {
                    let n = null;
                    "insert" == e.type && "table" == e.name && (n = e.position.nodeAfter), "insert" != e.type && "remove" != e.type || "tableRow" != e.name && "tableCell" != e.name || (n = e.position.findAncestor("table")), aD(e) && (n = e.range.start.findAncestor("table")), n && !i.has(n) && (o = rD(n, t) || o, o = sD(n, t) || o, i.add(n))
                }
                return o
            }(e, t)))
        }

        function rD(t, e) {
            let n = !1;
            const o = function(t) {
                const e = parseInt(t.getAttribute("headingRows") || "0"),
                    n = Array.from(t.getChildren()).reduce(((t, e) => e.is("element", "tableRow") ? t + 1 : t), 0),
                    o = [];
                for (const {
                        row: i,
                        cell: r,
                        cellHeight: s
                    }
                    of new AE(t)) {
                    if (s < 2) continue;
                    const t = i < e ? e : n;
                    if (i + s > t) {
                        const e = t - i;
                        o.push({
                            cell: r,
                            rowspan: e
                        })
                    }
                }
                return o
            }(t);
            if (o.length) {
                n = !0;
                for (const t of o) gE("rowspan", t.rowspan, t.cell, e, 1)
            }
            return n
        }

        function sD(t, e) {
            let n = !1;
            const o = function(t) {
                    const e = new Array(t.childCount).fill(0);
                    for (const {
                            rowIndex: n
                        }
                        of new AE(t, {
                            includeAllSlots: !0
                        })) e[n]++;
                    return e
                }(t),
                i = [];
            for (const [e, n] of o.entries()) !n && t.getChild(e).is("element", "tableRow") && i.push(e);
            if (i.length) {
                n = !0;
                for (const n of i.reverse()) e.remove(t.getChild(n)), o.splice(n, 1)
            }
            const r = o.filter(((e, n) => t.getChild(n).is("element", "tableRow"))),
                s = r[0];
            if (!r.every((t => t === s))) {
                const o = r.reduce(((t, e) => e > t ? e : t), 0);
                for (const [i, s] of r.entries()) {
                    const r = o - s;
                    if (r) {
                        for (let n = 0; n < r; n++) mE(e, e.createPositionAt(t.getChild(i), "end"));
                        n = !0
                    }
                }
            }
            return n
        }

        function aD(t) {
            if ("attribute" !== t.type) return !1;
            const e = t.attributeKey;
            return "headingRows" === e || "colspan" === e || "rowspan" === e
        }

        function lD(t) {
            t.document.registerPostFixer((e => function(t, e) {
                const n = e.document.differ.getChanges();
                let o = !1;
                for (const e of n) "insert" == e.type && "table" == e.name && (o = cD(e.position.nodeAfter, t) || o), "insert" == e.type && "tableRow" == e.name && (o = dD(e.position.nodeAfter, t) || o), "insert" == e.type && "tableCell" == e.name && (o = hD(e.position.nodeAfter, t) || o), "remove" != e.type && "insert" != e.type || !uD(e) || (o = hD(e.position.parent, t) || o);
                return o
            }(e, t)))
        }

        function cD(t, e) {
            let n = !1;
            for (const o of t.getChildren()) o.is("element", "tableRow") && (n = dD(o, e) || n);
            return n
        }

        function dD(t, e) {
            let n = !1;
            for (const o of t.getChildren()) n = hD(o, e) || n;
            return n
        }

        function hD(t, e) {
            if (0 == t.childCount) return e.insertElement("paragraph", t), !0;
            const n = Array.from(t.getChildren()).filter((t => t.is("$text")));
            for (const t of n) e.wrap(e.createRangeOn(t), "paragraph");
            return !!n.length
        }

        function uD(t) {
            return !!t.position.parent.is("element", "tableCell") && ("insert" == t.type && "$text" == t.name || "remove" == t.type)
        }

        function gD(t, e) {
            if (!t.is("element", "paragraph")) return !1;
            const n = e.toViewElement(t);
            return !!n && xE(t) !== n.is("element", "span")
        }
        var mD = n(3881),
            pD = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(mD.Z, pD);
        mD.Z.locals;
        class fD extends Vi {
            constructor(t) {
                super(t), this._additionalSlots = []
            }
            static get pluginName() {
                return "TableEditing"
            }
            static get requires() {
                return [GE]
            }
            init() {
                const t = this.editor,
                    e = t.model,
                    n = e.schema,
                    o = t.conversion,
                    i = t.plugins.get(GE);
                n.register("table", {
                    inheritAllFrom: "$blockObject",
                    allowAttributes: ["headingRows", "headingColumns"]
                }), n.register("tableRow", {
                    allowIn: "table",
                    isLimit: !0
                }), n.register("tableCell", {
                    allowContentOf: "$container",
                    allowIn: "tableRow",
                    allowAttributes: ["colspan", "rowspan"],
                    isLimit: !0,
                    isSelectable: !0
                }), o.for("upcast").add((t => {
                    t.on("element:figure", ((t, e, n) => {
                        if (!n.consumable.test(e.viewItem, {
                                name: !0,
                                classes: "table"
                            })) return;
                        const o = function(t) {
                            for (const e of t.getChildren())
                                if (e.is("element", "table")) return e
                        }(e.viewItem);
                        if (!o || !n.consumable.test(o, {
                                name: !0
                            })) return;
                        n.consumable.consume(e.viewItem, {
                            name: !0,
                            classes: "table"
                        });
                        const i = Ei(n.convertItem(o, e.modelCursor).modelRange.getItems());
                        i ? (n.convertChildren(e.viewItem, n.writer.createPositionAt(i, "end")), n.updateConversionResult(i, e)) : n.consumable.revert(e.viewItem, {
                            name: !0,
                            classes: "table"
                        })
                    }))
                })), o.for("upcast").add(bE()), o.for("editingDowncast").elementToStructure({
                    model: {
                        name: "table",
                        attributes: ["headingRows"]
                    },
                    view: _E(i, {
                        asWidget: !0,
                        additionalSlots: this._additionalSlots
                    })
                }), o.for("dataDowncast").elementToStructure({
                    model: {
                        name: "table",
                        attributes: ["headingRows"]
                    },
                    view: _E(i, {
                        additionalSlots: this._additionalSlots
                    })
                }), o.for("upcast").elementToElement({
                    model: "tableRow",
                    view: "tr"
                }), o.for("upcast").add((t => {
                    t.on("element:tr", ((t, e) => {
                        e.viewItem.isEmpty && 0 == e.modelCursor.index && t.stop()
                    }), {
                        priority: "high"
                    })
                })), o.for("downcast").elementToElement({
                    model: "tableRow",
                    view: (t, {
                        writer: e
                    }) => t.isEmpty ? e.createEmptyElement("tr") : e.createContainerElement("tr")
                }), o.for("upcast").elementToElement({
                    model: "tableCell",
                    view: "td"
                }), o.for("upcast").elementToElement({
                    model: "tableCell",
                    view: "th"
                }), o.for("upcast").add(kE("td")), o.for("upcast").add(kE("th")), o.for("editingDowncast").elementToElement({
                    model: "tableCell",
                    view: vE({
                        asWidget: !0
                    })
                }), o.for("dataDowncast").elementToElement({
                    model: "tableCell",
                    view: vE()
                }), o.for("editingDowncast").elementToElement({
                    model: "paragraph",
                    view: yE({
                        asWidget: !0
                    }),
                    converterPriority: "high"
                }), o.for("dataDowncast").elementToElement({
                    model: "paragraph",
                    view: yE(),
                    converterPriority: "high"
                }), o.for("downcast").attributeToAttribute({
                    model: "colspan",
                    view: "colspan"
                }), o.for("upcast").attributeToAttribute({
                    model: {
                        key: "colspan",
                        value: bD("colspan")
                    },
                    view: "colspan"
                }), o.for("downcast").attributeToAttribute({
                    model: "rowspan",
                    view: "rowspan"
                }), o.for("upcast").attributeToAttribute({
                    model: {
                        key: "rowspan",
                        value: bD("rowspan")
                    },
                    view: "rowspan"
                }), t.config.define("table.defaultHeadings.rows", 0), t.config.define("table.defaultHeadings.columns", 0), t.commands.add("insertTable", new EE(t)), t.commands.add("insertTableRowAbove", new DE(t, {
                    order: "above"
                })), t.commands.add("insertTableRowBelow", new DE(t, {
                    order: "below"
                })), t.commands.add("insertTableColumnLeft", new SE(t, {
                    order: "left"
                })), t.commands.add("insertTableColumnRight", new SE(t, {
                    order: "right"
                })), t.commands.add("removeTableRow", new qE(t)), t.commands.add("removeTableColumn", new WE(t)), t.commands.add("splitTableCellVertically", new TE(t, {
                    direction: "vertically"
                })), t.commands.add("splitTableCellHorizontally", new TE(t, {
                    direction: "horizontally"
                })), t.commands.add("mergeTableCells", new QE(t)), t.commands.add("mergeTableCellRight", new HE(t, {
                    direction: "right"
                })), t.commands.add("mergeTableCellLeft", new HE(t, {
                    direction: "left"
                })), t.commands.add("mergeTableCellDown", new HE(t, {
                    direction: "down"
                })), t.commands.add("mergeTableCellUp", new HE(t, {
                    direction: "up"
                })), t.commands.add("setTableColumnHeader", new $E(t)), t.commands.add("setTableRowHeader", new UE(t)), t.commands.add("selectTableRow", new nD(t)), t.commands.add("selectTableColumn", new oD(t)), iD(e), lD(e), this.listenTo(e.document, "change:data", (() => {
                    ! function(t, e) {
                        const n = t.document.differ;
                        for (const t of n.getChanges()) {
                            let n, o = !1;
                            if ("attribute" == t.type) {
                                const e = t.range.start.nodeAfter;
                                if (!e || !e.is("element", "table")) continue;
                                if ("headingRows" != t.attributeKey && "headingColumns" != t.attributeKey) continue;
                                n = e, o = "headingRows" == t.attributeKey
                            } else "tableRow" != t.name && "tableCell" != t.name || (n = t.position.findAncestor("table"), o = "tableRow" == t.name);
                            if (!n) continue;
                            const i = n.getAttribute("headingRows") || 0,
                                r = n.getAttribute("headingColumns") || 0,
                                s = new AE(n);
                            for (const t of s) {
                                const n = t.row < i || t.column < r ? "th" : "td",
                                    s = e.mapper.toViewElement(t.cell);
                                s && s.is("element") && s.name != n && e.reconvertItem(o ? t.cell.parent : t.cell)
                            }
                        }
                    }(e, t.editing),
                    function(t, e) {
                        const n = t.document.differ,
                            o = new Set;
                        for (const t of n.getChanges()) {
                            const e = "attribute" == t.type ? t.range.start.parent : t.position.parent;
                            e.is("element", "tableCell") && o.add(e)
                        }
                        for (const t of o.values()) {
                            const n = Array.from(t.getChildren()).filter((t => gD(t, e.mapper)));
                            for (const t of n) e.reconvertItem(t)
                        }
                    }(e, t.editing)
                }))
            }
            registerAdditionalSlot(t) {
                this._additionalSlots.push(t)
            }
        }

        function bD(t) {
            return e => {
                const n = parseInt(e.getAttribute(t));
                return Number.isNaN(n) || n <= 0 ? null : n
            }
        }
        var kD = n(1613),
            wD = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(kD.Z, wD);
        kD.Z.locals;
        class AD extends cg {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.items = this._createGridCollection(), this.keystrokes = new Si, this.focusTracker = new Di, this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", ((t, e) => `${e} × ${t}`)), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck"]
                    },
                    children: [{
                        tag: "div",
                        attributes: {
                            class: ["ck-insert-table-dropdown__grid"]
                        },
                        on: {
                            "mouseover@.ck-insert-table-dropdown-grid-box": e.to("boxover")
                        },
                        children: this.items
                    }, {
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-insert-table-dropdown__label"],
                            "aria-hidden": !0
                        },
                        children: [{
                            text: e.to("label")
                        }]
                    }],
                    on: {
                        mousedown: e.to((t => {
                            t.preventDefault()
                        })),
                        click: e.to((() => {
                            this.fire("execute")
                        }))
                    }
                }), this.on("boxover", ((t, e) => {
                    const {
                        row: n,
                        column: o
                    } = e.target.dataset;
                    this.items.get(10 * (parseInt(n, 10) - 1) + (parseInt(o, 10) - 1)).focus()
                })), this.focusTracker.on("change:focusedElement", ((t, e, n) => {
                    if (!n) return;
                    const {
                        row: o,
                        column: i
                    } = n.dataset;
                    this.set({
                        rows: parseInt(o),
                        columns: parseInt(i)
                    })
                })), this.on("change:columns", (() => this._highlightGridBoxes())), this.on("change:rows", (() => this._highlightGridBoxes()))
            }
            render() {
                super.render(), rg({
                    keystrokeHandler: this.keystrokes,
                    focusTracker: this.focusTracker,
                    gridItems: this.items,
                    numberOfColumns: 10,
                    uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
                });
                for (const t of this.items) this.focusTracker.add(t.element);
                this.keystrokes.listenTo(this.element)
            }
            focus() {
                this.items.get(0).focus()
            }
            focusLast() {
                this.items.get(0).focus()
            }
            _highlightGridBoxes() {
                const t = this.rows,
                    e = this.columns;
                this.items.map(((n, o) => {
                    const i = Math.floor(o / 10) < t && o % 10 < e;
                    n.set("isOn", i)
                }))
            }
            _createGridButton(t, e, n, o) {
                const i = new Mg(t);
                return i.set({
                    label: o,
                    class: "ck-insert-table-dropdown-grid-box"
                }), i.extendTemplate({
                    attributes: {
                        "data-row": e,
                        "data-column": n
                    }
                }), i
            }
            _createGridCollection() {
                const t = [];
                for (let e = 0; e < 100; e++) {
                    const n = Math.floor(e / 10),
                        o = e % 10,
                        i = `${n+1} × ${o+1}`;
                    t.push(this._createGridButton(this.locale, n + 1, o + 1, i))
                }
                return this.createCollection(t)
            }
        }
        class CD extends Vi {
            static get pluginName() {
                return "TableUI"
            }
            init() {
                const t = this.editor,
                    e = this.editor.t,
                    n = "ltr" === t.locale.contentLanguageDirection;
                t.ui.componentFactory.add("insertTable", (n => {
                    const o = t.commands.get("insertTable"),
                        i = Wm(n);
                    let r;
                    return i.bind("isEnabled").to(o), i.buttonView.set({
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>',
                        label: e("Insert table"),
                        tooltip: !0
                    }), i.on("change:isOpen", (() => {
                        r || (r = new AD(n), i.panelView.children.add(r), r.delegate("execute").to(i), i.on("execute", (() => {
                            t.execute("insertTable", {
                                rows: r.rows,
                                columns: r.columns
                            }), t.editing.view.focus()
                        })))
                    })), i
                })), t.ui.componentFactory.add("tableColumn", (t => {
                    const o = [{
                        type: "switchbutton",
                        model: {
                            commandName: "setTableColumnHeader",
                            label: e("Header column"),
                            bindIsOn: !0
                        }
                    }, {
                        type: "separator"
                    }, {
                        type: "button",
                        model: {
                            commandName: n ? "insertTableColumnLeft" : "insertTableColumnRight",
                            label: e("Insert column left")
                        }
                    }, {
                        type: "button",
                        model: {
                            commandName: n ? "insertTableColumnRight" : "insertTableColumnLeft",
                            label: e("Insert column right")
                        }
                    }, {
                        type: "button",
                        model: {
                            commandName: "removeTableColumn",
                            label: e("Delete column")
                        }
                    }, {
                        type: "button",
                        model: {
                            commandName: "selectTableColumn",
                            label: e("Select column")
                        }
                    }];
                    return this._prepareDropdown(e("Column"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', o, t)
                })), t.ui.componentFactory.add("tableRow", (t => {
                    const n = [{
                        type: "switchbutton",
                        model: {
                            commandName: "setTableRowHeader",
                            label: e("Header row"),
                            bindIsOn: !0
                        }
                    }, {
                        type: "separator"
                    }, {
                        type: "button",
                        model: {
                            commandName: "insertTableRowAbove",
                            label: e("Insert row above")
                        }
                    }, {
                        type: "button",
                        model: {
                            commandName: "insertTableRowBelow",
                            label: e("Insert row below")
                        }
                    }, {
                        type: "button",
                        model: {
                            commandName: "removeTableRow",
                            label: e("Delete row")
                        }
                    }, {
                        type: "button",
                        model: {
                            commandName: "selectTableRow",
                            label: e("Select row")
                        }
                    }];
                    return this._prepareDropdown(e("Row"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', n, t)
                })), t.ui.componentFactory.add("mergeTableCells", (t => {
                    const o = [{
                        type: "button",
                        model: {
                            commandName: "mergeTableCellUp",
                            label: e("Merge cell up")
                        }
                    }, {
                        type: "button",
                        model: {
                            commandName: n ? "mergeTableCellRight" : "mergeTableCellLeft",
                            label: e("Merge cell right")
                        }
                    }, {
                        type: "button",
                        model: {
                            commandName: "mergeTableCellDown",
                            label: e("Merge cell down")
                        }
                    }, {
                        type: "button",
                        model: {
                            commandName: n ? "mergeTableCellLeft" : "mergeTableCellRight",
                            label: e("Merge cell left")
                        }
                    }, {
                        type: "separator"
                    }, {
                        type: "button",
                        model: {
                            commandName: "splitTableCellVertically",
                            label: e("Split cell vertically")
                        }
                    }, {
                        type: "button",
                        model: {
                            commandName: "splitTableCellHorizontally",
                            label: e("Split cell horizontally")
                        }
                    }];
                    return this._prepareMergeSplitButtonDropdown(e("Merge cells"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>', o, t)
                }))
            }
            _prepareDropdown(t, e, n, o) {
                const i = this.editor,
                    r = Wm(o),
                    s = this._fillDropdownWithListOptions(r, n);
                return r.buttonView.set({
                    label: t,
                    icon: e,
                    tooltip: !0
                }), r.bind("isEnabled").toMany(s, "isEnabled", ((...t) => t.some((t => t)))), this.listenTo(r, "execute", (t => {
                    i.execute(t.source.commandName), t.source instanceof Hg || i.editing.view.focus()
                })), r
            }
            _prepareMergeSplitButtonDropdown(t, e, n, o) {
                const i = this.editor,
                    r = Wm(o, Nm),
                    s = "mergeTableCells",
                    a = i.commands.get(s),
                    l = this._fillDropdownWithListOptions(r, n);
                return r.buttonView.set({
                    label: t,
                    icon: e,
                    tooltip: !0,
                    isEnabled: !0
                }), r.bind("isEnabled").toMany([a, ...l], "isEnabled", ((...t) => t.some((t => t)))), this.listenTo(r.buttonView, "execute", (() => {
                    i.execute(s), i.editing.view.focus()
                })), this.listenTo(r, "execute", (t => {
                    i.execute(t.source.commandName), i.editing.view.focus()
                })), r
            }
            _fillDropdownWithListOptions(t, e) {
                const n = this.editor,
                    o = [],
                    i = new xi;
                for (const t of e) _D(t, n, o, i);
                return Gm(t, i), o
            }
        }

        function _D(t, e, n, o) {
            if ("button" === t.type || "switchbutton" === t.type) {
                const o = t.model = new Vf(t.model),
                    {
                        commandName: i,
                        bindIsOn: r
                    } = t.model,
                    s = e.commands.get(i);
                n.push(s), o.set({
                    commandName: i
                }), o.bind("isEnabled").to(s), r && o.bind("isOn").to(s, "value"), o.set({
                    withText: !0
                })
            }
            o.add(t)
        }
        var vD = n(6945),
            yD = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(vD.Z, yD);
        vD.Z.locals;
        class xD extends Vi {
            static get pluginName() {
                return "TableSelection"
            }
            static get requires() {
                return [GE, GE]
            }
            init() {
                const t = this.editor,
                    e = t.model,
                    n = t.editing.view;
                this.listenTo(e, "deleteContent", ((t, e) => this._handleDeleteContent(t, e)), {
                    priority: "high"
                }), this.listenTo(n.document, "insertText", ((t, e) => this._handleInsertTextEvent(t, e)), {
                    priority: "high"
                }), this._defineSelectionConverter(), this._enablePluginDisabling()
            }
            getSelectedTableCells() {
                const t = this.editor.plugins.get(GE),
                    e = this.editor.model.document.selection,
                    n = t.getSelectedTableCells(e);
                return 0 == n.length ? null : n
            }
            getSelectionAsFragment() {
                const t = this.editor.plugins.get(GE),
                    e = this.getSelectedTableCells();
                return e ? this.editor.model.change((n => {
                    const o = n.createDocumentFragment(),
                        {
                            first: i,
                            last: r
                        } = t.getColumnIndexes(e),
                        {
                            first: s,
                            last: a
                        } = t.getRowIndexes(e),
                        l = e[0].findAncestor("table");
                    let c = a,
                        d = r;
                    if (t.isSelectionRectangular(e)) {
                        const t = {
                            firstColumn: i,
                            lastColumn: r,
                            firstRow: s,
                            lastRow: a
                        };
                        c = NE(l, t), d = LE(l, t)
                    }
                    const h = BE(l, {
                        startRow: s,
                        startColumn: i,
                        endRow: c,
                        endColumn: d
                    }, n);
                    return n.insert(h, o, 0), o
                })) : null
            }
            setCellSelection(t, e) {
                const n = this._getCellsToSelect(t, e);
                this.editor.model.change((t => {
                    t.setSelection(n.cells.map((e => t.createRangeOn(e))), {
                        backward: n.backward
                    })
                }))
            }
            getFocusCell() {
                const t = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
                return t && t.is("element", "tableCell") ? t : null
            }
            getAnchorCell() {
                const t = Ei(this.editor.model.document.selection.getRanges()).getContainedElement();
                return t && t.is("element", "tableCell") ? t : null
            }
            _defineSelectionConverter() {
                const t = this.editor,
                    e = new Set;
                t.conversion.for("editingDowncast").add((t => t.on("selection", ((t, n, o) => {
                    const i = o.writer;
                    ! function(t) {
                        for (const n of e) t.removeClass("ck-editor__editable_selected", n);
                        e.clear()
                    }(i);
                    const r = this.getSelectedTableCells();
                    if (!r) return;
                    for (const t of r) {
                        const n = o.mapper.toViewElement(t);
                        i.addClass("ck-editor__editable_selected", n), e.add(n)
                    }
                    const s = o.mapper.toViewElement(r[r.length - 1]);
                    i.setSelection(s, 0)
                }), {
                    priority: "lowest"
                })))
            }
            _enablePluginDisabling() {
                const t = this.editor;
                this.on("change:isEnabled", (() => {
                    if (!this.isEnabled) {
                        const e = this.getSelectedTableCells();
                        if (!e) return;
                        t.model.change((n => {
                            const o = n.createPositionAt(e[0], 0),
                                i = t.model.schema.getNearestSelectionRange(o);
                            n.setSelection(i)
                        }))
                    }
                }))
            }
            _handleDeleteContent(t, e) {
                const n = this.editor.plugins.get(GE),
                    o = e[0],
                    i = e[1],
                    r = this.editor.model,
                    s = !i || "backward" == i.direction,
                    a = n.getSelectedTableCells(o);
                a.length && (t.stop(), r.change((t => {
                    const e = a[s ? a.length - 1 : 0];
                    r.change((t => {
                        for (const e of a) r.deleteContent(t.createSelection(e, "in"))
                    }));
                    const n = r.schema.getNearestSelectionRange(t.createPositionAt(e, 0));
                    o.is("documentSelection") ? t.setSelection(n) : o.setTo(n)
                })))
            }
            _handleInsertTextEvent(t, e) {
                const n = this.editor,
                    o = this.getSelectedTableCells();
                if (!o) return;
                const i = n.editing.view,
                    r = n.editing.mapper,
                    s = o.map((t => i.createRangeOn(r.toViewElement(t))));
                e.selection = i.createSelection(s)
            }
            _getCellsToSelect(t, e) {
                const n = this.editor.plugins.get("TableUtils"),
                    o = n.getCellLocation(t),
                    i = n.getCellLocation(e),
                    r = Math.min(o.row, i.row),
                    s = Math.max(o.row, i.row),
                    a = Math.min(o.column, i.column),
                    l = Math.max(o.column, i.column),
                    c = new Array(s - r + 1).fill(null).map((() => [])),
                    d = {
                        startRow: r,
                        endRow: s,
                        startColumn: a,
                        endColumn: l
                    };
                for (const {
                        row: e,
                        cell: n
                    }
                    of new AE(t.findAncestor("table"), d)) c[e - r].push(n);
                const h = i.row < o.row,
                    u = i.column < o.column;
                return h && c.reverse(), u && c.forEach((t => t.reverse())), {
                    cells: c.flat(),
                    backward: h || u
                }
            }
        }
        class ED extends Vi {
            static get pluginName() {
                return "TableClipboard"
            }
            static get requires() {
                return [xD, GE]
            }
            init() {
                const t = this.editor,
                    e = t.editing.view.document;
                this.listenTo(e, "copy", ((t, e) => this._onCopyCut(t, e))), this.listenTo(e, "cut", ((t, e) => this._onCopyCut(t, e))), this.listenTo(t.model, "insertContent", ((t, [e, n]) => this._onInsertContent(t, e, n)), {
                    priority: "high"
                }), this.decorate("_replaceTableSlotCell")
            }
            _onCopyCut(t, e) {
                const n = this.editor.plugins.get(xD);
                if (!n.getSelectedTableCells()) return;
                if ("cut" == t.name && !this.editor.model.canEditAt(this.editor.model.document.selection)) return;
                e.preventDefault(), t.stop();
                const o = this.editor.data,
                    i = this.editor.editing.view.document,
                    r = o.toView(n.getSelectionAsFragment());
                i.fire("clipboardOutput", {
                    dataTransfer: e.dataTransfer,
                    content: r,
                    method: t.name
                })
            }
            _onInsertContent(t, e, n) {
                if (n && !n.is("documentSelection")) return;
                const o = this.editor.model,
                    i = this.editor.plugins.get(GE);
                let r = this.getTableIfOnlyTableInContent(e, o);
                if (!r) return;
                const s = i.getSelectionAffectedTableCells(o.document.selection);
                s.length ? (t.stop(), o.change((t => {
                    const e = {
                            width: i.getColumns(r),
                            height: i.getRows(r)
                        },
                        n = function(t, e, n, o) {
                            const i = t[0].findAncestor("table"),
                                r = o.getColumnIndexes(t),
                                s = o.getRowIndexes(t),
                                a = {
                                    firstColumn: r.first,
                                    lastColumn: r.last,
                                    firstRow: s.first,
                                    lastRow: s.last
                                },
                                l = 1 === t.length;
                            l && (a.lastRow += e.height - 1, a.lastColumn += e.width - 1, function(t, e, n, o) {
                                const i = o.getColumns(t),
                                    r = o.getRows(t);
                                n > i && o.insertColumns(t, {
                                    at: i,
                                    columns: n - i
                                });
                                e > r && o.insertRows(t, {
                                    at: r,
                                    rows: e - r
                                })
                            }(i, a.lastRow + 1, a.lastColumn + 1, o));
                            l || !o.isSelectionRectangular(t) ? function(t, e, n) {
                                const {
                                    firstRow: o,
                                    lastRow: i,
                                    firstColumn: r,
                                    lastColumn: s
                                } = e, a = {
                                    first: o,
                                    last: i
                                }, l = {
                                    first: r,
                                    last: s
                                };
                                SD(t, r, a, n), SD(t, s + 1, a, n), DD(t, o, l, n), DD(t, i + 1, l, n, o)
                            }(i, a, n) : (a.lastRow = NE(i, a), a.lastColumn = LE(i, a));
                            return a
                        }(s, e, t, i),
                        o = n.lastRow - n.firstRow + 1,
                        a = n.lastColumn - n.firstColumn + 1,
                        l = {
                            startRow: 0,
                            startColumn: 0,
                            endRow: Math.min(o, e.height) - 1,
                            endColumn: Math.min(a, e.width) - 1
                        };
                    r = BE(r, l, t);
                    const c = s[0].findAncestor("table"),
                        d = this._replaceSelectedCellsWithPasted(r, e, c, n, t);
                    if (this.editor.plugins.get("TableSelection").isEnabled) {
                        const e = i.sortRanges(d.map((e => t.createRangeOn(e))));
                        t.setSelection(e)
                    } else t.setSelection(d[0], 0)
                }))) : ME(r, i)
            }
            _replaceSelectedCellsWithPasted(t, e, n, o, i) {
                const {
                    width: r,
                    height: s
                } = e, a = function(t, e, n) {
                    const o = new Array(n).fill(null).map((() => new Array(e).fill(null)));
                    for (const {
                            column: e,
                            row: n,
                            cell: i
                        }
                        of new AE(t)) o[n][e] = i;
                    return o
                }(t, r, s), l = [...new AE(n, {
                    startRow: o.firstRow,
                    endRow: o.lastRow,
                    startColumn: o.firstColumn,
                    endColumn: o.lastColumn,
                    includeAllSlots: !0
                })], c = [];
                let d;
                for (const t of l) {
                    const {
                        row: e,
                        column: n
                    } = t;
                    n === o.firstColumn && (d = t.getPositionBefore());
                    const l = e - o.firstRow,
                        h = n - o.firstColumn,
                        u = a[l % s][h % r],
                        g = u ? i.cloneElement(u) : null,
                        m = this._replaceTableSlotCell(t, g, d, i);
                    m && (VE(m, e, n, o.lastRow, o.lastColumn, i), c.push(m), d = i.createPositionAfter(m))
                }
                const h = parseInt(n.getAttribute("headingRows") || "0"),
                    u = parseInt(n.getAttribute("headingColumns") || "0"),
                    g = o.firstRow < h && h <= o.lastRow,
                    m = o.firstColumn < u && u <= o.lastColumn;
                if (g) {
                    const t = DD(n, h, {
                        first: o.firstColumn,
                        last: o.lastColumn
                    }, i, o.firstRow);
                    c.push(...t)
                }
                if (m) {
                    const t = SD(n, u, {
                        first: o.firstRow,
                        last: o.lastRow
                    }, i);
                    c.push(...t)
                }
                return c
            }
            _replaceTableSlotCell(t, e, n, o) {
                const {
                    cell: i,
                    isAnchor: r
                } = t;
                return r && o.remove(i), e ? (o.insert(e, n), e) : null
            }
            getTableIfOnlyTableInContent(t, e) {
                if (!t.is("documentFragment") && !t.is("element")) return null;
                if (t.is("element", "table")) return t;
                if (1 == t.childCount && t.getChild(0).is("element", "table")) return t.getChild(0);
                const n = e.createRangeIn(t);
                for (const t of n.getItems())
                    if (t.is("element", "table")) {
                        const o = e.createRange(n.start, e.createPositionBefore(t));
                        if (e.hasContent(o, {
                                ignoreWhitespaces: !0
                            })) return null;
                        const i = e.createRange(e.createPositionAfter(t), n.end);
                        return e.hasContent(i, {
                            ignoreWhitespaces: !0
                        }) ? null : t
                    } return null
            }
        }

        function DD(t, e, n, o, i = 0) {
            if (e < 1) return;
            return IE(t, e, i).filter((({
                column: t,
                cellWidth: e
            }) => TD(t, e, n))).map((({
                cell: t
            }) => PE(t, e, o)))
        }

        function SD(t, e, n, o) {
            if (e < 1) return;
            return RE(t, e).filter((({
                row: t,
                cellHeight: e
            }) => TD(t, e, n))).map((({
                cell: t,
                column: n
            }) => zE(t, n, e, o)))
        }

        function TD(t, e, n) {
            const o = t + e - 1,
                {
                    first: i,
                    last: r
                } = n;
            return t >= i && t <= r || t < i && o >= i
        }
        class BD extends Vi {
            static get pluginName() {
                return "TableKeyboard"
            }
            static get requires() {
                return [xD, GE]
            }
            init() {
                const t = this.editor.editing.view.document;
                this.listenTo(t, "arrowKey", ((...t) => this._onArrowKey(...t)), {
                    context: "table"
                }), this.listenTo(t, "tab", ((...t) => this._handleTabOnSelectedTable(...t)), {
                    context: "figure"
                }), this.listenTo(t, "tab", ((...t) => this._handleTab(...t)), {
                    context: ["th", "td"]
                })
            }
            _handleTabOnSelectedTable(t, e) {
                const n = this.editor,
                    o = n.model.document.selection.getSelectedElement();
                o && o.is("element", "table") && (e.preventDefault(), e.stopPropagation(), t.stop(), n.model.change((t => {
                    t.setSelection(t.createRangeIn(o.getChild(0).getChild(0)))
                })))
            }
            _handleTab(t, e) {
                const n = this.editor,
                    o = this.editor.plugins.get(GE),
                    i = this.editor.plugins.get("TableSelection"),
                    r = n.model.document.selection,
                    s = !e.shiftKey;
                let a = o.getTableCellsContainingSelection(r)[0];
                if (a || (a = i.getFocusCell()), !a) return;
                e.preventDefault(), e.stopPropagation(), t.stop();
                const l = a.parent,
                    c = l.parent,
                    d = c.getChildIndex(l),
                    h = l.getChildIndex(a),
                    u = 0 === h;
                if (!s && u && 0 === d) return void n.model.change((t => {
                    t.setSelection(t.createRangeOn(c))
                }));
                const g = h === l.childCount - 1,
                    m = d === o.getRows(c) - 1;
                if (s && m && g && (n.execute("insertTableRowBelow"), d === o.getRows(c) - 1)) return void n.model.change((t => {
                    t.setSelection(t.createRangeOn(c))
                }));
                let p;
                if (s && g) {
                    const t = c.getChild(d + 1);
                    p = t.getChild(0)
                } else if (!s && u) {
                    const t = c.getChild(d - 1);
                    p = t.getChild(t.childCount - 1)
                } else p = l.getChild(h + (s ? 1 : -1));
                n.model.change((t => {
                    t.setSelection(t.createRangeIn(p))
                }))
            }
            _onArrowKey(t, e) {
                const n = this.editor,
                    o = wi(e.keyCode, n.locale.contentLanguageDirection);
                this._handleArrowKeys(o, e.shiftKey) && (e.preventDefault(), e.stopPropagation(), t.stop())
            }
            _handleArrowKeys(t, e) {
                const n = this.editor.plugins.get(GE),
                    o = this.editor.plugins.get("TableSelection"),
                    i = this.editor.model,
                    r = i.document.selection,
                    s = ["right", "down"].includes(t),
                    a = n.getSelectedTableCells(r);
                if (a.length) {
                    let n;
                    return n = e ? o.getFocusCell() : s ? a[a.length - 1] : a[0], this._navigateFromCellInDirection(n, t, e), !0
                }
                const l = r.focus.findAncestor("tableCell");
                if (!l) return !1;
                if (!r.isCollapsed)
                    if (e) {
                        if (r.isBackward == s && !r.containsEntireContent(l)) return !1
                    } else {
                        const t = r.getSelectedElement();
                        if (!t || !i.schema.isObject(t)) return !1
                    } return !!this._isSelectionAtCellEdge(r, l, s) && (this._navigateFromCellInDirection(l, t, e), !0)
            }
            _isSelectionAtCellEdge(t, e, n) {
                const o = this.editor.model,
                    i = this.editor.model.schema,
                    r = n ? t.getLastPosition() : t.getFirstPosition();
                if (!i.getLimitElement(r).is("element", "tableCell")) {
                    return o.createPositionAt(e, n ? "end" : 0).isTouching(r)
                }
                const s = o.createSelection(r);
                return o.modifySelection(s, {
                    direction: n ? "forward" : "backward"
                }), r.isEqual(s.focus)
            }
            _navigateFromCellInDirection(t, e, n = !1) {
                const o = this.editor.model,
                    i = t.findAncestor("table"),
                    r = [...new AE(i, {
                        includeAllSlots: !0
                    })],
                    {
                        row: s,
                        column: a
                    } = r[r.length - 1],
                    l = r.find((({
                        cell: e
                    }) => e == t));
                let {
                    row: c,
                    column: d
                } = l;
                switch (e) {
                    case "left":
                        d--;
                        break;
                    case "up":
                        c--;
                        break;
                    case "right":
                        d += l.cellWidth;
                        break;
                    case "down":
                        c += l.cellHeight
                }
                if (c < 0 || c > s || d < 0 && c <= 0 || d > a && c >= s) return void o.change((t => {
                    t.setSelection(t.createRangeOn(i))
                }));
                d < 0 ? (d = n ? 0 : a, c--) : d > a && (d = n ? a : 0, c++);
                const h = r.find((t => t.row == c && t.column == d)).cell,
                    u = ["right", "down"].includes(e),
                    g = this.editor.plugins.get("TableSelection");
                if (n && g.isEnabled) {
                    const e = g.getAnchorCell() || t;
                    g.setCellSelection(e, h)
                } else {
                    const t = o.createPositionAt(h, u ? 0 : "end");
                    o.change((e => {
                        e.setSelection(t)
                    }))
                }
            }
        }
        class ID extends va {
            constructor() {
                super(...arguments), this.domEventType = ["mousemove", "mouseleave"]
            }
            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }
        class PD extends Vi {
            static get pluginName() {
                return "TableMouse"
            }
            static get requires() {
                return [xD, GE]
            }
            init() {
                this.editor.editing.view.addObserver(ID), this._enableShiftClickSelection(), this._enableMouseDragSelection()
            }
            _enableShiftClickSelection() {
                const t = this.editor,
                    e = t.plugins.get(GE);
                let n = !1;
                const o = t.plugins.get(xD);
                this.listenTo(t.editing.view.document, "mousedown", ((i, r) => {
                    const s = t.model.document.selection;
                    if (!this.isEnabled || !o.isEnabled) return;
                    if (!r.domEvent.shiftKey) return;
                    const a = o.getAnchorCell() || e.getTableCellsContainingSelection(s)[0];
                    if (!a) return;
                    const l = this._getModelTableCellFromDomEvent(r);
                    l && RD(a, l) && (n = !0, o.setCellSelection(a, l), r.preventDefault())
                })), this.listenTo(t.editing.view.document, "mouseup", (() => {
                    n = !1
                })), this.listenTo(t.editing.view.document, "selectionChange", (t => {
                    n && t.stop()
                }), {
                    priority: "highest"
                })
            }
            _enableMouseDragSelection() {
                const t = this.editor;
                let e, n, o = !1,
                    i = !1;
                const r = t.plugins.get(xD);
                this.listenTo(t.editing.view.document, "mousedown", ((t, n) => {
                    this.isEnabled && r.isEnabled && (n.domEvent.shiftKey || n.domEvent.ctrlKey || n.domEvent.altKey || (e = this._getModelTableCellFromDomEvent(n)))
                })), this.listenTo(t.editing.view.document, "mousemove", ((t, s) => {
                    if (!s.domEvent.buttons) return;
                    if (!e) return;
                    const a = this._getModelTableCellFromDomEvent(s);
                    a && RD(e, a) && (n = a, o || n == e || (o = !0)), o && (i = !0, r.setCellSelection(e, n), s.preventDefault())
                })), this.listenTo(t.editing.view.document, "mouseup", (() => {
                    o = !1, i = !1, e = null, n = null
                })), this.listenTo(t.editing.view.document, "selectionChange", (t => {
                    i && t.stop()
                }), {
                    priority: "highest"
                })
            }
            _getModelTableCellFromDomEvent(t) {
                const e = t.target,
                    n = this.editor.editing.view.createPositionAt(e, 0);
                return this.editor.editing.mapper.toModelPosition(n).parent.findAncestor("tableCell", {
                    includeSelf: !0
                })
            }
        }

        function RD(t, e) {
            return t.parent.parent == e.parent.parent
        }
        var zD = n(6306),
            VD = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(zD.Z, VD);
        zD.Z.locals;

        function OD(t) {
            const e = t.getSelectedElement();
            return e && MD(e) ? e : null
        }

        function FD(t) {
            const e = t.getFirstPosition();
            if (!e) return null;
            let n = e.parent;
            for (; n;) {
                if (n.is("element") && MD(n)) return n;
                n = n.parent
            }
            return null
        }

        function MD(t) {
            return !!t.getCustomProperty("table") && $w(t)
        }
        var ND = n(7368),
            LD = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(ND.Z, LD);
        ND.Z.locals;
        class HD extends cg {
            constructor(t, e) {
                super(t), this.set("value", ""), this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("isEmpty", !0), this.options = e, this.focusTracker = new Di, this._focusables = new sg, this.dropdownView = this._createDropdownView(), this.inputView = this._createInputTextView(), this.keystrokes = new Si, this._stillTyping = !1, this._focusCycler = new wm({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "shift + tab",
                        focusNext: "tab"
                    }
                }), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-input-color"]
                    },
                    children: [this.dropdownView, this.inputView]
                }), this.on("change:value", ((t, e, n) => this._setInputValue(n)))
            }
            render() {
                super.render(), this.keystrokes.listenTo(this.dropdownView.panelView.element)
            }
            focus() {
                this.inputView.focus()
            }
            destroy() {
                super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
            }
            _createDropdownView() {
                const t = this.locale,
                    e = t.t,
                    n = this.bindTemplate,
                    o = this._createColorGrid(t),
                    i = Wm(t),
                    r = new cg,
                    s = this._createRemoveColorButton();
                return r.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-input-color__button__preview"],
                        style: {
                            backgroundColor: n.to("value")
                        }
                    },
                    children: [{
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-input-color__button__preview__no-color-indicator", n.if("value", "ck-hidden", (t => "" != t))]
                        }
                    }]
                }), i.buttonView.extendTemplate({
                    attributes: {
                        class: "ck-input-color__button"
                    }
                }), i.buttonView.children.add(r), i.buttonView.label = e("Color picker"), i.buttonView.tooltip = !0, i.panelPosition = "rtl" === t.uiLanguageDirection ? "se" : "sw", i.panelView.children.add(s), i.panelView.children.add(o), i.bind("isEnabled").to(this, "isReadOnly", (t => !t)), this._focusables.add(s), this._focusables.add(o), this.focusTracker.add(s.element), this.focusTracker.add(o.element), i
            }
            _createInputTextView() {
                const t = this.locale,
                    e = new dm(t);
                return e.extendTemplate({
                    on: {
                        blur: e.bindTemplate.to("blur")
                    }
                }), e.value = this.value, e.bind("isReadOnly", "hasError").to(this), this.bind("isFocused", "isEmpty").to(e), e.on("input", (() => {
                    const t = e.element.value,
                        n = this.options.colorDefinitions.find((e => t === e.label));
                    this._stillTyping = !0, this.value = n && n.color || t
                })), e.on("blur", (() => {
                    this._stillTyping = !1, this._setInputValue(e.element.value)
                })), e.delegate("input").to(this), e
            }
            _createRemoveColorButton() {
                const t = this.locale,
                    e = t.t,
                    n = new Mg(t),
                    o = this.options.defaultColorValue || "",
                    i = e(o ? "Restore default" : "Remove color");
                return n.class = "ck-input-color__remove-color", n.withText = !0, n.icon = eg.eraser, n.label = i, n.on("execute", (() => {
                    this.value = o, this.dropdownView.isOpen = !1, this.fire("input")
                })), n
            }
            _createColorGrid(t) {
                const e = new Kg(t, {
                    colorDefinitions: this.options.colorDefinitions,
                    columns: this.options.columns
                });
                return e.on("execute", ((t, e) => {
                    this.value = e.value, this.dropdownView.isOpen = !1, this.fire("input")
                })), e.bind("selectedColor").to(this, "value"), e
            }
            _setInputValue(t) {
                if (!this._stillTyping) {
                    const e = jD(t),
                        n = this.options.colorDefinitions.find((t => e === jD(t.color)));
                    this.inputView.value = n ? n.label : t || ""
                }
            }
        }

        function jD(t) {
            return t.replace(/([(,])\s+/g, "$1").replace(/^\s+|\s+(?=[),\s]|$)/g, "").replace(/,|\s/g, " ")
        }
        const qD = t => "" === t;

        function WD(t) {
            return {
                none: t("None"),
                solid: t("Solid"),
                dotted: t("Dotted"),
                dashed: t("Dashed"),
                double: t("Double"),
                groove: t("Groove"),
                ridge: t("Ridge"),
                inset: t("Inset"),
                outset: t("Outset")
            }
        }

        function UD(t) {
            return t('The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".')
        }

        function $D(t) {
            return t('The value is invalid. Try "10px" or "2em" or simply "2".')
        }

        function GD(t) {
            return t = t.trim(), qD(t) || bu(t)
        }

        function KD(t) {
            return t = t.trim(), qD(t) || tS(t) || Cu(t) || vu(t)
        }

        function ZD(t) {
            return t = t.trim(), qD(t) || tS(t) || Cu(t)
        }

        function JD(t, e) {
            const n = new xi,
                o = WD(t.t);
            for (const i in o) {
                const r = {
                    type: "button",
                    model: new Vf({
                        _borderStyleValue: i,
                        label: o[i],
                        role: "menuitemradio",
                        withText: !0
                    })
                };
                "none" === i ? r.model.bind("isOn").to(t, "borderStyle", (t => "none" === e ? !t : t === i)) : r.model.bind("isOn").to(t, "borderStyle", (t => t === i)), n.add(r)
            }
            return n
        }

        function YD(t) {
            const {
                view: e,
                icons: n,
                toolbar: o,
                labels: i,
                propertyName: r,
                nameToValue: s,
                defaultValue: a
            } = t;
            for (const t in i) {
                const l = new Mg(e.locale);
                l.set({
                    label: i[t],
                    icon: n[t],
                    tooltip: i[t]
                });
                const c = s ? s(t) : t;
                l.bind("isOn").to(e, r, (t => {
                    let e = t;
                    return "" === t && a && (e = a), c === e
                })), l.on("execute", (() => {
                    e[r] = c
                })), o.items.add(l)
            }
        }
        const QD = [{
            color: "hsl(0, 0%, 0%)",
            label: "Black"
        }, {
            color: "hsl(0, 0%, 30%)",
            label: "Dim grey"
        }, {
            color: "hsl(0, 0%, 60%)",
            label: "Grey"
        }, {
            color: "hsl(0, 0%, 90%)",
            label: "Light grey"
        }, {
            color: "hsl(0, 0%, 100%)",
            label: "White",
            hasBorder: !0
        }, {
            color: "hsl(0, 75%, 60%)",
            label: "Red"
        }, {
            color: "hsl(30, 75%, 60%)",
            label: "Orange"
        }, {
            color: "hsl(60, 75%, 60%)",
            label: "Yellow"
        }, {
            color: "hsl(90, 75%, 60%)",
            label: "Light green"
        }, {
            color: "hsl(120, 75%, 60%)",
            label: "Green"
        }, {
            color: "hsl(150, 75%, 60%)",
            label: "Aquamarine"
        }, {
            color: "hsl(180, 75%, 60%)",
            label: "Turquoise"
        }, {
            color: "hsl(210, 75%, 60%)",
            label: "Light blue"
        }, {
            color: "hsl(240, 75%, 60%)",
            label: "Blue"
        }, {
            color: "hsl(270, 75%, 60%)",
            label: "Purple"
        }];

        function XD(t) {
            return (e, n, o) => {
                const i = new HD(e.locale, {
                    colorDefinitions: (r = t.colorConfig, r.map((t => ({
                        color: t.model,
                        label: t.label,
                        options: {
                            hasBorder: t.hasBorder
                        }
                    })))),
                    columns: t.columns,
                    defaultColorValue: t.defaultColorValue
                });
                var r;
                return i.inputView.set({
                    id: n,
                    ariaDescribedById: o
                }), i.bind("isReadOnly").to(e, "isEnabled", (t => !t)), i.bind("hasError").to(e, "errorText", (t => !!t)), i.on("input", (() => {
                    e.errorText = null
                })), e.bind("isEmpty", "isFocused").to(i), i
            }
        }

        function tS(t) {
            const e = parseFloat(t);
            return !Number.isNaN(e) && t === String(e)
        }
        var eS = n(9247),
            nS = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(eS.Z, nS);
        eS.Z.locals;
        class oS extends cg {
            constructor(t, e = {}) {
                super(t);
                const n = this.bindTemplate;
                this.set("class", e.class || null), this.children = this.createCollection(), e.children && e.children.forEach((t => this.children.add(t))), this.set("_role", null), this.set("_ariaLabelledBy", null), e.labelView && this.set({
                    _role: "group",
                    _ariaLabelledBy: e.labelView.id
                }), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-form__row", n.to("class")],
                        role: n.to("_role"),
                        "aria-labelledby": n.to("_ariaLabelledBy")
                    },
                    children: this.children
                })
            }
        }
        var iS = n(4070),
            rS = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(iS.Z, rS);
        iS.Z.locals;
        var sS = n(6237),
            aS = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(sS.Z, aS);
        sS.Z.locals;
        var lS = n(5087),
            cS = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(lS.Z, cS);
        lS.Z.locals;
        const dS = {
            left: eg.alignLeft,
            center: eg.alignCenter,
            right: eg.alignRight,
            justify: eg.alignJustify,
            top: eg.alignTop,
            middle: eg.alignMiddle,
            bottom: eg.alignBottom
        };
        class hS extends cg {
            constructor(t, e) {
                super(t), this.set({
                    borderStyle: "",
                    borderWidth: "",
                    borderColor: "",
                    padding: "",
                    backgroundColor: "",
                    width: "",
                    height: "",
                    horizontalAlignment: "",
                    verticalAlignment: ""
                }), this.options = e;
                const {
                    borderStyleDropdown: n,
                    borderWidthInput: o,
                    borderColorInput: i,
                    borderRowLabel: r
                } = this._createBorderFields(), {
                    backgroundRowLabel: s,
                    backgroundInput: a
                } = this._createBackgroundFields(), {
                    widthInput: l,
                    operatorLabel: c,
                    heightInput: d,
                    dimensionsLabel: h
                } = this._createDimensionFields(), {
                    horizontalAlignmentToolbar: u,
                    verticalAlignmentToolbar: g,
                    alignmentLabel: m
                } = this._createAlignmentFields();
                this.focusTracker = new Di, this.keystrokes = new Si, this.children = this.createCollection(), this.borderStyleDropdown = n, this.borderWidthInput = o, this.borderColorInput = i, this.backgroundInput = a, this.paddingInput = this._createPaddingField(), this.widthInput = l, this.heightInput = d, this.horizontalAlignmentToolbar = u, this.verticalAlignmentToolbar = g;
                const {
                    saveButtonView: p,
                    cancelButtonView: f
                } = this._createActionButtons();
                this.saveButtonView = p, this.cancelButtonView = f, this._focusables = new sg, this._focusCycler = new wm({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "shift + tab",
                        focusNext: "tab"
                    }
                }), this.children.add(new Rf(t, {
                    label: this.t("Cell properties")
                })), this.children.add(new oS(t, {
                    labelView: r,
                    children: [r, n, i, o],
                    class: "ck-table-form__border-row"
                })), this.children.add(new oS(t, {
                    labelView: s,
                    children: [s, a],
                    class: "ck-table-form__background-row"
                })), this.children.add(new oS(t, {
                    children: [new oS(t, {
                        labelView: h,
                        children: [h, l, c, d],
                        class: "ck-table-form__dimensions-row"
                    }), new oS(t, {
                        children: [this.paddingInput],
                        class: "ck-table-cell-properties-form__padding-row"
                    })]
                })), this.children.add(new oS(t, {
                    labelView: m,
                    children: [m, u, g],
                    class: "ck-table-cell-properties-form__alignment-row"
                })), this.children.add(new oS(t, {
                    children: [this.saveButtonView, this.cancelButtonView],
                    class: "ck-table-form__action-row"
                })), this.setTemplate({
                    tag: "form",
                    attributes: {
                        class: ["ck", "ck-form", "ck-table-form", "ck-table-cell-properties-form"],
                        tabindex: "-1"
                    },
                    children: this.children
                })
            }
            render() {
                super.render(), ig({
                    view: this
                }), [this.borderStyleDropdown, this.borderColorInput, this.borderColorInput.fieldView.dropdownView.buttonView, this.borderWidthInput, this.backgroundInput, this.backgroundInput.fieldView.dropdownView.buttonView, this.widthInput, this.heightInput, this.paddingInput, this.horizontalAlignmentToolbar, this.verticalAlignmentToolbar, this.saveButtonView, this.cancelButtonView].forEach((t => {
                    this._focusables.add(t), this.focusTracker.add(t.element)
                })), this.keystrokes.listenTo(this.element)
            }
            destroy() {
                super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            _createBorderFields() {
                const t = this.options.defaultTableCellProperties,
                    e = {
                        style: t.borderStyle,
                        width: t.borderWidth,
                        color: t.borderColor
                    },
                    n = XD({
                        colorConfig: this.options.borderColors,
                        columns: 5,
                        defaultColorValue: e.color
                    }),
                    o = this.locale,
                    i = this.t,
                    r = i("Style"),
                    s = new om(o);
                s.text = i("Border");
                const a = WD(i),
                    l = new sm(o, Qm);
                l.set({
                    label: r,
                    class: "ck-table-form__border-style"
                }), l.fieldView.buttonView.set({
                    ariaLabel: r,
                    ariaLabelledBy: void 0,
                    isOn: !1,
                    withText: !0,
                    tooltip: r
                }), l.fieldView.buttonView.bind("label").to(this, "borderStyle", (t => a[t || "none"])), l.fieldView.on("execute", (t => {
                    this.borderStyle = t.source._borderStyleValue
                })), l.bind("isEmpty").to(this, "borderStyle", (t => !t)), Gm(l.fieldView, JD(this, e.style), {
                    role: "menu",
                    ariaLabel: r
                });
                const c = new sm(o, Jm);
                c.set({
                    label: i("Width"),
                    class: "ck-table-form__border-width"
                }), c.fieldView.bind("value").to(this, "borderWidth"), c.bind("isEnabled").to(this, "borderStyle", uS), c.fieldView.on("input", (() => {
                    this.borderWidth = c.fieldView.element.value
                }));
                const d = new sm(o, n);
                return d.set({
                    label: i("Color"),
                    class: "ck-table-form__border-color"
                }), d.fieldView.bind("value").to(this, "borderColor"), d.bind("isEnabled").to(this, "borderStyle", uS), d.fieldView.on("input", (() => {
                    this.borderColor = d.fieldView.value
                })), this.on("change:borderStyle", ((t, n, o, i) => {
                    uS(o) || (this.borderColor = "", this.borderWidth = ""), uS(i) || (this.borderColor = e.color, this.borderWidth = e.width)
                })), {
                    borderRowLabel: s,
                    borderStyleDropdown: l,
                    borderColorInput: d,
                    borderWidthInput: c
                }
            }
            _createBackgroundFields() {
                const t = this.locale,
                    e = this.t,
                    n = new om(t);
                n.text = e("Background");
                const o = XD({
                        colorConfig: this.options.backgroundColors,
                        columns: 5,
                        defaultColorValue: this.options.defaultTableCellProperties.backgroundColor
                    }),
                    i = new sm(t, o);
                return i.set({
                    label: e("Color"),
                    class: "ck-table-cell-properties-form__background"
                }), i.fieldView.bind("value").to(this, "backgroundColor"), i.fieldView.on("input", (() => {
                    this.backgroundColor = i.fieldView.value
                })), {
                    backgroundRowLabel: n,
                    backgroundInput: i
                }
            }
            _createDimensionFields() {
                const t = this.locale,
                    e = this.t,
                    n = new om(t);
                n.text = e("Dimensions");
                const o = new sm(t, Jm);
                o.set({
                    label: e("Width"),
                    class: "ck-table-form__dimensions-row__width"
                }), o.fieldView.bind("value").to(this, "width"), o.fieldView.on("input", (() => {
                    this.width = o.fieldView.element.value
                }));
                const i = new cg(t);
                i.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck-table-form__dimension-operator"]
                    },
                    children: [{
                        text: "×"
                    }]
                });
                const r = new sm(t, Jm);
                return r.set({
                    label: e("Height"),
                    class: "ck-table-form__dimensions-row__height"
                }), r.fieldView.bind("value").to(this, "height"), r.fieldView.on("input", (() => {
                    this.height = r.fieldView.element.value
                })), {
                    dimensionsLabel: n,
                    widthInput: o,
                    operatorLabel: i,
                    heightInput: r
                }
            }
            _createPaddingField() {
                const t = this.locale,
                    e = this.t,
                    n = new sm(t, Jm);
                return n.set({
                    label: e("Padding"),
                    class: "ck-table-cell-properties-form__padding"
                }), n.fieldView.bind("value").to(this, "padding"), n.fieldView.on("input", (() => {
                    this.padding = n.fieldView.element.value
                })), n
            }
            _createAlignmentFields() {
                const t = this.locale,
                    e = this.t,
                    n = new om(t);
                n.text = e("Table cell text alignment");
                const o = new Sm(t),
                    i = "rtl" === t.contentLanguageDirection;
                o.set({
                    isCompact: !0,
                    ariaLabel: e("Horizontal text alignment toolbar")
                }), YD({
                    view: this,
                    icons: dS,
                    toolbar: o,
                    labels: this._horizontalAlignmentLabels,
                    propertyName: "horizontalAlignment",
                    nameToValue: t => {
                        if (i) {
                            if ("left" === t) return "right";
                            if ("right" === t) return "left"
                        }
                        return t
                    },
                    defaultValue: this.options.defaultTableCellProperties.horizontalAlignment
                });
                const r = new Sm(t);
                return r.set({
                    isCompact: !0,
                    ariaLabel: e("Vertical text alignment toolbar")
                }), YD({
                    view: this,
                    icons: dS,
                    toolbar: r,
                    labels: this._verticalAlignmentLabels,
                    propertyName: "verticalAlignment",
                    defaultValue: this.options.defaultTableCellProperties.verticalAlignment
                }), {
                    horizontalAlignmentToolbar: o,
                    verticalAlignmentToolbar: r,
                    alignmentLabel: n
                }
            }
            _createActionButtons() {
                const t = this.locale,
                    e = this.t,
                    n = new Mg(t),
                    o = new Mg(t),
                    i = [this.borderWidthInput, this.borderColorInput, this.backgroundInput, this.paddingInput];
                return n.set({
                    label: e("Save"),
                    icon: eg.check,
                    class: "ck-button-save",
                    type: "submit",
                    withText: !0
                }), n.bind("isEnabled").toMany(i, "errorText", ((...t) => t.every((t => !t)))), o.set({
                    label: e("Cancel"),
                    icon: eg.cancel,
                    class: "ck-button-cancel",
                    withText: !0
                }), o.delegate("execute").to(this, "cancel"), {
                    saveButtonView: n,
                    cancelButtonView: o
                }
            }
            get _horizontalAlignmentLabels() {
                const t = this.locale,
                    e = this.t,
                    n = e("Align cell text to the left"),
                    o = e("Align cell text to the center"),
                    i = e("Align cell text to the right"),
                    r = e("Justify cell text");
                return "rtl" === t.uiLanguageDirection ? {
                    right: i,
                    center: o,
                    left: n,
                    justify: r
                } : {
                    left: n,
                    center: o,
                    right: i,
                    justify: r
                }
            }
            get _verticalAlignmentLabels() {
                const t = this.t;
                return {
                    top: t("Align cell text to the top"),
                    middle: t("Align cell text to the middle"),
                    bottom: t("Align cell text to the bottom")
                }
            }
        }

        function uS(t) {
            return "none" !== t
        }
        const gS = Kp.defaultPositions,
            mS = [gS.northArrowSouth, gS.northArrowSouthWest, gS.northArrowSouthEast, gS.southArrowNorth, gS.southArrowNorthWest, gS.southArrowNorthEast, gS.viewportStickyNorth];

        function pS(t, e) {
            const n = t.plugins.get("ContextualBalloon");
            if (FD(t.editing.view.document.selection)) {
                let o;
                o = "cell" === e ? bS(t) : fS(t), n.updatePosition(o)
            }
        }

        function fS(t) {
            const e = t.model.document.selection.getFirstPosition().findAncestor("table"),
                n = t.editing.mapper.toViewElement(e);
            return {
                target: t.editing.view.domConverter.mapViewToDom(n),
                positions: mS
            }
        }

        function bS(t) {
            const e = t.editing.mapper,
                n = t.editing.view.domConverter,
                o = t.model.document.selection;
            if (o.rangeCount > 1) return {
                target: () => function(t, e) {
                    const n = e.editing.mapper,
                        o = e.editing.view.domConverter,
                        i = Array.from(t).map((t => {
                            const e = kS(t.start),
                                i = n.toViewElement(e);
                            return new Mo(o.mapViewToDom(i))
                        }));
                    return Mo.getBoundingRect(i)
                }(o.getRanges(), t),
                positions: mS
            };
            const i = kS(o.getFirstPosition()),
                r = e.toViewElement(i);
            return {
                target: n.mapViewToDom(r),
                positions: mS
            }
        }

        function kS(t) {
            return t.nodeAfter && t.nodeAfter.is("element", "tableCell") ? t.nodeAfter : t.findAncestor("tableCell")
        }
        var wS = Object.defineProperty,
            AS = Object.getOwnPropertySymbols,
            CS = Object.prototype.hasOwnProperty,
            _S = Object.prototype.propertyIsEnumerable,
            vS = (t, e, n) => e in t ? wS(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n;

        function yS(t) {
            if (!t || !O(t)) return t;
            const {
                top: e,
                right: n,
                bottom: o,
                left: i
            } = t;
            return e == n && n == o && o == i ? e : void 0
        }

        function xS(t, e) {
            const n = parseFloat(t);
            return Number.isNaN(n) || String(n) !== String(t) ? t : `${n}${e}`
        }

        function ES(t, e = {}) {
            const n = ((t, e) => {
                for (var n in e || (e = {})) CS.call(e, n) && vS(t, n, e[n]);
                if (AS)
                    for (var n of AS(e)) _S.call(e, n) && vS(t, n, e[n]);
                return t
            })({
                borderStyle: "none",
                borderWidth: "",
                borderColor: "",
                backgroundColor: "",
                width: "",
                height: ""
            }, t);
            return e.includeAlignmentProperty && !n.alignment && (n.alignment = "center"), e.includePaddingProperty && !n.padding && (n.padding = ""), e.includeVerticalAlignmentProperty && !n.verticalAlignment && (n.verticalAlignment = "middle"), e.includeHorizontalAlignmentProperty && !n.horizontalAlignment && (n.horizontalAlignment = e.isRightToLeftContent ? "right" : "left"), n
        }
        const DS = {
            borderStyle: "tableCellBorderStyle",
            borderColor: "tableCellBorderColor",
            borderWidth: "tableCellBorderWidth",
            height: "tableCellHeight",
            width: "tableCellWidth",
            padding: "tableCellPadding",
            backgroundColor: "tableCellBackgroundColor",
            horizontalAlignment: "tableCellHorizontalAlignment",
            verticalAlignment: "tableCellVerticalAlignment"
        };
        class SS extends Vi {
            constructor(t) {
                super(t), t.config.define("table.tableCellProperties", {
                    borderColors: QD,
                    backgroundColors: QD
                })
            }
            static get requires() {
                return [jf]
            }
            static get pluginName() {
                return "TableCellPropertiesUI"
            }
            init() {
                const t = this.editor,
                    e = t.t;
                this._defaultTableCellProperties = ES(t.config.get("table.tableCellProperties.defaultProperties"), {
                    includeVerticalAlignmentProperty: !0,
                    includeHorizontalAlignmentProperty: !0,
                    includePaddingProperty: !0,
                    isRightToLeftContent: "rtl" === t.locale.contentLanguageDirection
                }), this._balloon = t.plugins.get(jf), this.view = null, this._isReady = !1, t.ui.componentFactory.add("tableCellProperties", (n => {
                    const o = new Mg(n);
                    o.set({
                        label: e("Cell properties"),
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.105 18-.17 1H2.5A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1h15A1.5 1.5 0 0 1 19 2.5v9.975l-.85-.124-.15-.302V8h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5h3.105zM2 12h5V8H2v4zm10-4H8v4h4V8zM2 2v5h5V2H2zm0 16h5v-5H2v5zM13 7h5V2h-5v5zM8 2v5h4V2H8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM13 6a1 1 0 0 1 1 1v3.172a2.047 2.047 0 0 0-.293.443l-.858 1.736-1.916.28-.151.027A1.976 1.976 0 0 0 9.315 14H7a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm-1 2H8v4h4V8z"/></svg>',
                        tooltip: !0
                    }), this.listenTo(o, "execute", (() => this._showView()));
                    const i = Object.values(DS).map((e => t.commands.get(e)));
                    return o.bind("isEnabled").toMany(i, "isEnabled", ((...t) => t.some((t => t)))), o
                }))
            }
            destroy() {
                super.destroy(), this.view && this.view.destroy()
            }
            _createPropertiesView() {
                const t = this.editor,
                    e = t.config.get("table.tableCellProperties"),
                    n = qg(e.borderColors),
                    o = jg(t.locale, n),
                    i = qg(e.backgroundColors),
                    r = jg(t.locale, i),
                    s = new hS(t.locale, {
                        borderColors: o,
                        backgroundColors: r,
                        defaultTableCellProperties: this._defaultTableCellProperties
                    }),
                    a = t.t;
                s.render(), this.listenTo(s, "submit", (() => {
                    this._hideView()
                })), this.listenTo(s, "cancel", (() => {
                    this._undoStepBatch.operations.length && t.execute("undo", this._undoStepBatch), this._hideView()
                })), s.keystrokes.set("Esc", ((t, e) => {
                    this._hideView(), e()
                })), ng({
                    emitter: s,
                    activator: () => this._isViewInBalloon,
                    contextElements: [this._balloon.view.element],
                    callback: () => this._hideView()
                });
                const l = UD(a),
                    c = $D(a);
                return s.on("change:borderStyle", this._getPropertyChangeCallback("tableCellBorderStyle")), s.on("change:borderColor", this._getValidatedPropertyChangeCallback({
                    viewField: s.borderColorInput,
                    commandName: "tableCellBorderColor",
                    errorText: l,
                    validator: GD
                })), s.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
                    viewField: s.borderWidthInput,
                    commandName: "tableCellBorderWidth",
                    errorText: c,
                    validator: ZD
                })), s.on("change:padding", this._getValidatedPropertyChangeCallback({
                    viewField: s.paddingInput,
                    commandName: "tableCellPadding",
                    errorText: c,
                    validator: KD
                })), s.on("change:width", this._getValidatedPropertyChangeCallback({
                    viewField: s.widthInput,
                    commandName: "tableCellWidth",
                    errorText: c,
                    validator: KD
                })), s.on("change:height", this._getValidatedPropertyChangeCallback({
                    viewField: s.heightInput,
                    commandName: "tableCellHeight",
                    errorText: c,
                    validator: KD
                })), s.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
                    viewField: s.backgroundInput,
                    commandName: "tableCellBackgroundColor",
                    errorText: l,
                    validator: GD
                })), s.on("change:horizontalAlignment", this._getPropertyChangeCallback("tableCellHorizontalAlignment")), s.on("change:verticalAlignment", this._getPropertyChangeCallback("tableCellVerticalAlignment")), s
            }
            _fillViewFormFromCommandValues() {
                const t = this.editor.commands,
                    e = t.get("tableCellBorderStyle");
                Object.entries(DS).map((([e, n]) => {
                    const o = this._defaultTableCellProperties[e] || "";
                    return [e, t.get(n).value || o]
                })).forEach((([t, n]) => {
                    ("borderColor" !== t && "borderWidth" !== t || "none" !== e.value) && this.view.set(t, n)
                })), this._isReady = !0
            }
            _showView() {
                const t = this.editor;
                this.view || (this.view = this._createPropertiesView()), this.listenTo(t.ui, "update", (() => {
                    this._updateView()
                })), this._fillViewFormFromCommandValues(), this._balloon.add({
                    view: this.view,
                    position: bS(t)
                }), this._undoStepBatch = t.model.createBatch(), this.view.focus()
            }
            _hideView() {
                const t = this.editor;
                this.stopListening(t.ui, "update"), this._isReady = !1, this.view.saveButtonView.focus(), this._balloon.remove(this.view), this.editor.editing.view.focus()
            }
            _updateView() {
                const t = this.editor;
                FD(t.editing.view.document.selection) ? this._isViewVisible && pS(t, "cell") : this._hideView()
            }
            get _isViewVisible() {
                return !!this.view && this._balloon.visibleView === this.view
            }
            get _isViewInBalloon() {
                return !!this.view && this._balloon.hasView(this.view)
            }
            _getPropertyChangeCallback(t) {
                return (e, n, o) => {
                    this._isReady && this.editor.execute(t, {
                        value: o,
                        batch: this._undoStepBatch
                    })
                }
            }
            _getValidatedPropertyChangeCallback(t) {
                const {
                    commandName: e,
                    viewField: n,
                    validator: o,
                    errorText: i
                } = t, r = Fa((() => {
                    n.errorText = i
                }), 500);
                return (t, i, s) => {
                    r.cancel(), this._isReady && (o(s) ? (this.editor.execute(e, {
                        value: s,
                        batch: this._undoStepBatch
                    }), n.errorText = null) : r())
                }
            }
        }
        class TS extends Fi {
            constructor(t, e, n) {
                super(t), this.attributeName = e, this._defaultValue = n
            }
            refresh() {
                const t = this.editor,
                    e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t.model.document.selection);
                this.isEnabled = !!e.length, this.value = this._getSingleValue(e)
            }
            execute(t = {}) {
                const {
                    value: e,
                    batch: n
                } = t, o = this.editor.model, i = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(o.document.selection), r = this._getValueToSet(e);
                o.enqueueChange(n, (t => {
                    r ? i.forEach((e => t.setAttribute(this.attributeName, r, e))) : i.forEach((e => t.removeAttribute(this.attributeName, e)))
                }))
            }
            _getAttribute(t) {
                if (!t) return;
                const e = t.getAttribute(this.attributeName);
                return e !== this._defaultValue ? e : void 0
            }
            _getValueToSet(t) {
                if (t !== this._defaultValue) return t
            }
            _getSingleValue(t) {
                const e = this._getAttribute(t[0]);
                return t.every((t => this._getAttribute(t) === e)) ? e : void 0
            }
        }
        class BS extends TS {
            constructor(t, e) {
                super(t, "tableCellWidth", e)
            }
            _getValueToSet(t) {
                if ((t = xS(t, "px")) !== this._defaultValue) return t
            }
        }
        class IS extends Vi {
            static get pluginName() {
                return "TableCellWidthEditing"
            }
            static get requires() {
                return [fD]
            }
            init() {
                const t = this.editor,
                    e = ES(t.config.get("table.tableCellProperties.defaultProperties"));
                fE(t.model.schema, t.conversion, {
                    modelAttribute: "tableCellWidth",
                    styleName: "width",
                    defaultValue: e.width
                }), t.commands.add("tableCellWidth", new BS(t, e.width))
            }
        }
        class PS extends TS {
            constructor(t, e) {
                super(t, "tableCellPadding", e)
            }
            _getAttribute(t) {
                if (!t) return;
                const e = yS(t.getAttribute(this.attributeName));
                return e !== this._defaultValue ? e : void 0
            }
            _getValueToSet(t) {
                const e = xS(t, "px");
                if (e !== this._defaultValue) return e
            }
        }
        class RS extends TS {
            constructor(t, e) {
                super(t, "tableCellHeight", e)
            }
            _getValueToSet(t) {
                const e = xS(t, "px");
                if (e !== this._defaultValue) return e
            }
        }
        class zS extends TS {
            constructor(t, e) {
                super(t, "tableCellBackgroundColor", e)
            }
        }
        class VS extends TS {
            constructor(t, e) {
                super(t, "tableCellVerticalAlignment", e)
            }
        }
        class OS extends TS {
            constructor(t, e) {
                super(t, "tableCellHorizontalAlignment", e)
            }
        }
        class FS extends TS {
            constructor(t, e) {
                super(t, "tableCellBorderStyle", e)
            }
            _getAttribute(t) {
                if (!t) return;
                const e = yS(t.getAttribute(this.attributeName));
                return e !== this._defaultValue ? e : void 0
            }
        }
        class MS extends TS {
            constructor(t, e) {
                super(t, "tableCellBorderColor", e)
            }
            _getAttribute(t) {
                if (!t) return;
                const e = yS(t.getAttribute(this.attributeName));
                return e !== this._defaultValue ? e : void 0
            }
        }
        class NS extends TS {
            constructor(t, e) {
                super(t, "tableCellBorderWidth", e)
            }
            _getAttribute(t) {
                if (!t) return;
                const e = yS(t.getAttribute(this.attributeName));
                return e !== this._defaultValue ? e : void 0
            }
            _getValueToSet(t) {
                const e = xS(t, "px");
                if (e !== this._defaultValue) return e
            }
        }
        const LS = /^(top|middle|bottom)$/,
            HS = /^(left|center|right|justify)$/;
        class jS extends Vi {
            static get pluginName() {
                return "TableCellPropertiesEditing"
            }
            static get requires() {
                return [fD, IS]
            }
            init() {
                const t = this.editor,
                    e = t.model.schema,
                    n = t.conversion;
                t.config.define("table.tableCellProperties.defaultProperties", {});
                const o = ES(t.config.get("table.tableCellProperties.defaultProperties"), {
                    includeVerticalAlignmentProperty: !0,
                    includeHorizontalAlignmentProperty: !0,
                    includePaddingProperty: !0,
                    isRightToLeftContent: "rtl" === t.locale.contentLanguageDirection
                });
                t.data.addStyleProcessorRules(Mu),
                    function(t, e, n) {
                        const o = {
                            width: "tableCellBorderWidth",
                            color: "tableCellBorderColor",
                            style: "tableCellBorderStyle"
                        };
                        t.extend("tableCell", {
                            allowAttributes: Object.values(o)
                        }), oE(e, "td", o, n), oE(e, "th", o, n), iE(e, {
                            modelElement: "tableCell",
                            modelAttribute: o.style,
                            styleName: "border-style"
                        }), iE(e, {
                            modelElement: "tableCell",
                            modelAttribute: o.color,
                            styleName: "border-color"
                        }), iE(e, {
                            modelElement: "tableCell",
                            modelAttribute: o.width,
                            styleName: "border-width"
                        })
                    }(e, n, {
                        color: o.borderColor,
                        style: o.borderStyle,
                        width: o.borderWidth
                    }), t.commands.add("tableCellBorderStyle", new FS(t, o.borderStyle)), t.commands.add("tableCellBorderColor", new MS(t, o.borderColor)), t.commands.add("tableCellBorderWidth", new NS(t, o.borderWidth)), fE(e, n, {
                        modelAttribute: "tableCellHeight",
                        styleName: "height",
                        defaultValue: o.height
                    }), t.commands.add("tableCellHeight", new RS(t, o.height)), t.data.addStyleProcessorRules(Zu), fE(e, n, {
                        modelAttribute: "tableCellPadding",
                        styleName: "padding",
                        reduceBoxSides: !0,
                        defaultValue: o.padding
                    }), t.commands.add("tableCellPadding", new PS(t, o.padding)), t.data.addStyleProcessorRules(Fu), fE(e, n, {
                        modelAttribute: "tableCellBackgroundColor",
                        styleName: "background-color",
                        defaultValue: o.backgroundColor
                    }), t.commands.add("tableCellBackgroundColor", new zS(t, o.backgroundColor)),
                    function(t, e, n) {
                        t.extend("tableCell", {
                            allowAttributes: ["tableCellHorizontalAlignment"]
                        }), e.for("downcast").attributeToAttribute({
                            model: {
                                name: "tableCell",
                                key: "tableCellHorizontalAlignment"
                            },
                            view: t => ({
                                key: "style",
                                value: {
                                    "text-align": t
                                }
                            })
                        }), e.for("upcast").attributeToAttribute({
                            view: {
                                name: /^(td|th)$/,
                                styles: {
                                    "text-align": HS
                                }
                            },
                            model: {
                                key: "tableCellHorizontalAlignment",
                                value: t => {
                                    const e = t.getStyle("text-align");
                                    return e === n ? null : e
                                }
                            }
                        }).attributeToAttribute({
                            view: {
                                name: /^(td|th)$/,
                                attributes: {
                                    align: HS
                                }
                            },
                            model: {
                                key: "tableCellHorizontalAlignment",
                                value: t => {
                                    const e = t.getAttribute("align");
                                    return e === n ? null : e
                                }
                            }
                        })
                    }(e, n, o.horizontalAlignment), t.commands.add("tableCellHorizontalAlignment", new OS(t, o.horizontalAlignment)),
                    function(t, e, n) {
                        t.extend("tableCell", {
                            allowAttributes: ["tableCellVerticalAlignment"]
                        }), e.for("downcast").attributeToAttribute({
                            model: {
                                name: "tableCell",
                                key: "tableCellVerticalAlignment"
                            },
                            view: t => ({
                                key: "style",
                                value: {
                                    "vertical-align": t
                                }
                            })
                        }), e.for("upcast").attributeToAttribute({
                            view: {
                                name: /^(td|th)$/,
                                styles: {
                                    "vertical-align": LS
                                }
                            },
                            model: {
                                key: "tableCellVerticalAlignment",
                                value: t => {
                                    const e = t.getStyle("vertical-align");
                                    return e === n ? null : e
                                }
                            }
                        }).attributeToAttribute({
                            view: {
                                name: /^(td|th)$/,
                                attributes: {
                                    valign: LS
                                }
                            },
                            model: {
                                key: "tableCellVerticalAlignment",
                                value: t => {
                                    const e = t.getAttribute("valign");
                                    return e === n ? null : e
                                }
                            }
                        })
                    }(e, n, o.verticalAlignment), t.commands.add("tableCellVerticalAlignment", new VS(t, o.verticalAlignment))
            }
        }
        class qS extends Fi {
            constructor(t, e, n) {
                super(t), this.attributeName = e, this._defaultValue = n
            }
            refresh() {
                const t = this.editor.model.document.selection.getFirstPosition().findAncestor("table");
                this.isEnabled = !!t, this.value = this._getValue(t)
            }
            execute(t = {}) {
                const e = this.editor.model,
                    n = e.document.selection,
                    {
                        value: o,
                        batch: i
                    } = t,
                    r = n.getFirstPosition().findAncestor("table"),
                    s = this._getValueToSet(o);
                e.enqueueChange(i, (t => {
                    s ? t.setAttribute(this.attributeName, s, r) : t.removeAttribute(this.attributeName, r)
                }))
            }
            _getValue(t) {
                if (!t) return;
                const e = t.getAttribute(this.attributeName);
                return e !== this._defaultValue ? e : void 0
            }
            _getValueToSet(t) {
                if (t !== this._defaultValue) return t
            }
        }
        class WS extends qS {
            constructor(t, e) {
                super(t, "tableBackgroundColor", e)
            }
        }
        class US extends qS {
            constructor(t, e) {
                super(t, "tableBorderColor", e)
            }
            _getValue(t) {
                if (!t) return;
                const e = yS(t.getAttribute(this.attributeName));
                return e !== this._defaultValue ? e : void 0
            }
        }
        class $S extends qS {
            constructor(t, e) {
                super(t, "tableBorderStyle", e)
            }
            _getValue(t) {
                if (!t) return;
                const e = yS(t.getAttribute(this.attributeName));
                return e !== this._defaultValue ? e : void 0
            }
        }
        class GS extends qS {
            constructor(t, e) {
                super(t, "tableBorderWidth", e)
            }
            _getValue(t) {
                if (!t) return;
                const e = yS(t.getAttribute(this.attributeName));
                return e !== this._defaultValue ? e : void 0
            }
            _getValueToSet(t) {
                const e = xS(t, "px");
                if (e !== this._defaultValue) return e
            }
        }
        class KS extends qS {
            constructor(t, e) {
                super(t, "tableWidth", e)
            }
            _getValueToSet(t) {
                if ((t = xS(t, "px")) !== this._defaultValue) return t
            }
        }
        class ZS extends qS {
            constructor(t, e) {
                super(t, "tableHeight", e)
            }
            _getValueToSet(t) {
                if ((t = xS(t, "px")) !== this._defaultValue) return t
            }
        }
        class JS extends qS {
            constructor(t, e) {
                super(t, "tableAlignment", e)
            }
        }
        var YS = Object.defineProperty,
            QS = Object.getOwnPropertySymbols,
            XS = Object.prototype.hasOwnProperty,
            tT = Object.prototype.propertyIsEnumerable,
            eT = (t, e, n) => e in t ? YS(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n,
            nT = (t, e) => {
                for (var n in e || (e = {})) XS.call(e, n) && eT(t, n, e[n]);
                if (QS)
                    for (var n of QS(e)) tT.call(e, n) && eT(t, n, e[n]);
                return t
            };
        const oT = /^(left|center|right)$/,
            iT = /^(left|none|right)$/;
        class rT extends Vi {
            static get pluginName() {
                return "TablePropertiesEditing"
            }
            static get requires() {
                return [fD]
            }
            init() {
                const t = this.editor,
                    e = t.model.schema,
                    n = t.conversion;
                t.config.define("table.tableProperties.defaultProperties", {});
                const o = ES(t.config.get("table.tableProperties.defaultProperties"), {
                    includeAlignmentProperty: !0
                });
                t.data.addStyleProcessorRules(Mu),
                    function(t, e, n) {
                        const o = {
                            width: "tableBorderWidth",
                            color: "tableBorderColor",
                            style: "tableBorderStyle"
                        };
                        t.extend("table", {
                            allowAttributes: Object.values(o)
                        }), oE(e, "table", o, n), rE(e, {
                            modelAttribute: o.color,
                            styleName: "border-color"
                        }), rE(e, {
                            modelAttribute: o.style,
                            styleName: "border-style"
                        }), rE(e, {
                            modelAttribute: o.width,
                            styleName: "border-width"
                        })
                    }(e, n, {
                        color: o.borderColor,
                        style: o.borderStyle,
                        width: o.borderWidth
                    }), t.commands.add("tableBorderColor", new US(t, o.borderColor)), t.commands.add("tableBorderStyle", new $S(t, o.borderStyle)), t.commands.add("tableBorderWidth", new GS(t, o.borderWidth)),
                    function(t, e, n) {
                        t.extend("table", {
                            allowAttributes: ["tableAlignment"]
                        }), e.for("downcast").attributeToAttribute({
                            model: {
                                name: "table",
                                key: "tableAlignment"
                            },
                            view: t => ({
                                key: "style",
                                value: {
                                    float: "center" === t ? "none" : t
                                }
                            }),
                            converterPriority: "high"
                        }), e.for("upcast").attributeToAttribute({
                            view: {
                                name: /^(table|figure)$/,
                                styles: {
                                    float: iT
                                }
                            },
                            model: {
                                key: "tableAlignment",
                                value: t => {
                                    let e = t.getStyle("float");
                                    return "none" === e && (e = "center"), e === n ? null : e
                                }
                            }
                        }).attributeToAttribute({
                            view: {
                                attributes: {
                                    align: oT
                                }
                            },
                            model: {
                                name: "table",
                                key: "tableAlignment",
                                value: t => {
                                    const e = t.getAttribute("align");
                                    return e === n ? null : e
                                }
                            }
                        })
                    }(e, n, o.alignment), t.commands.add("tableAlignment", new JS(t, o.alignment)), sT(e, n, {
                        modelAttribute: "tableWidth",
                        styleName: "width",
                        defaultValue: o.width
                    }), t.commands.add("tableWidth", new KS(t, o.width)), sT(e, n, {
                        modelAttribute: "tableHeight",
                        styleName: "height",
                        defaultValue: o.height
                    }), t.commands.add("tableHeight", new ZS(t, o.height)), t.data.addStyleProcessorRules(Fu),
                    function(t, e, n) {
                        const {
                            modelAttribute: o
                        } = n;
                        t.extend("table", {
                            allowAttributes: [o]
                        }), nE(e, nT({
                            viewElement: "table"
                        }, n)), rE(e, n)
                    }(e, n, {
                        modelAttribute: "tableBackgroundColor",
                        styleName: "background-color",
                        defaultValue: o.backgroundColor
                    }), t.commands.add("tableBackgroundColor", new WS(t, o.backgroundColor))
            }
        }

        function sT(t, e, n) {
            const {
                modelAttribute: o
            } = n;
            t.extend("table", {
                allowAttributes: [o]
            }), nE(e, nT({
                viewElement: /^(table|figure)$/,
                shouldUpcast: t => !("table" == t.name && "figure" == t.parent.name)
            }, n)), iE(e, nT({
                modelElement: "table"
            }, n))
        }
        var aT = n(7341),
            lT = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(aT.Z, lT);
        aT.Z.locals;
        const cT = {
            left: eg.objectLeft,
            center: eg.objectCenter,
            right: eg.objectRight
        };
        class dT extends cg {
            constructor(t, e) {
                super(t), this.set({
                    borderStyle: "",
                    borderWidth: "",
                    borderColor: "",
                    backgroundColor: "",
                    width: "",
                    height: "",
                    alignment: ""
                }), this.options = e;
                const {
                    borderStyleDropdown: n,
                    borderWidthInput: o,
                    borderColorInput: i,
                    borderRowLabel: r
                } = this._createBorderFields(), {
                    backgroundRowLabel: s,
                    backgroundInput: a
                } = this._createBackgroundFields(), {
                    widthInput: l,
                    operatorLabel: c,
                    heightInput: d,
                    dimensionsLabel: h
                } = this._createDimensionFields(), {
                    alignmentToolbar: u,
                    alignmentLabel: g
                } = this._createAlignmentFields();
                this.focusTracker = new Di, this.keystrokes = new Si, this.children = this.createCollection(), this.borderStyleDropdown = n, this.borderWidthInput = o, this.borderColorInput = i, this.backgroundInput = a, this.widthInput = l, this.heightInput = d, this.alignmentToolbar = u;
                const {
                    saveButtonView: m,
                    cancelButtonView: p
                } = this._createActionButtons();
                this.saveButtonView = m, this.cancelButtonView = p, this._focusables = new sg, this._focusCycler = new wm({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "shift + tab",
                        focusNext: "tab"
                    }
                }), this.children.add(new Rf(t, {
                    label: this.t("Table properties")
                })), this.children.add(new oS(t, {
                    labelView: r,
                    children: [r, n, i, o],
                    class: "ck-table-form__border-row"
                })), this.children.add(new oS(t, {
                    labelView: s,
                    children: [s, a],
                    class: "ck-table-form__background-row"
                })), this.children.add(new oS(t, {
                    children: [new oS(t, {
                        labelView: h,
                        children: [h, l, c, d],
                        class: "ck-table-form__dimensions-row"
                    }), new oS(t, {
                        labelView: g,
                        children: [g, u],
                        class: "ck-table-properties-form__alignment-row"
                    })]
                })), this.children.add(new oS(t, {
                    children: [this.saveButtonView, this.cancelButtonView],
                    class: "ck-table-form__action-row"
                })), this.setTemplate({
                    tag: "form",
                    attributes: {
                        class: ["ck", "ck-form", "ck-table-form", "ck-table-properties-form"],
                        tabindex: "-1"
                    },
                    children: this.children
                })
            }
            render() {
                super.render(), ig({
                    view: this
                }), [this.borderStyleDropdown, this.borderColorInput, this.borderColorInput.fieldView.dropdownView.buttonView, this.borderWidthInput, this.backgroundInput, this.backgroundInput.fieldView.dropdownView.buttonView, this.widthInput, this.heightInput, this.alignmentToolbar, this.saveButtonView, this.cancelButtonView].forEach((t => {
                    this._focusables.add(t), this.focusTracker.add(t.element)
                })), this.keystrokes.listenTo(this.element)
            }
            destroy() {
                super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            _createBorderFields() {
                const t = this.options.defaultTableProperties,
                    e = {
                        style: t.borderStyle,
                        width: t.borderWidth,
                        color: t.borderColor
                    },
                    n = XD({
                        colorConfig: this.options.borderColors,
                        columns: 5,
                        defaultColorValue: e.color
                    }),
                    o = this.locale,
                    i = this.t,
                    r = i("Style"),
                    s = new om(o);
                s.text = i("Border");
                const a = WD(i),
                    l = new sm(o, Qm);
                l.set({
                    label: r,
                    class: "ck-table-form__border-style"
                }), l.fieldView.buttonView.set({
                    ariaLabel: r,
                    ariaLabelledBy: void 0,
                    isOn: !1,
                    withText: !0,
                    tooltip: r
                }), l.fieldView.buttonView.bind("label").to(this, "borderStyle", (t => a[t || "none"])), l.fieldView.on("execute", (t => {
                    this.borderStyle = t.source._borderStyleValue
                })), l.bind("isEmpty").to(this, "borderStyle", (t => !t)), Gm(l.fieldView, JD(this, e.style), {
                    role: "menu",
                    ariaLabel: r
                });
                const c = new sm(o, Jm);
                c.set({
                    label: i("Width"),
                    class: "ck-table-form__border-width"
                }), c.fieldView.bind("value").to(this, "borderWidth"), c.bind("isEnabled").to(this, "borderStyle", hT), c.fieldView.on("input", (() => {
                    this.borderWidth = c.fieldView.element.value
                }));
                const d = new sm(o, n);
                return d.set({
                    label: i("Color"),
                    class: "ck-table-form__border-color"
                }), d.fieldView.bind("value").to(this, "borderColor"), d.bind("isEnabled").to(this, "borderStyle", hT), d.fieldView.on("input", (() => {
                    this.borderColor = d.fieldView.value
                })), this.on("change:borderStyle", ((t, n, o, i) => {
                    hT(o) || (this.borderColor = "", this.borderWidth = ""), hT(i) || (this.borderColor = e.color, this.borderWidth = e.width)
                })), {
                    borderRowLabel: s,
                    borderStyleDropdown: l,
                    borderColorInput: d,
                    borderWidthInput: c
                }
            }
            _createBackgroundFields() {
                const t = this.locale,
                    e = this.t,
                    n = new om(t);
                n.text = e("Background");
                const o = XD({
                        colorConfig: this.options.backgroundColors,
                        columns: 5,
                        defaultColorValue: this.options.defaultTableProperties.backgroundColor
                    }),
                    i = new sm(t, o);
                return i.set({
                    label: e("Color"),
                    class: "ck-table-properties-form__background"
                }), i.fieldView.bind("value").to(this, "backgroundColor"), i.fieldView.on("input", (() => {
                    this.backgroundColor = i.fieldView.value
                })), {
                    backgroundRowLabel: n,
                    backgroundInput: i
                }
            }
            _createDimensionFields() {
                const t = this.locale,
                    e = this.t,
                    n = new om(t);
                n.text = e("Dimensions");
                const o = new sm(t, Jm);
                o.set({
                    label: e("Width"),
                    class: "ck-table-form__dimensions-row__width"
                }), o.fieldView.bind("value").to(this, "width"), o.fieldView.on("input", (() => {
                    this.width = o.fieldView.element.value
                }));
                const i = new cg(t);
                i.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck-table-form__dimension-operator"]
                    },
                    children: [{
                        text: "×"
                    }]
                });
                const r = new sm(t, Jm);
                return r.set({
                    label: e("Height"),
                    class: "ck-table-form__dimensions-row__height"
                }), r.fieldView.bind("value").to(this, "height"), r.fieldView.on("input", (() => {
                    this.height = r.fieldView.element.value
                })), {
                    dimensionsLabel: n,
                    widthInput: o,
                    operatorLabel: i,
                    heightInput: r
                }
            }
            _createAlignmentFields() {
                const t = this.locale,
                    e = this.t,
                    n = new om(t);
                n.text = e("Alignment");
                const o = new Sm(t);
                return o.set({
                    isCompact: !0,
                    ariaLabel: e("Table alignment toolbar")
                }), YD({
                    view: this,
                    icons: cT,
                    toolbar: o,
                    labels: this._alignmentLabels,
                    propertyName: "alignment",
                    defaultValue: this.options.defaultTableProperties.alignment
                }), {
                    alignmentLabel: n,
                    alignmentToolbar: o
                }
            }
            _createActionButtons() {
                const t = this.locale,
                    e = this.t,
                    n = new Mg(t),
                    o = new Mg(t),
                    i = [this.borderWidthInput, this.borderColorInput, this.backgroundInput, this.widthInput, this.heightInput];
                return n.set({
                    label: e("Save"),
                    icon: eg.check,
                    class: "ck-button-save",
                    type: "submit",
                    withText: !0
                }), n.bind("isEnabled").toMany(i, "errorText", ((...t) => t.every((t => !t)))), o.set({
                    label: e("Cancel"),
                    icon: eg.cancel,
                    class: "ck-button-cancel",
                    withText: !0
                }), o.delegate("execute").to(this, "cancel"), {
                    saveButtonView: n,
                    cancelButtonView: o
                }
            }
            get _alignmentLabels() {
                const t = this.locale,
                    e = this.t,
                    n = e("Align table to the left"),
                    o = e("Center table"),
                    i = e("Align table to the right");
                return "rtl" === t.uiLanguageDirection ? {
                    right: i,
                    center: o,
                    left: n
                } : {
                    left: n,
                    center: o,
                    right: i
                }
            }
        }

        function hT(t) {
            return "none" !== t
        }
        const uT = {
            borderStyle: "tableBorderStyle",
            borderColor: "tableBorderColor",
            borderWidth: "tableBorderWidth",
            backgroundColor: "tableBackgroundColor",
            width: "tableWidth",
            height: "tableHeight",
            alignment: "tableAlignment"
        };
        class gT extends Vi {
            constructor(t) {
                super(t), this.view = null, t.config.define("table.tableProperties", {
                    borderColors: QD,
                    backgroundColors: QD
                })
            }
            static get requires() {
                return [jf]
            }
            static get pluginName() {
                return "TablePropertiesUI"
            }
            init() {
                const t = this.editor,
                    e = t.t;
                this._defaultTableProperties = ES(t.config.get("table.tableProperties.defaultProperties"), {
                    includeAlignmentProperty: !0
                }), this._balloon = t.plugins.get(jf), t.ui.componentFactory.add("tableProperties", (n => {
                    const o = new Mg(n);
                    o.set({
                        label: e("Table properties"),
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v5h4V2h1v5h5v1h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5H7v-5H2v-1h5V8H2V7h5V2h1zm4 6H8v4h4V8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM17 1a2 2 0 0 1 2 2v9.475l-.85-.124-.857-1.736a2.048 2.048 0 0 0-.292-.44L17 3H3v14h7.808l.402.392L10.935 19H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14z"/></svg>',
                        tooltip: !0
                    }), this.listenTo(o, "execute", (() => this._showView()));
                    const i = Object.values(uT).map((e => t.commands.get(e)));
                    return o.bind("isEnabled").toMany(i, "isEnabled", ((...t) => t.some((t => t)))), o
                }))
            }
            destroy() {
                super.destroy(), this.view && this.view.destroy()
            }
            _createPropertiesView() {
                const t = this.editor,
                    e = t.config.get("table.tableProperties"),
                    n = qg(e.borderColors),
                    o = jg(t.locale, n),
                    i = qg(e.backgroundColors),
                    r = jg(t.locale, i),
                    s = new dT(t.locale, {
                        borderColors: o,
                        backgroundColors: r,
                        defaultTableProperties: this._defaultTableProperties
                    }),
                    a = t.t;
                s.render(), this.listenTo(s, "submit", (() => {
                    this._hideView()
                })), this.listenTo(s, "cancel", (() => {
                    this._undoStepBatch.operations.length && t.execute("undo", this._undoStepBatch), this._hideView()
                })), s.keystrokes.set("Esc", ((t, e) => {
                    this._hideView(), e()
                })), ng({
                    emitter: s,
                    activator: () => this._isViewInBalloon,
                    contextElements: [this._balloon.view.element],
                    callback: () => this._hideView()
                });
                const l = UD(a),
                    c = $D(a);
                return s.on("change:borderStyle", this._getPropertyChangeCallback("tableBorderStyle")), s.on("change:borderColor", this._getValidatedPropertyChangeCallback({
                    viewField: s.borderColorInput,
                    commandName: "tableBorderColor",
                    errorText: l,
                    validator: GD
                })), s.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
                    viewField: s.borderWidthInput,
                    commandName: "tableBorderWidth",
                    errorText: c,
                    validator: ZD
                })), s.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
                    viewField: s.backgroundInput,
                    commandName: "tableBackgroundColor",
                    errorText: l,
                    validator: GD
                })), s.on("change:width", this._getValidatedPropertyChangeCallback({
                    viewField: s.widthInput,
                    commandName: "tableWidth",
                    errorText: c,
                    validator: KD
                })), s.on("change:height", this._getValidatedPropertyChangeCallback({
                    viewField: s.heightInput,
                    commandName: "tableHeight",
                    errorText: c,
                    validator: KD
                })), s.on("change:alignment", this._getPropertyChangeCallback("tableAlignment")), s
            }
            _fillViewFormFromCommandValues() {
                const t = this.editor.commands,
                    e = t.get("tableBorderStyle");
                Object.entries(uT).map((([e, n]) => {
                    const o = e,
                        i = this._defaultTableProperties[o] || "";
                    return [o, t.get(n).value || i]
                })).forEach((([t, n]) => {
                    ("borderColor" !== t && "borderWidth" !== t || "none" !== e.value) && this.view.set(t, n)
                })), this._isReady = !0
            }
            _showView() {
                const t = this.editor;
                this.view || (this.view = this._createPropertiesView()), this.listenTo(t.ui, "update", (() => {
                    this._updateView()
                })), this._fillViewFormFromCommandValues(), this._balloon.add({
                    view: this.view,
                    position: fS(t)
                }), this._undoStepBatch = t.model.createBatch(), this.view.focus()
            }
            _hideView() {
                const t = this.editor;
                this.stopListening(t.ui, "update"), this._isReady = !1, this.view.saveButtonView.focus(), this._balloon.remove(this.view), this.editor.editing.view.focus()
            }
            _updateView() {
                const t = this.editor;
                FD(t.editing.view.document.selection) ? this._isViewVisible && pS(t, "table") : this._hideView()
            }
            get _isViewVisible() {
                return !!this.view && this._balloon.visibleView === this.view
            }
            get _isViewInBalloon() {
                return !!this.view && this._balloon.hasView(this.view)
            }
            _getPropertyChangeCallback(t) {
                return (e, n, o) => {
                    this._isReady && this.editor.execute(t, {
                        value: o,
                        batch: this._undoStepBatch
                    })
                }
            }
            _getValidatedPropertyChangeCallback(t) {
                const {
                    commandName: e,
                    viewField: n,
                    validator: o,
                    errorText: i
                } = t, r = Fa((() => {
                    n.errorText = i
                }), 500);
                return (t, i, s) => {
                    r.cancel(), this._isReady && (o(s) ? (this.editor.execute(e, {
                        value: s,
                        batch: this._undoStepBatch
                    }), n.errorText = null) : r())
                }
            }
        }

        function mT(t) {
            t.document.registerPostFixer((e => function(t, e) {
                const n = e.document.differ.getChanges();
                let o = !1;
                for (const e of n) {
                    if ("insert" != e.type) continue;
                    const n = e.position.parent;
                    if (n.is("element", "table") || "table" == e.name) {
                        const i = "table" == e.name ? e.position.nodeAfter : n,
                            r = Array.from(i.getChildren()).filter((t => t.is("element", "caption"))),
                            s = r.shift();
                        if (!s) continue;
                        for (const e of r) t.move(t.createRangeIn(e), s, "end"), t.remove(e);
                        s.nextSibling && (t.move(t.createRangeOn(s), i, "end"), o = !0), o = !!r.length || o
                    }
                }
                return o
            }(e, t)))
        }

        function pT(t) {
            return !!t && t.is("element", "table")
        }

        function fT(t) {
            for (const e of t.getChildren())
                if (e.is("element", "caption")) return e;
            return null
        }

        function bT(t) {
            const e = t.parent;
            return "figcaption" == t.name && e && e.is("element", "figure") && e.hasClass("table") || "caption" == t.name && e && e.is("element", "table") ? {
                name: !0
            } : null
        }

        function kT(t) {
            const e = t.getSelectedElement();
            return e && e.is("element", "table") ? e : t.getFirstPosition().findAncestor("table")
        }
        class wT extends Fi {
            refresh() {
                const t = kT(this.editor.model.document.selection);
                this.isEnabled = !!t, this.isEnabled ? this.value = !!fT(t) : this.value = !1
            }
            execute({
                focusCaptionOnShow: t = !1
            } = {}) {
                this.editor.model.change((e => {
                    this.value ? this._hideTableCaption(e) : this._showTableCaption(e, t)
                }))
            }
            _showTableCaption(t, e) {
                const n = this.editor.model,
                    o = kT(n.document.selection),
                    i = this.editor.plugins.get("TableCaptionEditing")._getSavedCaption(o) || t.createElement("caption");
                n.insertContent(i, o, "end"), e && t.setSelection(i, "in")
            }
            _hideTableCaption(t) {
                const e = this.editor.model,
                    n = kT(e.document.selection),
                    o = this.editor.plugins.get("TableCaptionEditing"),
                    i = fT(n);
                o._saveCaption(n, i), e.deleteContent(t.createSelection(i, "on"))
            }
        }
        class AT extends Vi {
            constructor(t) {
                super(t), this._savedCaptionsMap = new WeakMap
            }
            static get pluginName() {
                return "TableCaptionEditing"
            }
            init() {
                const t = this.editor,
                    e = t.model.schema,
                    n = t.editing.view,
                    o = t.t;
                e.isRegistered("caption") ? e.extend("caption", {
                    allowIn: "table"
                }) : e.register("caption", {
                    allowIn: "table",
                    allowContentOf: "$block",
                    isLimit: !0
                }), t.commands.add("toggleTableCaption", new wT(this.editor)), t.conversion.for("upcast").elementToElement({
                    view: bT,
                    model: "caption"
                }), t.conversion.for("dataDowncast").elementToElement({
                    model: "caption",
                    view: (t, {
                        writer: e
                    }) => pT(t.parent) ? e.createContainerElement("figcaption") : null
                }), t.conversion.for("editingDowncast").elementToElement({
                    model: "caption",
                    view: (t, {
                        writer: e
                    }) => {
                        if (!pT(t.parent)) return null;
                        const i = e.createEditableElement("figcaption");
                        return e.setCustomProperty("tableCaption", !0, i), Zi({
                            view: n,
                            element: i,
                            text: o("Enter table caption"),
                            keepOnFocus: !0
                        }), Yw(i, e)
                    }
                }), mT(t.model)
            }
            _getSavedCaption(t) {
                const e = this._savedCaptionsMap.get(t);
                return e ? vl.fromJSON(e) : null
            }
            _saveCaption(t, e) {
                this._savedCaptionsMap.set(t, e.toJSON())
            }
        }
        class CT extends Vi {
            static get pluginName() {
                return "TableCaptionUI"
            }
            init() {
                const t = this.editor,
                    e = t.editing.view,
                    n = t.t;
                t.ui.componentFactory.add("toggleTableCaption", (o => {
                    const i = t.commands.get("toggleTableCaption"),
                        r = new Mg(o);
                    return r.set({
                        icon: eg.caption,
                        tooltip: !0,
                        isToggleable: !0
                    }), r.bind("isOn", "isEnabled").to(i, "value", "isEnabled"), r.bind("label").to(i, "value", (t => n(t ? "Toggle caption off" : "Toggle caption on"))), this.listenTo(r, "execute", (() => {
                        if (t.execute("toggleTableCaption", {
                                focusCaptionOnShow: !0
                            }), i.value) {
                            const n = function(t) {
                                    const e = kT(t);
                                    return e ? fT(e) : null
                                }(t.model.document.selection),
                                o = t.editing.mapper.toViewElement(n);
                            if (!o) return;
                            e.scrollToTheSelection(), e.change((t => {
                                t.addClass("table__caption_highlighted", o)
                            }))
                        }
                        t.editing.view.focus()
                    })), r
                }))
            }
        }
        var _T = n(2128),
            vT = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(_T.Z, vT);
        _T.Z.locals;
        const yT = 5,
            xT = 40,
            ET = 2;

        function DT(t, e) {
            return 100 * xT / ST(t, e)
        }

        function ST(t, e) {
            const n = TT(t, "tbody", e) || TT(t, "thead", e);
            return BT(e.editing.view.domConverter.mapViewToDom(n))
        }

        function TT(t, e, n) {
            return [...[...n.editing.mapper.toViewElement(t).getChildren()].find((t => t.is("element", "table"))).getChildren()].find((t => t.is("element", e)))
        }

        function BT(t) {
            const e = Po.window.getComputedStyle(t);
            return "border-box" === e.boxSizing ? parseFloat(e.width) - parseFloat(e.paddingLeft) - parseFloat(e.paddingRight) - parseFloat(e.borderLeftWidth) - parseFloat(e.borderRightWidth) : parseFloat(e.width)
        }

        function IT(t) {
            const e = Math.pow(10, ET),
                n = "number" == typeof t ? t : parseFloat(t);
            return Math.round(n * e) / e
        }

        function PT(t) {
            return t.map((t => "number" == typeof t ? t : parseFloat(t))).filter((t => !Number.isNaN(t))).reduce(((t, e) => t + e), 0)
        }

        function RT(t) {
            let e = function(t) {
                const e = t.filter((t => "auto" === t)).length;
                if (0 === e) return t.map((t => IT(t)));
                const n = PT(t),
                    o = Math.max((100 - n) / e, yT);
                return t.map((t => "auto" === t ? o : t)).map((t => IT(t)))
            }(t.map((t => "auto" === t ? t : parseFloat(t.replace("%", "")))));
            const n = PT(e);
            return 100 !== n && (e = e.map((t => IT(100 * t / n))).map(((t, e, n) => {
                if (!(e === n.length - 1)) return t;
                return IT(t + 100 - PT(n))
            }))), e.map((t => t + "%"))
        }

        function zT(t) {
            const e = Po.window.getComputedStyle(t);
            return "border-box" === e.boxSizing ? parseInt(e.width) : parseFloat(e.width) + parseFloat(e.paddingLeft) + parseFloat(e.paddingRight) + parseFloat(e.borderWidth)
        }

        function VT(t, e, n, o) {
            for (let i = 0; i < Math.max(n.length, t.length); i++) {
                const r = t[i],
                    s = n[i];
                s ? r ? o.setAttribute("columnWidth", s, r) : o.appendElement("tableColumn", {
                    columnWidth: s
                }, e) : o.remove(r)
            }
        }

        function OT(t) {
            if (t.is("element", "tableColumnGroup")) return t;
            const e = t.getChildren();
            return Array.from(e).find((t => t.is("element", "tableColumnGroup")))
        }

        function FT(t) {
            return Array.from(OT(t).getChildren())
        }

        function MT(t) {
            return FT(t).map((t => t.getAttribute("columnWidth")))
        }
        class NT extends Fi {
            refresh() {
                this.isEnabled = !0
            }
            execute(t = {}) {
                const {
                    model: e,
                    plugins: n
                } = this.editor;
                let {
                    table: o = e.document.selection.getSelectedElement(),
                    columnWidths: i,
                    tableWidth: r
                } = t;
                i && (i = Array.isArray(i) ? i : i.split(",")), e.change((t => {
                    r ? t.setAttribute("tableWidth", r, o) : t.removeAttribute("tableWidth", o);
                    const e = n.get("TableColumnResizeEditing").getColumnGroupElement(o);
                    if (!i && !e) return;
                    if (!i) return t.remove(e);
                    const s = RT(i);
                    if (e) Array.from(e.getChildren()).forEach(((e, n) => t.setAttribute("columnWidth", s[n], e)));
                    else {
                        const e = t.createElement("tableColumnGroup");
                        s.forEach((n => t.appendElement("tableColumn", {
                            columnWidth: n
                        }, e))), t.append(e, o)
                    }
                }))
            }
        }
        class LT extends Vi {
            constructor(t) {
                super(t), this._isResizingActive = !1, this.set("_isResizingAllowed", !0), this._resizingData = null, this._domEmitter = new(So()), this._tableUtilsPlugin = t.plugins.get("TableUtils"), this.on("change:_isResizingAllowed", ((e, n, o) => {
                    const i = o ? "removeClass" : "addClass";
                    t.editing.view.change((e => {
                        for (const n of t.editing.view.document.roots) e[i]("ck-column-resize_disabled", t.editing.view.document.getRoot(n.rootName))
                    }))
                }))
            }
            static get requires() {
                return [fD, GE]
            }
            static get pluginName() {
                return "TableColumnResizeEditing"
            }
            init() {
                this._extendSchema(), this._registerPostFixer(), this._registerConverters(), this._registerResizingListeners(), this._registerResizerInserter();
                const t = this.editor,
                    e = t.plugins.get("TableColumnResize");
                t.plugins.get("TableEditing").registerAdditionalSlot({
                    filter: t => t.is("element", "tableColumnGroup"),
                    positionOffset: 0
                });
                const n = new NT(t);
                t.commands.add("resizeTableWidth", n), t.commands.add("resizeColumnWidths", n), this.bind("_isResizingAllowed").to(t, "isReadOnly", e, "isEnabled", n, "isEnabled", ((t, e, n) => !t && e && n))
            }
            destroy() {
                this._domEmitter.stopListening(), super.destroy()
            }
            getColumnGroupElement(t) {
                return OT(t)
            }
            getTableColumnElements(t) {
                return FT(t)
            }
            getTableColumnsWidths(t) {
                return MT(t)
            }
            _extendSchema() {
                this.editor.model.schema.extend("table", {
                    allowAttributes: ["tableWidth"]
                }), this.editor.model.schema.register("tableColumnGroup", {
                    allowIn: "table",
                    isLimit: !0
                }), this.editor.model.schema.register("tableColumn", {
                    allowIn: "tableColumnGroup",
                    allowAttributes: ["columnWidth"],
                    isLimit: !0
                })
            }
            _registerPostFixer() {
                const t = this.editor.model;

                function e(t, e, n) {
                    const o = n._tableUtilsPlugin.getColumns(e);
                    if (0 === o - t.length) return t;
                    const i = t.map((t => Number(t.replace("%", "")))),
                        r = function(t, e) {
                            const n = new Set;
                            for (const o of t.getChanges())
                                if ("insert" == o.type && o.position.nodeAfter && "tableCell" == o.position.nodeAfter.name && o.position.nodeAfter.getAncestors().includes(e)) n.add(o.position.nodeAfter);
                                else if ("remove" == o.type) {
                                const t = o.position.nodeBefore || o.position.nodeAfter;
                                "tableCell" == t.name && t.getAncestors().includes(e) && n.add(t)
                            }
                            return n
                        }(n.editor.model.document.differ, e);
                    for (const t of r) {
                        const r = o - i.length;
                        if (0 === r) continue;
                        const a = r > 0,
                            l = n._tableUtilsPlugin.getCellLocation(t).column;
                        if (a) {
                            const t = DT(e, n.editor),
                                o = (s = t, Array(r).fill(s));
                            i.splice(l, 0, ...o)
                        } else {
                            const t = i.splice(l, Math.abs(r));
                            i[l] += PT(t)
                        }
                    }
                    var s;
                    return i.map((t => t + "%"))
                }
                t.document.registerPostFixer((n => {
                    let o = !1;
                    for (const i of function(t) {
                            const e = new Set;
                            for (const n of t.document.differ.getChanges()) {
                                let o = null;
                                switch (n.type) {
                                    case "insert":
                                        o = ["table", "tableRow", "tableCell"].includes(n.name) ? n.position : null;
                                        break;
                                    case "remove":
                                        o = ["tableRow", "tableCell"].includes(n.name) ? n.position : null;
                                        break;
                                    case "attribute":
                                        n.range.start.nodeAfter && (o = ["table", "tableRow", "tableCell"].includes(n.range.start.nodeAfter.name) ? n.range.start : null)
                                }
                                if (!o) continue;
                                const i = o.nodeAfter && o.nodeAfter.is("element", "table") ? o.nodeAfter : o.findAncestor("table");
                                for (const n of t.createRangeOn(i).getItems()) n.is("element", "table") && OT(n) && e.add(n)
                            }
                            return e
                        }(t)) {
                        const t = this.getColumnGroupElement(i),
                            r = this.getTableColumnElements(t),
                            s = this.getTableColumnsWidths(t);
                        let a = RT(s);
                        a = e(a, i, this), Vd(s, a) || (VT(r, t, a, n), o = !0)
                    }
                    return o
                }))
            }
            _registerConverters() {
                const t = this.editor.conversion;
                var e;
                t.for("upcast").attributeToAttribute({
                    view: {
                        name: "figure",
                        key: "style",
                        value: {
                            width: /[\s\S]+/
                        }
                    },
                    model: {
                        name: "table",
                        key: "tableWidth",
                        value: t => t.getStyle("width")
                    }
                }), t.for("downcast").attributeToAttribute({
                    model: {
                        name: "table",
                        key: "tableWidth"
                    },
                    view: t => ({
                        name: "figure",
                        key: "style",
                        value: {
                            width: t
                        }
                    })
                }), t.elementToElement({
                    model: "tableColumnGroup",
                    view: "colgroup"
                }), t.elementToElement({
                    model: "tableColumn",
                    view: "col"
                }), t.for("downcast").add((t => t.on("insert:table", ((t, e, n) => {
                    const o = n.writer,
                        i = e.item,
                        r = n.mapper.toViewElement(i),
                        s = r.is("element", "table") ? r : Array.from(r.getChildren()).find((t => t.is("element", "table")));
                    OT(i) ? o.addClass("ck-table-resized", s) : o.removeClass("ck-table-resized", s)
                }), {
                    priority: "low"
                }))), t.for("upcast").add((e = this._tableUtilsPlugin, t => t.on("element:colgroup", ((t, n, o) => {
                    const i = n.modelCursor.findAncestor("table"),
                        r = OT(i);
                    if (!r) return;
                    const s = FT(r);
                    let a = MT(r);
                    const l = e.getColumns(i);
                    a = Array.from({
                        length: l
                    }, ((t, e) => a[e] || "auto")), (a.length != s.length || a.includes("auto")) && VT(s, r, RT(a), o.writer)
                }), {
                    priority: "low"
                }))), t.for("upcast").attributeToAttribute({
                    view: {
                        name: "col",
                        styles: {
                            width: /.*/
                        }
                    },
                    model: {
                        key: "columnWidth",
                        value: t => {
                            const e = t.getStyle("width");
                            return e && e.endsWith("%") ? e : "auto"
                        }
                    }
                }), t.for("downcast").attributeToAttribute({
                    model: {
                        name: "tableColumn",
                        key: "columnWidth"
                    },
                    view: t => ({
                        key: "style",
                        value: {
                            width: t
                        }
                    })
                })
            }
            _registerResizingListeners() {
                const t = this.editor.editing.view;
                t.addObserver(ID), t.document.on("mousedown", this._onMouseDownHandler.bind(this), {
                    priority: "high"
                }), this._domEmitter.listenTo(Po.window.document, "mousemove", of(this._onMouseMoveHandler.bind(this), 50)), this._domEmitter.listenTo(Po.window.document, "mouseup", this._onMouseUpHandler.bind(this))
            }
            _onMouseDownHandler(t, e) {
                const n = e.target;
                if (!n.hasClass("ck-table-column-resizer")) return;
                if (!this._isResizingAllowed) return;
                const o = this.editor,
                    i = o.editing.mapper.toModelElement(n.findAncestor("figure"));
                if (!o.model.canEditAt(i)) return;
                e.preventDefault(), t.stop();
                const r = function(t, e, n) {
                        const o = Array(e.getColumns(t)),
                            i = new AE(t);
                        for (const t of i) {
                            const e = n.editing.mapper.toViewElement(t.cell),
                                i = zT(n.editing.view.domConverter.mapViewToDom(e));
                            (!o[t.column] || i < o[t.column]) && (o[t.column] = IT(i))
                        }
                        return o
                    }(i, this._tableUtilsPlugin, o),
                    s = n.findAncestor("table"),
                    a = o.editing.view;
                Array.from(s.getChildren()).find((t => t.is("element", "colgroup"))) || a.change((t => {
                    ! function(t, e, n) {
                        const o = t.createContainerElement("colgroup");
                        for (let n = 0; n < e.length; n++) {
                            const i = t.createEmptyElement("col"),
                                r = `${IT(e[n]/PT(e)*100)}%`;
                            t.setStyle("width", r, i), t.insert(t.createPositionAt(o, "end"), i)
                        }
                        t.insert(t.createPositionAt(n, 0), o)
                    }(t, r, s)
                })), this._isResizingActive = !0, this._resizingData = this._getResizingData(e, r), a.change((t => function(t, e, n) {
                    const o = n.widths.viewFigureWidth / n.widths.viewFigureParentWidth;
                    t.addClass("ck-table-resized", e), t.addClass("ck-table-column-resizer__active", n.elements.viewResizer), t.setStyle("width", `${IT(100*o)}%`, e.findAncestor("figure"))
                }(t, s, this._resizingData)))
            }
            _onMouseMoveHandler(t, e) {
                if (!this._isResizingActive) return;
                if (!this._isResizingAllowed) return void this._onMouseUpHandler();
                const {
                    columnPosition: n,
                    flags: {
                        isRightEdge: o,
                        isTableCentered: i,
                        isLtrContent: r
                    },
                    elements: {
                        viewFigure: s,
                        viewLeftColumn: a,
                        viewRightColumn: l
                    },
                    widths: {
                        viewFigureParentWidth: c,
                        tableWidth: d,
                        leftColumnWidth: h,
                        rightColumnWidth: u
                    }
                } = this._resizingData, g = -h + xT, m = o ? c - d : u - xT, p = (r ? 1 : -1) * (o && i ? 2 : 1), f = (b = (e.clientX - n) * p, k = Math.min(g, 0), w = Math.max(m, 0), IT(b <= k ? k : b >= w ? w : b));
                var b, k, w;
                0 !== f && this.editor.editing.view.change((t => {
                    const e = IT(100 * (h + f) / d);
                    if (t.setStyle("width", `${e}%`, a), o) {
                        const e = IT(100 * (d + f) / c);
                        t.setStyle("width", `${e}%`, s)
                    } else {
                        const e = IT(100 * (u - f) / d);
                        t.setStyle("width", `${e}%`, l)
                    }
                }))
            }
            _onMouseUpHandler() {
                if (!this._isResizingActive) return;
                const {
                    viewResizer: t,
                    modelTable: e,
                    viewFigure: n,
                    viewColgroup: o
                } = this._resizingData.elements, i = this.editor, r = i.editing.view, s = this.getColumnGroupElement(e), a = Array.from(o.getChildren()).filter((t => t.is("view:element"))), l = s ? this.getTableColumnsWidths(s) : null, c = a.map((t => t.getStyle("width"))), d = !Vd(l, c), h = e.getAttribute("tableWidth"), u = n.getStyle("width"), g = h !== u;
                (d || g) && (this._isResizingAllowed ? i.execute("resizeTableWidth", {
                    table: e,
                    tableWidth: `${IT(u)}%`,
                    columnWidths: c
                }) : r.change((t => {
                    if (l)
                        for (const e of a) t.setStyle("width", l.shift(), e);
                    else t.remove(o);
                    g && (h ? t.setStyle("width", h, n) : t.removeStyle("width", n)), l || h || t.removeClass("ck-table-resized", [...n.getChildren()].find((t => "table" === t.name)))
                }))), r.change((e => {
                    e.removeClass("ck-table-column-resizer__active", t)
                })), this._isResizingActive = !1, this._resizingData = null
            }
            _getResizingData(t, e) {
                const n = this.editor,
                    o = t.domEvent.clientX,
                    i = t.target,
                    r = i.findAncestor("td") || i.findAncestor("th"),
                    s = n.editing.mapper.toModelElement(r),
                    a = s.findAncestor("table"),
                    l = function(t, e) {
                        const n = e.getCellLocation(t).column;
                        return {
                            leftEdge: n,
                            rightEdge: n + (t.getAttribute("colspan") || 1) - 1
                        }
                    }(s, this._tableUtilsPlugin).rightEdge,
                    c = l === this._tableUtilsPlugin.getColumns(a) - 1,
                    d = !a.hasAttribute("tableAlignment"),
                    h = "rtl" !== n.locale.contentLanguageDirection,
                    u = r.findAncestor("table"),
                    g = u.findAncestor("figure"),
                    m = [...u.getChildren()].find((t => t.is("element", "colgroup"))),
                    p = m.getChild(l),
                    f = c ? void 0 : m.getChild(l + 1);
                return {
                    columnPosition: o,
                    flags: {
                        isRightEdge: c,
                        isTableCentered: d,
                        isLtrContent: h
                    },
                    elements: {
                        viewResizer: i,
                        modelTable: a,
                        viewFigure: g,
                        viewColgroup: m,
                        viewLeftColumn: p,
                        viewRightColumn: f
                    },
                    widths: {
                        viewFigureParentWidth: BT(n.editing.view.domConverter.mapViewToDom(g.parent)),
                        viewFigureWidth: BT(n.editing.view.domConverter.mapViewToDom(g)),
                        tableWidth: ST(a, n),
                        leftColumnWidth: e[l],
                        rightColumnWidth: c ? void 0 : e[l + 1]
                    }
                }
            }
            _registerResizerInserter() {
                this.editor.conversion.for("editingDowncast").add((t => {
                    t.on("insert:tableCell", ((t, e, n) => {
                        const o = e.item,
                            i = n.mapper.toViewElement(o),
                            r = n.writer;
                        r.insert(r.createPositionAt(i, "end"), r.createUIElement("div", {
                            class: "ck-table-column-resizer"
                        }))
                    }), {
                        priority: "lowest"
                    })
                }))
            }
        }
        var HT = n(4101),
            jT = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(HT.Z, jT);
        HT.Z.locals;
        class qT extends Fi {
            constructor(t, e) {
                super(t), this.attributeKey = e
            }
            refresh() {
                const t = this.editor.model,
                    e = t.document;
                this.value = e.selection.getAttribute(this.attributeKey), this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey)
            }
            execute(t = {}) {
                const e = this.editor.model,
                    n = e.document.selection,
                    o = t.value,
                    i = t.batch,
                    r = t => {
                        if (n.isCollapsed) o ? t.setSelectionAttribute(this.attributeKey, o) : t.removeSelectionAttribute(this.attributeKey);
                        else {
                            const i = e.schema.getValidRanges(n.getRanges(), this.attributeKey);
                            for (const e of i) o ? t.setAttribute(this.attributeKey, o, e) : t.removeAttribute(this.attributeKey, e)
                        }
                    };
                i ? e.enqueueChange(i, (t => {
                    r(t)
                })) : e.change((t => {
                    r(t)
                }))
            }
        }
        class WT extends(q(xi)) {
            constructor(t) {
                super(t), this.set("isEmpty", !0), this.on("change", (() => {
                    this.set("isEmpty", 0 === this.length)
                }))
            }
            add(t, e) {
                return this.find((e => e.color === t.color)) ? this : super.add(t, e)
            }
            hasColor(t) {
                return !!this.find((e => e.color === t))
            }
        }
        var UT = n(1896),
            $T = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(UT.Z, $T);
        UT.Z.locals;
        class GT extends cg {
            constructor(t, {
                colors: e,
                columns: n,
                removeButtonLabel: o,
                documentColorsLabel: i,
                documentColorsCount: r,
                colorPickerLabel: s,
                colorPickerConfig: a
            }) {
                super(t), this.items = this.createCollection(), this.focusTracker = new Di, this.keystrokes = new Si, this._focusables = new sg, this._colorPickerConfig = a, this._focusCycler = new wm({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "shift + tab",
                        focusNext: "tab"
                    }
                }), this.colorGridsPageView = new KT(t, {
                    colors: e,
                    columns: n,
                    removeButtonLabel: o,
                    documentColorsLabel: i,
                    documentColorsCount: r,
                    colorPickerLabel: s,
                    focusTracker: this.focusTracker,
                    focusables: this._focusables
                }), this.colorPickerPageView = new ZT(t, {
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokes: this.keystrokes,
                    colorPickerConfig: a
                }), this.set("_isColorGridsPageVisible", !0), this.set("_isColorPickerPageVisible", !1), this.set("selectedColor", void 0), this.colorGridsPageView.bind("isVisible").to(this, "_isColorGridsPageVisible"), this.colorPickerPageView.bind("isVisible").to(this, "_isColorPickerPageVisible"), this.on("change:selectedColor", ((t, e, n) => {
                    this.colorGridsPageView.set("selectedColor", n), this.colorPickerPageView.set("selectedColor", n)
                })), this.colorGridsPageView.on("change:selectedColor", ((t, e, n) => {
                    this.set("selectedColor", n)
                })), this.colorPickerPageView.on("change:selectedColor", ((t, e, n) => {
                    this.set("selectedColor", n)
                })), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-color-table"]
                    },
                    children: this.items
                })
            }
            render() {
                super.render(), this.keystrokes.listenTo(this.element)
            }
            destroy() {
                super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
            }
            appendGrids() {
                this.items.length || (this.items.add(this.colorGridsPageView), this.colorGridsPageView.delegate("execute").to(this), this.colorGridsPageView.delegate("showColorPicker").to(this))
            }
            appendUI() {
                this.appendGrids(), this._colorPickerConfig && this._appendColorPicker()
            }
            showColorPicker() {
                this.colorPickerPageView.colorPickerView && (this.set("_isColorPickerPageVisible", !0), this.colorPickerPageView.focus(), this.set("_isColorGridsPageVisible", !1))
            }
            showColorGrids() {
                this.set("_isColorGridsPageVisible", !0), this.set("_isColorPickerPageVisible", !1)
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            focusLast() {
                this._focusCycler.focusLast()
            }
            updateDocumentColors(t, e) {
                this.colorGridsPageView.updateDocumentColors(t, e)
            }
            updateSelectedColors() {
                this.colorGridsPageView.updateSelectedColors()
            }
            _appendColorPicker() {
                2 !== this.items.length && (this.items.add(this.colorPickerPageView), this.colorGridsPageView.colorPickerButtonView && this.colorGridsPageView.colorPickerButtonView.on("execute", (() => {
                    this.showColorPicker()
                })), this.colorGridsPageView.addColorPickerButton(), this.colorPickerPageView.delegate("execute").to(this), this.colorPickerPageView.delegate("cancel").to(this))
            }
        }
        class KT extends cg {
            constructor(t, {
                colors: e,
                columns: n,
                removeButtonLabel: o,
                documentColorsLabel: i,
                documentColorsCount: r,
                colorPickerLabel: s,
                focusTracker: a,
                focusables: l
            }) {
                super(t);
                const c = this.bindTemplate;
                this.set("isVisible", !0), this.focusTracker = a, this.items = this.createCollection(), this.colorDefinitions = e, this.columns = n, this.documentColors = new WT, this.documentColorsCount = r, this._focusables = l, this._removeButtonLabel = o, this._colorPickerLabel = s, this._documentColorsLabel = i, this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck-color-grids-page-view", c.if("isVisible", "ck-hidden", (t => !t))]
                    },
                    children: this.items
                }), this.removeColorButtonView = this._createRemoveColorButton(), this.items.add(this.removeColorButtonView)
            }
            updateDocumentColors(t, e) {
                const n = t.document,
                    o = this.documentColorsCount;
                this.documentColors.clear();
                for (const i of n.getRootNames()) {
                    const r = n.getRoot(i),
                        s = t.createRangeIn(r);
                    for (const t of s.getItems())
                        if (t.is("$textProxy") && t.hasAttribute(e) && (this._addColorToDocumentColors(t.getAttribute(e)), this.documentColors.length >= o)) return
                }
            }
            updateSelectedColors() {
                const t = this.documentColorsGrid,
                    e = this.staticColorsGrid,
                    n = this.selectedColor;
                e.selectedColor = n, t && (t.selectedColor = n)
            }
            render() {
                if (super.render(), this.staticColorsGrid = this._createStaticColorsGrid(), this.items.add(this.staticColorsGrid), this.documentColorsCount) {
                    const t = dg.bind(this.documentColors, this.documentColors),
                        e = new om(this.locale);
                    e.text = this._documentColorsLabel, e.extendTemplate({
                        attributes: {
                            class: ["ck", "ck-color-grid__label", t.if("isEmpty", "ck-hidden")]
                        }
                    }), this.items.add(e), this.documentColorsGrid = this._createDocumentColorsGrid(), this.items.add(this.documentColorsGrid)
                }
                this._createColorPickerButton(), this._addColorTablesElementsToFocusTracker(), this.focus()
            }
            focus() {
                this.removeColorButtonView.focus()
            }
            destroy() {
                super.destroy()
            }
            addColorPickerButton() {
                this.colorPickerButtonView && (this.items.add(this.colorPickerButtonView), this.focusTracker.add(this.colorPickerButtonView.element), this._focusables.add(this.colorPickerButtonView))
            }
            _addColorTablesElementsToFocusTracker() {
                this.focusTracker.add(this.removeColorButtonView.element), this._focusables.add(this.removeColorButtonView), this.staticColorsGrid && (this.focusTracker.add(this.staticColorsGrid.element), this._focusables.add(this.staticColorsGrid)), this.documentColorsGrid && (this.focusTracker.add(this.documentColorsGrid.element), this._focusables.add(this.documentColorsGrid))
            }
            _createColorPickerButton() {
                this.colorPickerButtonView = new Mg, this.colorPickerButtonView.set({
                    label: this._colorPickerLabel,
                    withText: !0,
                    icon: eb,
                    class: "ck-color-table__color-picker"
                }), this.colorPickerButtonView.on("execute", (() => {
                    this.fire("showColorPicker")
                }))
            }
            _createRemoveColorButton() {
                const t = new Mg;
                return t.set({
                    withText: !0,
                    icon: eg.eraser,
                    label: this._removeButtonLabel
                }), t.class = "ck-color-table__remove-color", t.on("execute", (() => {
                    this.fire("execute", {
                        value: null,
                        source: "removeColorButton"
                    })
                })), t.render(), t
            }
            _createStaticColorsGrid() {
                const t = new Kg(this.locale, {
                    colorDefinitions: this.colorDefinitions,
                    columns: this.columns
                });
                return t.on("execute", ((t, e) => {
                    this.fire("execute", {
                        value: e.value,
                        source: "staticColorsGrid"
                    })
                })), t
            }
            _createDocumentColorsGrid() {
                const t = dg.bind(this.documentColors, this.documentColors),
                    e = new Kg(this.locale, {
                        columns: this.columns
                    });
                return e.extendTemplate({
                    attributes: {
                        class: t.if("isEmpty", "ck-hidden")
                    }
                }), e.items.bindTo(this.documentColors).using((t => {
                    const e = new Ug;
                    return e.set({
                        color: t.color,
                        hasBorder: t.options && t.options.hasBorder
                    }), t.label && e.set({
                        label: t.label,
                        tooltip: !0
                    }), e.on("execute", (() => {
                        this.fire("execute", {
                            value: t.color,
                            source: "documentColorsGrid"
                        })
                    })), e
                })), this.documentColors.on("change:isEmpty", ((t, n, o) => {
                    o && (e.selectedColor = null)
                })), e
            }
            _addColorToDocumentColors(t) {
                const e = this.colorDefinitions.find((e => e.color === t));
                e ? this.documentColors.add(Object.assign({}, e)) : this.documentColors.add({
                    color: t,
                    label: t,
                    options: {
                        hasBorder: !1
                    }
                })
            }
        }
        class ZT extends cg {
            constructor(t, {
                focusTracker: e,
                focusables: n,
                keystrokes: o,
                colorPickerConfig: i
            }) {
                super(t), this.items = this.createCollection(), this.focusTracker = e, this.keystrokes = o, this.set("isVisible", !1), this.set("selectedColor", void 0), this._focusables = n, this._pickerConfig = i;
                const r = this.bindTemplate,
                    {
                        saveButtonView: s,
                        cancelButtonView: a
                    } = this._createActionButtons();
                this.saveButtonView = s, this.cancelButtonView = a, this.actionBarView = this._createActionBarView({
                    saveButtonView: s,
                    cancelButtonView: a
                }), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck-color-picker-page-view", r.if("isVisible", "ck-hidden", (t => !t))]
                    },
                    children: this.items
                })
            }
            render() {
                super.render();
                const t = new Bp(this.locale, this._pickerConfig);
                this.colorPickerView = t, this.colorPickerView.render(), this.selectedColor && (t.color = this.selectedColor), this.listenTo(this, "change:selectedColor", ((e, n, o) => {
                    t.color = o
                })), this.items.add(this.colorPickerView), this.items.add(this.actionBarView), this._addColorPickersElementsToFocusTracker(), this._stopPropagationOnArrowsKeys(), this._executeOnEnterPress(), this._executeUponColorChange()
            }
            destroy() {
                super.destroy()
            }
            focus() {
                this.colorPickerView.focus()
            }
            _executeOnEnterPress() {
                this.keystrokes.set("enter", (t => {
                    this.isVisible && this.focusTracker.focusedElement !== this.cancelButtonView.element && (this.fire("execute", {
                        value: this.selectedColor
                    }), t.stopPropagation(), t.preventDefault())
                }))
            }
            _stopPropagationOnArrowsKeys() {
                const t = t => t.stopPropagation();
                this.keystrokes.set("arrowright", t), this.keystrokes.set("arrowleft", t), this.keystrokes.set("arrowup", t), this.keystrokes.set("arrowdown", t)
            }
            _addColorPickersElementsToFocusTracker() {
                for (const t of this.colorPickerView.slidersView) this.focusTracker.add(t.element), this._focusables.add(t);
                this.focusTracker.add(this.colorPickerView.hexInputRow.children.get(1).element), this._focusables.add(this.colorPickerView.hexInputRow.children.get(1)), this.focusTracker.add(this.saveButtonView.element), this._focusables.add(this.saveButtonView), this.focusTracker.add(this.cancelButtonView.element), this._focusables.add(this.cancelButtonView)
            }
            _createActionBarView({
                saveButtonView: t,
                cancelButtonView: e
            }) {
                const n = new cg,
                    o = this.createCollection();
                return o.add(t), o.add(e), n.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-color-table_action-bar"]
                    },
                    children: o
                }), n
            }
            _createActionButtons() {
                const t = this.locale,
                    e = t.t,
                    n = new Mg(t),
                    o = new Mg(t);
                return n.set({
                    icon: eg.check,
                    class: "ck-button-save",
                    withText: !1,
                    label: e("Accept"),
                    type: "button"
                }), o.set({
                    icon: eg.cancel,
                    class: "ck-button-cancel",
                    withText: !1,
                    label: e("Cancel")
                }), n.on("execute", (() => {
                    this.fire("execute", {
                        source: "saveButton",
                        value: this.selectedColor
                    })
                })), o.on("execute", (() => {
                    this.fire("cancel")
                })), {
                    saveButtonView: n,
                    cancelButtonView: o
                }
            }
            _executeUponColorChange() {
                this.colorPickerView.on("change:color", ((t, e, n) => {
                    this.fire("execute", {
                        value: n,
                        source: "colorPicker"
                    })
                }))
            }
        }
        const JT = "fontSize",
            YT = "fontFamily",
            QT = "fontColor",
            XT = "fontBackgroundColor";

        function tB(t, e) {
            const n = {
                model: {
                    key: t,
                    values: []
                },
                view: {},
                upcastAlso: {}
            };
            for (const t of e) n.model.values.push(t.model), n.view[t.model] = t.view, t.upcastAlso && (n.upcastAlso[t.model] = t.upcastAlso);
            return n
        }

        function eB(t) {
            return e => e.getStyle(t).replace(/\s/g, "")
        }

        function nB(t) {
            return (e, {
                writer: n
            }) => n.createAttributeElement("span", {
                style: `${t}:${e}`
            }, {
                priority: 7
            })
        }
        class oB extends qT {
            constructor(t) {
                super(t, YT)
            }
        }

        function iB(t) {
            return t.map(rB).filter((t => void 0 !== t))
        }

        function rB(t) {
            return "object" == typeof t ? t : "default" === t ? {
                title: "Default",
                model: void 0
            } : "string" == typeof t ? function(t) {
                const e = t.replace(/"|'/g, "").split(","),
                    n = e[0],
                    o = e.map(sB).join(", ");
                return {
                    title: n,
                    model: o,
                    view: {
                        name: "span",
                        styles: {
                            "font-family": o
                        },
                        priority: 7
                    }
                }
            }(t) : void 0
        }

        function sB(t) {
            return (t = t.trim()).indexOf(" ") > 0 && (t = `'${t}'`), t
        }
        class aB extends Vi {
            static get pluginName() {
                return "FontFamilyEditing"
            }
            constructor(t) {
                super(t), t.config.define(YT, {
                    options: ["default", "Arial, Helvetica, sans-serif", "Courier New, Courier, monospace", "Georgia, serif", "Lucida Sans Unicode, Lucida Grande, sans-serif", "Tahoma, Geneva, sans-serif", "Times New Roman, Times, serif", "Trebuchet MS, Helvetica, sans-serif", "Verdana, Geneva, sans-serif"],
                    supportAllValues: !1
                })
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: YT
                }), t.model.schema.setAttributeProperties(YT, {
                    isFormatting: !0,
                    copyOnEnter: !0
                });
                const e = iB(t.config.get("fontFamily.options")).filter((t => t.model)),
                    n = tB(YT, e);
                t.config.get("fontFamily.supportAllValues") ? (this._prepareAnyValueConverters(), this._prepareCompatibilityConverter()) : t.conversion.attributeToElement(n), t.commands.add(YT, new oB(t))
            }
            _prepareAnyValueConverters() {
                const t = this.editor;
                t.conversion.for("downcast").attributeToElement({
                    model: YT,
                    view: (t, {
                        writer: e
                    }) => e.createAttributeElement("span", {
                        style: "font-family:" + t
                    }, {
                        priority: 7
                    })
                }), t.conversion.for("upcast").elementToAttribute({
                    model: {
                        key: YT,
                        value: t => t.getStyle("font-family")
                    },
                    view: {
                        name: "span",
                        styles: {
                            "font-family": /.*/
                        }
                    }
                })
            }
            _prepareCompatibilityConverter() {
                this.editor.conversion.for("upcast").elementToAttribute({
                    view: {
                        name: "font",
                        attributes: {
                            face: /.*/
                        }
                    },
                    model: {
                        key: YT,
                        value: t => t.getAttribute("face")
                    }
                })
            }
        }
        class lB extends Vi {
            static get pluginName() {
                return "FontFamilyUI"
            }
            init() {
                const t = this.editor,
                    e = t.t,
                    n = this._getLocalizedOptions(),
                    o = t.commands.get(YT),
                    i = e("Font Family");
                t.ui.componentFactory.add(YT, (e => {
                    const r = Wm(e);
                    return Gm(r, (() => function(t, e) {
                        const n = new xi;
                        for (const o of t) {
                            const t = {
                                type: "button",
                                model: new Vf({
                                    commandName: YT,
                                    commandParam: o.model,
                                    label: o.title,
                                    role: "menuitemradio",
                                    withText: !0
                                })
                            };
                            t.model.bind("isOn").to(e, "value", (t => t === o.model || !(!t || !o.model) && t.split(",")[0].replace(/'/g, "").toLowerCase() === o.model.toLowerCase())), o.view && "string" != typeof o.view && o.view.styles && t.model.set("labelStyle", `font-family: ${o.view.styles["font-family"]}`), n.add(t)
                        }
                        return n
                    }(n, o)), {
                        role: "menu",
                        ariaLabel: i
                    }), r.buttonView.set({
                        label: i,
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.03 3h6.149a.75.75 0 1 1 0 1.5h-5.514L11.03 3zm1.27 3h4.879a.75.75 0 1 1 0 1.5h-4.244L12.3 6zm1.27 3h3.609a.75.75 0 1 1 0 1.5h-2.973L13.57 9zm-2.754 2.5L8.038 4.785 5.261 11.5h5.555zm.62 1.5H4.641l-1.666 4.028H1.312l5.789-14h1.875l5.789 14h-1.663L11.436 13z"/></svg>',
                        tooltip: !0
                    }), r.extendTemplate({
                        attributes: {
                            class: "ck-font-family-dropdown"
                        }
                    }), r.bind("isEnabled").to(o), this.listenTo(r, "execute", (e => {
                        t.execute(e.source.commandName, {
                            value: e.source.commandParam
                        }), t.editing.view.focus()
                    })), r
                }))
            }
            _getLocalizedOptions() {
                const t = this.editor,
                    e = t.t;
                return iB(t.config.get(YT).options).map((t => ("Default" === t.title && (t.title = e("Default")), t)))
            }
        }
        class cB extends Vi {
            static get requires() {
                return [aB, lB]
            }
            static get pluginName() {
                return "FontFamily"
            }
        }
        class dB extends qT {
            constructor(t) {
                super(t, JT)
            }
        }

        function hB(t) {
            return t.map((t => function(t) {
                "number" == typeof t && (t = String(t));
                if ("object" == typeof t && (e = t, e.title && e.model && e.view)) return gB(t);
                var e;
                const n = function(t) {
                    return "string" == typeof t ? uB[t] : uB[t.model]
                }(t);
                if (n) return gB(n);
                if ("default" === t) return {
                    model: void 0,
                    title: "Default"
                };
                if (function(t) {
                        let e;
                        if ("object" == typeof t) {
                            if (!t.model) throw new b("font-size-invalid-definition", null, t);
                            e = parseFloat(t.model)
                        } else e = parseFloat(t);
                        return isNaN(e)
                    }(t)) return;
                return function(t) {
                    "string" == typeof t && (t = {
                        title: t,
                        model: `${parseFloat(t)}px`
                    });
                    return t.view = {
                        name: "span",
                        styles: {
                            "font-size": t.model
                        }
                    }, gB(t)
                }(t)
            }(t))).filter((t => void 0 !== t))
        }
        const uB = {
            get tiny() {
                return {
                    title: "Tiny",
                    model: "tiny",
                    view: {
                        name: "span",
                        classes: "text-tiny",
                        priority: 7
                    }
                }
            },
            get small() {
                return {
                    title: "Small",
                    model: "small",
                    view: {
                        name: "span",
                        classes: "text-small",
                        priority: 7
                    }
                }
            },
            get big() {
                return {
                    title: "Big",
                    model: "big",
                    view: {
                        name: "span",
                        classes: "text-big",
                        priority: 7
                    }
                }
            },
            get huge() {
                return {
                    title: "Huge",
                    model: "huge",
                    view: {
                        name: "span",
                        classes: "text-huge",
                        priority: 7
                    }
                }
            }
        };

        function gB(t) {
            return t.view && "string" != typeof t.view && !t.view.priority && (t.view.priority = 7), t
        }
        const mB = ["x-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "xxx-large"];
        class pB extends Vi {
            static get pluginName() {
                return "FontSizeEditing"
            }
            constructor(t) {
                super(t), t.config.define(JT, {
                    options: ["tiny", "small", "default", "big", "huge"],
                    supportAllValues: !1
                })
            }
            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {
                    allowAttributes: JT
                }), t.model.schema.setAttributeProperties(JT, {
                    isFormatting: !0,
                    copyOnEnter: !0
                });
                const e = t.config.get("fontSize.supportAllValues"),
                    n = hB(this.editor.config.get("fontSize.options")).filter((t => t.model)),
                    o = tB(JT, n);
                e ? (this._prepareAnyValueConverters(o), this._prepareCompatibilityConverter()) : t.conversion.attributeToElement(o), t.commands.add(JT, new dB(t))
            }
            _prepareAnyValueConverters(t) {
                const e = this.editor,
                    n = t.model.values.filter((t => !Cu(String(t)) && !vu(String(t))));
                if (n.length) throw new b("font-size-invalid-use-of-named-presets", null, {
                    presets: n
                });
                e.conversion.for("downcast").attributeToElement({
                    model: JT,
                    view: (t, {
                        writer: e
                    }) => {
                        if (t) return e.createAttributeElement("span", {
                            style: "font-size:" + t
                        }, {
                            priority: 7
                        })
                    }
                }), e.conversion.for("upcast").elementToAttribute({
                    model: {
                        key: JT,
                        value: t => t.getStyle("font-size")
                    },
                    view: {
                        name: "span",
                        styles: {
                            "font-size": /.*/
                        }
                    }
                })
            }
            _prepareCompatibilityConverter() {
                this.editor.conversion.for("upcast").elementToAttribute({
                    view: {
                        name: "font",
                        attributes: {
                            size: /^[+-]?\d{1,3}$/
                        }
                    },
                    model: {
                        key: JT,
                        value: t => {
                            const e = t.getAttribute("size"),
                                n = "-" === e[0] || "+" === e[0];
                            let o = parseInt(e, 10);
                            n && (o = 3 + o);
                            const i = mB.length - 1,
                                r = Math.min(Math.max(o, 0), i);
                            return mB[r]
                        }
                    }
                })
            }
        }
        var fB = n(6007),
            bB = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(fB.Z, bB);
        fB.Z.locals;
        class kB extends Vi {
            static get pluginName() {
                return "FontSizeUI"
            }
            init() {
                const t = this.editor,
                    e = t.t,
                    n = this._getLocalizedOptions(),
                    o = t.commands.get(JT),
                    i = e("Font Size");
                t.ui.componentFactory.add(JT, (e => {
                    const r = Wm(e);
                    return Gm(r, (() => function(t, e) {
                        const n = new xi;
                        for (const o of t) {
                            const t = {
                                type: "button",
                                model: new Vf({
                                    commandName: JT,
                                    commandParam: o.model,
                                    label: o.title,
                                    class: "ck-fontsize-option",
                                    role: "menuitemradio",
                                    withText: !0
                                })
                            };
                            o.view && "string" != typeof o.view && (o.view.styles && t.model.set("labelStyle", `font-size:${o.view.styles["font-size"]}`), o.view.classes && t.model.set("class", `${t.model.class} ${o.view.classes}`)), t.model.bind("isOn").to(e, "value", (t => t === o.model)), n.add(t)
                        }
                        return n
                    }(n, o)), {
                        role: "menu",
                        ariaLabel: i
                    }), r.buttonView.set({
                        label: i,
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>',
                        tooltip: !0
                    }), r.extendTemplate({
                        attributes: {
                            class: ["ck-font-size-dropdown"]
                        }
                    }), r.bind("isEnabled").to(o), this.listenTo(r, "execute", (e => {
                        t.execute(e.source.commandName, {
                            value: e.source.commandParam
                        }), t.editing.view.focus()
                    })), r
                }))
            }
            _getLocalizedOptions() {
                const t = this.editor,
                    e = t.t,
                    n = {
                        Default: e("Default"),
                        Tiny: e("Tiny"),
                        Small: e("Small"),
                        Big: e("Big"),
                        Huge: e("Huge")
                    };
                return hB(t.config.get(JT).options).map((t => {
                    const e = n[t.title];
                    return e && e != t.title && (t = Object.assign({}, t, {
                        title: e
                    })), t
                }))
            }
        }
        class wB extends Vi {
            static get requires() {
                return [pB, kB]
            }
            static get pluginName() {
                return "FontSize"
            }
            normalizeSizeOptions(t) {
                return hB(t)
            }
        }
        class AB extends qT {
            constructor(t) {
                super(t, QT)
            }
        }
        class CB extends Vi {
            static get pluginName() {
                return "FontColorEditing"
            }
            constructor(t) {
                super(t), t.config.define(QT, {
                    colors: [{
                        color: "hsl(0, 0%, 0%)",
                        label: "Black"
                    }, {
                        color: "hsl(0, 0%, 30%)",
                        label: "Dim grey"
                    }, {
                        color: "hsl(0, 0%, 60%)",
                        label: "Grey"
                    }, {
                        color: "hsl(0, 0%, 90%)",
                        label: "Light grey"
                    }, {
                        color: "hsl(0, 0%, 100%)",
                        label: "White",
                        hasBorder: !0
                    }, {
                        color: "hsl(0, 75%, 60%)",
                        label: "Red"
                    }, {
                        color: "hsl(30, 75%, 60%)",
                        label: "Orange"
                    }, {
                        color: "hsl(60, 75%, 60%)",
                        label: "Yellow"
                    }, {
                        color: "hsl(90, 75%, 60%)",
                        label: "Light green"
                    }, {
                        color: "hsl(120, 75%, 60%)",
                        label: "Green"
                    }, {
                        color: "hsl(150, 75%, 60%)",
                        label: "Aquamarine"
                    }, {
                        color: "hsl(180, 75%, 60%)",
                        label: "Turquoise"
                    }, {
                        color: "hsl(210, 75%, 60%)",
                        label: "Light blue"
                    }, {
                        color: "hsl(240, 75%, 60%)",
                        label: "Blue"
                    }, {
                        color: "hsl(270, 75%, 60%)",
                        label: "Purple"
                    }],
                    columns: 5
                }), t.conversion.for("upcast").elementToAttribute({
                    view: {
                        name: "span",
                        styles: {
                            color: /[\s\S]+/
                        }
                    },
                    model: {
                        key: QT,
                        value: eB("color")
                    }
                }), t.conversion.for("upcast").elementToAttribute({
                    view: {
                        name: "font",
                        attributes: {
                            color: /^#?\w+$/
                        }
                    },
                    model: {
                        key: QT,
                        value: t => t.getAttribute("color")
                    }
                }), t.conversion.for("downcast").attributeToElement({
                    model: QT,
                    view: nB("color")
                }), t.commands.add(QT, new AB(t)), t.model.schema.extend("$text", {
                    allowAttributes: QT
                }), t.model.schema.setAttributeProperties(QT, {
                    isFormatting: !0,
                    copyOnEnter: !0
                })
            }
        }
        class _B extends Vi {
            constructor(t, {
                commandName: e,
                componentName: n,
                icon: o,
                dropdownLabel: i
            }) {
                super(t), this.commandName = e, this.componentName = n, this.icon = o, this.dropdownLabel = i, this.columns = t.config.get(`${this.componentName}.columns`), this.colorTableView = void 0
            }
            init() {
                const t = this.editor,
                    e = t.locale,
                    n = e.t,
                    o = t.commands.get(this.commandName),
                    i = t.config.get(this.componentName),
                    r = jg(e, qg(i.colors)),
                    s = i.documentColors,
                    a = !1 !== i.colorPicker;
                t.ui.componentFactory.add(this.componentName, (e => {
                    const l = Wm(e);
                    let c = !1;
                    return this.colorTableView = function({
                        dropdownView: t,
                        colors: e,
                        columns: n,
                        removeButtonLabel: o,
                        colorPickerLabel: i,
                        documentColorsLabel: r,
                        documentColorsCount: s,
                        colorPickerConfig: a
                    }) {
                        const l = t.locale,
                            c = new GT(l, {
                                colors: e,
                                columns: n,
                                removeButtonLabel: o,
                                colorPickerLabel: i,
                                documentColorsLabel: r,
                                documentColorsCount: s,
                                colorPickerConfig: a
                            });
                        return t.colorTableView = c, t.panelView.children.add(c), c
                    }({
                        dropdownView: l,
                        colors: r.map((t => ({
                            label: t.label,
                            color: t.model,
                            options: {
                                hasBorder: t.hasBorder
                            }
                        }))),
                        columns: this.columns,
                        removeButtonLabel: n("Remove color"),
                        colorPickerLabel: n("Color picker"),
                        documentColorsLabel: 0 !== s ? n("Document colors") : "",
                        documentColorsCount: void 0 === s ? this.columns : s,
                        colorPickerConfig: !!a && (i.colorPicker || {})
                    }), this.colorTableView.bind("selectedColor").to(o, "value"), l.buttonView.set({
                        label: this.dropdownLabel,
                        icon: this.icon,
                        tooltip: !0
                    }), l.extendTemplate({
                        attributes: {
                            class: "ck-color-ui-dropdown"
                        }
                    }), l.bind("isEnabled").to(o), this.colorTableView.on("execute", ((e, n) => {
                        l.isOpen && t.execute(this.commandName, {
                            value: n.value,
                            batch: this._undoStepBatch
                        }), "colorPicker" !== n.source && t.editing.view.focus()
                    })), this.colorTableView.on("showColorPicker", (() => {
                        this._undoStepBatch = t.model.createBatch()
                    })), this.colorTableView.on("cancel", (() => {
                        this._undoStepBatch.operations.length && (l.isOpen = !1, t.execute("undo", this._undoStepBatch)), t.editing.view.focus()
                    })), l.on("change:isOpen", ((e, n, o) => {
                        c || (c = !0, l.colorTableView.appendUI()), o ? (0 !== s && this.colorTableView.updateDocumentColors(t.model, this.componentName), this.colorTableView.updateSelectedColors()) : this.colorTableView.showColorGrids()
                    })), Zm(l, (() => l.colorTableView.colorGridsPageView.staticColorsGrid.items.find((t => t.isOn)))), l
                }))
            }
        }
        class vB extends _B {
            constructor(t) {
                const e = t.locale.t;
                super(t, {
                    commandName: QT,
                    componentName: QT,
                    icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>',
                    dropdownLabel: e("Font Color")
                })
            }
            static get pluginName() {
                return "FontColorUI"
            }
        }
        class yB extends Vi {
            static get requires() {
                return [CB, vB]
            }
            static get pluginName() {
                return "FontColor"
            }
        }
        class xB extends qT {
            constructor(t) {
                super(t, XT)
            }
        }
        class EB extends Vi {
            static get pluginName() {
                return "FontBackgroundColorEditing"
            }
            constructor(t) {
                super(t), t.config.define(XT, {
                    colors: [{
                        color: "hsl(0, 0%, 0%)",
                        label: "Black"
                    }, {
                        color: "hsl(0, 0%, 30%)",
                        label: "Dim grey"
                    }, {
                        color: "hsl(0, 0%, 60%)",
                        label: "Grey"
                    }, {
                        color: "hsl(0, 0%, 90%)",
                        label: "Light grey"
                    }, {
                        color: "hsl(0, 0%, 100%)",
                        label: "White",
                        hasBorder: !0
                    }, {
                        color: "hsl(0, 75%, 60%)",
                        label: "Red"
                    }, {
                        color: "hsl(30, 75%, 60%)",
                        label: "Orange"
                    }, {
                        color: "hsl(60, 75%, 60%)",
                        label: "Yellow"
                    }, {
                        color: "hsl(90, 75%, 60%)",
                        label: "Light green"
                    }, {
                        color: "hsl(120, 75%, 60%)",
                        label: "Green"
                    }, {
                        color: "hsl(150, 75%, 60%)",
                        label: "Aquamarine"
                    }, {
                        color: "hsl(180, 75%, 60%)",
                        label: "Turquoise"
                    }, {
                        color: "hsl(210, 75%, 60%)",
                        label: "Light blue"
                    }, {
                        color: "hsl(240, 75%, 60%)",
                        label: "Blue"
                    }, {
                        color: "hsl(270, 75%, 60%)",
                        label: "Purple"
                    }],
                    columns: 5
                }), t.data.addStyleProcessorRules(Fu), t.conversion.for("upcast").elementToAttribute({
                    view: {
                        name: "span",
                        styles: {
                            "background-color": /[\s\S]+/
                        }
                    },
                    model: {
                        key: XT,
                        value: eB("background-color")
                    }
                }), t.conversion.for("downcast").attributeToElement({
                    model: XT,
                    view: nB("background-color")
                }), t.commands.add(XT, new xB(t)), t.model.schema.extend("$text", {
                    allowAttributes: XT
                }), t.model.schema.setAttributeProperties(XT, {
                    isFormatting: !0,
                    copyOnEnter: !0
                })
            }
        }
        class DB extends _B {
            constructor(t) {
                const e = t.locale.t;
                super(t, {
                    commandName: XT,
                    componentName: XT,
                    icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>',
                    dropdownLabel: e("Font Background Color")
                })
            }
            static get pluginName() {
                return "FontBackgroundColorUI"
            }
        }
        class SB extends Vi {
            static get requires() {
                return [EB, DB]
            }
            static get pluginName() {
                return "FontBackgroundColor"
            }
        }

        function TB(t) {
            const e = t.t,
                n = t.config.get("codeBlock.languages");
            for (const t of n) "Plain text" === t.label && (t.label = e("Plain text")), void 0 === t.class && (t.class = `language-${t.language}`);
            return n
        }

        function BB(t, e, n) {
            const o = {};
            for (const i of t)
                if ("class" === e) {
                    o[i[e].split(" ").shift()] = i[n]
                } else o[i[e]] = i[n];
            return o
        }

        function IB(t) {
            return t.data.match(/^(\s*)/)[0]
        }

        function PB(t) {
            const e = t.document.selection,
                n = [];
            if (e.isCollapsed) return [e.anchor];
            const o = e.getFirstRange().getWalker({
                ignoreElementEnd: !0,
                direction: "backward"
            });
            for (const {
                    item: e
                }
                of o) {
                if (!e.is("$textProxy")) continue;
                const {
                    parent: o,
                    startOffset: i
                } = e.textNode;
                if (!o.is("element", "codeBlock")) continue;
                const r = IB(e.textNode),
                    s = t.createPositionAt(o, i + r.length);
                n.push(s)
            }
            return n
        }

        function RB(t) {
            const e = Ei(t.getSelectedBlocks());
            return !!e && e.is("element", "codeBlock")
        }

        function zB(t, e) {
            return !e.is("rootElement") && !t.isLimit(e) && t.checkChild(e.parent, "codeBlock")
        }
        class VB extends Fi {
            constructor(t) {
                super(t), this._lastLanguage = null
            }
            refresh() {
                this.value = this._getValue(), this.isEnabled = this._checkEnabled()
            }
            execute(t = {}) {
                const e = this.editor,
                    n = e.model,
                    o = n.document.selection,
                    i = TB(e)[0],
                    r = Array.from(o.getSelectedBlocks()),
                    s = null == t.forceValue ? !this.value : t.forceValue,
                    a = function(t, e, n) {
                        if (t.language) return t.language;
                        if (t.usePreviousLanguageChoice && e) return e;
                        return n
                    }(t, this._lastLanguage, i.language);
                n.change((t => {
                    s ? this._applyCodeBlock(t, r, a) : this._removeCodeBlock(t, r)
                }))
            }
            _getValue() {
                const t = Ei(this.editor.model.document.selection.getSelectedBlocks());
                return !!!(!t || !t.is("element", "codeBlock")) && t.getAttribute("language")
            }
            _checkEnabled() {
                if (this.value) return !0;
                const t = this.editor.model.document.selection,
                    e = this.editor.model.schema,
                    n = Ei(t.getSelectedBlocks());
                return !!n && zB(e, n)
            }
            _applyCodeBlock(t, e, n) {
                this._lastLanguage = n;
                const o = this.editor.model.schema,
                    i = e.filter((t => zB(o, t)));
                for (const e of i) t.rename(e, "codeBlock"), t.setAttribute("language", n, e), o.removeDisallowedAttributes([e], t), Array.from(e.getChildren()).filter((t => !o.checkChild(e, t))).forEach((e => t.remove(e)));
                i.reverse().forEach(((e, n) => {
                    const o = i[n + 1];
                    e.previousSibling === o && (t.appendElement("softBreak", o), t.merge(t.createPositionBefore(e)))
                }))
            }
            _removeCodeBlock(t, e) {
                const n = e.filter((t => t.is("element", "codeBlock")));
                for (const e of n) {
                    const n = t.createRangeOn(e);
                    for (const e of Array.from(n.getItems()).reverse())
                        if (e.is("element", "softBreak") && e.parent.is("element", "codeBlock")) {
                            const {
                                position: n
                            } = t.split(t.createPositionBefore(e)), o = n.nodeAfter;
                            t.rename(o, "paragraph"), t.removeAttribute("language", o), t.remove(e)
                        } t.rename(e, "paragraph"), t.removeAttribute("language", e)
                }
            }
        }
        class OB extends Fi {
            constructor(t) {
                super(t), this._indentSequence = t.config.get("codeBlock.indentSequence")
            }
            refresh() {
                this.isEnabled = this._checkEnabled()
            }
            execute() {
                const t = this.editor.model;
                t.change((e => {
                    const n = PB(t);
                    for (const o of n) {
                        const n = e.createText(this._indentSequence);
                        t.insertContent(n, o)
                    }
                }))
            }
            _checkEnabled() {
                return !!this._indentSequence && RB(this.editor.model.document.selection)
            }
        }
        class FB extends Fi {
            constructor(t) {
                super(t), this._indentSequence = t.config.get("codeBlock.indentSequence")
            }
            refresh() {
                this.isEnabled = this._checkEnabled()
            }
            execute() {
                const t = this.editor.model;
                t.change((() => {
                    const e = PB(t);
                    for (const n of e) {
                        const e = MB(t, n, this._indentSequence);
                        e && t.deleteContent(t.createSelection(e))
                    }
                }))
            }
            _checkEnabled() {
                if (!this._indentSequence) return !1;
                const t = this.editor.model;
                return !!RB(t.document.selection) && PB(t).some((e => MB(t, e, this._indentSequence)))
            }
        }

        function MB(t, e, n) {
            const o = function(t) {
                let e = t.parent.getChild(t.index);
                e && !e.is("element", "softBreak") || (e = t.nodeBefore);
                if (!e || e.is("element", "softBreak")) return null;
                return e
            }(e);
            if (!o) return null;
            const i = IB(o),
                r = i.lastIndexOf(n);
            if (r + n.length !== i.length) return null;
            if (-1 === r) return null;
            const {
                parent: s,
                startOffset: a
            } = o;
            return t.createRange(t.createPositionAt(s, a + r), t.createPositionAt(s, a + r + n.length))
        }

        function NB(t, e, n = !1) {
            const o = BB(e, "language", "class"),
                i = BB(e, "language", "label");
            return (e, r, s) => {
                const {
                    writer: a,
                    mapper: l,
                    consumable: c
                } = s;
                if (!c.consume(r.item, "insert")) return;
                const d = r.item.getAttribute("language"),
                    h = l.toViewPosition(t.createPositionBefore(r.item)),
                    u = {};
                n && (u["data-language"] = i[d], u.spellcheck = "false");
                const g = o[d] ? {
                        class: o[d]
                    } : void 0,
                    m = a.createContainerElement("code", g),
                    p = a.createContainerElement("pre", u, m);
                a.insert(h, p), l.bindElements(r.item, m)
            }
        }
        const LB = "paragraph";
        class HB extends Vi {
            static get pluginName() {
                return "CodeBlockEditing"
            }
            static get requires() {
                return [hw]
            }
            constructor(t) {
                super(t), t.config.define("codeBlock", {
                    languages: [{
                        language: "plaintext",
                        label: "Plain text"
                    }, {
                        language: "c",
                        label: "C"
                    }, {
                        language: "cs",
                        label: "C#"
                    }, {
                        language: "cpp",
                        label: "C++"
                    }, {
                        language: "css",
                        label: "CSS"
                    }, {
                        language: "diff",
                        label: "Diff"
                    }, {
                        language: "html",
                        label: "HTML"
                    }, {
                        language: "java",
                        label: "Java"
                    }, {
                        language: "javascript",
                        label: "JavaScript"
                    }, {
                        language: "php",
                        label: "PHP"
                    }, {
                        language: "python",
                        label: "Python"
                    }, {
                        language: "ruby",
                        label: "Ruby"
                    }, {
                        language: "typescript",
                        label: "TypeScript"
                    }, {
                        language: "xml",
                        label: "XML"
                    }],
                    indentSequence: "\t"
                })
            }
            init() {
                const t = this.editor,
                    e = t.model.schema,
                    n = t.model,
                    o = t.editing.view,
                    i = t.plugins.has("DocumentListEditing"),
                    r = TB(t);
                t.commands.add("codeBlock", new VB(t)), t.commands.add("indentCodeBlock", new OB(t)), t.commands.add("outdentCodeBlock", new FB(t)), this.listenTo(o.document, "tab", ((e, n) => {
                    const o = n.shiftKey ? "outdentCodeBlock" : "indentCodeBlock";
                    t.commands.get(o).isEnabled && (t.execute(o), n.stopPropagation(), n.preventDefault(), e.stop())
                }), {
                    context: "pre"
                }), e.register("codeBlock", {
                    allowWhere: "$block",
                    allowChildren: "$text",
                    isBlock: !0,
                    allowAttributes: ["language"]
                }), e.addAttributeCheck(((t, e) => {
                    const n = t.endsWith("codeBlock") && e.startsWith("list") && "list" !== e;
                    return !(!i || !n) || !t.endsWith("codeBlock $text") && void 0
                })), t.model.schema.addChildCheck(((t, e) => {
                    if (t.endsWith("codeBlock") && e.isObject) return !1
                })), t.editing.downcastDispatcher.on("insert:codeBlock", NB(n, r, !0)), t.data.downcastDispatcher.on("insert:codeBlock", NB(n, r)), t.data.downcastDispatcher.on("insert:softBreak", function(t) {
                    return (e, n, o) => {
                        if ("codeBlock" !== n.item.parent.name) return;
                        const {
                            writer: i,
                            mapper: r,
                            consumable: s
                        } = o;
                        if (!s.consume(n.item, "insert")) return;
                        const a = r.toViewPosition(t.createPositionBefore(n.item));
                        i.insert(a, i.createText("\n"))
                    }
                }(n), {
                    priority: "high"
                }), t.data.upcastDispatcher.on("element:code", function(t, e) {
                    const n = BB(e, "class", "language"),
                        o = e[0].language;
                    return (t, e, i) => {
                        const r = e.viewItem,
                            s = r.parent;
                        if (!s || !s.is("element", "pre")) return;
                        if (e.modelCursor.findAncestor("codeBlock")) return;
                        const {
                            consumable: a,
                            writer: l
                        } = i;
                        if (!a.test(r, {
                                name: !0
                            })) return;
                        const c = l.createElement("codeBlock"),
                            d = [...r.getClassNames()];
                        d.length || d.push("");
                        for (const t of d) {
                            const e = n[t];
                            if (e) {
                                l.setAttribute("language", e, c);
                                break
                            }
                        }
                        c.hasAttribute("language") || l.setAttribute("language", o, c), i.convertChildren(r, c), i.safeInsert(c, e.modelCursor) && (a.consume(r, {
                            name: !0
                        }), i.updateConversionResult(c, e))
                    }
                }(0, r)), t.data.upcastDispatcher.on("text", ((t, e, {
                    consumable: n,
                    writer: o
                }) => {
                    let i = e.modelCursor;
                    if (!n.test(e.viewItem)) return;
                    if (!i.findAncestor("codeBlock")) return;
                    n.consume(e.viewItem);
                    const r = e.viewItem.data.split("\n").map((t => o.createText(t))),
                        s = r[r.length - 1];
                    for (const t of r)
                        if (o.insert(t, i), i = i.getShiftedBy(t.offsetSize), t !== s) {
                            const t = o.createElement("softBreak");
                            o.insert(t, i), i = o.createPositionAfter(t)
                        } e.modelRange = o.createRange(e.modelCursor, i), e.modelCursor = i
                })), t.data.upcastDispatcher.on("element:pre", ((t, e, {
                    consumable: n
                }) => {
                    const o = e.viewItem;
                    if (o.findAncestor("pre")) return;
                    const i = Array.from(o.getChildren()),
                        r = i.find((t => t.is("element", "code")));
                    if (r)
                        for (const t of i) t !== r && t.is("$text") && n.consume(t, {
                            name: !0
                        })
                }), {
                    priority: "high"
                }), this.listenTo(t.editing.view.document, "clipboardInput", ((e, o) => {
                    let i = n.createRange(n.document.selection.anchor);
                    if (o.targetRanges && (i = t.editing.mapper.toModelRange(o.targetRanges[0])), !i.start.parent.is("element", "codeBlock")) return;
                    const r = o.dataTransfer.getData("text/plain"),
                        s = new cu(t.editing.view.document);
                    o.content = function(t, e) {
                        const n = t.createDocumentFragment(),
                            o = e.split("\n"),
                            i = o.reduce(((e, n, i) => (e.push(n), i < o.length - 1 && e.push(t.createElement("br")), e)), []);
                        return t.appendChild(i, n), n
                    }(s, r)
                })), this.listenTo(n, "getSelectedContent", ((t, [o]) => {
                    const i = o.anchor;
                    !o.isCollapsed && i.parent.is("element", "codeBlock") && i.hasSameParentAs(o.focus) && n.change((n => {
                        const r = t.return;
                        if (i.parent.is("element") && (r.childCount > 1 || o.containsEntireContent(i.parent))) {
                            const e = n.createElement("codeBlock", i.parent.getAttributes());
                            n.append(r, e);
                            const o = n.createDocumentFragment();
                            return n.append(e, o), void(t.return = o)
                        }
                        const s = r.getChild(0);
                        e.checkAttribute(s, "code") && n.setAttribute("code", !0, s)
                    }))
                }))
            }
            afterInit() {
                const t = this.editor,
                    e = t.commands,
                    n = e.get("indent"),
                    o = e.get("outdent");
                n && n.registerChildCommand(e.get("indentCodeBlock"), {
                    priority: "highest"
                }), o && o.registerChildCommand(e.get("outdentCodeBlock")), this.listenTo(t.editing.view.document, "enter", ((e, n) => {
                    t.model.document.selection.getLastPosition().parent.is("element", "codeBlock") && (function(t, e) {
                        const n = t.model,
                            o = n.document,
                            i = t.editing.view,
                            r = o.selection.getLastPosition(),
                            s = r.nodeAfter;
                        if (e || !o.selection.isCollapsed || !r.isAtStart) return !1;
                        if (!qB(s)) return !1;
                        return t.model.change((e => {
                            t.execute("enter");
                            const n = o.selection.anchor.parent.previousSibling;
                            e.rename(n, LB), e.setSelection(n, "in"), t.model.schema.removeDisallowedAttributes([n], e), e.remove(s)
                        })), i.scrollToTheSelection(), !0
                    }(t, n.isSoft) || function(t, e) {
                        const n = t.model,
                            o = n.document,
                            i = t.editing.view,
                            r = o.selection.getLastPosition(),
                            s = r.nodeBefore;
                        let a;
                        if (e || !o.selection.isCollapsed || !r.isAtEnd || !s || !s.previousSibling) return !1;
                        if (qB(s) && qB(s.previousSibling)) a = n.createRange(n.createPositionBefore(s.previousSibling), n.createPositionAfter(s));
                        else if (jB(s) && qB(s.previousSibling) && qB(s.previousSibling.previousSibling)) a = n.createRange(n.createPositionBefore(s.previousSibling.previousSibling), n.createPositionAfter(s));
                        else {
                            if (!(jB(s) && qB(s.previousSibling) && jB(s.previousSibling.previousSibling) && s.previousSibling.previousSibling && qB(s.previousSibling.previousSibling.previousSibling))) return !1;
                            a = n.createRange(n.createPositionBefore(s.previousSibling.previousSibling.previousSibling), n.createPositionAfter(s))
                        }
                        return t.model.change((e => {
                            e.remove(a), t.execute("enter");
                            const n = o.selection.anchor.parent;
                            e.rename(n, LB), t.model.schema.removeDisallowedAttributes([n], e)
                        })), i.scrollToTheSelection(), !0
                    }(t, n.isSoft) || function(t) {
                        const e = t.model,
                            n = e.document,
                            o = n.selection.getLastPosition(),
                            i = o.nodeBefore || o.textNode;
                        let r;
                        i && i.is("$text") && (r = IB(i));
                        t.model.change((e => {
                            t.execute("shiftEnter"), r && e.insertText(r, n.selection.anchor)
                        }))
                    }(t), n.preventDefault(), e.stop())
                }), {
                    context: "pre"
                })
            }
        }

        function jB(t) {
            return t && t.is("$text") && !t.data.match(/\S/)
        }

        function qB(t) {
            return t && t.is("element", "softBreak")
        }
        var WB = n(8343),
            UB = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(WB.Z, UB);
        WB.Z.locals;
        class $B extends Vi {
            static get pluginName() {
                return "CodeBlockUI"
            }
            init() {
                const t = this.editor,
                    e = t.t,
                    n = t.ui.componentFactory,
                    o = TB(t);
                n.add("codeBlock", (n => {
                    const i = t.commands.get("codeBlock"),
                        r = Wm(n, Nm),
                        s = r.buttonView,
                        a = e("Insert code block");
                    return s.set({
                        label: a,
                        tooltip: !0,
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174zm2.795-.231.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207zM16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>',
                        isToggleable: !0
                    }), s.bind("isOn").to(i, "value", (t => !!t)), s.on("execute", (() => {
                        t.execute("codeBlock", {
                            usePreviousLanguageChoice: !0
                        }), t.editing.view.focus()
                    })), r.on("execute", (e => {
                        t.execute("codeBlock", {
                            language: e.source._codeBlockLanguage,
                            forceValue: !0
                        }), t.editing.view.focus()
                    })), r.class = "ck-code-block-dropdown", r.bind("isEnabled").to(i), Gm(r, (() => this._getLanguageListItemDefinitions(o)), {
                        role: "menu",
                        ariaLabel: a
                    }), r
                }))
            }
            _getLanguageListItemDefinitions(t) {
                const e = this.editor.commands.get("codeBlock"),
                    n = new xi;
                for (const o of t) {
                    const t = {
                        type: "button",
                        model: new Vf({
                            _codeBlockLanguage: o.language,
                            label: o.label,
                            role: "menuitemradio",
                            withText: !0
                        })
                    };
                    t.model.bind("isOn").to(e, "value", (e => e === t.model._codeBlockLanguage)), n.add(t)
                }
                return n
            }
        }
        class GB extends Fi {
            constructor(t) {
                super(t), this._isEnabledBasedOnSelection = !1
            }
            refresh() {
                const t = this.editor.model,
                    e = t.document;
                this.isEnabled = t.schema.checkAttributeInSelection(e.selection, "mention")
            }
            execute(t) {
                const e = this.editor.model,
                    n = e.document.selection,
                    o = "string" == typeof t.mention ? {
                        id: t.mention
                    } : t.mention,
                    i = o.id,
                    r = t.range || n.getFirstRange();
                if (!e.canEditAt(r)) return;
                const s = t.text || i,
                    a = ZB({
                        _text: s,
                        id: i
                    }, o);
                if (1 != t.marker.length) throw new b("mentioncommand-incorrect-marker", this);
                if (i.charAt(0) != t.marker) throw new b("mentioncommand-incorrect-id", this);
                e.change((t => {
                    const o = Ti(n.getAttributes()),
                        i = new Map(o.entries());
                    i.set("mention", a), e.insertContent(t.createText(s, i), r), e.insertContent(t.createText(" ", o), r.start.getShiftedBy(s.length))
                }))
            }
        }
        class KB extends Vi {
            static get pluginName() {
                return "MentionEditing"
            }
            init() {
                const t = this.editor,
                    e = t.model,
                    n = e.document;
                e.schema.extend("$text", {
                    allowAttributes: "mention"
                }), t.conversion.for("upcast").elementToAttribute({
                    view: {
                        name: "span",
                        key: "data-mention",
                        classes: "mention"
                    },
                    model: {
                        key: "mention",
                        value: t => JB(t)
                    }
                }), t.conversion.for("downcast").attributeToElement({
                    model: "mention",
                    view: QB
                }), t.conversion.for("downcast").add(YB), n.registerPostFixer((t => function(t, e, n) {
                    const o = e.differ.getChanges();
                    let i = !1;
                    for (const e of o) {
                        if ("attribute" == e.type) continue;
                        const o = e.position;
                        if ("$text" == e.name) {
                            const e = o.textNode && o.textNode.nextSibling;
                            i = tI(o.textNode, t) || i, i = tI(e, t) || i, i = tI(o.nodeBefore, t) || i, i = tI(o.nodeAfter, t) || i
                        }
                        if ("$text" != e.name && "insert" == e.type) {
                            const e = o.nodeAfter;
                            for (const n of t.createRangeIn(e).getItems()) i = tI(n, t) || i
                        }
                        if ("insert" == e.type && n.isInline(e.name)) {
                            const e = o.nodeAfter && o.nodeAfter.nextSibling;
                            i = tI(o.nodeBefore, t) || i, i = tI(e, t) || i
                        }
                    }
                    return i
                }(t, n, e.schema))), n.registerPostFixer((t => function(t, e) {
                    const n = e.differ.getChanges();
                    let o = !1;
                    for (const e of n)
                        if ("attribute" === e.type && "mention" != e.attributeKey) {
                            const n = e.range.start.nodeBefore,
                                i = e.range.end.nodeAfter;
                            for (const r of [n, i]) XB(r) && r.getAttribute(e.attributeKey) != e.attributeNewValue && (t.setAttribute(e.attributeKey, e.attributeNewValue, r), o = !0)
                        } return o
                }(t, n))), n.registerPostFixer((t => function(t, e) {
                    const n = e.selection,
                        o = n.focus;
                    if (n.isCollapsed && n.hasAttribute("mention") && function(t) {
                            const e = t.isAtStart;
                            return t.nodeBefore && t.nodeBefore.is("$text") || e
                        }(o)) return t.removeSelectionAttribute("mention"), !0;
                    return !1
                }(t, n))), t.commands.add("mention", new GB(t))
            }
        }

        function ZB(t, e) {
            return Object.assign({
                uid: g()
            }, t, e || {})
        }

        function JB(t, e) {
            const n = t.getAttribute("data-mention"),
                o = t.getChild(0);
            if (!o) return;
            return ZB({
                id: n,
                _text: o.data
            }, e)
        }

        function YB(t) {
            t.on("attribute:mention", ((t, e, n) => {
                const o = e.attributeNewValue;
                if (!e.item.is("$textProxy") || !o) return;
                const i = e.range.start;
                (i.textNode || i.nodeAfter).data != o._text && n.consumable.consume(e.item, t.name)
            }), {
                priority: "highest"
            })
        }

        function QB(t, {
            writer: e
        }) {
            if (!t) return;
            const n = {
                    class: "mention",
                    "data-mention": t.id
                },
                o = {
                    id: t.uid,
                    priority: 20
                };
            return e.createAttributeElement("span", n, o)
        }

        function XB(t) {
            if (!t || !t.is("$text") && !t.is("$textProxy") || !t.hasAttribute("mention")) return !1;
            return t.data != t.getAttribute("mention")._text
        }

        function tI(t, e) {
            return !!XB(t) && (e.removeAttribute("mention", t), !0)
        }
        var eI = n(7640),
            nI = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(eI.Z, nI);
        eI.Z.locals;
        class oI extends zm {
            constructor(t) {
                super(t), this.extendTemplate({
                    attributes: {
                        class: ["ck-mentions"],
                        tabindex: "-1"
                    }
                })
            }
            selectFirst() {
                this.select(0)
            }
            selectNext() {
                const t = this.selected,
                    e = this.items.getIndex(t);
                this.select(e + 1)
            }
            selectPrevious() {
                const t = this.selected,
                    e = this.items.getIndex(t);
                this.select(e - 1)
            }
            select(t) {
                let e = 0;
                t > 0 && t < this.items.length ? e = t : t < 0 && (e = this.items.length - 1);
                const n = this.items.get(e);
                this.selected !== n && (this.selected && this.selected.removeHighlight(), n.highlight(), this.selected = n, this._isItemVisibleInScrolledArea(n) || (this.element.scrollTop = n.element.offsetTop))
            }
            executeSelected() {
                this.selected.fire("execute")
            }
            _isItemVisibleInScrolledArea(t) {
                return new Mo(this.element).contains(new Mo(t.element))
            }
        }
        class iI extends cg {
            constructor(t, e) {
                super(t), this.template = void 0, this.domElement = e, this.domElement.classList.add("ck-button"), this.set("isOn", !1), this.on("change:isOn", ((t, e, n) => {
                    n ? (this.domElement.classList.add("ck-on"), this.domElement.classList.remove("ck-off")) : (this.domElement.classList.add("ck-off"), this.domElement.classList.remove("ck-on"))
                })), this.listenTo(this.domElement, "click", (() => {
                    this.fire("execute")
                }))
            }
            render() {
                super.render(), this.element = this.domElement
            }
        }
        class rI extends Vm {
            highlight() {
                this.children.first.isOn = !0
            }
            removeHighlight() {
                this.children.first.isOn = !1
            }
        }
        var sI = Object.defineProperty,
            aI = Object.defineProperties,
            lI = Object.getOwnPropertyDescriptors,
            cI = Object.getOwnPropertySymbols,
            dI = Object.prototype.hasOwnProperty,
            hI = Object.prototype.propertyIsEnumerable,
            uI = (t, e, n) => e in t ? sI(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n;
        const gI = [mi.arrowup, mi.arrowdown, mi.esc],
            mI = [mi.enter, mi.tab];
        class pI extends Vi {
            constructor(t) {
                super(t), this._items = new xi, this._mentionsView = this._createMentionView(), this._mentionsConfigurations = new Map, this._requestFeedDebounced = Fa(this._requestFeed, 100), t.config.define("mention", {
                    feeds: []
                })
            }
            static get pluginName() {
                return "MentionUI"
            }
            static get requires() {
                return [jf]
            }
            init() {
                const t = this.editor,
                    e = t.config.get("mention.commitKeys") || mI,
                    n = gI.concat(e);
                this._balloon = t.plugins.get(jf), t.editing.view.document.on("keydown", ((t, o) => {
                    if (i = o.keyCode, n.includes(i) && this._isUIVisible) {
                        if (o.keyCode == mi.space) return void this._hideUIAndRemoveMarker();
                        o.preventDefault(), t.stop(), o.keyCode == mi.arrowdown && this._mentionsView.selectNext(), o.keyCode == mi.arrowup && this._mentionsView.selectPrevious(), e.includes(o.keyCode) && this._mentionsView.executeSelected(), o.keyCode == mi.esc && this._hideUIAndRemoveMarker()
                    }
                    var i
                }), {
                    priority: "highest"
                }), ng({
                    emitter: this._mentionsView,
                    activator: () => this._isUIVisible,
                    contextElements: () => [this._balloon.view.element],
                    callback: () => this._hideUIAndRemoveMarker()
                });
                const o = t.config.get("mention.feeds");
                for (const t of o) {
                    const {
                        feed: e,
                        marker: n,
                        dropdownLimit: o
                    } = t;
                    if (!AI(n)) throw new b("mentionconfig-incorrect-marker", null, {
                        marker: n
                    });
                    const i = {
                        marker: n,
                        feedCallback: "function" == typeof e ? e.bind(this.editor) : wI(e),
                        itemRenderer: t.itemRenderer,
                        dropdownLimit: o
                    };
                    this._mentionsConfigurations.set(n, i)
                }
                this._setupTextWatcher(o), this.listenTo(t, "change:isReadOnly", (() => {
                    this._hideUIAndRemoveMarker()
                })), this.on("requestFeed:response", ((t, e) => this._handleFeedResponse(e))), this.on("requestFeed:error", (() => this._hideUIAndRemoveMarker()))
            }
            destroy() {
                super.destroy(), this._mentionsView.destroy()
            }
            get _isUIVisible() {
                return this._balloon.visibleView === this._mentionsView
            }
            _createMentionView() {
                const t = this.editor.locale,
                    e = new oI(t);
                return e.items.bindTo(this._items).using((n => {
                    const {
                        item: o,
                        marker: i
                    } = n, {
                        dropdownLimit: r
                    } = this._mentionsConfigurations.get(i), s = r || this.editor.config.get("mention.dropdownLimit") || 10;
                    if (e.items.length >= s) return null;
                    const a = new rI(t),
                        l = this._renderItem(o, i);
                    return l.delegate("execute").to(a), a.children.add(l), a.item = o, a.marker = i, a.on("execute", (() => {
                        e.fire("execute", {
                            item: o,
                            marker: i
                        })
                    })), a
                })), e.on("execute", ((t, e) => {
                    const n = this.editor,
                        o = n.model,
                        i = e.item,
                        r = e.marker,
                        s = n.model.markers.get("mention"),
                        a = o.createPositionAt(o.document.selection.focus),
                        l = o.createPositionAt(s.getStart()),
                        c = o.createRange(l, a);
                    this._hideUIAndRemoveMarker(), n.execute("mention", {
                        mention: i,
                        text: i.text,
                        marker: r,
                        range: c
                    }), n.editing.view.focus()
                })), e
            }
            _getItemRenderer(t) {
                const {
                    itemRenderer: e
                } = this._mentionsConfigurations.get(t);
                return e
            }
            _requestFeed(t, e) {
                this._lastRequested = e;
                const {
                    feedCallback: n
                } = this._mentionsConfigurations.get(t), o = n(e);
                o instanceof Promise ? o.then((n => {
                    this._lastRequested == e ? this.fire("requestFeed:response", {
                        feed: n,
                        marker: t,
                        feedText: e
                    }) : this.fire("requestFeed:discarded", {
                        feed: n,
                        marker: t,
                        feedText: e
                    })
                })).catch((e => {
                    this.fire("requestFeed:error", {
                        error: e
                    }), k("mention-feed-callback-error", {
                        marker: t
                    })
                })) : this.fire("requestFeed:response", {
                    feed: o,
                    marker: t,
                    feedText: e
                })
            }
            _setupTextWatcher(t) {
                const e = this.editor,
                    n = t.map((t => {
                        return e = ((t, e) => {
                            for (var n in e || (e = {})) dI.call(e, n) && uI(t, n, e[n]);
                            if (cI)
                                for (var n of cI(e)) hI.call(e, n) && uI(t, n, e[n]);
                            return t
                        })({}, t), n = {
                            pattern: kI(t.marker, t.minimumCharacters || 0)
                        }, aI(e, lI(n));
                        var e, n
                    })),
                    o = new rk(e.model, function(t) {
                        const e = e => {
                            const n = bI(t, e);
                            if (!n) return !1;
                            let o = 0;
                            0 !== n.position && (o = n.position - 1);
                            const i = e.substring(o);
                            return n.pattern.test(i)
                        };
                        return e
                    }(n));
                o.on("matched:data", ((t, o) => {
                    const i = bI(n, o.text),
                        r = e.model.document.selection.focus,
                        s = e.model.createPositionAt(r.parent, i.position);
                    if (function(t) {
                            const e = t.textNode && t.textNode.hasAttribute("mention"),
                                n = t.nodeBefore;
                            return e || n && n.is("$text") && n.hasAttribute("mention")
                        }(r) || function(t) {
                            const e = t.nodeAfter;
                            return e && e.is("$text") && e.hasAttribute("mention")
                        }(s)) return void this._hideUIAndRemoveMarker();
                    const a = function(t, e) {
                            let n = 0;
                            0 !== t.position && (n = t.position - 1);
                            const o = kI(t.marker, 0),
                                i = e.substring(n);
                            return i.match(o)[2]
                        }(i, o.text),
                        l = i.marker.length + a.length,
                        c = r.getShiftedBy(-l),
                        d = r.getShiftedBy(-a.length),
                        h = e.model.createRange(c, d);
                    if (CI(e)) {
                        const t = e.model.markers.get("mention");
                        e.model.change((e => {
                            e.updateMarker(t, {
                                range: h
                            })
                        }))
                    } else e.model.change((t => {
                        t.addMarker("mention", {
                            range: h,
                            usingOperation: !1,
                            affectsData: !1
                        })
                    }));
                    this._requestFeedDebounced(i.marker, a)
                })), o.on("unmatched", (() => {
                    this._hideUIAndRemoveMarker()
                }));
                const i = e.commands.get("mention");
                return o.bind("isEnabled").to(i), o
            }
            _handleFeedResponse(t) {
                const {
                    feed: e,
                    marker: n
                } = t;
                if (!CI(this.editor)) return;
                this._items.clear();
                for (const t of e) {
                    const e = "object" != typeof t ? {
                        id: t,
                        text: t
                    } : t;
                    this._items.add({
                        item: e,
                        marker: n
                    })
                }
                const o = this.editor.model.markers.get("mention");
                this._items.length ? this._showOrUpdateUI(o) : this._hideUIAndRemoveMarker()
            }
            _showOrUpdateUI(t) {
                this._isUIVisible ? this._balloon.updatePosition(this._getBalloonPanelPositionData(t, this._mentionsView.position)) : this._balloon.add({
                    view: this._mentionsView,
                    position: this._getBalloonPanelPositionData(t, this._mentionsView.position),
                    singleViewMode: !0
                }), this._mentionsView.position = this._balloon.view.position, this._mentionsView.selectFirst()
            }
            _hideUIAndRemoveMarker() {
                this._balloon.hasView(this._mentionsView) && this._balloon.remove(this._mentionsView), CI(this.editor) && this.editor.model.change((t => t.removeMarker("mention"))), this._mentionsView.position = void 0
            }
            _renderItem(t, e) {
                const n = this.editor;
                let o, i = t.id;
                const r = this._getItemRenderer(e);
                if (r) {
                    const e = r(t);
                    "string" != typeof e ? o = new iI(n.locale, e) : i = e
                }
                if (!o) {
                    const t = new Mg(n.locale);
                    t.label = i, t.withText = !0, o = t
                }
                return o
            }
            _getBalloonPanelPositionData(t, e) {
                const n = this.editor,
                    o = n.editing,
                    i = o.view.domConverter,
                    r = o.mapper;
                return {
                    target: () => {
                        let e = t.getRange();
                        "$graveyard" == e.start.root.rootName && (e = n.model.document.selection.getFirstRange());
                        const o = r.toViewRange(e);
                        return Mo.getDomRangeRects(i.viewRangeToDom(o)).pop()
                    },
                    limiter: () => {
                        const t = this.editor.editing.view,
                            e = t.document.selection.editableElement;
                        return e ? t.domConverter.mapViewToDom(e.root) : null
                    },
                    positions: fI(e, n.locale.uiLanguageDirection)
                }
            }
        }

        function fI(t, e) {
            const n = {
                caret_se: t => ({
                    top: t.bottom + 3,
                    left: t.right,
                    name: "caret_se",
                    config: {
                        withArrow: !1
                    }
                }),
                caret_ne: (t, e) => ({
                    top: t.top - e.height - 3,
                    left: t.right,
                    name: "caret_ne",
                    config: {
                        withArrow: !1
                    }
                }),
                caret_sw: (t, e) => ({
                    top: t.bottom + 3,
                    left: t.right - e.width,
                    name: "caret_sw",
                    config: {
                        withArrow: !1
                    }
                }),
                caret_nw: (t, e) => ({
                    top: t.top - e.height - 3,
                    left: t.right - e.width,
                    name: "caret_nw",
                    config: {
                        withArrow: !1
                    }
                })
            };
            return Object.prototype.hasOwnProperty.call(n, t) ? [n[t]] : "rtl" !== e ? [n.caret_se, n.caret_sw, n.caret_ne, n.caret_nw] : [n.caret_sw, n.caret_se, n.caret_nw, n.caret_ne]
        }

        function bI(t, e) {
            let n;
            for (const o of t) {
                const t = e.lastIndexOf(o.marker);
                t > 0 && !e.substring(t - 1).match(o.pattern) || (!n || t >= n.position) && (n = {
                    marker: o.marker,
                    position: t,
                    minimumCharacters: o.minimumCharacters,
                    pattern: o.pattern
                })
            }
            return n
        }

        function kI(t, e) {
            const n = 0 == e ? "*" : `{${e},}`,
                o = i.features.isRegExpUnicodePropertySupported ? "\\p{Ps}\\p{Pi}\"'" : "\\(\\[{\"'";
            return new RegExp(`(?:^|[= ${o}])([${t}])([^=]${n})$`, "u")
        }

        function wI(t) {
            return e => t.filter((t => ("string" == typeof t ? t : String(t.id)).toLowerCase().includes(e.toLowerCase())))
        }

        function AI(t) {
            return t && 1 == t.length
        }

        function CI(t) {
            return t.model.markers.has("mention")
        }
        var _I = n(5023),
            vI = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(_I.Z, vI);
        _I.Z.locals;
        class yI extends Vi {
            static get pluginName() {
                return "IndentEditing"
            }
            init() {
                const t = this.editor;
                t.commands.add("indent", new Ni(t)), t.commands.add("outdent", new Ni(t))
            }
        }
        const xI = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>',
            EI = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
        class DI extends Vi {
            static get pluginName() {
                return "IndentUI"
            }
            init() {
                const t = this.editor,
                    e = t.locale,
                    n = t.t,
                    o = "ltr" == e.uiLanguageDirection ? xI : EI,
                    i = "ltr" == e.uiLanguageDirection ? EI : xI;
                this._defineButton("indent", n("Increase indent"), o), this._defineButton("outdent", n("Decrease indent"), i)
            }
            _defineButton(t, e, n) {
                const o = this.editor;
                o.ui.componentFactory.add(t, (i => {
                    const r = o.commands.get(t),
                        s = new Mg(i);
                    return s.set({
                        label: e,
                        icon: n,
                        tooltip: !0
                    }), s.bind("isEnabled").to(r, "isEnabled"), this.listenTo(s, "execute", (() => {
                        o.execute(t), o.editing.view.focus()
                    })), s
                }))
            }
        }
        class SI extends Fi {
            constructor(t, e) {
                super(t), this._indentBehavior = e
            }
            refresh() {
                const t = this.editor.model,
                    e = Ei(t.document.selection.getSelectedBlocks());
                e && t.schema.checkAttribute(e, "blockIndent") ? this.isEnabled = this._indentBehavior.checkEnabled(e.getAttribute("blockIndent")) : this.isEnabled = !1
            }
            execute() {
                const t = this.editor.model,
                    e = function(t) {
                        const e = t.document.selection,
                            n = t.schema;
                        return Array.from(e.getSelectedBlocks()).filter((t => n.checkAttribute(t, "blockIndent")))
                    }(t);
                t.change((t => {
                    for (const n of e) {
                        const e = n.getAttribute("blockIndent"),
                            o = this._indentBehavior.getNextIndent(e);
                        o ? t.setAttribute("blockIndent", o, n) : t.removeAttribute("blockIndent", n)
                    }
                }))
            }
        }
        class TI {
            constructor(t) {
                this.isForward = "forward" === t.direction, this.offset = t.offset, this.unit = t.unit
            }
            checkEnabled(t) {
                const e = parseFloat(t || "0");
                return this.isForward || e > 0
            }
            getNextIndent(t) {
                const e = parseFloat(t || "0");
                if (!(!t || t.endsWith(this.unit))) return this.isForward ? this.offset + this.unit : void 0;
                const n = e + (this.isForward ? this.offset : -this.offset);
                return n > 0 ? n + this.unit : void 0
            }
        }
        class BI {
            constructor(t) {
                this.isForward = "forward" === t.direction, this.classes = t.classes
            }
            checkEnabled(t) {
                const e = this.classes.indexOf(t);
                return this.isForward ? e < this.classes.length - 1 : e >= 0
            }
            getNextIndent(t) {
                const e = this.classes.indexOf(t),
                    n = this.isForward ? 1 : -1;
                return this.classes[e + n]
            }
        }
        const II = ["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"];
        class PI extends Fi {
            constructor(t) {
                super(t), this.affectsData = !1
            }
            execute() {
                const t = this.editor.model,
                    e = t.document.selection;
                let n = t.schema.getLimitElement(e);
                if (e.containsEntireContent(n) || !RI(t.schema, n))
                    do {
                        if (n = n.parent, !n) return
                    } while (!RI(t.schema, n));
                t.change((t => {
                    t.setSelection(n, "in")
                }))
            }
        }

        function RI(t, e) {
            return t.isLimit(e) && (t.checkChild(e, "$text") || t.checkChild(e, "paragraph"))
        }
        const zI = bi("Ctrl+A");
        class VI extends Vi {
            static get pluginName() {
                return "SelectAllEditing"
            }
            init() {
                const t = this.editor,
                    e = t.editing.view.document;
                t.commands.add("selectAll", new PI(t)), this.listenTo(e, "keydown", ((e, n) => {
                    fi(n) === zI && (t.execute("selectAll"), n.preventDefault())
                }))
            }
        }
        class OI extends Vi {
            static get pluginName() {
                return "SelectAllUI"
            }
            init() {
                const t = this.editor;
                t.ui.componentFactory.add("selectAll", (e => {
                    const n = t.commands.get("selectAll"),
                        o = new Mg(e),
                        i = e.t;
                    return o.set({
                        label: i("Select all"),
                        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>',
                        keystroke: "Ctrl+A",
                        tooltip: !0
                    }), o.bind("isEnabled").to(n, "isEnabled"), this.listenTo(o, "execute", (() => {
                        t.execute("selectAll"), t.editing.view.focus()
                    })), o
                }))
            }
        }
        class FI extends Vi {
            static get requires() {
                return [VI, OI]
            }
            static get pluginName() {
                return "SelectAll"
            }
        }
        class MI extends Fi {
            refresh() {
                const t = this.editor.model,
                    e = t.schema,
                    n = t.document.selection;
                this.isEnabled = function(t, e, n) {
                    const o = function(t, e) {
                        const n = Qw(t, e),
                            o = n.start.parent;
                        if (o.isEmpty && !o.is("element", "$root")) return o.parent;
                        return o
                    }(t, n);
                    return e.checkChild(o, "horizontalLine")
                }(n, e, t)
            }
            execute() {
                const t = this.editor.model;
                t.change((e => {
                    const n = e.createElement("horizontalLine");
                    t.insertObject(n, null, null, {
                        setSelection: "after"
                    })
                }))
            }
        }
        var NI = n(2974),
            LI = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(NI.Z, LI);
        NI.Z.locals;
        class HI extends Vi {
            static get pluginName() {
                return "HorizontalLineEditing"
            }
            init() {
                const t = this.editor,
                    e = t.model.schema,
                    n = t.t,
                    o = t.conversion;
                e.register("horizontalLine", {
                    inheritAllFrom: "$blockObject"
                }), o.for("dataDowncast").elementToElement({
                    model: "horizontalLine",
                    view: (t, {
                        writer: e
                    }) => e.createEmptyElement("hr")
                }), o.for("editingDowncast").elementToStructure({
                    model: "horizontalLine",
                    view: (t, {
                        writer: e
                    }) => {
                        const o = n("Horizontal line"),
                            i = e.createContainerElement("div", null, e.createEmptyElement("hr"));
                        return e.addClass("ck-horizontal-line", i), e.setCustomProperty("hr", !0, i),
                            function(t, e, n) {
                                return e.setCustomProperty("horizontalLine", !0, t), Gw(t, e, {
                                    label: n
                                })
                            }(i, e, o)
                    }
                }), o.for("upcast").elementToElement({
                    view: "hr",
                    model: "horizontalLine"
                }), t.commands.add("horizontalLine", new MI(t))
            }
        }
        class jI extends Vi {
            static get pluginName() {
                return "HorizontalLineUI"
            }
            init() {
                const t = this.editor,
                    e = t.t;
                t.ui.componentFactory.add("horizontalLine", (n => {
                    const o = t.commands.get("horizontalLine"),
                        i = new Mg(n);
                    return i.set({
                        label: e("Horizontal line"),
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>',
                        tooltip: !0
                    }), i.bind("isEnabled").to(o, "isEnabled"), this.listenTo(i, "execute", (() => {
                        t.execute("horizontalLine"), t.editing.view.focus()
                    })), i
                }))
            }
        }
        const qI = "removeFormat";
        class WI extends Vi {
            static get pluginName() {
                return "RemoveFormatUI"
            }
            init() {
                const t = this.editor,
                    e = t.t;
                t.ui.componentFactory.add(qI, (n => {
                    const o = t.commands.get(qI),
                        i = new Mg(n);
                    return i.set({
                        label: e("Remove Format"),
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>',
                        tooltip: !0
                    }), i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), this.listenTo(i, "execute", (() => {
                        t.execute(qI), t.editing.view.focus()
                    })), i
                }))
            }
        }
        class UI extends Fi {
            refresh() {
                const t = this.editor.model;
                this.isEnabled = !!Ei(this._getFormattingItems(t.document.selection, t.schema))
            }
            execute() {
                const t = this.editor.model,
                    e = t.schema;
                t.change((n => {
                    for (const o of this._getFormattingItems(t.document.selection, e))
                        if (o.is("selection"))
                            for (const t of this._getFormattingAttributes(o, e)) n.removeSelectionAttribute(t);
                        else {
                            const t = n.createRangeOn(o);
                            for (const i of this._getFormattingAttributes(o, e)) n.removeAttribute(i, t)
                        }
                }))
            }* _getFormattingItems(t, e) {
                const n = t => !!Ei(this._getFormattingAttributes(t, e));
                for (const o of t.getRanges())
                    for (const t of o.getItems()) !e.isBlock(t) && n(t) && (yield t);
                for (const e of t.getSelectedBlocks()) n(e) && (yield e);
                n(t) && (yield t)
            }* _getFormattingAttributes(t, e) {
                for (const [n] of t.getAttributes()) {
                    const t = e.getAttributeProperties(n);
                    t && t.isFormatting && (yield n)
                }
            }
        }
        class $I extends Vi {
            static get pluginName() {
                return "RemoveFormatEditing"
            }
            init() {
                const t = this.editor;
                t.commands.add("removeFormat", new UI(t))
            }
        }
        class GI extends Fi {
            refresh() {
                this.isEnabled = !0
            }
            execute(t) {
                const e = this.editor,
                    n = e.model,
                    o = e.plugins.get(Ob);
                n.change((e => {
                    const i = t.file;
                    for (const t of i) KI(e, n, o, t)
                }))
            }
        }

        function KI(t, e, n, o) {
            const i = n.createLoader(o);
            i && function(t, e, n = {}, o) {
                const i = t.createElement("reference", n);
                e.insertContent(i, e.document.selection), t.insertText(" ", i, "after")
            }(t, e, {
                href: "",
                uploadId: i.id
            })
        }
        class ZI extends Vi {
            static get requires() {
                return [Ob, zf, HA]
            }
            static get pluginName() {
                return "FileUploadEditing"
            }
            init() {
                const t = this.editor,
                    e = t.model.document,
                    n = t.conversion,
                    o = t.plugins.get(Ob);
                t.commands.add("fileUpload", new GI(t)), n.for("upcast").attributeToAttribute({
                    view: {
                        name: "a",
                        key: "uploadId"
                    },
                    model: "uploadId"
                }), this.listenTo(t.editing.view.document, "clipboardInput", ((e, n) => {
                    if (o = n.dataTransfer, Array.from(o.types).includes("text/html") && "" !== o.getData("text/html")) return;
                    var o;
                    if (!n.targetRanges) return;
                    const i = Array.from(n.dataTransfer.files),
                        r = n.targetRanges.map((e => t.editing.mapper.toModelRange(e))) ?? [];
                    t.model.change((n => {
                        n.setSelection(r), i.length && (e.stop(), t.model.enqueueChange("default", (() => {
                            t.execute("fileUpload", {
                                file: i
                            })
                        })))
                    }))
                })), this.listenTo(t.plugins.get(HA), "inputTransformation", ((e, n) => {
                    const i = Array.from(t.editing.view.createRangeIn(n.content)).filter((t => function(t) {
                        if (!t.is("element", "a") || !t.getAttribute("href")) return !1;
                        return t.getAttribute("href")
                    }(t.item) && !t.item.getAttribute("uploadProcessed"))).map((t => {
                        return {
                            promise: (e = t.item, new Promise(((t, n) => {
                                const o = e.getAttribute("href");
                                fetch(o).then((t => t.blob())).then((e => {
                                    const i = function(t, e) {
                                            if (t.type) return t.type;
                                            if (e.match(/data:(image\/\w+);base64/)) return e.match(/data:(image\/\w+);base64/)[1].toLowerCase();
                                            throw new Error("Could not retrieve mime type for file.")
                                        }(e, o),
                                        r = i.replace("file/", ""),
                                        s = `file.${r}`,
                                        a = function(t, e, n) {
                                            try {
                                                return new File([t], e, {
                                                    type: n
                                                })
                                            } catch (t) {
                                                return null
                                            }
                                        }(e, s, i);
                                    a ? t(a) : n()
                                })).catch(n)
                            }))),
                            fileElement: t.item
                        };
                        var e
                    }));
                    if (!i.length) return;
                    const r = new cu;
                    for (const t of i) {
                        r.setAttribute("uploadProcessed", !0, t.fileElement);
                        const e = o.createLoader(t.promise);
                        e && (r.setAttribute("href", "", t.fileElement), r.setAttribute("uploadId", e.id, t.fileElement))
                    }
                })), t.editing.view.document.on("dragover", ((t, e) => {
                    e.preventDefault()
                })), e.on("change", (() => {
                    const n = e.differ.getChanges({
                        includeChangesInGraveyard: !0
                    });
                    for (const e of n)
                        if ("insert" == e.type) {
                            const n = e.position.nodeAfter;
                            if (n) {
                                const i = "$graveyard" == e.position.root.rootName;
                                for (const e of JI(t, n)) {
                                    const t = e.getAttribute("uploadId");
                                    if (!t) continue;
                                    const n = o.loaders.get(t);
                                    n && (i ? n.abort() : "idle" == n.status && this._readAndUpload(n, e))
                                }
                            }
                        }
                }))
            }
            _readAndUpload(t, e) {
                const n = this.editor,
                    o = n.model,
                    i = n.locale.t,
                    r = n.plugins.get(Ob),
                    s = n.plugins.get(zf);
                return o.enqueueChange("transparent", (t => {
                    t.setAttribute("uploadStatus", "reading", e)
                })), t.read().then((() => {
                    const n = t.upload();
                    return o.enqueueChange("transparent", (t => {
                        t.setAttribute("uploadStatus", "uploading", e)
                    })), n
                })).then((t => (o.enqueueChange("transparent", (n => {
                    n.setAttributes({
                        uploadStatus: "complete",
                        href: t.default
                    }, e)
                })), a(), new Promise((t => setTimeout(t, 100)))))).then((() => {
                    n.setData(n.getData())
                })).catch((n => {
                    if ("error" !== t.status && "aborted" !== t.status) throw n;
                    "error" == t.status && n && s.showWarning(n, {
                        title: i("Upload failed"),
                        namespace: "upload"
                    }), a(), o.enqueueChange("transparent", (t => {
                        t.remove(e)
                    }))
                }));

                function a() {
                    o.enqueueChange("transparent", (t => {
                        t.removeAttribute("uploadId", e), t.removeAttribute("uploadStatus", e)
                    })), r.destroyLoader(t)
                }
            }
        }

        function JI(t, e) {
            return Array.from(t.model.createRangeOn(e)).filter((t => t.item.hasAttribute("href"))).map((t => t.item))
        }

        function YI(t) {
            return t.match(/^(\\\[.*?\\\]|\\\(.*?\\\))$/)
        }

        function QI(t) {
            const e = (t = t.trim()).includes("\\(") && t.includes("\\)"),
                n = t.includes("\\[") && t.includes("\\]");
            return (e || n) && (t = t.substring(2, t.length - 2).trim()), {
                equation: t,
                display: n
            }
        }
        async function XI(t, e, n = "katex", o, i = !1, r = !1, s, a = [], l = {}) {
            if ("mathjax" === n && "undefined" != typeof MathJax) ! function(t) {
                return t && "string" == typeof t && 3 === t.split(".").length && "3" === t.split(".")[0]
            }(MathJax.version) ? eP(e, r, s, a, (n => {
                Po.window.setTimeout((() => {
                    ! function(t, e, n) {
                        e.innerHTML = n ? "\\[" + t + "\\]" : "\\(" + t + "\\)";
                        MathJax.Hub.Queue(["Typeset", MathJax.Hub, e])
                    }(t, n, i), r && MathJax.Hub.Queue((() => {
                        nP(e, n), n.style.visibility = "visible"
                    }))
                }))
            })) : eP(e, r, s, a, (n => {
                ! function(t, e, n, o) {
                    let i;
                    void 0 !== MathJax.tex2chtmlPromise ? i = MathJax.tex2chtmlPromise : void 0 !== MathJax.tex2svgPromise && (i = MathJax.tex2svgPromise);
                    void 0 !== i && i(t, {
                        display: n
                    }).then((t => {
                        e.firstChild && e.removeChild(e.firstChild), e.appendChild(t), o()
                    }))
                }(t, n, i, (() => {
                    r && (nP(e, n), n.style.visibility = "visible")
                }))
            }));
            else if ("katex" === n && "undefined" != typeof katex) eP(e, r, s, a, (n => {
                katex.render(t, n, {
                    throwOnError: !1,
                    displayMode: i,
                    ...l
                }), r && (nP(e, n), n.style.visibility = "visible")
            }));
            else if ("function" == typeof n) n(t, e, i);
            else if (void 0 !== o) try {
                Po.window.CKEDITOR_MATH_LAZY_LOAD || (Po.window.CKEDITOR_MATH_LAZY_LOAD = o()), e.innerHTML = t, await Po.window.CKEDITOR_MATH_LAZY_LOAD, XI(t, e, n, void 0, i, r, s, a, l)
            } catch (n) {
                e.innerHTML = t, console.error(`math-tex-typesetting-lazy-load-failed: Lazy load failed: ${n}`)
            } else e.innerHTML = t, console.warn(`math-tex-typesetting-missing: Missing the mathematical typesetting engine (${n}) for tex.`)
        }

        function tP(t) {
            const e = t.editing.view,
                n = Kp.defaultPositions,
                o = e.document.selection.getSelectedElement();
            if (o) return {
                target: e.domConverter.viewToDom(o),
                positions: [n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast]
            };
            {
                const t = e.document;
                return {
                    target: e.domConverter.viewRangeToDom(t.selection.getFirstRange()),
                    positions: [n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast]
                }
            }
        }

        function eP(t, e, n, o, i) {
            e ? function(t, e, n, o) {
                const i = function(t, e, n) {
                    let o = Po.document.getElementById(e);
                    if (!o) {
                        o = Po.document.createElement("div"), o.setAttribute("id", e), o.classList.add(...n), o.style.visibility = "hidden", Po.document.body.appendChild(o);
                        let i = !1;
                        const r = () => {
                            i || (Po.window.requestAnimationFrame((() => {
                                oP(t, o), i = !1
                            })), i = !0)
                        };
                        Po.window.addEventListener("resize", r), Po.window.addEventListener("scroll", r)
                    }
                    return o
                }(t, e, n);
                o(i)
            }(t, n, o, (t => {
                i(t)
            })) : i(t)
        }

        function nP(t, e) {
            oP(t, e);
            const n = e.getBoundingClientRect();
            t.style.width = n.width + "px", t.style.height = n.height + "px"
        }

        function oP(t, e) {
            const n = t.getBoundingClientRect(),
                o = Po.window.scrollX + n.left,
                i = Po.window.scrollY + n.top;
            e.style.position = "absolute", e.style.left = o + "px", e.style.top = i + "px", e.style.zIndex = "var(--ck-z-modal)", e.style.pointerEvents = "none"
        }
        class iP extends Fi {
            execute(t, e, n, o) {
                const i = this.editor.model,
                    r = i.document.selection.getSelectedElement();
                i.change((s => {
                    let a;
                    if (r && (r.is("element", "mathtex-inline") || r.is("element", "mathtex-display"))) {
                        const i = r.getAttribute("type"),
                            l = o ? n : i || n;
                        a = s.createElement(e ? "mathtex-display" : "mathtex-inline", {
                            equation: t,
                            type: l,
                            display: e
                        })
                    } else a = s.createElement(e ? "mathtex-display" : "mathtex-inline", {
                        equation: t,
                        type: n,
                        display: e
                    });
                    i.insertContent(a)
                }))
            }
            refresh() {
                const t = this.editor.model.document.selection,
                    e = t.getSelectedElement();
                this.isEnabled = null === e || e.is("element", "mathtex-inline") || e.is("element", "mathtex-display");
                const n = function(t) {
                    const e = t.getSelectedElement();
                    return e && (e.is("element", "mathtex-inline") || e.is("element", "mathtex-display")) ? e : null
                }(t);
                this.value = n ? n.getAttribute("equation") : null, this.display = n ? n.getAttribute("display") : null
            }
        }
        class rP extends Vi {
            static get requires() {
                return [pA]
            }
            static get pluginName() {
                return "MathEditing"
            }
            constructor(t) {
                super(t), t.config.define("math", {
                    engine: "mathjax",
                    outputType: "script",
                    className: "math-tex",
                    forceOutputType: !1,
                    enablePreview: !0,
                    previewClassName: [],
                    popupClassName: [],
                    katexRenderOptions: {}
                })
            }
            init() {
                const t = this.editor;
                t.commands.add("math", new iP(t)), this._defineSchema(), this._defineConverters(), t.editing.mapper.on("viewToModelPosition", Xw(t.model, (t => t.hasClass("math"))))
            }
            _defineSchema() {
                const t = this.editor.model.schema;
                t.register("mathtex-inline", {
                    allowWhere: "$text",
                    isInline: !0,
                    isObject: !0,
                    allowAttributes: ["equation", "type", "display"]
                }), t.register("mathtex-display", {
                    allowWhere: "$block",
                    isInline: !1,
                    isObject: !0,
                    allowAttributes: ["equation", "type", "display"]
                })
            }
            _defineConverters() {
                const t = this.editor.conversion,
                    e = this.editor.config.get("math");

                function n(t, n) {
                    const o = t.getAttribute("equation"),
                        i = t.getAttribute("display"),
                        r = "user-select: none; " + (i ? "" : "display: inline-block;"),
                        s = "ck-math-tex " + (i ? "ck-math-tex-display" : "ck-math-tex-inline"),
                        a = n.createContainerElement(i ? "div" : "span", {
                            style: r,
                            class: s
                        }),
                        l = n.createUIElement("div", null, (function(t) {
                            const n = this.toDomElement(t);
                            return XI(o, n, e.engine, e.lazyLoad, i, !1, e.previewClassName, null, e.katexRenderOptions), n
                        }));
                    return n.insert(n.createPositionAt(a, 0), l), a
                }

                function o(t, {
                    writer: n
                }) {
                    const o = t.getAttribute("equation"),
                        i = t.getAttribute("type"),
                        r = t.getAttribute("display");
                    if ("span" === i) {
                        const t = n.createContainerElement("span", {
                            class: e.className
                        });
                        return r ? n.insert(n.createPositionAt(t, 0), n.createText("\\[" + o + "\\]")) : n.insert(n.createPositionAt(t, 0), n.createText("\\(" + o + "\\)")), t
                    } {
                        const t = n.createContainerElement("script", {
                            type: r ? "math/tex; mode=display" : "math/tex"
                        });
                        return n.insert(n.createPositionAt(t, 0), n.createText(o)), t
                    }
                }
                t.for("upcast").elementToElement({
                    view: {
                        name: "script",
                        attributes: {
                            type: "math/tex"
                        }
                    },
                    model: (t, {
                        writer: n
                    }) => {
                        const o = t.getChild(0).data.trim();
                        return n.createElement("mathtex-inline", {
                            equation: o,
                            type: e.forceOutputType ? e.outputType : "script",
                            display: !1
                        })
                    }
                }).elementToElement({
                    view: {
                        name: "script",
                        attributes: {
                            type: "math/tex; mode=display"
                        }
                    },
                    model: (t, {
                        writer: n
                    }) => {
                        const o = t.getChild(0).data.trim();
                        return n.createElement("mathtex-display", {
                            equation: o,
                            type: e.forceOutputType ? e.outputType : "script",
                            display: !0
                        })
                    }
                }).elementToElement({
                    view: {
                        name: "span",
                        classes: [e.className]
                    },
                    model: (t, {
                        writer: n
                    }) => {
                        const o = t.getChild(0).data.trim(),
                            i = Object.assign(QI(o), {
                                type: e.forceOutputType ? e.outputType : "span"
                            });
                        return n.createElement(i.display ? "mathtex-display" : "mathtex-inline", i)
                    }
                }).elementToElement({
                    view: {
                        name: "span",
                        classes: ["ql-formula"]
                    },
                    model: (t, {
                        writer: n
                    }) => {
                        const o = t.getAttribute("data-value").trim();
                        return n.createElement("mathtex-inline", {
                            equation: o,
                            type: e.forceOutputType ? e.outputType : "script",
                            display: !1
                        })
                    }
                }), t.for("editingDowncast").elementToElement({
                    model: "mathtex-inline",
                    view: (t, {
                        writer: e
                    }) => Gw(n(t, e), e, "span")
                }).elementToElement({
                    model: "mathtex-display",
                    view: (t, {
                        writer: e
                    }) => Gw(n(t, e), e, "div")
                }), t.for("dataDowncast").elementToElement({
                    model: "mathtex-inline",
                    view: o
                }).elementToElement({
                    model: "mathtex-display",
                    view: o
                })
            }
        }
        class sP extends cg {
            constructor(t, e, n, o, i, r) {
                super(n), this.engine = t, this.lazyLoad = e, this.previewUid = o, this.katexRenderOptions = r, this.previewClassName = i, this.set("value", ""), this.set("display", !1), this.on("change", (() => {
                    this.isRendered && this.updateMath()
                })), this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-math-preview"]
                    }
                })
            }
            updateMath() {
                XI(this.value, this.element, this.engine, this.lazyLoad, this.display, !0, this.previewUid, this.previewClassName, this.katexRenderOptions)
            }
            render() {
                super.render(), this.updateMath()
            }
        }
        var aP = n(6299),
            lP = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(aP.Z, lP);
        aP.Z.locals;
        const {
            check: cP,
            cancel: dP
        } = eg;
        class hP extends cg {
            constructor(t, e, n, o, i, r, s, a) {
                super(t);
                const l = t.t;
                this._createKeyAndFocusTrackers(), this.saveButtonView = this._createButton(l("Save"), cP, "ck-button-save", null), this.saveButtonView.type = "submit", this.mathInputView = this._createMathInput(), this.displayButtonView = this._createDisplayButton(), this.cancelButtonView = this._createButton(l("Cancel"), dP, "ck-button-cancel", "cancel"), this.previewEnabled = o;
                let c = [];
                this.previewEnabled ? (this.previewLabel = new om(t), this.previewLabel.text = l("Equation preview"), this.mathView = new sP(e, n, t, i, r, a), this.mathView.bind("display").to(this.displayButtonView, "isOn"), c = [this.mathInputView, this.displayButtonView, this.previewLabel, this.mathView]) : c = [this.mathInputView, this.displayButtonView], this.setTemplate({
                    tag: "form",
                    attributes: {
                        class: ["ck", "ck-math-form", ...s],
                        tabindex: "-1",
                        spellcheck: "false"
                    },
                    children: [{
                        tag: "div",
                        attributes: {
                            class: ["ck-math-view"]
                        },
                        children: c
                    }, this.saveButtonView, this.cancelButtonView]
                })
            }
            render() {
                super.render(), ig({
                    view: this
                });
                [this.mathInputView, this.displayButtonView, this.saveButtonView, this.cancelButtonView].forEach((t => {
                    this._focusables.add(t), this.focusTracker.add(t.element)
                })), this.keystrokes.listenTo(this.element)
            }
            focus() {
                this._focusCycler.focusFirst()
            }
            get equation() {
                return this.mathInputView.fieldView.element.value
            }
            set equation(t) {
                this.mathInputView.fieldView.element.value = t, this.previewEnabled && (this.mathView.value = t)
            }
            _createKeyAndFocusTrackers() {
                this.focusTracker = new Di, this.keystrokes = new Si, this._focusables = new sg, this._focusCycler = new wm({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: "shift + tab",
                        focusNext: "tab"
                    }
                })
            }
            _createMathInput() {
                const t = this.locale.t,
                    e = new sm(this.locale, Jm),
                    n = e.fieldView;
                e.infoText = t("Insert equation in TeX format.");
                const o = () => {
                    if (null != n.element) {
                        let t = n.element.value.trim();
                        if (YI(t)) {
                            const e = QI(t);
                            n.element.value = e.equation, t = e.equation, this.displayButtonView.isOn = e.display
                        }
                        this.previewEnabled && (this.mathView.value = t), this.saveButtonView.isEnabled = !!t
                    }
                };
                return n.on("render", o), n.on("input", o), e
            }
            _createButton(t, e, n, o) {
                const i = new Mg(this.locale);
                return i.set({
                    label: t,
                    icon: e,
                    tooltip: !0
                }), i.extendTemplate({
                    attributes: {
                        class: n
                    }
                }), o && i.delegate("execute").to(this, o), i
            }
            _createDisplayButton() {
                const t = this.locale.t,
                    e = new Hg(this.locale);
                return e.set({
                    label: t("Display mode"),
                    withText: !0
                }), e.extendTemplate({
                    attributes: {
                        class: "ck-button-display-toggle"
                    }
                }), e.on("execute", (() => {
                    e.isOn = !e.isOn, this.previewEnabled && (this.mathView.display = e.isOn)
                })), e
            }
        }
        const uP = "Ctrl+M";
        class gP extends Vi {
            static get requires() {
                return [jf, rP]
            }
            static get pluginName() {
                return "MathUI"
            }
            init() {
                const t = this.editor;
                t.editing.view.addObserver(au), this._previewUid = `math-preview-${g()}`, this.formView = this._createFormView(), this._balloon = t.plugins.get(jf), this._createToolbarMathButton(), this._enableUserBalloonInteractions()
            }
            destroy() {
                super.destroy(), this.formView.destroy();
                const t = Po.document.getElementById(this._previewUid);
                t && t.parentNode.removeChild(t)
            }
            _showUI() {
                this.editor.commands.get("math").isEnabled && (this._addFormView(), this._balloon.showStack("main"))
            }
            _createFormView() {
                const t = this.editor,
                    e = t.commands.get("math"),
                    n = t.config.get("math"),
                    o = new hP(t.locale, n.engine, n.lazyLoad, n.enablePreview, this._previewUid, n.previewClassName, n.popupClassName, n.katexRenderOptions);
                return o.mathInputView.bind("value").to(e, "value"), o.displayButtonView.bind("isOn").to(e, "display"), o.mathInputView.bind("isReadOnly").to(e, "isEnabled", (t => !t)), o.saveButtonView.bind("isEnabled").to(e), o.displayButtonView.bind("isEnabled").to(e), this.listenTo(o, "submit", (() => {
                    t.execute("math", o.equation, o.displayButtonView.isOn, n.outputType, n.forceOutputType), this._closeFormView()
                })), this.listenTo(o, "cancel", (() => {
                    this._closeFormView()
                })), o.keystrokes.set("esc", ((t, e) => {
                    this._closeFormView(), e()
                })), o
            }
            _addFormView() {
                if (this._isFormInPanel) return;
                const t = this.editor,
                    e = t.commands.get("math");
                this._balloon.add({
                    view: this.formView,
                    position: tP(t)
                }), this._balloon.visibleView === this.formView && this.formView.mathInputView.fieldView.element.select();
                Po.document.getElementById(this._previewUid) && this.formView.previewEnabled && this.formView.mathView.updateMath(), this.formView.equation = e.value || "", this.formView.displayButtonView.isOn = e.display || !1
            }
            _hideUI() {
                if (!this._isFormInPanel) return;
                const t = this.editor;
                this.stopListening(t.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), t.editing.view.focus(), this._removeFormView()
            }
            _closeFormView() {
                void 0 !== this.editor.commands.get("math").value ? this._removeFormView() : this._hideUI()
            }
            _removeFormView() {
                if (this._isFormInPanel) {
                    this.formView.saveButtonView.focus(), this._balloon.remove(this.formView);
                    const t = Po.document.getElementById(this._previewUid);
                    t && (t.style.visibility = "hidden"), this.editor.editing.view.focus()
                }
            }
            _createToolbarMathButton() {
                const t = this.editor,
                    e = t.commands.get("math"),
                    n = t.t;
                t.keystrokes.set(uP, ((t, n) => {
                    n(), e.isEnabled && this._showUI()
                })), this.editor.ui.componentFactory.add("math", (t => {
                    const o = new Mg(t);
                    return o.isEnabled = !0, o.label = n("Insert math"), o.icon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.44 10.78" height="40.74" width="58.35"><path d="M8.15 0c-.06 0-.1.02-.11.03a.12.12 0 0 0-.02.01 6.81 6.81 0 0 0-2.32 4.9v.9a6.82 6.82 0 0 0 2.32 4.9.12.12 0 0 0 .02 0c.02.02.06.04.11.04.07 0 .12-.03.16-.07a.22.22 0 0 0 0-.32.12.12 0 0 0-.02-.02A4.4 4.4 0 0 1 7 8.44a7.62 7.62 0 0 1-.5-2.6v-.9c0-.82.19-1.76.5-2.6A4.4 4.4 0 0 1 8.3.42.12.12 0 0 0 8.3.39a.22.22 0 0 0 .08-.16.22.22 0 0 0-.07-.16.22.22 0 0 0-.16-.07zm4.83 0a.22.22 0 0 0-.16.07.22.22 0 0 0-.07.16c0 .08.05.13.08.16a.12.12 0 0 0 .01.02c.52.39.98 1.1 1.3 1.94.3.83.49 1.77.49 2.6v.88c0 .83-.18 1.78-.5 2.6a4.4 4.4 0 0 1-1.29 1.95.22.22 0 0 0-.01.33c.03.04.08.07.15.07.05 0 .09-.02.12-.03a.12.12 0 0 0 .02-.01 6.82 6.82 0 0 0 2.32-4.9v-.9a6.81 6.81 0 0 0-2.32-4.9.12.12 0 0 0-.02 0c-.03-.02-.06-.04-.12-.04zm-8.5.46c-.4 0-1.13.23-1.46 1.32-.06.2-.11.45-.33 1.58h-.64c-.1 0-.19-.01-.28.03a.25.25 0 0 0-.12.12.38.38 0 0 0-.03.17c0 .04 0 .1.04.14.03.04.07.07.11.08.09.03.16.02.26.02h.56l-.77 4.04c-.1.51-.19 1-.32 1.36-.06.18-.14.32-.22.4-.08.1-.16.13-.26.13-.03 0-.1 0-.2-.03.11-.05.2-.13.26-.2a.7.7 0 0 0 .13-.4.48.48 0 0 0-.16-.38.53.53 0 0 0-.35-.12c-.34 0-.7.3-.7.76 0 .27.14.5.34.64s.44.2.68.2c.33 0 .61-.17.83-.4.21-.21.37-.48.47-.69.18-.35.32-.84.43-1.25a14.17 14.17 0 0 0 .18-.8l.61-3.26h.81c.1 0 .2.01.3-.03.04-.03.09-.07.11-.13.02-.05.03-.1.03-.17 0-.05-.01-.1-.05-.14a.23.23 0 0 0-.11-.07c-.08-.03-.16-.02-.25-.02h-.73l.2-1.07a26.3 26.3 0 0 1 .24-1.07c.08-.17.22-.3.39-.3l.21.05a.7.7 0 0 0-.25.2.7.7 0 0 0-.13.4c0 .15.06.28.16.37.1.08.22.12.35.12.34 0 .7-.3.7-.76 0-.28-.15-.5-.35-.64-.2-.14-.45-.2-.7-.2zm5.4 2.78c-.6 0-1.06.37-1.36.76-.16.2-.27.4-.35.57-.07.18-.12.3-.12.42 0 .1.08.18.14.2.06.03.1.02.1.02.06 0 .12 0 .18-.04.05-.05.07-.1.08-.17v.02c.35-1.09 1-1.3 1.3-1.3.09 0 .2.01.29.09.09.07.17.2.17.5 0 .27-.18 1-.57 2.48a1.8 1.8 0 0 1-.37.75.7.7 0 0 1-.52.26c-.04 0-.13 0-.22-.03a.68.68 0 0 0 .3-.56.47.47 0 0 0-.18-.39.55.55 0 0 0-.32-.1c-.4 0-.7.33-.7.74 0 .28.16.5.38.63.21.13.48.18.73.18.39 0 .69-.2.89-.41.09-.1.15-.19.2-.27.2.36.59.68 1.16.68.6 0 1.05-.37 1.35-.76.15-.2.27-.4.34-.57.08-.18.12-.3.12-.42a.24.24 0 0 0-.11-.2c-.06-.03-.12-.02-.13-.02a.26.26 0 0 0-.18.06c-.05.05-.06.1-.07.14-.34 1.1-1.02 1.3-1.3 1.3-.17 0-.27-.06-.35-.17a.72.72 0 0 1-.11-.4c0-.22.06-.45.18-.91l.36-1.45c.03-.14.1-.44.25-.7.15-.25.36-.46.68-.46.03 0 .12 0 .22.03a.7.7 0 0 0-.32.56c0 .11.04.23.13.33.08.1.22.16.4.16.14 0 .3-.06.44-.18a.73.73 0 0 0 .24-.55c0-.32-.2-.54-.42-.66a1.52 1.52 0 0 0-.68-.16c-.34 0-.62.16-.82.34a1.8 1.8 0 0 0-.3.35 1.32 1.32 0 0 0-.5-.54 1.37 1.37 0 0 0-.63-.15z" style="line-height:1.25;-inkscape-font-specification:\'Latin Modern Math\'" font-weight="400" font-size="10.58" font-family="Latin Modern Math" letter-spacing="-1.06" word-spacing="0"/></svg>\n', o.keystroke = uP, o.tooltip = !0, o.isToggleable = !0, o.bind("isEnabled").to(e, "isEnabled"), this.listenTo(o, "execute", (() => this._showUI())), o
                }))
            }
            _enableUserBalloonInteractions() {
                const t = this.editor,
                    e = this.editor.editing.view.document;
                this.listenTo(e, "click", (() => {
                    const e = t.commands.get("math");
                    e.value && e.isEnabled && this._showUI()
                })), t.keystrokes.set("Esc", ((t, e) => {
                    this._isUIVisible && (this._hideUI(), e())
                })), ng({
                    emitter: this.formView,
                    activator: () => this._isFormInPanel,
                    contextElements: [this._balloon.view.element],
                    callback: () => this._hideUI()
                })
            }
            get _isUIVisible() {
                return this._balloon.visibleView == this.formView
            }
            get _isFormInPanel() {
                return this._balloon.hasView(this.formView)
            }
        }
        class mP extends Vi {
            static get requires() {
                return [HA, nC]
            }
            static get pluginName() {
                return "AutoMath"
            }
            constructor(t) {
                super(t), this._timeoutId = null, this._positionToInsert = null
            }
            init() {
                const t = this.editor,
                    e = t.model.document;
                this.listenTo(t.plugins.get(HA), "inputTransformation", (() => {
                    const t = e.selection.getFirstRange(),
                        n = th.fromPosition(t.start);
                    n.stickiness = "toPrevious";
                    const o = th.fromPosition(t.end);
                    o.stickiness = "toNext", e.once("change:data", (() => {
                        this._mathBetweenPositions(n, o), n.detach(), o.detach()
                    }), {
                        priority: "high"
                    })
                })), t.commands.get("undo").on("execute", (() => {
                    this._timeoutId && (Po.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null)
                }), {
                    priority: "high"
                })
            }
            _mathBetweenPositions(t, e) {
                const n = this.editor,
                    o = this.editor.config.get("math"),
                    i = new ec(t, e),
                    r = i.getWalker({
                        ignoreElementEnd: !0
                    });
                let s = "";
                for (const t of r) t.item.is("$textProxy") && (s += t.item.data);
                if (s = s.trim(), !YI(s) || 2 !== function(t) {
                        return t.match(/(\\\[|\\\]|\\\(|\\\))/g).length
                    }(s)) return;
                n.commands.get("math").isEnabled && (this._positionToInsert = th.fromPosition(t), this._timeoutId = Po.window.setTimeout((() => {
                    n.model.change((t => {
                        let e;
                        this._timeoutId = null, t.remove(i), "$graveyard" !== this._positionToInsert.root.rootName && (e = this._positionToInsert), n.model.change((t => {
                            const i = Object.assign(QI(s), {
                                    type: o.outputType
                                }),
                                r = t.createElement(i.display ? "mathtex-display" : "mathtex-inline", i);
                            n.model.insertContent(r, e), t.setSelection(r, "on")
                        })), this._positionToInsert.detach(), this._positionToInsert = null
                    }))
                }), 100))
            }
        }
        class pP extends Vi {
            static get requires() {
                return [rP, gP, mP, pA]
            }
            static get pluginName() {
                return "Math"
            }
        }
        class fP extends Fi {
            execute(t) {
                const {
                    model: e
                } = this.editor, {
                    document: n
                } = e, {
                    selection: o
                } = n, {
                    mention: i
                } = t, r = t.range || o.getFirstRange();
                if (i.id.startsWith("#") || i.id.startsWith("~")) e.change((t => {
                    e.insertContent(t.createText(i.id, {}), r)
                }));
                else if ("create-note" === i.action) {
                    const t = this.editor.editing.view.getDomRoot();
                    glob.getComponentByEl(t).createNoteForReferenceLink(i.noteTitle).then((t => {
                        this.insertReference(r, t)
                    }))
                } else this.insertReference(r, t.mention.notePath)
            }
            insertReference(t, e) {
                const {
                    model: n
                } = this.editor;
                n.change((o => {
                    n.insertContent(o.createText("", {}), t), this.editor.execute("referenceLink", {
                        href: "#" + e
                    })
                }))
            }
        }
        class bP {
            constructor(t) {
                this.loader = t
            }
            upload() {
                return this.loader.file.then((t => new Promise(((e, n) => {
                    this._initRequest().then((() => {
                        this._initListeners(e, n, t), this._sendRequest(t)
                    }))
                }))))
            }
            abort() {
                this.xhr && this.xhr.abort()
            }
            _initRequest() {
                return glob.getHeaders().then((t => {
                    const e = this.xhr = new XMLHttpRequest,
                        {
                            noteId: n
                        } = glob.getActiveContextNote(),
                        o = `api/notes/${n}/attachments/upload`;
                    e.open("POST", o, !0), e.responseType = "json";
                    for (const n in t) e.setRequestHeader(n, t[n])
                }))
            }
            async _initListeners(t, e) {
                const n = this.xhr,
                    o = this.loader,
                    i = `Cannot upload file: ${(await o.file).name}.`;
                n.addEventListener("error", (() => e(i))), n.addEventListener("abort", (() => e())), n.addEventListener("load", (() => {
                    const o = n.response;
                    if (!o || !o.uploaded) return e(o && o.error && o.error.message ? o.error.message : i);
                    t({
                        default: o.url
                    })
                })), n.upload && n.upload.addEventListener("progress", (t => {
                    t.lengthComputable && (o.uploadTotal = t.total, o.uploaded = t.loaded)
                }))
            }
            async _sendRequest() {
                const t = new FormData;
                t.append("upload", await this.loader.file), this.xhr.send(t)
            }
        }
        class kP extends Vi {
            init() {
                const t = this.editor,
                    e = t.t;
                t.ui.componentFactory.add("includeNote", (n => {
                    const o = t.commands.get("insertIncludeNote"),
                        i = new Mg(n);
                    return i.set({
                        label: e("Include note"),
                        icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19,3H5C3.897,3,3,3.897,3,5v14c0,1.103,0.897,2,2,2h8c0.131,0,0.26-0.026,0.381-0.076s0.232-0.123,0.326-0.217l7-7 c0.086-0.086,0.147-0.187,0.196-0.293c0.014-0.03,0.022-0.061,0.033-0.093c0.028-0.084,0.046-0.17,0.051-0.259 C20.989,13.041,21,13.021,21,13V5C21,3.897,20.103,3,19,3z M5,5h14v7h-6c-0.553,0-1,0.448-1,1v6H5V5z M14,17.586V14h3.586 L14,17.586z"/></svg>',
                        tooltip: !0
                    }), i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), this.listenTo(i, "execute", (() => t.execute("insertIncludeNote"))), i
                }))
            }
        }
        class wP extends Vi {
            static get requires() {
                return [pA]
            }
            init() {
                this._defineSchema(), this._defineConverters(), this.editor.commands.add("insertIncludeNote", new AP(this.editor))
            }
            _defineSchema() {
                this.editor.model.schema.register("includeNote", {
                    isObject: !0,
                    allowAttributes: ["noteId", "boxSize"],
                    allowWhere: "$block"
                })
            }
            _defineConverters() {
                const t = this.editor,
                    e = t.conversion;
                e.for("upcast").elementToElement({
                    model: (t, {
                        writer: e
                    }) => e.createElement("includeNote", {
                        noteId: t.getAttribute("data-note-id"),
                        boxSize: t.getAttribute("data-box-size")
                    }),
                    view: {
                        name: "section",
                        classes: "include-note"
                    }
                }), e.for("dataDowncast").elementToElement({
                    model: "includeNote",
                    view: (t, {
                        writer: e
                    }) => e.createContainerElement("section", {
                        class: "include-note",
                        "data-note-id": t.getAttribute("noteId"),
                        "data-box-size": t.getAttribute("boxSize")
                    })
                }), e.for("editingDowncast").elementToElement({
                    model: "includeNote",
                    view: (e, {
                        writer: n
                    }) => {
                        const o = e.getAttribute("noteId"),
                            i = e.getAttribute("boxSize"),
                            r = n.createContainerElement("section", {
                                class: "include-note box-size-" + i,
                                "data-note-id": o,
                                "data-box-size": i
                            }),
                            s = n.createUIElement("div", {
                                class: "include-note-wrapper"
                            }, (function(e) {
                                const n = this.toDomElement(e),
                                    i = t.editing.view.getDomRoot();
                                return glob.getComponentByEl(i).loadIncludedNote(o, $(n)),
                                    function(t, e) {
                                        function n(t) {
                                            t.stopPropagation(), e.editing.view._renderer.isFocused = !1
                                        }
                                        t.addEventListener("mousedown", n, {
                                            capture: !0
                                        }), t.addEventListener("focus", n, {
                                            capture: !0
                                        }), t.addEventListener("keydown", n, {
                                            capture: !0
                                        })
                                    }(n, t), n
                            }));
                        return n.insert(n.createPositionAt(r, 0), s), Gw(r, n, {
                            label: "include note widget"
                        })
                    }
                })
            }
        }
        class AP extends Fi {
            execute() {
                const t = this.editor.editing.view.getDomRoot();
                glob.getComponentByEl(t).triggerCommand("addIncludeNoteToText")
            }
            refresh() {
                const t = this.editor.model,
                    e = t.document.selection,
                    n = t.schema.findAllowedParent(e.getFirstPosition(), "includeNote");
                this.isEnabled = null !== n
            }
        }
        class CP extends Fi {
            execute({
                href: t
            }) {
                if (!t?.trim()) return;
                const e = this.editor;
                glob.getReferenceLinkTitle(t).then((() => {
                    e.model.change((n => {
                        const o = n.createElement("reference", {
                            href: t
                        });
                        e.model.insertContent(o), n.setSelection(o, "after")
                    }))
                }))
            }
            refresh() {
                const t = this.editor.model,
                    e = t.document.selection;
                this.isEnabled = t.schema.checkChild(e.focus.parent, "reference")
            }
        }
        class _P extends Vi {
            static get requires() {
                return [pA]
            }
            init() {
                this._defineSchema(), this._defineConverters(), this.editor.commands.add("referenceLink", new CP(this.editor)), this.editor.editing.mapper.on("viewToModelPosition", Xw(this.editor.model, (t => t.hasClass("reference-link"))))
            }
            _defineSchema() {
                this.editor.model.schema.register("reference", {
                    allowWhere: "$text",
                    isInline: !0,
                    isObject: !0,
                    allowAttributes: ["href", "uploadId", "uploadStatus"]
                })
            }
            _defineConverters() {
                const t = this.editor,
                    e = t.conversion;
                e.for("upcast").elementToElement({
                    view: {
                        name: "a",
                        classes: ["reference-link"]
                    },
                    model: (t, {
                        writer: e
                    }) => {
                        const n = t.getAttribute("href");
                        return e.createElement("reference", {
                            href: n
                        })
                    }
                }), e.for("editingDowncast").elementToElement({
                    model: "reference",
                    view: (e, {
                        writer: n
                    }) => {
                        const o = e.getAttribute("href"),
                            i = n.createContainerElement("a", {
                                href: o,
                                class: "reference-link"
                            }, {
                                renderUnsafeAttributes: ["href"]
                            }),
                            r = n.createUIElement("span", {}, (function(e) {
                                const n = this.toDomElement(e),
                                    i = t.editing.view.getDomRoot();
                                return glob.getComponentByEl(i).loadReferenceLinkTitle($(n), o), n
                            }));
                        return n.insert(n.createPositionAt(i, 0), r), Gw(i, n)
                    }
                }), e.for("dataDowncast").elementToElement({
                    model: "reference",
                    view: (t, {
                        writer: e
                    }) => {
                        const n = t.getAttribute("href"),
                            o = e.createContainerElement("a", {
                                href: n,
                                class: "reference-link"
                            }),
                            i = glob.getReferenceLinkTitleSync(n),
                            r = e.createText(i);
                        return e.insert(e.createPositionAt(o, 0), r), o
                    }
                })
            }
        }
        var vP = n(7657),
            yP = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
        Ui()(vP.Z, yP);
        vP.Z.locals;
        window.EditorWatchdog = sb;
        class xP extends ub {}
        xP.builtinPlugins = [HA, aw, FI, hw, class extends Vi {
            static get requires() {
                return [Kb, ok]
            }
            static get pluginName() {
                return "Typing"
            }
        }, nC, class extends Vi {
            static get requires() {
                return [Ob]
            }
            static get pluginName() {
                return "CKFinderUploadAdapter"
            }
            init() {
                const t = this.editor.config.get("ckfinder.uploadUrl");
                t && (this.editor.plugins.get(Ob).createUploadAdapter = e => new qb(e, t, this.editor.t))
            }
        }, class extends Vi {
            static get requires() {
                return [ok]
            }
            static get pluginName() {
                return "Autoformat"
            }
            afterInit() {
                this._addListAutoformats(), this._addBasicStylesAutoformats(), this._addHeadingAutoformats(), this._addBlockQuoteAutoformats(), this._addCodeBlockAutoformats(), this._addHorizontalLineAutoformats()
            }
            _addListAutoformats() {
                const t = this.editor.commands;
                t.get("bulletedList") && Ck(this.editor, this, /^[*-]\s$/, "bulletedList"), t.get("numberedList") && Ck(this.editor, this, /^1[.|)]\s$/, "numberedList"), t.get("todoList") && Ck(this.editor, this, /^\[\s?\]\s$/, "todoList"), t.get("checkTodoList") && Ck(this.editor, this, /^\[\s?x\s?\]\s$/, (() => {
                    this.editor.execute("todoList"), this.editor.execute("checkTodoList")
                }))
            }
            _addBasicStylesAutoformats() {
                const t = this.editor.commands;
                if (t.get("bold")) {
                    const t = yk(this.editor, "bold");
                    _k(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t), _k(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t)
                }
                if (t.get("italic")) {
                    const t = yk(this.editor, "italic");
                    _k(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t), _k(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t)
                }
                if (t.get("code")) {
                    const t = yk(this.editor, "code");
                    _k(this.editor, this, /(`)([^`]+)(`)$/g, t)
                }
                if (t.get("strikethrough")) {
                    const t = yk(this.editor, "strikethrough");
                    _k(this.editor, this, /(~~)([^~]+)(~~)$/g, t)
                }
            }
            _addHeadingAutoformats() {
                const t = this.editor.commands.get("heading");
                t && t.modelElements.filter((t => t.match(/^heading[1-6]$/))).forEach((e => {
                    const n = e[7],
                        o = new RegExp(`^(#{${n}})\\s$`);
                    Ck(this.editor, this, o, (() => {
                        if (!t.isEnabled || t.value === e) return !1;
                        this.editor.execute("heading", {
                            value: e
                        })
                    }))
                }))
            }
            _addBlockQuoteAutoformats() {
                this.editor.commands.get("blockQuote") && Ck(this.editor, this, /^>\s$/, "blockQuote")
            }
            _addCodeBlockAutoformats() {
                const t = this.editor,
                    e = t.model.document.selection;
                t.commands.get("codeBlock") && Ck(t, this, /^```$/, (() => {
                    if (e.getFirstPosition().parent.is("element", "listItem")) return !1;
                    this.editor.execute("codeBlock", {
                        usePreviousLanguageChoice: !0
                    })
                }))
            }
            _addHorizontalLineAutoformats() {
                this.editor.commands.get("horizontalLine") && Ck(this.editor, this, /^---$/, "horizontalLine")
            }
        }, class extends Vi {
            static get requires() {
                return [Dk, Tk]
            }
            static get pluginName() {
                return "Bold"
            }
        }, class extends Vi {
            static get requires() {
                return [Fk, Nk]
            }
            static get pluginName() {
                return "Italic"
            }
        }, class extends Vi {
            static get requires() {
                return [Xk, ew]
            }
            static get pluginName() {
                return "Underline"
            }
        }, class extends Vi {
            static get requires() {
                return [Hk, qk]
            }
            static get pluginName() {
                return "Strikethrough"
            }
        }, class extends Vi {
            static get requires() {
                return [Ik, Vk]
            }
            static get pluginName() {
                return "Code"
            }
        }, class extends Vi {
            static get requires() {
                return [Zk, Yk]
            }
            static get pluginName() {
                return "Superscript"
            }
        }, class extends Vi {
            static get requires() {
                return [Uk, Gk]
            }
            static get pluginName() {
                return "Subscript"
            }
        }, class extends Vi {
            static get requires() {
                return [fw, ww]
            }
            static get pluginName() {
                return "BlockQuote"
            }
        }, class extends Vi {
            static get requires() {
                return [Tw, Rw]
            }
            static get pluginName() {
                return "Heading"
            }
        }, class extends Vi {
            static get requires() {
                return [MC, LC]
            }
            static get pluginName() {
                return "Image"
            }
        }, class extends Vi {
            static get requires() {
                return [qC, WC]
            }
            static get pluginName() {
                return "ImageCaption"
            }
        }, class extends Vi {
            static get requires() {
                return [X_, nv]
            }
            static get pluginName() {
                return "ImageStyle"
            }
        }, class extends Vi {
            static get requires() {
                return [bA, uC]
            }
            static get pluginName() {
                return "ImageToolbar"
            }
            afterInit() {
                const t = this.editor,
                    e = t.t,
                    n = t.plugins.get(bA),
                    o = t.plugins.get("ImageUtils");
                var i;
                n.register("image", {
                    ariaLabel: e("Image toolbar"),
                    items: (i = t.config.get("image.toolbar") || [], i.map((t => O(t) ? t.name : t))),
                    getRelatedElement: t => o.getClosestSelectedImageWidget(t)
                })
            }
        }, class extends Vi {
            static get pluginName() {
                return "ImageUpload"
            }
            static get requires() {
                return [b_, JC, o_]
            }
        }, class extends Vi {
            static get requires() {
                return [y_, B_, E_]
            }
            static get pluginName() {
                return "ImageResize"
            }
        }, class extends Vi {
            static get requires() {
                return [Yv, ly, hy]
            }
            static get pluginName() {
                return "Link"
            }
        }, hy, class extends Vi {
            static get requires() {
                return [fx, Fy]
            }
            static get pluginName() {
                return "List"
            }
        }, class extends Vi {
            static get requires() {
                return [_x, Jy]
            }
            static get pluginName() {
                return "ListProperties"
            }
        }, class extends Vi {
            static get requires() {
                return [Vx, Ox]
            }
            static get pluginName() {
                return "TodoList"
            }
        }, yw, class extends Vi {
            static get pluginName() {
                return "PasteFromOffice"
            }
            static get requires() {
                return [Mw]
            }
            init() {
                const t = this.editor,
                    e = t.plugins.get("ClipboardPipeline"),
                    n = t.editing.view.document,
                    o = [];
                o.push(new Gx(n)), o.push(new Yx(n)), o.push(new Xx(n)), e.on("inputTransformation", ((e, i) => {
                    if (i._isTransformedWithPasteFromOffice) return;
                    if (t.model.document.selection.getFirstPosition().parent.is("element", "codeBlock")) return;
                    const r = i.dataTransfer.getData("text/html"),
                        s = o.find((t => t.isActive(r)));
                    s && (i._parsedData || (i._parsedData = eE(r, n.stylesProcessor)), s.execute(i), i._isTransformedWithPasteFromOffice = !0)
                }), {
                    priority: "high"
                })
            }
        }, class extends Vi {
            static get requires() {
                return [RC, uC]
            }
            static get pluginName() {
                return "PictureEditing"
            }
            afterInit() {
                const t = this.editor;
                t.plugins.has("ImageBlockEditing") && t.model.schema.extend("imageBlock", {
                    allowAttributes: ["sources"]
                }), t.plugins.has("ImageInlineEditing") && t.model.schema.extend("imageInline", {
                    allowAttributes: ["sources"]
                }), this._setupConversion(), this._setupImageUploadEditingIntegration()
            }
            _setupConversion() {
                const t = this.editor,
                    e = t.conversion,
                    n = t.plugins.get("ImageUtils");
                e.for("upcast").add(function(t) {
                    const e = ["srcset", "media", "type", "sizes"],
                        n = (n, o, i) => {
                            const r = o.viewItem;
                            if (!i.consumable.test(r, {
                                    name: !0
                                })) return;
                            const s = new Map;
                            for (const t of r.getChildren())
                                if (t.is("element", "source")) {
                                    const n = {};
                                    for (const o of e) t.hasAttribute(o) && i.consumable.test(t, {
                                        attributes: o
                                    }) && (n[o] = t.getAttribute(o));
                                    Object.keys(n).length && s.set(t, n)
                                } const a = t.findViewImgElement(r);
                            if (!a) return;
                            let l = o.modelCursor.parent;
                            if (!l.is("element", "imageBlock")) {
                                const t = i.convertItem(a, o.modelCursor);
                                o.modelRange = t.modelRange, o.modelCursor = t.modelCursor, l = Ei(t.modelRange.getItems())
                            }
                            i.consumable.consume(r, {
                                name: !0
                            });
                            for (const [t, e] of s) i.consumable.consume(t, {
                                attributes: Object.keys(e)
                            });
                            s.size && i.writer.setAttribute("sources", Array.from(s.values()), l), i.convertChildren(r, l)
                        };
                    return t => {
                        t.on("element:picture", n)
                    }
                }(n)), e.for("downcast").add(function(t) {
                    const e = (e, n, o) => {
                        if (!o.consumable.consume(n.item, e.name)) return;
                        const i = o.writer,
                            r = o.mapper.toViewElement(n.item),
                            s = t.findViewImgElement(r),
                            a = n.attributeNewValue;
                        if (a && a.length) {
                            const t = i.createContainerElement("picture", null, a.map((t => i.createEmptyElement("source", t)))),
                                e = [];
                            let n = s.parent;
                            for (; n && n.is("attributeElement");) {
                                const t = n.parent;
                                i.unwrap(i.createRangeOn(s), n), e.unshift(n), n = t
                            }
                            i.insert(i.createPositionBefore(s), t), i.move(i.createRangeOn(s), i.createPositionAt(t, "end"));
                            for (const n of e) i.wrap(i.createRangeOn(t), n)
                        } else if (s.parent.is("element", "picture")) {
                            const t = s.parent;
                            i.move(i.createRangeOn(s), i.createPositionBefore(t)), i.remove(t)
                        }
                    };
                    return t => {
                        t.on("attribute:sources:imageBlock", e), t.on("attribute:sources:imageInline", e)
                    }
                }(n))
            }
            _setupImageUploadEditingIntegration() {
                const t = this.editor;
                if (!t.plugins.has("ImageUploadEditing")) return;
                const e = t.plugins.get("ImageUploadEditing");
                this.listenTo(e, "uploadComplete", ((e, {
                    imageElement: n,
                    data: o
                }) => {
                    const i = o.sources;
                    i && t.model.change((t => {
                        t.setAttributes({
                            sources: i
                        }, n)
                    }))
                }))
            }
        }, class extends Vi {
            static get requires() {
                return [fD, CD, xD, PD, BD, ED, pA]
            }
            static get pluginName() {
                return "Table"
            }
        }, class extends Vi {
            static get requires() {
                return [bA]
            }
            static get pluginName() {
                return "TableToolbar"
            }
            afterInit() {
                const t = this.editor,
                    e = t.t,
                    n = t.plugins.get(bA),
                    o = t.config.get("table.contentToolbar"),
                    i = t.config.get("table.tableToolbar");
                o && n.register("tableContent", {
                    ariaLabel: e("Table toolbar"),
                    items: o,
                    getRelatedElement: FD
                }), i && n.register("table", {
                    ariaLabel: e("Table toolbar"),
                    items: i,
                    getRelatedElement: OD
                })
            }
        }, class extends Vi {
            static get pluginName() {
                return "TableProperties"
            }
            static get requires() {
                return [rT, gT]
            }
        }, class extends Vi {
            static get pluginName() {
                return "TableCellProperties"
            }
            static get requires() {
                return [jS, SS]
            }
        }, xD, class extends Vi {
            static get pluginName() {
                return "TableCaption"
            }
            static get requires() {
                return [AT, CT]
            }
        }, class extends Vi {
            static get requires() {
                return [LT, IS]
            }
            static get pluginName() {
                return "TableColumnResize"
            }
        }, class extends Vi {
            static get pluginName() {
                return "Indent"
            }
            static get requires() {
                return [yI, DI]
            }
        }, class extends Vi {
            constructor(t) {
                super(t), t.config.define("indentBlock", {
                    offset: 40,
                    unit: "px"
                })
            }
            static get pluginName() {
                return "IndentBlock"
            }
            init() {
                const t = this.editor,
                    e = t.config.get("indentBlock");
                e.classes && e.classes.length ? (this._setupConversionUsingClasses(e.classes), t.commands.add("indentBlock", new SI(t, new BI({
                    direction: "forward",
                    classes: e.classes
                }))), t.commands.add("outdentBlock", new SI(t, new BI({
                    direction: "backward",
                    classes: e.classes
                })))) : (t.data.addStyleProcessorRules(Ku), this._setupConversionUsingOffset(), t.commands.add("indentBlock", new SI(t, new TI({
                    direction: "forward",
                    offset: e.offset,
                    unit: e.unit
                }))), t.commands.add("outdentBlock", new SI(t, new TI({
                    direction: "backward",
                    offset: e.offset,
                    unit: e.unit
                }))))
            }
            afterInit() {
                const t = this.editor,
                    e = t.model.schema,
                    n = t.commands.get("indent"),
                    o = t.commands.get("outdent"),
                    i = t.config.get("heading.options");
                (i && i.map((t => t.model)) || II).forEach((t => {
                    e.isRegistered(t) && e.extend(t, {
                        allowAttributes: "blockIndent"
                    })
                })), e.setAttributeProperties("blockIndent", {
                    isFormatting: !0
                }), n.registerChildCommand(t.commands.get("indentBlock")), o.registerChildCommand(t.commands.get("outdentBlock"))
            }
            _setupConversionUsingOffset() {
                const t = this.editor.conversion,
                    e = "rtl" === this.editor.locale.contentLanguageDirection ? "margin-right" : "margin-left";
                t.for("upcast").attributeToAttribute({
                    view: {
                        styles: {
                            [e]: /[\s\S]+/
                        }
                    },
                    model: {
                        key: "blockIndent",
                        value: t => t.getStyle(e)
                    }
                }), t.for("downcast").attributeToAttribute({
                    model: "blockIndent",
                    view: t => ({
                        key: "style",
                        value: {
                            [e]: t
                        }
                    })
                })
            }
            _setupConversionUsingClasses(t) {
                const e = {
                    model: {
                        key: "blockIndent",
                        values: []
                    },
                    view: {}
                };
                for (const n of t) e.model.values.push(n), e.view[n] = {
                    key: "class",
                    value: [n]
                };
                this.editor.conversion.attributeToAttribute(e)
            }
        }, class extends Vi {
            constructor(t) {
                super(t), this._resizeObserver = null, this._blockToolbarConfig = vm(this.editor.config.get("blockToolbar")), this.toolbarView = this._createToolbarView(), this.panelView = this._createPanelView(), this.buttonView = this._createButtonView(), ng({
                    emitter: this.panelView,
                    contextElements: [this.panelView.element, this.buttonView.element],
                    activator: () => this.panelView.isVisible,
                    callback: () => this._hidePanel()
                })
            }
            static get pluginName() {
                return "BlockToolbar"
            }
            init() {
                const t = this.editor;
                this.listenTo(t.model.document.selection, "change:range", ((t, e) => {
                    e.directChange && this._hidePanel()
                })), this.listenTo(t.ui, "update", (() => this._updateButton())), this.listenTo(t, "change:isReadOnly", (() => this._updateButton()), {
                    priority: "low"
                }), this.listenTo(t.ui.focusTracker, "change:isFocused", (() => this._updateButton())), this.listenTo(this.buttonView, "change:isVisible", ((t, e, n) => {
                    n ? this.buttonView.listenTo(window, "resize", (() => this._updateButton())) : (this.buttonView.stopListening(window, "resize"), this._hidePanel())
                })), t.ui.addToolbar(this.toolbarView, {
                    beforeFocus: () => this._showPanel(),
                    afterBlur: () => this._hidePanel()
                })
            }
            afterInit() {
                this.toolbarView.fillFromConfig(this._blockToolbarConfig, this.editor.ui.componentFactory);
                for (const t of this.toolbarView.items) t.on("execute", (() => this._hidePanel(!0)), {
                    priority: "high"
                })
            }
            destroy() {
                super.destroy(), this.panelView.destroy(), this.buttonView.destroy(), this.toolbarView.destroy(), this._resizeObserver && this._resizeObserver.destroy()
            }
            _createToolbarView() {
                const t = this.editor.locale.t,
                    e = !this._blockToolbarConfig.shouldNotGroupWhenFull,
                    n = new Sm(this.editor.locale, {
                        shouldGroupWhenFull: e,
                        isFloating: !0
                    });
                return n.ariaLabel = t("Editor block content toolbar"), n
            }
            _createPanelView() {
                const t = this.editor,
                    e = new Kp(t.locale);
                return e.content.add(this.toolbarView), e.class = "ck-toolbar-container", t.ui.view.body.add(e), t.ui.focusTracker.add(e.element), this.toolbarView.keystrokes.set("Esc", ((t, e) => {
                    this._hidePanel(!0), e()
                })), e
            }
            _createButtonView() {
                const t = this.editor,
                    e = t.t,
                    n = new Qf(t.locale);
                return n.set({
                    label: e("Edit block"),
                    icon: tb,
                    withText: !1
                }), n.bind("isOn").to(this.panelView, "isVisible"), n.bind("tooltip").to(this.panelView, "isVisible", (t => !t)), this.listenTo(n, "execute", (() => {
                    this.panelView.isVisible ? this._hidePanel(!0) : this._showPanel()
                })), t.ui.view.body.add(n), t.ui.focusTracker.add(n.element), n
            }
            _updateButton() {
                const t = this.editor,
                    e = t.model,
                    n = t.editing.view;
                if (!t.ui.focusTracker.isFocused) return void this._hideButton();
                if (!t.model.canEditAt(t.model.document.selection)) return void this._hideButton();
                const o = Array.from(e.document.selection.getSelectedBlocks())[0];
                if (!o || Array.from(this.toolbarView.items).every((t => !t.isEnabled))) return void this._hideButton();
                const i = n.domConverter.mapViewToDom(t.editing.mapper.toViewElement(o));
                this.buttonView.isVisible = !0, this._setupToolbarResize(), this._attachButtonToElement(i), this.panelView.isVisible && this._showPanel()
            }
            _hideButton() {
                this.buttonView.isVisible = !1
            }
            _showPanel() {
                if (!this.buttonView.isVisible) return;
                const t = this.panelView.isVisible;
                this.panelView.show();
                const e = this._getSelectedEditableElement();
                this.toolbarView.maxWidth = this._getToolbarMaxWidth(e), this.panelView.pin({
                    target: this.buttonView.element,
                    limiter: e
                }), t || this.toolbarView.items.get(0).focus()
            }
            _getSelectedEditableElement() {
                const t = this.editor.model.document.selection.getFirstRange().root.rootName;
                return this.editor.ui.getEditableElement(t)
            }
            _hidePanel(t) {
                this.panelView.isVisible = !1, t && this.editor.editing.view.focus()
            }
            _attachButtonToElement(t) {
                const e = window.getComputedStyle(t),
                    n = new Mo(this._getSelectedEditableElement()),
                    o = parseInt(e.paddingTop, 10),
                    i = parseInt(e.lineHeight, 10) || 1.2 * parseInt(e.fontSize, 10),
                    r = Qo({
                        element: this.buttonView.element,
                        target: t,
                        positions: [(t, e) => {
                            let r;
                            return r = "ltr" === this.editor.locale.uiLanguageDirection ? n.left - e.width : n.right, {
                                top: t.top + o + (i - e.height) / 2,
                                left: r
                            }
                        }]
                    });
                this.buttonView.top = r.top, this.buttonView.left = r.left
            }
            _setupToolbarResize() {
                const t = this._getSelectedEditableElement();
                this._blockToolbarConfig.shouldNotGroupWhenFull || (this._resizeObserver && this._resizeObserver.element !== t && (this._resizeObserver.destroy(), this._resizeObserver = null), this._resizeObserver || (this._resizeObserver = new Wo(t, (() => {
                    this.toolbarView.maxWidth = this._getToolbarMaxWidth(t)
                }))))
            }
            _getToolbarMaxWidth(t) {
                const e = new Mo(t),
                    n = new Mo(this.buttonView.element),
                    o = "rtl" === this.editor.locale.uiLanguageDirection ? n.left - e.right + n.width : e.left - n.left;
                return Xf(e.width + o)
            }
        }, class extends Vi {
            static get requires() {
                return [yw]
            }
            init() {
                const t = this.editor,
                    e = t.t;
                t.ui.componentFactory.add("paragraph", (n => {
                    const o = new Mg(n),
                        i = t.commands.get("paragraph");
                    return o.label = e("Paragraph"), o.icon = xw, o.tooltip = !0, o.isToggleable = !0, o.bind("isEnabled").to(i), o.bind("isOn").to(i, "value"), o.on("execute", (() => {
                        t.execute("paragraph")
                    })), o
                }))
            }
        }, class extends Vi {
            init() {
                Bw(this.editor).filter((t => "paragraph" !== t.model)).map((t => this._createButton(t)))
            }
            _createButton(t) {
                const e = this.editor;
                e.ui.componentFactory.add(t.model, (n => {
                    const o = new Mg(n),
                        i = e.commands.get("heading");
                    return o.label = t.title, o.icon = t.icon || zw[t.model], o.tooltip = !0, o.isToggleable = !0, o.bind("isEnabled").to(i), o.bind("isOn").to(i, "value", (e => e == t.model)), o.on("execute", (() => {
                        e.execute("heading", {
                            value: t.model
                        }), e.editing.view.focus()
                    })), o
                }))
            }
        }, class extends Vi {
            static get requires() {
                return [ZI]
            }
            static get pluginName() {
                return "fileUploadPlugin"
            }
        }, class extends Vi {
            static get requires() {
                return [Ob]
            }
            static get pluginName() {
                return "UploadimagePlugin"
            }
            init() {
                this.editor.plugins.get("FileRepository").createUploadAdapter = t => new bP(t)
            }
        }, class extends Vi {
            static get requires() {
                return ["Delete", "Input"]
            }
            static get pluginName() {
                return "TextTransformation"
            }
            constructor(t) {
                super(t), t.config.define("typing", {
                    transformations: {
                        include: gk
                    }
                })
            }
            init() {
                const t = this.editor.model.document.selection;
                t.on("change:range", (() => {
                    this.isEnabled = !t.anchor.parent.is("element", "codeBlock")
                })), this._enableTransformationWatchers()
            }
            _enableTransformationWatchers() {
                const t = this.editor,
                    e = t.model,
                    n = t.plugins.get("Delete"),
                    o = function(t) {
                        const e = t.extra || [],
                            n = t.remove || [],
                            o = t => !n.includes(t);
                        return function(t) {
                            const e = new Set;
                            for (const n of t)
                                if ("string" == typeof n && uk[n])
                                    for (const t of uk[n]) e.add(t);
                                else e.add(n);
                            return Array.from(e)
                        }(t.include.concat(e).filter(o)).filter(o).map((t => "string" == typeof t && hk[t] ? hk[t] : t)).filter((t => "object" == typeof t)).map((t => ({
                            from: mk(t.from),
                            to: pk(t.to)
                        })))
                    }(t.config.get("typing.transformations")),
                    i = new rk(t.model, (t => {
                        for (const e of o) {
                            if (e.from.test(t)) return {
                                normalizedTransformation: e
                            }
                        }
                    }));
                i.on("matched:data", ((t, o) => {
                    if (!o.batch.isTyping) return;
                    const {
                        from: i,
                        to: r
                    } = o.normalizedTransformation, s = i.exec(o.text), a = r(s.slice(1)), l = o.range;
                    let c = s.index;
                    e.enqueueChange((t => {
                        for (let n = 1; n < s.length; n++) {
                            const o = s[n],
                                i = a[n - 1];
                            if (null == i) {
                                c += o.length;
                                continue
                            }
                            const r = l.start.getShiftedBy(c),
                                d = e.createRange(r, r.getShiftedBy(o.length)),
                                h = fk(r);
                            e.insertContent(t.createText(i, h), d), c += i.length
                        }
                        e.enqueueChange((() => {
                            n.requestUndoOnBackspace()
                        }))
                    }))
                })), i.bind("isEnabled").to(this)
            }
        }, class extends Vi {
            static get requires() {
                return [cB, wB, yB, SB]
            }
            static get pluginName() {
                return "Font"
            }
        }, yB, SB, class extends Vi {
            static get requires() {
                return [HB, $B]
            }
            static get pluginName() {
                return "CodeBlock"
            }
        }, FI, class extends Vi {
            static get requires() {
                return [HI, jI, pA]
            }
            static get pluginName() {
                return "HorizontalLine"
            }
        }, class extends Vi {
            static get requires() {
                return [$I, WI]
            }
            static get pluginName() {
                return "RemoveFormat"
            }
        }, class extends Vi {
            static get requires() {
                return [zb, wb]
            }
            static get pluginName() {
                return "FindAndReplace"
            }
            init() {
                const t = this.editor.plugins.get("FindAndReplaceUI"),
                    e = this.editor.plugins.get("FindAndReplaceEditing"),
                    n = e.state;
                t.on("findNext", ((t, e) => {
                    e ? (n.searchText = e.searchText, this.editor.execute("find", e.searchText, e)) : this.editor.execute("findNext")
                })), t.on("findPrevious", ((t, e) => {
                    e && n.searchText !== e.searchText ? this.editor.execute("find", e.searchText) : this.editor.execute("findPrevious")
                })), t.on("replace", ((t, e) => {
                    n.searchText !== e.searchText && this.editor.execute("find", e.searchText);
                    const o = n.highlightedResult;
                    o && this.editor.execute("replace", e.replaceText, o)
                })), t.on("replaceAll", ((t, e) => {
                    n.searchText !== e.searchText && this.editor.execute("find", e.searchText), this.editor.execute("replaceAll", e.replaceText, n.results)
                })), t.on("searchReseted", (() => {
                    n.clear(this.editor.model), e.stop()
                }))
            }
        }, class extends Vi {
            toMentionAttribute(t, e) {
                return JB(t, e)
            }
            static get pluginName() {
                return "Mention"
            }
            static get requires() {
                return [KB, pI]
            }
        }, class extends Vi {
            init() {
                const t = this.editor;
                t.ui.componentFactory.add("internalLink", (e => {
                    const n = new Mg(e);
                    return n.set({
                        label: "Internal Trilium link (CTRL-L)",
                        icon: '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n\x3c!-- Created with Inkscape (http://www.inkscape.org/) --\x3e\n\n<svg\n   viewBox="0 0 1000 1000"\n   version="1.1"\n   id="svg52"\n   sodipodi:docname="trilium.svg"\n   inkscape:version="1.1.2 (0a00cf5339, 2022-02-04)"\n   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"\n   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:svg="http://www.w3.org/2000/svg">\n  <sodipodi:namedview\n     id="namedview8"\n     pagecolor="#ffffff"\n     bordercolor="#666666"\n     borderopacity="1.0"\n     inkscape:pageshadow="2"\n     inkscape:pageopacity="0.0"\n     inkscape:pagecheckerboard="0"\n     showgrid="false"\n     inkscape:zoom="0.644"\n     inkscape:cx="263.19876"\n     inkscape:cy="552.01863"\n     inkscape:window-width="1860"\n     inkscape:window-height="1171"\n     inkscape:window-x="60"\n     inkscape:window-y="0"\n     inkscape:window-maximized="1"\n     inkscape:current-layer="svg52" />\n  <defs\n     id="defs49" />\n  <g\n     id="layer1"\n     transform="matrix(38.901422,0,0,38.901422,-3639.1766,-4159.6755)">\n    <path\n       d="m 113.74804,110.03165 c -1.42996,-0.0442 -2.17088,0.625 -2.34981,0.68707 0.16278,-0.3083 0.27171,-0.50253 0.688,-0.936 -1.41596,-0.0148 -2.72887,0.29159 -3.73058,1.22872 -1.34352,1.25681 -1.23908,2.2981 -1.24178,2.29296 2.6e-4,5.3e-4 -0.21198,-0.67904 -0.27564,-1.40587 -1.46206,2.02387 -2.03936,4.70551 -0.93087,6.70595 0.6881,-1.65994 1.78073,-3.09055 3.18884,-4.21865 0.0464,-1.18373 0.52261,-2.18385 1.27529,-2.92226 -0.67922,0.81298 -0.97894,1.73919 -0.94869,2.67267 1.63782,-1.2219 3.64526,-2.03628 5.85031,-2.30351 -1.59648,0.29336 -3.04295,0.92965 -4.30723,1.79752 0.79133,0.36141 1.69504,0.41807 2.64485,0.0873 -0.91061,0.42675 -1.92147,0.49657 -2.9441,0.12489 -0.90763,0.66467 -1.71482,1.45002 -2.40861,2.31313 1.2317,0.40267 2.57896,0.31941 3.91968,-0.36393 -1.23077,0.79497 -2.67669,1.0931 -4.22173,0.75455 -0.61594,0.82662 -1.1322,1.71446 -1.53571,2.62946 0.49703,0.36645 2.65401,1.5162 6.35388,-1.21219 -0.52242,-0.15439 -0.94581,-0.37271 -0.946,-0.37308 0.0118,0.005 0.3813,0.0392 1.46198,-0.6082 0.95542,-0.55873 1.77726,-1.5708 2.38397,-2.35858 -0.51607,-0.19014 -0.91799,-0.38969 -0.91818,-0.39016 -2.6e-4,-2.6e-4 0.66691,0.0449 1.70185,-0.74737 0.92313,-0.70667 1.95369,-1.73106 1.95686,-1.70213 0.007,0.006 -2.27337,-1.67833 -4.66658,-1.75226"\n       id="path1983"\n       style="stroke-width:0.264583" />\n    <path\n       d="m 97.266941,113.71206 c 1.085186,-0.31546 1.776174,0.0487 1.924677,0.0607 -0.181896,-0.20295 -0.301379,-0.32953 -0.700376,-0.57786 1.079852,-0.29036 2.140718,-0.31557 3.081128,0.20137 1.26132,0.69332 1.37526,1.50765 1.37643,1.50324 -2.1e-4,5.2e-4 0.0356,-0.55938 -0.051,-1.12601 1.49474,1.25469 2.43548,3.18504 1.96031,4.92842 -0.83512,-1.12979 -1.93695,-2.00494 -3.22366,-2.58743 -0.25583,-0.89312 -0.80621,-1.56175 -1.51917,-1.97627 0.67072,0.48585 1.07227,1.13284 1.22302,1.85031 -1.47981,-0.60864 -3.166266,-0.83387 -4.90201,-0.60297 1.275297,-0.091 3.97663,0.0938 6.16856,1.91271 -0.8667,0.54971 -1.91231,0.75182 -3.064598,0.49509 1.089028,0.36336 2.250068,0.30579 3.368318,-0.25684 0.62485,0.50874 1.18494,1.08377 1.66384,1.70177 -0.31184,0.37733 -1.74694,1.67877 -5.0839,0.32807 0.370727,-0.22061 0.65376,-0.47052 0.65386,-0.47083 -0.008,0.006 -0.2842,0.10505 -1.231125,-0.17543 -0.83448,-0.23762 -1.651249,-0.84721 -2.261907,-1.32822 0.359204,-0.24655 0.629433,-0.47787 0.629433,-0.47829 1.03e-4,-2.1e-4 -0.50152,0.16566 -1.440336,-0.23425 -0.837464,-0.35685 -1.816182,-0.93461 -1.813195,-0.91192 -0.0038,0.006 1.425721,-1.7274 3.241691,-2.25538"\n       id="path1985"\n       style="stroke-width:0.264583" />\n    <path\n       d="m 105.05663,128.63261 c -0.79134,-0.73638 -0.82521,-1.48618 -0.88758,-1.6143 -0.0802,0.25063 -0.12732,0.41184 -0.13946,0.86376 -0.76798,-0.74444 -1.30598,-1.60504 -1.33424,-2.63626 -0.0379,-1.38278 0.58413,-1.88161 0.57992,-1.88032 5.3e-4,0 -0.48274,0.24889 -0.91199,0.60198 0.31536,-1.85427 1.46295,-3.58849 3.14515,-4.06444 -0.53297,1.24924 -0.72418,2.5913 -0.58168,3.94005 -0.61836,0.65478 -0.90639,1.44016 -0.90382,2.23317 0.0773,-0.79359 0.4199,-1.44591 0.94341,-1.92678 0.21481,1.52067 0.84951,3.02079 1.88754,4.33458 -0.6972,-1.00448 -1.86009,-3.31968 -1.41507,-6.02844 0.87976,0.44016 1.55757,1.20019 1.90564,2.27635 -0.22846,-1.0771 -0.84226,-2.00411 -1.85541,-2.64481 0.11867,-0.76719 0.32424,-1.51409 0.60492,-2.21568 0.46593,0.0691 2.24834,0.60303 2.75082,4.02125 -0.36419,-0.19538 -0.71004,-0.30404 -0.71039,-0.30392 0.009,0.003 0.22601,0.18165 0.45413,1.10045 0.20896,0.8051 0.1,1.78048 -0.003,2.5223 -0.38031,-0.17308 -0.70444,-0.28043 -0.70467,-0.28019 -2.6e-4,0 0.38218,0.33044 0.50704,1.30201 0.11131,0.86673 0.10758,1.95955 0.12498,1.94579 0.007,2.2e-4 -2.13212,-0.31444 -3.45655,-1.54655"\n       id="path1987"\n       style="stroke-width:0.264583" />\n  </g>\n</svg>\n',
                        tooltip: !0
                    }), n.bind("isEnabled").to(t, "isReadOnly", (t => !t)), n.on("execute", (() => {
                        const e = t.editing.view.getDomRoot();
                        glob.getComponentByEl(e).triggerCommand("addLinkToText")
                    })), n
                }))
            }
        }, class extends Vi {
            init() {
                this.editor.ui.componentFactory.add("markdownImport", (t => {
                    const e = new Mg(t);
                    return e.set({
                        label: "Markdown import from clipboard",
                        icon: '<svg xmlns="http://www.w3.org/2000/svg" width="208" height="128" viewBox="0 0 208 128"><rect width="198" height="118" x="5" y="5" ry="10" stroke="#000" stroke-width="10" fill="none"/><path d="M30 98V30h20l20 25 20-25h20v68H90V59L70 84 50 59v39zm125 0l-30-33h20V30h20v35h20z"/></svg>',
                        tooltip: !0
                    }), e.on("execute", (() => {
                        glob.importMarkdownInline()
                    })), e
                }))
            }
        }, class extends Vi {
            init() {
                this.htmlDataProcessor = new bd, this.editor.ui.componentFactory.add("cutToNote", (t => {
                    const e = new Mg(t);
                    return e.set({
                        label: "Cut & paste selection to sub-note",
                        icon: '<?xml version="1.0" encoding="utf-8"?>\n\x3c!-- Svg Vector Icons : http://www.onlinewebfonts.com/icon --\x3e\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 1000 1000" enable-background="new 0 0 1000 1000" xml:space="preserve">\n<metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>\n<g><g><path d="M853.9,754.9c-26-45.4-66.5-76.2-109.1-87.8c-33.7-9.2-68.7-6.4-98.9,10.7l-90-157.3C611.6,409.5,736.5,160.5,759,121.2C788,70.4,736,10,736,10L500,422.8L264,10c0,0-52,60.4-22.9,111.2c22.5,39.3,147.5,288.3,203.1,399.3l-89.9,157.3c-30.2-17.1-65.3-19.9-98.9-10.7c-42.7,11.6-83.1,42.3-109.1,87.8c-46.8,81.7-28.9,179.7,39.7,219c30.4,17.5,65.7,20.3,99.6,11.1c42.6-11.6,83.1-42.4,109.1-87.7c11.4-20,18.9-41,22.8-61.8v0c0-0.2,0-0.3,0.2-0.5c0.2-1.7,0.5-3.5,0.7-5.4c19.3-129.5,55.8-195.7,81.6-227.8c25.9,32.1,62.4,98.3,81.7,227.8c0.2,1.9,0.5,3.6,0.7,5.4c0.1,0.2,0.1,0.3,0.2,0.5v0c3.9,20.8,11.4,41.8,22.7,61.8c26,45.3,66.5,76.1,109.2,87.7c34,9.2,69.2,6.4,99.7-11.1C882.8,934.5,900.6,836.5,853.9,754.9z M327.9,858.9c-14.8,25.8-38.1,45.2-62.5,51.8c-10.8,3-26.7,4.7-41.3-3.6c-31.1-17.8-36.2-70.1-11.1-114c15-26,37.8-45,62.5-51.8c10.7-2.9,26.7-4.7,41.3,3.6C347.9,762.7,353,814.9,327.9,858.9z M775.9,907.1c-14.6,8.4-30.4,6.6-41.3,3.6c-24.4-6.6-47.7-26-62.5-51.8c-25.1-44-20-96.2,11.1-114c14.7-8.3,30.6-6.5,41.3-3.6C749.3,748,772.1,767,787,793C812.1,837,807.1,889.3,775.9,907.1z"/><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></g>\n</svg>',
                        tooltip: !0
                    }), e.on("execute", (() => {
                        const t = this.editor.editing.view.getDomRoot();
                        glob.getComponentByEl(t).triggerCommand("cutIntoNote")
                    })), e
                })), this.editor.getSelectedHtml = () => this.getSelectedHtml(), this.editor.removeSelection = () => this.removeSelection()
            }
            getSelectedHtml() {
                const t = this.editor.model,
                    e = t.document,
                    n = this.editor.data.toView(t.getSelectedContent(e.selection));
                return this.htmlDataProcessor.toData(n)
            }
            async removeSelection() {
                const t = this.editor.model;
                t.deleteContent(t.document.selection);
                const e = this.getComponent();
                await e.triggerCommand("saveNoteDetailNow")
            }
            getComponent() {
                const t = this.editor.editing.view.getDomRoot();
                return glob.getComponentByEl(t)
            }
        }, class extends Vi {
            afterInit() {
                const t = this.editor;
                t.commands.add("mention", new fP(t))
            }
        }, class extends Vi {
            static get requires() {
                return [wP, kP]
            }
        }, class extends Vi {
            static get requires() {
                return [_P]
            }
        }, function(t) {
            function e() {
                let e = t.model.document.selection.getFirstPosition();
                for (; e;) {
                    if ("tableCell" === e.name) return !0;
                    e = e.parent
                }
                return !1
            }
            t.keystrokes.set("Tab", ((n, o) => {
                const i = t.commands.get("indentBlock");
                i.isEnabled && !e() && (i.execute(), o())
            })), t.keystrokes.set("Shift+Tab", ((n, o) => {
                const i = t.commands.get("outdentBlock");
                i.isEnabled && !e() && (i.execute(), o())
            }))
        }, function(t) {
            t.model.schema.setAttributeProperties("linkHref", {
                isFormatting: !0
            })
        }, pP, class extends Vi {
            static get requires() {
                return [pP, "Autoformat"]
            }
            init() {
                const t = this.editor;
                t.plugins.has("Math") || k("autoformat-math-feature-missing", t)
            }
            afterInit() {
                const t = this.editor,
                    e = t.commands.get("math");
                if (e) {
                    const n = () => {
                        if (!e.isEnabled) return !1;
                        e.display = !0, Po.window.setTimeout((() => t.plugins.get("MathUI")._showUI()), 50)
                    };
                    Ck(t, this, /^\$\$$/, n), Ck(t, this, /^\\\[$/, n)
                }
            }
            static get pluginName() {
                return "AutoformatMath"
            }
        }], xP.defaultConfig = {
            toolbar: {
                items: ["fontSize", "bold", "italic", "underline", "strikethrough", "superscript", "subscript", "fontColor", "fontBackgroundColor", "code", "link", "removeFormat", "internallink", "cuttonote"]
            },
            image: {
                styles: {
                    options: ["alignLeft", "alignCenter", "alignRight", "full", "side"]
                },
                resizeOptions: [{
                    name: "imageResize:original",
                    value: null,
                    icon: "original"
                }, {
                    name: "imageResize:25",
                    value: "25",
                    icon: "small"
                }, {
                    name: "imageResize:50",
                    value: "50",
                    icon: "medium"
                }, {
                    name: "imageResize:75",
                    value: "75",
                    icon: "medium"
                }],
                toolbar: ["imageStyle:inline", "imageStyle:alignLeft", "imageStyle:alignCenter", "imageStyle:alignRight", "|", "imageResize:25", "imageResize:50", "imageResize:original", "|", "toggleImageCaption"]
            },
            heading: {
                options: [{
                    model: "paragraph",
                    title: "Paragraph",
                    class: "ck-heading_paragraph"
                }, {
                    model: "heading2",
                    view: "h2",
                    title: "Heading 2",
                    class: "ck-heading_heading2"
                }, {
                    model: "heading3",
                    view: "h3",
                    title: "Heading 3",
                    class: "ck-heading_heading3"
                }, {
                    model: "heading4",
                    view: "h4",
                    title: "Heading 4",
                    class: "ck-heading_heading4"
                }, {
                    model: "heading5",
                    view: "h5",
                    title: "Heading 5",
                    class: "ck-heading_heading5"
                }, {
                    model: "heading6",
                    view: "h6",
                    title: "Heading 6",
                    class: "ck-heading_heading6"
                }]
            },
            blockToolbar: ["heading", "|", "bulletedList", "numberedList", "todoList", "|", "blockQuote", "codeBlock", "insertTable", "internallink", "includeNote", "math", "|", "outdent", "indent", "horizontalLine", "|", "imageUpload", "markdownImport", "findAndReplace"],
            table: {
                contentToolbar: ["tableColumn", "tableRow", "mergeTableCells", "tableProperties", "tableCellProperties", "toggleTableCaption"]
            },
            list: {
                properties: {
                    styles: !0,
                    startIndex: !0,
                    reversed: !0
                }
            },
            link: {
                defaultProtocol: "https://"
            },
            language: "en"
        }
    })(), o = o.default
})()));
//# sourceMappingURL=libraries/ckeditor/ckeditor.js.map